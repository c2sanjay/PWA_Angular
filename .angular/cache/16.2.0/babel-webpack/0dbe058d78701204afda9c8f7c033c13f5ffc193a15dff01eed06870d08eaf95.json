{"ast":null,"code":"import { localeInfo, localeCurrency, currencyDisplays } from '../cldr';\nimport { PERCENT, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, DEFAULT_LOCALE, EMPTY, POINT } from '../common/constants';\nimport { setStyleOptions, setFormatLiterals } from './utils';\nimport isNumber from '../common/is-number';\nimport isCurrencyStyle from './is-currency-style';\nimport formatOptions from './format-options';\nimport isString from '../common/is-string';\nconst exponentRegExp = /[eE][-+]?[0-9]+/;\nconst nonBreakingSpaceRegExp = /\\u00A0/g;\nfunction cleanNegativePattern(number, patterns) {\n  if (patterns.length > 1) {\n    const parts = (patterns[1] || EMPTY).replace(CURRENCY_PLACEHOLDER, EMPTY).split(NUMBER_PLACEHOLDER);\n    if (number.indexOf(parts[0]) > -1 && number.indexOf(parts[1]) > -1) {\n      return number.replace(parts[0], EMPTY).replace(parts[1], EMPTY);\n    }\n  }\n}\nfunction cleanCurrencyNumber(value, info, format) {\n  const options = formatOptions(format) || {};\n  let isCurrency = isCurrencyStyle(options.style);\n  let number = value;\n  let negative;\n  const currency = options.currency || localeCurrency(info, isCurrency);\n  if (currency) {\n    const displays = currencyDisplays(info, currency, isCurrency);\n    if (displays) {\n      for (let idx = 0; idx < displays.length; idx++) {\n        let display = displays[idx];\n        if (number.includes(display)) {\n          number = number.replace(display, EMPTY);\n          isCurrency = true;\n          break;\n        }\n      }\n    }\n    if (isCurrency) {\n      const cleanNumber = cleanNegativePattern(number, info.numbers.currency.patterns) || cleanNegativePattern(number, info.numbers.accounting.patterns);\n      if (cleanNumber) {\n        negative = true;\n        number = cleanNumber;\n      }\n    }\n  }\n  return {\n    number: number,\n    negative: negative\n  };\n}\nfunction cleanLiterals(number, formatOptions) {\n  const literals = formatOptions.literals;\n  let result = number;\n  if (literals) {\n    for (let idx = 0; idx < literals.length; idx++) {\n      result = result.replace(literals[idx], EMPTY);\n    }\n  }\n  return result;\n}\nfunction divideBy100(number) {\n  const strNumber = String(number);\n  const pointIndex = strNumber.indexOf(POINT);\n  const zeroesCount = 2;\n  let result = number / Math.pow(10, zeroesCount);\n  if (pointIndex === -1 || String(result).length <= strNumber.length + zeroesCount) {\n    return result;\n  }\n  const fractionDigits = strNumber.length - pointIndex + 1 + zeroesCount;\n  return parseFloat(result.toFixed(fractionDigits));\n}\nexport default function parseNumber(value, locale = DEFAULT_LOCALE, format = {}) {\n  if (!value && value !== 0) {\n    return null;\n  }\n  if (isNumber(value)) {\n    return value;\n  }\n  const info = localeInfo(locale);\n  const symbols = info.numbers.symbols;\n  let number = value.toString();\n  let formatOptions = format || {};\n  let isPercent;\n  if (isString(format)) {\n    formatOptions = {\n      format: format\n    };\n    setFormatLiterals(formatOptions);\n    number = cleanLiterals(number, formatOptions);\n    setStyleOptions(formatOptions, info);\n  }\n  if (formatOptions.style === PERCENT || number.indexOf(symbols.percentSign) > -1) {\n    number = number.replace(symbols.percentSign, EMPTY);\n    isPercent = true;\n  }\n  if (exponentRegExp.test(number)) {\n    number = parseFloat(number.replace(symbols.decimal, POINT));\n    return isNaN(number) ? null : number;\n  }\n  const {\n    negative: negativeCurrency,\n    number: currencyNumber\n  } = cleanCurrencyNumber(number, info, formatOptions);\n  number = String(currencyNumber).trim();\n  const negativeSignIndex = number.indexOf(\"-\");\n  if (negativeSignIndex > 0) {\n    return null;\n  }\n  let isNegative = negativeSignIndex > -1;\n  isNegative = negativeCurrency !== undefined ? negativeCurrency : isNegative;\n  number = number.replace(\"-\", EMPTY).replace(nonBreakingSpaceRegExp, \" \").split(symbols.group.replace(nonBreakingSpaceRegExp, \" \")).join(EMPTY).replace(symbols.decimal, POINT);\n  number = parseFloat(number);\n  if (isNaN(number)) {\n    number = null;\n  } else if (isNegative) {\n    number *= -1;\n  }\n  if (number && isPercent) {\n    number = divideBy100(number);\n  }\n  return number;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}