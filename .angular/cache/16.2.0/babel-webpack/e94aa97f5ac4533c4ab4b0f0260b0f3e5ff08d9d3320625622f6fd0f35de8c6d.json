{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Directive, HostBinding, Input, Injectable, Component, isDevMode, EventEmitter, Output, ContentChildren, NgModule, InjectionToken, Optional, Inject } from '@angular/core';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { dispatchDragAndDrop, getScrollableParent, autoScroll } from '@progress/kendo-draggable-common';\nimport { PreventableEvent, contains, isDocumentAvailable, parseCSSClassNames, isPresent as isPresent$1, areObjectsEqual } from '@progress/kendo-angular-common';\nimport { NgTemplateOutlet } from '@angular/common';\nimport { Subject, BehaviorSubject, Subscription } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\n\n/**\n * Represents the Kendo UI DragHandle directive for Angular.\n * It is used to specify a concrete element within a drag target as a handle for dragging, instead the drag target itself.\n */\nconst _c0 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    index: a1,\n    data: a2\n  };\n};\nlet DragHandleDirective = /*#__PURE__*/(() => {\n  var _class;\n  class DragHandleDirective {\n    constructor(element) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"touchActionStyle\", 'none');\n      /**\n       * Specifies the cursor style of the drag handle. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).\n       *\n       * @default 'move'\n       */\n      _defineProperty(this, \"cursorStyle\", 'move');\n      this.element = element;\n    }\n  }\n  _class = DragHandleDirective;\n  _defineProperty(DragHandleDirective, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(DragHandleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class,\n    selectors: [[\"\", \"kendoDragHandle\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchActionStyle)(\"cursor\", ctx.cursorStyle);\n      }\n    },\n    inputs: {\n      cursorStyle: \"cursorStyle\"\n    },\n    exportAs: [\"kendoDragHandle\"],\n    standalone: true\n  }));\n  return DragHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-utils',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163578,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\nfunction isDocumentNode(container) {\n  return container.nodeType === 9;\n}\n/**\n * @hidden\n */\nconst getAction = (event, draggable) => {\n  return {\n    event: event,\n    payload: draggable\n  };\n};\n/**\n * @hidden\n */\nconst dragTargetTransition = 'transform .3s ease-in-out';\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nfunction closestBySelector(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);\n  let node = element;\n  while (node && !isDocumentNode(node)) {\n    if (matches(node, selector)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n}\n/**\n * @hidden\n */\nconst intersect = (element, candidates) => {\n  let max = 0;\n  let result = null;\n  candidates.forEach(candidate => {\n    if (candidate && element) {\n      const ration = getRatio(element, candidate);\n      if (ration > max) {\n        max = ration;\n        result = candidate;\n      }\n    }\n  });\n  return result;\n};\nconst getRatio = (element, target) => {\n  const elementRect = element.getBoundingClientRect();\n  const targetRect = target.getBoundingClientRect();\n  const top = Math.max(targetRect.top, elementRect.top);\n  const left = Math.max(targetRect.left, elementRect.left);\n  const right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);\n  const bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);\n  const width = right - left;\n  const height = bottom - top;\n  if (left < right && top < bottom) {\n    const targetArea = targetRect.width * targetRect.height;\n    const entryArea = elementRect.width * elementRect.height;\n    const intersectionArea = width * height;\n    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);\n    return Number(intersectionRatio.toFixed(4));\n  }\n  return 0;\n};\n/**\n * @hidden\n */\nconst setElementStyles = (renderer, elem, styles) => {\n  const props = Object.keys(styles);\n  props.forEach(p => {\n    renderer.setStyle(elem, p, styles[p]);\n  });\n};\n/**\n * @hidden\n */\nconst noop = () => {};\n\n/**\n * @hidden\n */\nlet DragStateService = /*#__PURE__*/(() => {\n  var _class2;\n  class DragStateService {\n    constructor() {\n      _defineProperty(this, \"dragTarget\", null);\n      _defineProperty(this, \"dropTarget\", null);\n      _defineProperty(this, \"dragTargets\", []);\n      _defineProperty(this, \"dropTargets\", []);\n      _defineProperty(this, \"pressed\", false);\n      _defineProperty(this, \"ignoreMouse\", false);\n      _defineProperty(this, \"autoScroll\", true);\n      _defineProperty(this, \"isScrolling\", false);\n      _defineProperty(this, \"scrollableParent\", null);\n      _defineProperty(this, \"autoScrollDirection\", {\n        horizontal: true,\n        vertical: true\n      });\n      _defineProperty(this, \"initialClientOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"clientOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"initialScrollOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"scrollOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"offset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"pageOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"velocity\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"dragTargetDirective\", void 0);\n      _defineProperty(this, \"state\", void 0);\n      _defineProperty(this, \"dragIndex\", null);\n      _defineProperty(this, \"dropIndex\", null);\n      _defineProperty(this, \"dragData\", void 0);\n      _defineProperty(this, \"dragTargetId\", void 0);\n      _defineProperty(this, \"callbacks\", {});\n      _defineProperty(this, \"scrollInterval\", null);\n      this.setCallbacks();\n    }\n    handleDragAndDrop(action) {\n      this.updateState();\n      dispatchDragAndDrop(this.state, action, this.callbacks);\n    }\n    setPressed(pressed) {\n      this.pressed = pressed;\n    }\n    setScrolling(isScrolling) {\n      this.isScrolling = isScrolling;\n      if (isScrolling) {\n        const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));\n        window.clearInterval(this.scrollInterval);\n        this.scrollInterval = window.setInterval(() => {\n          autoScroll(scrollableParent, {\n            x: this.velocity.x,\n            y: this.velocity.y\n          });\n        }, 50);\n      } else {\n        if (this.scrollInterval) {\n          window.clearInterval(this.scrollInterval);\n          this.scrollInterval = null;\n        }\n      }\n    }\n    setVelocity(velocity) {\n      this.velocity = velocity;\n    }\n    setOffset(offset) {\n      this.offset = offset;\n    }\n    setClientOffset(clientOffset) {\n      this.clientOffset = clientOffset;\n    }\n    setPageOffset(pageOffset) {\n      this.pageOffset = pageOffset;\n    }\n    setInitialClientOffset(initialClientOffset) {\n      this.initialClientOffset = initialClientOffset;\n    }\n    setScrollOffset(scrollOffset) {\n      this.scrollOffset = scrollOffset;\n    }\n    setInitialScrollOffset(initialScrollOffset) {\n      this.initialScrollOffset = initialScrollOffset;\n    }\n    get dragTargetPresent() {\n      return isPresent(this.dragTarget?.element);\n    }\n    get dropTargetPresent() {\n      return isPresent(this.dropTarget?.element);\n    }\n    updateState() {\n      this.state = {\n        drag: this.dragTarget,\n        drop: this.dropTarget,\n        drags: this.dragTargets,\n        drops: this.dropTargets,\n        pressed: this.pressed,\n        ignoreMouse: this.ignoreMouse,\n        autoScroll: this.autoScroll,\n        isScrolling: this.isScrolling,\n        scrollableParent: this.scrollableParent,\n        autoScrollDirection: this.autoScrollDirection,\n        initialClientOffset: this.initialClientOffset,\n        clientOffset: this.clientOffset,\n        initialScrollOffset: this.initialScrollOffset,\n        scrollOffset: this.scrollOffset,\n        offset: this.offset,\n        pageOffset: this.pageOffset,\n        velocity: this.velocity\n      };\n    }\n    setCallbacks() {\n      this.callbacks = {\n        onVelocityChange: this.setVelocity.bind(this),\n        onOffsetChange: this.setOffset.bind(this),\n        onClientOffsetChange: this.setClientOffset.bind(this),\n        onPageOffsetChange: this.setPageOffset.bind(this),\n        onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),\n        onScrollOffsetChange: this.setScrollOffset.bind(this),\n        onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),\n        onIsPressedChange: this.setPressed.bind(this),\n        onIsScrollingChange: this.setScrolling.bind(this)\n      };\n    }\n    ngOnDestroy() {\n      if (this.scrollInterval) {\n        window.clearInterval(this.scrollInterval);\n        this.scrollInterval = null;\n      }\n    }\n  }\n  _class2 = DragStateService;\n  _defineProperty(DragStateService, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)();\n  });\n  _defineProperty(DragStateService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac,\n    providedIn: 'root'\n  }));\n  return DragStateService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet HintComponent = /*#__PURE__*/(() => {\n  var _class3;\n  class HintComponent {\n    constructor(element) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"directive\", void 0);\n      _defineProperty(this, \"targetIndex\", void 0);\n      _defineProperty(this, \"contextData\", void 0);\n      _defineProperty(this, \"customContext\", void 0);\n      _defineProperty(this, \"pointerEvents\", 'none');\n      this.element = element;\n    }\n  }\n  _class3 = HintComponent;\n  _defineProperty(HintComponent, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(HintComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class3,\n    selectors: [[\"kendo-draghint\"]],\n    hostVars: 2,\n    hostBindings: function _class3_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"pointer-events\", ctx.pointerEvents);\n      }\n    },\n    inputs: {\n      template: \"template\",\n      directive: \"directive\",\n      targetIndex: \"targetIndex\",\n      contextData: \"contextData\",\n      customContext: \"customContext\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 6,\n    consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class3_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.customContext || i0.ɵɵpureFunction3(2, _c0, ctx.directive, ctx.targetIndex, ctx.contextData));\n      }\n    },\n    dependencies: [NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return HintComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the press event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetPressEvent {\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dragTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the dragReady event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetDragReadyEvent {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the dragStart event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetDragStartEvent extends PreventableEvent {\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dragTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the dragEnd event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetDragEndEvent {\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dragTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the drag event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetDragEvent extends PreventableEvent {\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dragTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The hint of the DragTarget.\n     */\n    _defineProperty(this, \"hintElement\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the release event of the DragTarget and DragTargetContainer.\n */\nclass DragTargetReleaseEvent {\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DragTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dragTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    /**\n     * The normalized drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The DOM element that is being dragged.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragTargetId\", void 0);\n    /**\n     * The index of the current drag target in the collection of drag targets (applicable for the `DragTargetContainer` directive).\n     */\n    _defineProperty(this, \"dragTargetIndex\", void 0);\n    Object.assign(this, args);\n  }\n}\nlet isDragStartPrevented$1 = false;\nlet isDragPrevented$1 = false;\n/**\n * Represents the [Kendo UI DragTargetContainer directive for Angular]({% slug api_utils_dragtargetcontainerdirective %}).\n * Used to configure multiple elements as draggable.\n *\n * @example\n * ```ts-no-run\n * <ul kendoDragTargetContainer dragTargetFilter=\".my-draggable\">\n *    <li class=\"my-draggable\">foo</li>\n * </ul>\n * ```\n */\nlet DragTargetContainerDirective = /*#__PURE__*/(() => {\n  var _class10;\n  class DragTargetContainerDirective {\n    /**\n     * Specifies a selector for elements within a container which will be configured as draggable\n     * ([see example]({% slug drag_target_container %})). The possible values include any\n     * DOM `selector`.\n     */\n    set dragTargetFilter(value) {\n      this._dragTargetFilter = value;\n      if (!this.dragDisabled) {\n        this.initializeDragTargets();\n      }\n    }\n    get dragTargetFilter() {\n      return this._dragTargetFilter;\n    }\n    /**\n     * Specifies a selector for elements within each DragTarget which will be configured as drag handles.\n     */\n\n    /**\n     * Defines a unique identifier for each drag target.\n     * It exposes the current DragTarget HTML element and its index in the collection of drag targets as arguments.\n     */\n    set dragTargetId(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`dragTargetId must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._dragTargetId = fn;\n    }\n    get dragTargetId() {\n      return this._dragTargetId;\n    }\n    /**\n     * Defines a callback function which returns custom data passed to the DropTarget events.\n     * It exposes the current DragTarget HTML element, its `dragTargetId` and its index in the collection of drag targets as arguments.\n     */\n    set dragData(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._dragData = fn;\n    }\n    get dragData() {\n      return this._dragData;\n    }\n    /**\n     * If set to true, the dragging of DragTargets within the container will be disabled.\n     *\n     * @default false\n     */\n    set dragDisabled(value) {\n      this._dragDisabled = value;\n      if (value) {\n        this.clearPreviousTargets();\n        this.removeListeners();\n        if (isPresent(this.hintElem)) {\n          this.destroyHint();\n        }\n      } else {\n        if (isPresent(this.wrapper) || isPresent(this.currentDragTarget)) {\n          this.subscribe();\n        }\n        this.initializeDragTargets();\n      }\n    }\n    get dragDisabled() {\n      return this._dragDisabled;\n    }\n    /**\n     * Specifies whether the default dragging behavior will be performed or the developer will manually handle the drag action.\n     *\n     * @default 'auto'\n     */\n\n    /**\n     * Used for notifying the DragTargetContainer that its content has changed.\n     */\n    notify() {\n      this.cdr.detectChanges();\n      this.initializeDragTargets();\n    }\n    get allDragTargets() {\n      return this.queryHost(this.dragTargetFilter);\n    }\n    get dragHandles() {\n      return this.isHandleSelectorValid ? this.queryHost(this.dragHandle) : null;\n    }\n    get hintTemplate() {\n      return isPresent(this.hint) && typeof this.hint === 'object' ? this.hint.hintTemplate : null;\n    }\n    constructor(wrapper, ngZone, renderer, service, viewContainer, cdr) {\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"viewContainer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      /**\n       * Defines whether a hint will be used for dragging. By default, the hint is a copy of the current drag target. ([see example]({% slug drag_hint %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"hint\", false);\n      _defineProperty(this, \"dragHandle\", void 0);\n      /**\n       * Defines the delay in milliseconds after which the drag will begin ([see example](slug:drag_target_container#toc-events)).\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"dragDelay\", 0);\n      /**\n       * The number of pixels the pointer moves in any direction before the dragging starts ([see example]({% slug minimum_distance %})).\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"threshold\", 0);\n      _defineProperty(this, \"mode\", 'auto');\n      /**\n       * Specifies the cursor style of the drag targets. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).\n       *\n       * @default 'move'\n       */\n      _defineProperty(this, \"cursorStyle\", 'move');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"hintContext\", void 0);\n      /**\n       * Fires when a DragTarget's `dragDelay` has passed and the user is able to drag the element.\n       */\n      _defineProperty(this, \"onDragReady\", new EventEmitter());\n      /**\n       * Fires when the user presses a DragTarget element.\n       */\n      _defineProperty(this, \"onPress\", new EventEmitter());\n      /**\n       * Fires when the dragging of a DragTarget element begins.\n      */\n      _defineProperty(this, \"onDragStart\", new EventEmitter());\n      /**\n       * Fires while the user drags a DragTarget element.\n       */\n      _defineProperty(this, \"onDrag\", new EventEmitter());\n      /**\n       * Fires when the user releases a DragTarget element after being pressed.\n       */\n      _defineProperty(this, \"onRelease\", new EventEmitter());\n      /**\n       * Fires when the dragging of a DragTarget ends and the element is released.\n       */\n      _defineProperty(this, \"onDragEnd\", new EventEmitter());\n      _defineProperty(this, \"currentDragTarget\", null);\n      _defineProperty(this, \"dragTimeout\", null);\n      _defineProperty(this, \"pressed\", false);\n      _defineProperty(this, \"dragStarted\", false);\n      _defineProperty(this, \"hintComponent\", null);\n      _defineProperty(this, \"defaultHint\", null);\n      _defineProperty(this, \"currentDragTargetElement\", null);\n      _defineProperty(this, \"scrollableParent\", null);\n      _defineProperty(this, \"previousDragTargets\", []);\n      _defineProperty(this, \"initialPosition\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"position\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"positionsMap\", new Map());\n      _defineProperty(this, \"_dragTargetFilter\", null);\n      _defineProperty(this, \"_dragDisabled\", false);\n      _defineProperty(this, \"_dragData\", () => null);\n      _defineProperty(this, \"_dragTargetId\", () => null);\n      _defineProperty(this, \"prevUserSelect\", void 0);\n      this.wrapper = wrapper;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.service = service;\n      this.viewContainer = viewContainer;\n      this.cdr = cdr;\n      validatePackage(packageMetadata);\n    }\n    ngAfterViewInit() {\n      const isTargetPresent = isPresent(this.wrapper) || isPresent(this.currentDragTarget);\n      if (!this.dragDisabled && isTargetPresent) {\n        this.subscribe();\n      }\n      !this.dragDisabled && this.initializeDragTargets();\n    }\n    ngOnDestroy() {\n      this.removeListeners();\n    }\n    onPointerDown(event) {\n      const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);\n      if (this.dragTargetFilter === '' || !isPresent(filterElement)) {\n        return;\n      }\n      if (isPresent(this.dragHandles) && !this.isDragHandle(event.target)) {\n        return;\n      }\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n      this.subscribe();\n    }\n    onTouchStart(event) {\n      const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);\n      if (this.dragTargetFilter === '' || !isPresent(filterElement)) {\n        return;\n      }\n      if (isPresent(this.dragHandles) && !this.isDragHandle(event.target)) {\n        return;\n      }\n      event.preventDefault();\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n      this.subscribe();\n    }\n    onPointerMove(event) {\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n    }\n    onTouchMove(event) {\n      event.preventDefault();\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n    }\n    onPointerUp(event) {\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n      this.subscribe();\n    }\n    onContextMenu(event) {\n      event.preventDefault();\n      const action = getAction(event, this.currentDragTarget);\n      this.service.handleDragAndDrop(action);\n      this.subscribe();\n    }\n    handlePress(event) {\n      if (this.dragDelay > 0) {\n        this.dragTimeout = window.setTimeout(() => {\n          this.pressed = true;\n          this.emitZoneAwareEvent('onDragReady', event);\n        }, this.dragDelay);\n      } else {\n        this.pressed = true;\n      }\n      const eventTarget = event.originalEvent.target;\n      this.currentDragTargetElement = closestBySelector(eventTarget, this.dragTargetFilter);\n      this.currentDragTarget.element = this.currentDragTargetElement;\n      this.service.dragIndex = this.getDragIndex();\n      this.scrollableParent = this.hintTemplate ? document.body : this.currentDragTargetElement ? getScrollableParent(this.currentDragTargetElement) : null;\n      this.prevUserSelect = this.currentDragTargetElement.style.userSelect;\n      this.renderer.setStyle(this.currentDragTargetElement, 'user-select', 'none');\n      this.emitZoneAwareEvent('onPress', event);\n    }\n    handleDragStart(event) {\n      if (!this.pressed) {\n        if (this.dragTimeout) {\n          window.clearTimeout(this.dragTimeout);\n          this.dragTimeout = null;\n        }\n        return;\n      }\n      isDragStartPrevented$1 = this.emitZoneAwareEvent('onDragStart', event).isDefaultPrevented();\n      if (isDragStartPrevented$1) {\n        return;\n      }\n      this.position = this.positionsMap.has(this.currentDragTargetElement) ? this.positionsMap.get(this.currentDragTargetElement) : {\n        x: 0,\n        y: 0\n      };\n      if (this.hint) {\n        this.createHint();\n        if (this.mode === 'auto') {\n          this.renderer.setStyle(this.currentDragTargetElement, 'opacity', '0.7');\n        }\n      } else {\n        this.initialPosition = {\n          x: event.clientX - this.position.x,\n          y: event.clientY - this.position.y\n        };\n      }\n      this.dragStarted = this.threshold === 0;\n      this.service.dragTarget = this.currentDragTarget;\n      const targetIdArgs = {\n        dragTarget: this.currentDragTargetElement,\n        dragTargetIndex: this.service.dragIndex\n      };\n      this.service.dragTargetId = this.dragTargetId(targetIdArgs);\n      const targetDataArgs = Object.assign({\n        dragTargetId: this.service.dragTargetId\n      }, targetIdArgs);\n      this.service.dragData = this.dragData(targetDataArgs);\n    }\n    handleDrag(event) {\n      if (!this.pressed || isDragStartPrevented$1) {\n        return;\n      }\n      const elem = this.hint ? this.hintElem : this.currentDragTargetElement;\n      this.position = this.calculatePosition(elem, event);\n      const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;\n      if (!this.dragStarted && thresholdNotReached) {\n        return;\n      }\n      if (!this.dragStarted && this.threshold > 0) {\n        this.dragStarted = true;\n      }\n      isDragPrevented$1 = this.emitZoneAwareEvent('onDrag', event).isDefaultPrevented();\n      if (isDragPrevented$1) {\n        return;\n      }\n      if (this.mode === 'auto') {\n        this.performDrag();\n      } else {\n        this.dragStarted = true;\n      }\n    }\n    handleRelease(event) {\n      if (this.dragStarted) {\n        this.positionsMap.set(this.currentDragTargetElement, this.position);\n      }\n      if (this.dragTimeout) {\n        clearTimeout(this.dragTimeout);\n        this.dragTimeout = null;\n      }\n      this.pressed = false;\n      this.prevUserSelect ? this.renderer.setStyle(this.currentDragTargetElement, 'user-select', this.prevUserSelect) : this.renderer.removeStyle(this.currentDragTargetElement, 'user-select');\n      this.prevUserSelect = null;\n      this.emitZoneAwareEvent('onRelease', event);\n    }\n    handleDragEnd(event) {\n      if (!this.dragStarted) {\n        return;\n      }\n      if (this.mode === 'auto') {\n        const isDroppedOverParentTarget = isPresent(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);\n        const elem = this.hint ? this.hintElem : this.currentDragTargetElement;\n        if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent(elem)) {\n          this.renderer.removeStyle(elem, 'transform');\n          setElementStyles(this.renderer, elem, {\n            transition: dragTargetTransition\n          });\n          this.positionsMap.delete(this.currentDragTargetElement);\n        }\n      }\n      if (this.hint && isPresent(this.hintElem)) {\n        this.destroyHint();\n        if (this.mode === 'auto') {\n          this.renderer.removeStyle(this.currentDragTargetElement, 'opacity');\n        }\n      }\n      this.service.dragTarget = null;\n      this.service.dragIndex = null;\n      this.currentDragTarget.element = null;\n      this.emitZoneAwareEvent('onDragEnd', event);\n      if (isDragStartPrevented$1 || isDragPrevented$1) {\n        return;\n      }\n      this.dragStarted = false;\n    }\n    get nativeElement() {\n      return this.wrapper.nativeElement;\n    }\n    get hintElem() {\n      return this.hintTemplate && isPresent(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;\n    }\n    removeListeners() {\n      if (isPresent(this.scrollableParent)) {\n        this.scrollableParent.removeEventListener('scroll', this.onPointerMove);\n      }\n      const element = this.nativeElement;\n      document.removeEventListener('pointermove', this.onPointerMove);\n      document.removeEventListener('pointerup', this.onPointerUp, true);\n      document.removeEventListener('pointercancel', this.onPointerUp);\n      document.removeEventListener('contextmenu', this.onContextMenu);\n      window.removeEventListener('touchmove', noop);\n      element.removeEventListener('touchmove', this.onTouchMove);\n      element.removeEventListener('touchend', this.onPointerUp);\n      document.removeEventListener('mousemove', this.onPointerMove);\n      document.removeEventListener('mouseup', this.onPointerUp);\n      document.removeEventListener('touchcancel', this.onPointerUp);\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('mousedown', this.onPointerDown);\n      element.removeEventListener('touchstart', this.onTouchStart);\n    }\n    get supportPointerEvent() {\n      return Boolean(typeof window !== 'undefined' && window.PointerEvent);\n    }\n    subscribe() {\n      this.ngZone.runOutsideAngular(() => {\n        this.removeListeners();\n        if (!(isDocumentAvailable() && isPresent(this.wrapper))) {\n          return;\n        }\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.onTouchMove = this.onTouchMove.bind(this);\n        this.onContextMenu = this.onContextMenu.bind(this);\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onTouchStart = this.onTouchStart.bind(this);\n        const element = this.nativeElement;\n        if (this.supportPointerEvent) {\n          if (isPresent(this.scrollableParent)) {\n            this.scrollableParent.addEventListener('scroll', this.onPointerMove, {\n              passive: true\n            });\n          }\n          element.addEventListener('pointerdown', this.onPointerDown, {\n            passive: true\n          });\n          if (this.pressed) {\n            document.addEventListener('pointermove', this.onPointerMove);\n            document.addEventListener('pointerup', this.onPointerUp, true);\n            document.addEventListener('contextmenu', this.onContextMenu);\n            document.addEventListener('pointercancel', this.onPointerUp, {\n              passive: true\n            });\n          }\n        } else {\n          window.addEventListener('touchmove', noop, {\n            capture: false,\n            passive: false\n          });\n          element.addEventListener('mousedown', this.onPointerDown, {\n            passive: true\n          });\n          element.addEventListener('touchstart', this.onTouchStart, {\n            passive: true\n          });\n          if (this.pressed) {\n            document.addEventListener('mousemove', this.onPointerMove, {\n              passive: true\n            });\n            document.addEventListener('mouseup', this.onPointerUp, {\n              passive: true\n            });\n            element.addEventListener('touchmove', this.onTouchMove, {\n              passive: true\n            });\n            element.addEventListener('touchend', this.onPointerUp, {\n              passive: true\n            });\n          }\n        }\n      });\n    }\n    emitZoneAwareEvent(event, normalizedEvent) {\n      const targetIdArgs = {\n        dragTarget: this.currentDragTargetElement,\n        dragTargetIndex: this.service.dragIndex\n      };\n      const eventProps = {\n        dragTarget: this.currentDragTargetElement,\n        dragEvent: normalizedEvent,\n        dragTargetIndex: this.service.dragIndex,\n        dragTargetId: this.dragTargetId(targetIdArgs)\n      };\n      if (this.hint && isPresent(this.hintElem)) {\n        eventProps.hintElement = this.hintElem;\n      }\n      let eventArgs;\n      switch (event) {\n        case 'onDragReady':\n          eventArgs = new DragTargetDragReadyEvent(eventProps);\n          break;\n        case 'onPress':\n          eventArgs = new DragTargetPressEvent(eventProps);\n          break;\n        case 'onDragStart':\n          eventArgs = new DragTargetDragStartEvent(eventProps);\n          break;\n        case 'onDrag':\n          eventArgs = new DragTargetDragEvent(eventProps);\n          break;\n        case 'onRelease':\n          eventArgs = new DragTargetReleaseEvent(eventProps);\n          break;\n        case 'onDragEnd':\n          eventArgs = new DragTargetDragEndEvent(eventProps);\n          break;\n        default:\n          break;\n      }\n      this.ngZone.run(() => {\n        this[event].emit(eventArgs);\n      });\n      return eventArgs;\n    }\n    createHint() {\n      if (!(isDocumentAvailable() && isPresent(this.wrapper))) {\n        return;\n      }\n      if (isPresent(this.hint) && typeof this.hint === 'object') {\n        if (isPresent(this.hint.hintTemplate)) {\n          this.createCustomHint();\n        } else {\n          this.createDefaultHint();\n        }\n      } else {\n        this.createDefaultHint();\n      }\n      this.currentDragTarget.hint = this.hintElem;\n      if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {\n        this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);\n      } else {\n        document.body.appendChild(this.hintElem);\n      }\n    }\n    createDefaultHint() {\n      this.defaultHint = this.currentDragTargetElement.cloneNode(true);\n      if (typeof this.hint === 'object') {\n        if (isPresent(this.hint.hintClass)) {\n          const hintClasses = parseCSSClassNames(this.hint.hintClass);\n          hintClasses.forEach(className => this.renderer.addClass(this.defaultHint, className));\n        }\n      }\n    }\n    createCustomHint() {\n      if (isPresent(this.hint.appendTo)) {\n        this.hintComponent = this.hint.appendTo.createComponent(HintComponent);\n      } else {\n        this.hintComponent = this.viewContainer.createComponent(HintComponent);\n      }\n      this.hintComponent.instance.template = this.hintTemplate;\n      this.hintComponent.instance.directive = this;\n      this.hintComponent.instance.targetIndex = this.service.dragIndex;\n      const targetDataArgs = {\n        dragTarget: this.currentDragTargetElement,\n        dragTargetId: this.service.dragTargetId,\n        dragTargetIndex: this.service.dragIndex\n      };\n      this.hintComponent.instance.contextData = this.dragData(targetDataArgs);\n      this.hintComponent.instance.customContext = this.hintContext;\n      this.hintComponent.changeDetectorRef.detectChanges();\n    }\n    destroyHint() {\n      if (isPresent(this.hintTemplate)) {\n        this.hintComponent.destroy();\n        this.hintComponent.changeDetectorRef.detectChanges();\n        this.hintComponent = null;\n      } else {\n        document.body.removeChild(this.defaultHint);\n        this.defaultHint = null;\n      }\n      this.currentDragTarget.hint = null;\n    }\n    getDragIndex() {\n      return this.allDragTargets.indexOf(this.currentDragTargetElement);\n    }\n    initializeDragTargets() {\n      if (!isPresent(this.allDragTargets)) {\n        if (this.previousDragTargets.length > 0) {\n          this.clearPreviousTargets();\n        }\n        return;\n      }\n      this.allDragTargets.forEach(dragTargetEl => {\n        const isDragTargetInitialized = this.service.dragTargets.find(dt => dt.element === dragTargetEl);\n        if (!isDragTargetInitialized) {\n          this.service.dragTargets.push({\n            element: dragTargetEl,\n            hint: null,\n            onPress: this.handlePress.bind(this),\n            onRelease: this.handleRelease.bind(this),\n            onDragStart: this.handleDragStart.bind(this),\n            onDrag: this.handleDrag.bind(this),\n            onDragEnd: this.handleDragEnd.bind(this)\n          });\n        }\n      });\n      if (this.previousDragTargets.length > 0) {\n        const dragTargetsToRemove = this.previousDragTargets.filter(dt => !this.allDragTargets.includes(dt));\n        dragTargetsToRemove.forEach(dragTarget => {\n          const idx = this.service.dragTargets.findIndex(serviceDragTarget => serviceDragTarget.element === dragTarget);\n          if (idx > -1) {\n            this.service.dragTargets.splice(idx, 1);\n          }\n        });\n      }\n      this.previousDragTargets = this.allDragTargets;\n      this.currentDragTarget = {\n        element: null,\n        hint: null,\n        onPress: this.handlePress.bind(this),\n        onRelease: this.handleRelease.bind(this),\n        onDragStart: this.handleDragStart.bind(this),\n        onDrag: this.handleDrag.bind(this),\n        onDragEnd: this.handleDragEnd.bind(this)\n      };\n      this.setTargetStyles();\n    }\n    isDragHandle(el) {\n      return this.dragHandles.some(dh => contains(dh, el, true));\n    }\n    get isHandleSelectorValid() {\n      return isPresent(this.dragHandle) && this.dragHandle !== '';\n    }\n    setTargetStyles() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (isPresent(this.dragHandle) && this.dragHandle !== '') {\n        if (isPresent(this.dragHandles) && this.dragHandles.length > 0) {\n          this.dragHandles.forEach(handle => {\n            this.renderer.setStyle(handle, 'cursor', this.cursorStyle);\n            this.renderer.setStyle(handle, 'touch-action', 'none');\n          });\n        }\n      } else {\n        this.allDragTargets.forEach(target => {\n          this.renderer.setStyle(target, 'cursor', this.cursorStyle);\n          this.renderer.setStyle(target, 'touch-action', 'none');\n        });\n      }\n    }\n    queryHost(selector) {\n      if (isPresent(selector) && selector !== \"\") {\n        return Array.from(this.nativeElement.querySelectorAll(selector));\n      }\n    }\n    clearPreviousTargets() {\n      this.previousDragTargets.forEach(dragTarget => {\n        const idx = this.service.dragTargets.findIndex(serviceDragTarget => serviceDragTarget.element === dragTarget);\n        if (idx > -1) {\n          this.service.dragTargets.splice(idx, 1);\n        }\n      });\n      this.previousDragTargets = [];\n    }\n    performDrag() {\n      const elem = this.hint ? this.hintElem : this.currentDragTargetElement;\n      if (elem) {\n        const styles = this.getStylesPerElement(elem);\n        setElementStyles(this.renderer, elem, styles);\n      }\n    }\n    calculatePosition(element, event) {\n      let position = null;\n      if (element === this.hintElem) {\n        position = {\n          x: event.clientX + window.scrollX,\n          y: event.clientY + window.scrollY\n        };\n      } else {\n        position = {\n          x: event.clientX - this.initialPosition.x + event.scrollX,\n          y: event.clientY - this.initialPosition.y + event.scrollY\n        };\n      }\n      return position;\n    }\n    getStylesPerElement(element) {\n      if (element === this.hintElem) {\n        return {\n          top: `${this.position.y}px`,\n          left: `${this.position.x}px`,\n          transition: 'none',\n          position: 'absolute',\n          zIndex: 1999\n        };\n      } else {\n        const transform = `translate(${this.position.x}px, ${this.position.y}px)`;\n        return {\n          transform: transform,\n          transition: 'none'\n        };\n      }\n    }\n  }\n  _class10 = DragTargetContainerDirective;\n  _defineProperty(DragTargetContainerDirective, \"\\u0275fac\", function _class10_Factory(t) {\n    return new (t || _class10)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragStateService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DragTargetContainerDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class10,\n    selectors: [[\"\", \"kendoDragTargetContainer\", \"\"]],\n    inputs: {\n      hint: \"hint\",\n      dragTargetFilter: \"dragTargetFilter\",\n      dragHandle: \"dragHandle\",\n      dragDelay: \"dragDelay\",\n      threshold: \"threshold\",\n      dragTargetId: \"dragTargetId\",\n      dragData: \"dragData\",\n      dragDisabled: \"dragDisabled\",\n      mode: \"mode\",\n      cursorStyle: \"cursorStyle\",\n      hintContext: \"hintContext\"\n    },\n    outputs: {\n      onDragReady: \"onDragReady\",\n      onPress: \"onPress\",\n      onDragStart: \"onDragStart\",\n      onDrag: \"onDrag\",\n      onRelease: \"onRelease\",\n      onDragEnd: \"onDragEnd\"\n    },\n    exportAs: [\"kendoDragTargetContainer\"],\n    standalone: true\n  }));\n  return DragTargetContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet isDragStartPrevented = false;\nlet isDragPrevented = false;\n/**\n * Represents the Kendo UI DragTarget directive for Angular.\n */\nlet DragTargetDirective = /*#__PURE__*/(() => {\n  var _class11;\n  class DragTargetDirective {\n    get touchActionStyle() {\n      return this.dragHandles.length > 0 ? null : 'none';\n    }\n    /**\n     * Defines whether a hint will be used for dragging. By default, the hint is a copy of the drag target. ([see example]({% slug drag_hint %})).\n     *\n     * @default false\n     */\n\n    /**\n     * Defines a callback function used for attaching custom data to the dragTarget.\n     * The data will be available in the events of the respective [`DropTarget`]({% slug api_utils_droptargetdirective %}) or [`DropTargetContainer`]({% slug api_utils_droptargetcontainerdirective %}) directives.\n     * The current DragTarget HTML element and its `dragTargetId` will be available as arguments.\n     */\n    set dragData(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._dragData = fn;\n    }\n    get dragData() {\n      return this._dragData;\n    }\n    /**\n     * Specifies the cursor style of the drag target. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).\n     *\n     * @default 'move'\n     */\n\n    get hintTemplate() {\n      return isPresent(this.hint) && typeof this.hint === 'object' ? this.hint.hintTemplate : null;\n    }\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    get hintElem() {\n      return this.hintTemplate && isPresent(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;\n    }\n    onPointerDown(event) {\n      if (this.dragHandles.length && !this.isDragHandle(event.target)) {\n        return;\n      }\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n      this.service.autoScroll = typeof this.autoScroll === 'object' ? this.autoScroll.enabled !== false : this.autoScroll;\n      this.service.scrollableParent = this.getAutoScrollContainer();\n      this.service.autoScrollDirection = typeof this.autoScroll === 'object' ? this.autoScroll.direction : {\n        horizontal: true,\n        vertical: true\n      };\n      this.attachDomHandlers();\n    }\n    onTouchStart(event) {\n      if (this.dragHandles.length && !this.isDragHandle(event.target)) {\n        return;\n      }\n      event.preventDefault();\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n      this.service.autoScroll = typeof this.autoScroll === 'object' ? this.autoScroll.enabled !== false : this.autoScroll;\n      this.service.scrollableParent = this.getAutoScrollContainer();\n      this.service.autoScrollDirection = typeof this.autoScroll === 'object' ? this.autoScroll.direction : {\n        horizontal: true,\n        vertical: true\n      };\n      this.attachDomHandlers();\n    }\n    onPointerMove(event) {\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n    }\n    onTouchMove(event) {\n      event.preventDefault();\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n    }\n    onPointerUp(event) {\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n      this.attachDomHandlers();\n    }\n    onContextMenu(event) {\n      event.preventDefault();\n      const action = getAction(event, this.dragTarget);\n      this.service.handleDragAndDrop(action);\n      this.attachDomHandlers();\n    }\n    constructor(element, renderer, ngZone, service, viewContainer) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"viewContainer\", void 0);\n      _defineProperty(this, \"hint\", false);\n      /**\n       * The number of pixels the pointer moves in any direction before the dragging starts ([see example]({% slug minimum_distance %})). Applicable when `manualDrag` is set to `false`.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"threshold\", 0);\n      /**\n       * Defines the automatic container scrolling behavior when close to the edge ([see example]({% slug auto_scroll %})).\n       *\n       * @default true\n       */\n      _defineProperty(this, \"autoScroll\", true);\n      /**\n       * Defines a unique identifier for the dragTarget.\n       */\n      _defineProperty(this, \"dragTargetId\", void 0);\n      /**\n       * Defines the delay in milliseconds after which the drag will begin ([see example]({% slug drag_delay %})).\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"dragDelay\", 0);\n      /**\n       * Restricts the element to be dragged horizontally or vertically only ([see example]({% slug axis_lock %})). Applicable when `mode` is set to `auto`.\n       */\n      _defineProperty(this, \"restrictByAxis\", void 0);\n      /**\n       * Specifies whether the default dragging behavior will be performed or the developer will manually handle the drag action.\n       *\n       * @default 'auto'\n       */\n      _defineProperty(this, \"mode\", 'auto');\n      _defineProperty(this, \"cursorStyle\", 'move');\n      /**\n       * Fires when the user presses the DragTarget element.\n       */\n      _defineProperty(this, \"onPress\", new EventEmitter());\n      /**\n       * Fires when the dragging of the DragTarget element begins.\n       */\n      _defineProperty(this, \"onDragStart\", new EventEmitter());\n      /**\n       * Fires while the user drags the DragTarget element.\n       */\n      _defineProperty(this, \"onDrag\", new EventEmitter());\n      /**\n       * Fires when the DragTarget's `dragDelay` has passed and the user is able to drag the element.\n       */\n      _defineProperty(this, \"onDragReady\", new EventEmitter());\n      /**\n       * Fires when the user releases the DragTarget element after being pressed.\n       */\n      _defineProperty(this, \"onRelease\", new EventEmitter());\n      /**\n       * Fires when the dragging of the DragTarget ends and the element is released.\n       */\n      _defineProperty(this, \"onDragEnd\", new EventEmitter());\n      _defineProperty(this, \"dragTarget\", null);\n      _defineProperty(this, \"hintComponent\", null);\n      _defineProperty(this, \"dragStarted\", false);\n      _defineProperty(this, \"pressed\", false);\n      _defineProperty(this, \"dragTimeout\", null);\n      _defineProperty(this, \"initialPosition\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"position\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"scrollableParent\", null);\n      _defineProperty(this, \"defaultHint\", null);\n      _defineProperty(this, \"_dragData\", () => null);\n      _defineProperty(this, \"prevUserSelect\", void 0);\n      _defineProperty(this, \"dragHandles\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.service = service;\n      this.viewContainer = viewContainer;\n      validatePackage(packageMetadata);\n    }\n    ngOnInit() {\n      this.initializeDragTarget();\n    }\n    ngAfterContentInit() {\n      if (isPresent(this.element) || isPresent(this.dragTarget)) {\n        this.attachDomHandlers();\n        if (!this.dragHandles.length) {\n          this.renderer.setStyle(this.nativeElement, 'cursor', this.cursorStyle);\n        }\n      }\n      this.service.dragTargets.push(this.dragTarget);\n    }\n    ngOnDestroy() {\n      this.removeListeners();\n      const currentDragTargetIndex = this.service.dragTargets.indexOf(this.dragTarget);\n      this.service.dragTargets.splice(currentDragTargetIndex, 1);\n    }\n    handlePress(event) {\n      if (this.dragDelay > 0) {\n        this.dragTimeout = window.setTimeout(() => {\n          this.pressed = true;\n          this.emitZoneAwareEvent('onDragReady', event);\n        }, this.dragDelay);\n      } else {\n        this.pressed = true;\n      }\n      this.scrollableParent = this.dragTarget.element ? getScrollableParent(this.dragTarget.element) : null;\n      this.prevUserSelect = this.dragTarget.element.style.userSelect;\n      this.renderer.setStyle(this.dragTarget.element, 'user-select', 'none');\n      this.emitZoneAwareEvent('onPress', event);\n    }\n    handleDragStart(event) {\n      if (!this.pressed) {\n        if (this.dragTimeout) {\n          window.clearTimeout(this.dragTimeout);\n          this.dragTimeout = null;\n        }\n        return;\n      }\n      isDragStartPrevented = this.emitZoneAwareEvent('onDragStart', event).isDefaultPrevented();\n      if (isDragStartPrevented) {\n        return;\n      }\n      if (this.hint) {\n        this.createHint();\n        if (this.mode === 'auto') {\n          this.renderer.setStyle(this.nativeElement, 'opacity', '0.7');\n        }\n        this.initialPosition = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      } else {\n        this.initialPosition = {\n          x: event.clientX - this.position.x,\n          y: event.clientY - this.position.y\n        };\n      }\n      this.dragStarted = this.threshold === 0;\n      this.service.dragTarget = this.dragTarget;\n      this.service.dragTargetDirective = this;\n      this.service.dragData = this.dragData({\n        dragTarget: this.dragTarget.element,\n        dragTargetId: this.dragTargetIdResult,\n        dragTargetIndex: null\n      });\n    }\n    handleDrag(event) {\n      if (!this.pressed || isDragStartPrevented) {\n        return;\n      }\n      const elem = this.hint ? this.hintElem : this.nativeElement;\n      this.position = this.calculatePosition(elem, event);\n      const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;\n      if (!this.dragStarted && thresholdNotReached) {\n        return;\n      }\n      if (!this.dragStarted && this.threshold > 0) {\n        this.dragStarted = true;\n      }\n      isDragPrevented = this.emitZoneAwareEvent('onDrag', event).isDefaultPrevented();\n      if (isDragPrevented) {\n        return;\n      }\n      if (this.mode === 'auto') {\n        this.performDrag();\n      } else {\n        this.dragStarted = true;\n      }\n    }\n    handleRelease(event) {\n      if (this.dragTimeout) {\n        clearTimeout(this.dragTimeout);\n        this.dragTimeout = null;\n      }\n      this.pressed = false;\n      this.prevUserSelect ? this.renderer.setStyle(this.dragTarget.element, 'user-select', this.prevUserSelect) : this.renderer.removeStyle(this.dragTarget.element, 'user-select');\n      this.prevUserSelect = null;\n      this.emitZoneAwareEvent('onRelease', event);\n    }\n    handleDragEnd(event) {\n      if (this.mode === 'auto') {\n        const isDroppedOverParentTarget = isPresent(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);\n        const elem = this.hint ? this.hintElem : this.nativeElement;\n        if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent(elem)) {\n          this.renderer.removeStyle(elem, 'transform');\n          setElementStyles(this.renderer, elem, {\n            transition: dragTargetTransition\n          });\n          this.position = {\n            x: 0,\n            y: 0\n          };\n        }\n      }\n      if (this.hint && isPresent(this.hintElem)) {\n        this.destroyHint();\n        if (this.mode === 'auto') {\n          this.renderer.removeStyle(this.nativeElement, 'opacity');\n        }\n      }\n      this.service.dragTarget = null;\n      this.service.dragTargetDirective = null;\n      if (!this.dragStarted || isDragStartPrevented || isDragPrevented) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDragEnd', event);\n      this.dragStarted = false;\n    }\n    initializeDragTarget() {\n      this.dragTarget = {\n        element: this.nativeElement,\n        hint: null,\n        onPress: this.handlePress.bind(this),\n        onRelease: this.handleRelease.bind(this),\n        onDragStart: this.handleDragStart.bind(this),\n        onDrag: this.handleDrag.bind(this),\n        onDragEnd: this.handleDragEnd.bind(this)\n      };\n    }\n    get supportPointerEvent() {\n      return Boolean(typeof window !== 'undefined' && window.PointerEvent);\n    }\n    removeListeners() {\n      if (isPresent(this.scrollableParent)) {\n        this.scrollableParent.removeEventListener('scroll', this.onPointerMove);\n      }\n      const element = this.nativeElement;\n      document.removeEventListener('pointermove', this.onPointerMove);\n      document.removeEventListener('pointerup', this.onPointerUp, true);\n      document.removeEventListener('contextmenu', this.onContextMenu);\n      document.removeEventListener('pointercancel', this.onPointerUp);\n      window.removeEventListener('touchmove', noop);\n      element.removeEventListener('touchmove', this.onTouchMove);\n      element.removeEventListener('touchend', this.onPointerUp);\n      document.removeEventListener('mousemove', this.onPointerMove);\n      document.removeEventListener('mouseup', this.onPointerUp);\n      document.removeEventListener('touchcancel', this.onPointerUp);\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('mousedown', this.onPointerDown);\n      element.removeEventListener('touchstart', this.onTouchStart);\n    }\n    attachDomHandlers() {\n      this.ngZone.runOutsideAngular(() => {\n        this.removeListeners();\n        if (!(isDocumentAvailable() && isPresent(this.element))) {\n          return;\n        }\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.onTouchMove = this.onTouchMove.bind(this);\n        this.onContextMenu = this.onContextMenu.bind(this);\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onTouchStart = this.onTouchStart.bind(this);\n        const element = this.nativeElement;\n        if (this.supportPointerEvent) {\n          if (isPresent(this.scrollableParent)) {\n            if (this.scrollableParent === document.getElementsByTagName('html')[0]) {\n              this.scrollableParent = window;\n            }\n            this.scrollableParent.addEventListener('scroll', this.onPointerMove, {\n              passive: true\n            });\n          }\n          element.addEventListener('pointerdown', this.onPointerDown, {\n            passive: true\n          });\n          if (this.pressed) {\n            document.addEventListener('pointermove', this.onPointerMove);\n            document.addEventListener('pointerup', this.onPointerUp, true);\n            document.addEventListener('contextmenu', this.onContextMenu);\n            document.addEventListener('pointercancel', this.onPointerUp, {\n              passive: true\n            });\n          }\n        } else {\n          window.addEventListener('touchmove', noop, {\n            capture: false,\n            passive: false\n          });\n          element.addEventListener('mousedown', this.onPointerDown, {\n            passive: true\n          });\n          element.addEventListener('touchstart', this.onTouchStart, {\n            passive: true\n          });\n          if (this.pressed) {\n            document.addEventListener('mousemove', this.onPointerMove, {\n              passive: true\n            });\n            document.addEventListener('mouseup', this.onPointerUp, {\n              passive: true\n            });\n            element.addEventListener('touchmove', this.onTouchMove, {\n              passive: true\n            });\n            element.addEventListener('touchend', this.onPointerUp, {\n              passive: true\n            });\n          }\n        }\n      });\n    }\n    isDragHandle(el) {\n      return this.dragHandles.toArray().some(dh => contains(dh.element.nativeElement, el, true));\n    }\n    getAutoScrollContainer() {\n      return typeof this.autoScroll === 'object' && this.autoScroll.boundaryElementRef && this.autoScroll.boundaryElementRef.nativeElement ? this.autoScroll.boundaryElementRef.nativeElement : null;\n    }\n    createHint() {\n      if (!(isDocumentAvailable() && isPresent(this.element))) {\n        return;\n      }\n      if (isPresent(this.hint) && typeof this.hint === 'object') {\n        if (isPresent(this.hint.hintTemplate)) {\n          this.createCustomHint();\n        } else {\n          this.createDefaultHint();\n        }\n      } else {\n        this.createDefaultHint();\n      }\n      this.dragTarget.hint = this.hintElem;\n      if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {\n        this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);\n      } else {\n        document.body.appendChild(this.hintElem);\n      }\n    }\n    createDefaultHint() {\n      this.defaultHint = this.nativeElement.cloneNode(true);\n      if (typeof this.hint === 'object') {\n        if (isPresent(this.hint.hintClass)) {\n          const hintClasses = parseCSSClassNames(this.hint.hintClass);\n          hintClasses.forEach(className => this.renderer.addClass(this.defaultHint, className));\n        }\n      }\n    }\n    createCustomHint() {\n      if (isPresent(this.hint.appendTo)) {\n        this.hintComponent = this.hint.appendTo.createComponent(HintComponent);\n      } else {\n        this.hintComponent = this.viewContainer.createComponent(HintComponent);\n      }\n      this.hintComponent.instance.template = this.hintTemplate;\n      this.hintComponent.instance.directive = this;\n      this.hintComponent.changeDetectorRef.detectChanges();\n    }\n    destroyHint() {\n      if (isPresent(this.hintTemplate)) {\n        this.hintComponent.destroy();\n        this.hintComponent.changeDetectorRef.detectChanges();\n        this.hintComponent = null;\n      } else {\n        if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {\n          this.hint.appendTo.element.nativeElement.removeChild(this.defaultHint);\n        } else {\n          document.body.removeChild(this.defaultHint);\n        }\n        this.defaultHint = null;\n      }\n      this.dragTarget.hint = null;\n    }\n    emitZoneAwareEvent(event, normalizedEvent) {\n      const eventProps = {\n        dragTarget: this.nativeElement,\n        dragEvent: normalizedEvent\n      };\n      if (this.hint && isPresent(this.hintElem)) {\n        eventProps.hintElement = this.hintElem;\n      }\n      if (this.dragTargetId && this.dragTargetId !== '') {\n        eventProps.dragTargetId = this.dragTargetIdResult;\n      }\n      let eventArgs;\n      switch (event) {\n        case 'onDragReady':\n          eventArgs = new DragTargetDragReadyEvent(eventProps);\n          break;\n        case 'onPress':\n          eventArgs = new DragTargetPressEvent(eventProps);\n          break;\n        case 'onDragStart':\n          eventArgs = new DragTargetDragStartEvent(eventProps);\n          break;\n        case 'onDrag':\n          eventArgs = new DragTargetDragEvent(eventProps);\n          break;\n        case 'onRelease':\n          eventArgs = new DragTargetReleaseEvent(eventProps);\n          break;\n        case 'onDragEnd':\n          eventArgs = new DragTargetDragEndEvent(eventProps);\n          break;\n        default:\n          break;\n      }\n      this.ngZone.run(() => {\n        this[event].emit(eventArgs);\n      });\n      return eventArgs;\n    }\n    get dragTargetIdResult() {\n      if (this.dragTargetId && this.dragTargetId !== '') {\n        return typeof this.dragTargetId === 'string' ? this.dragTargetId : this.dragTargetId({\n          dragTarget: this.dragTarget.element,\n          dragTargetIndex: null\n        });\n      }\n    }\n    performDrag() {\n      const elem = this.hint ? this.hintElem : this.nativeElement;\n      if (elem) {\n        const styles = this.getStylesPerElement(elem);\n        setElementStyles(this.renderer, elem, styles);\n      }\n    }\n    calculatePosition(element, event) {\n      let position = null;\n      if (element === this.hintElem) {\n        position = {\n          x: event.clientX + window.scrollX,\n          y: event.clientY + window.scrollY\n        };\n      } else {\n        position = {\n          x: event.clientX - this.initialPosition.x + event.scrollX,\n          y: event.clientY - this.initialPosition.y + event.scrollY\n        };\n      }\n      if (this.restrictByAxis === 'horizontal') {\n        position.y = 0;\n      } else if (this.restrictByAxis === 'vertical') {\n        position.x = 0;\n      }\n      return position;\n    }\n    getStylesPerElement(element) {\n      if (element === this.hintElem) {\n        const hintCoordinates = {\n          x: this.position.x - this.initialPosition.x,\n          y: this.position.y - this.initialPosition.y\n        };\n        return {\n          top: `${hintCoordinates.y}px`,\n          left: `${hintCoordinates.x}px`,\n          transition: 'none',\n          position: 'absolute',\n          zIndex: 1999\n        };\n      } else {\n        const transform = `translate(${this.position.x}px, ${this.position.y}px)`;\n        return {\n          transform: transform,\n          transition: 'none'\n        };\n      }\n    }\n  }\n  _class11 = DragTargetDirective;\n  _defineProperty(DragTargetDirective, \"\\u0275fac\", function _class11_Factory(t) {\n    return new (t || _class11)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DragStateService), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  });\n  _defineProperty(DragTargetDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class11,\n    selectors: [[\"\", \"kendoDragTarget\", \"\"]],\n    contentQueries: function _class11_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DragHandleDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragHandles = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class11_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchActionStyle);\n      }\n    },\n    inputs: {\n      hint: \"hint\",\n      threshold: \"threshold\",\n      autoScroll: \"autoScroll\",\n      dragTargetId: \"dragTargetId\",\n      dragDelay: \"dragDelay\",\n      restrictByAxis: \"restrictByAxis\",\n      mode: \"mode\",\n      dragData: \"dragData\",\n      cursorStyle: \"cursorStyle\"\n    },\n    outputs: {\n      onPress: \"onPress\",\n      onDragStart: \"onDragStart\",\n      onDrag: \"onDrag\",\n      onDragReady: \"onDragReady\",\n      onRelease: \"onRelease\",\n      onDragEnd: \"onDragEnd\"\n    },\n    exportAs: [\"kendoDragTarget\"],\n    standalone: true\n  }));\n  return DragTargetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the drag events of the DropTarget and DropTargetContainer directives.\n */\nclass DropTargetEvent {\n  /**\n   * Left for backward compatibility for the DropTarget deprecated events.\n   * @hidden\n   */\n  get normalizedEvent() {\n    return this.dragEvent;\n  }\n  /**\n   * Left for backward compatibility for the DropTarget deprecated events.\n   * @hidden\n   */\n  get hostElement() {\n    return this.dropTarget;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    /**\n     * The current drag target element.\n     */\n    _defineProperty(this, \"dragTarget\", void 0);\n    /**\n     * The current drop target element.\n     */\n    _defineProperty(this, \"dropTarget\", void 0);\n    /**\n     * The information related to the current drag event.\n     */\n    _defineProperty(this, \"dragEvent\", void 0);\n    /**\n     * The data passed to the `dragData` input property of the `DragTarget` or `DragTargetContainer` directive.\n     */\n    _defineProperty(this, \"dragData\", void 0);\n    /**\n     * The index of the current drop target in the collection of drop targets (applicable for the `DropTargetContainer` directive).\n     */\n    _defineProperty(this, \"dropTargetIndex\", void 0);\n    /**\n     * The hint of the DragTarget.\n     */\n    _defineProperty(this, \"hintElement\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Represents the [Kendo UI DropTargetContainer directive for Angular]({% slug api_utils_droptargetcontainerdirective %}).\n * Used to configure multiple elements as drop targets.\n *\n * @example\n * ```ts-no-run\n * <div kendoDropTargetContainer dropTargetFilter=\".my-droptarget\">\n *    <div class=\"my-droptarget\">foo</div>\n * </div>\n * ```\n */\nlet DropTargetContainerDirective = /*#__PURE__*/(() => {\n  var _class13;\n  class DropTargetContainerDirective {\n    /**\n     * Specifies a selector for elements within a container which will be configured as drop targets\n     * ([see example]({% slug drop_target_container %})). The possible values include any\n     * DOM `selector`.\n     */\n    set dropTargetFilter(value) {\n      this._dropTargetFilter = value;\n      if (!this.dropDisabled) {\n        this.initializeDropTargets();\n      }\n    }\n    get dropTargetFilter() {\n      return this._dropTargetFilter;\n    }\n    /**\n     * Specifies whether the Drop Targets within the container will emit the corresponding events upon interaction with a Drag Target.\n     */\n    set dropDisabled(value) {\n      this._dropDisabled = value;\n      if (value) {\n        this.clearPreviousTargets();\n      } else {\n        this.initializeDropTargets();\n      }\n    }\n    get dropDisabled() {\n      return this._dropDisabled;\n    }\n    /**\n     * Fires when a DragTarget element enters the DropTarget.\n     */\n\n    /**\n     * Used for notifying the DropTargetContainer that its content has changed.\n     */\n    notify() {\n      this.cdr.detectChanges();\n      this.initializeDropTargets();\n    }\n    constructor(service, element, ngZone, cdr) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"onDragEnter\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element is being dragged over the DropTarget.\n       */\n      _defineProperty(this, \"onDragOver\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element leaves the DropTarget.\n       */\n      _defineProperty(this, \"onDragLeave\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element is dropped over the DropTarget.\n       */\n      _defineProperty(this, \"onDrop\", new EventEmitter());\n      _defineProperty(this, \"currentDropTargetElement\", null);\n      _defineProperty(this, \"previousDropTargets\", []);\n      _defineProperty(this, \"_dropTargetFilter\", null);\n      _defineProperty(this, \"_dropDisabled\", false);\n      this.service = service;\n      this.element = element;\n      this.ngZone = ngZone;\n      this.cdr = cdr;\n      validatePackage(packageMetadata);\n    }\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    ngAfterViewInit() {\n      !this.dropDisabled && this.initializeDropTargets();\n    }\n    get allDropTargets() {\n      if (isPresent(this.dropTargetFilter) && this.dropTargetFilter !== '') {\n        return Array.from(this.nativeElement.querySelectorAll(this.dropTargetFilter));\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleDragEnter(event) {\n      if (!this.service.dragTargetPresent || this.service.dropTargetPresent) {\n        return;\n      }\n      const currDragTargetElement = this.service.dragTarget.hint || this.service.dragTarget.element;\n      const currDropTargetElem = intersect(currDragTargetElement, this.allDropTargets);\n      const currDropTarget = this.service.dropTargets.find(dt => dt.element === currDropTargetElem);\n      if (!isPresent(currDropTargetElem) || !isPresent(currDropTarget)) {\n        return;\n      }\n      this.currentDropTargetElement = currDropTargetElem;\n      this.service.dropTarget = currDropTarget;\n      this.service.dropIndex = this.getDropIndex();\n      this.emitZoneAwareEvent('onDragEnter', event);\n    }\n    /**\n     * @hidden\n     */\n    handleDragLeave(event) {\n      if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDragLeave', event);\n      this.currentDropTargetElement = null;\n      this.service.dropTarget = null;\n      this.service.dropIndex = null;\n    }\n    /**\n     * @hidden\n     */\n    handleDragOver(event) {\n      if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDragOver', event);\n    }\n    /**\n     * @hidden\n     */\n    handleDrop(event) {\n      if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDrop', event);\n      this.currentDropTargetElement = null;\n      this.service.dropTarget = null;\n      this.service.dropIndex = null;\n    }\n    initializeDropTargets() {\n      if (!isPresent(this.allDropTargets)) {\n        if (this.previousDropTargets.length > 0) {\n          this.clearPreviousTargets();\n        }\n        return;\n      }\n      this.allDropTargets.forEach(dropTargetEl => {\n        const isDropTargetInitialized = this.service.dropTargets.find(dt => dt.element === dropTargetEl);\n        if (!isDropTargetInitialized) {\n          this.service.dropTargets.push({\n            element: dropTargetEl,\n            onDragEnter: this.handleDragEnter.bind(this),\n            onDragLeave: this.handleDragLeave.bind(this),\n            onDragOver: this.handleDragOver.bind(this),\n            onDrop: this.handleDrop.bind(this)\n          });\n        }\n      });\n      if (this.previousDropTargets.length > 0) {\n        const dropTargetsToRemove = this.previousDropTargets.filter(dt => !this.allDropTargets.includes(dt));\n        dropTargetsToRemove.forEach(dropTarget => {\n          const idx = this.service.dropTargets.findIndex(serviceDropTarget => serviceDropTarget.element === dropTarget);\n          if (idx > -1) {\n            this.service.dropTargets.splice(idx, 1);\n          }\n        });\n      }\n      this.previousDropTargets = this.allDropTargets;\n    }\n    emitZoneAwareEvent(event, normalizedEvent) {\n      const eventProps = {\n        dragTarget: this.service.dragTarget?.element,\n        dropTarget: this.currentDropTargetElement,\n        dragData: this.service.dragData,\n        dragEvent: normalizedEvent,\n        dropTargetIndex: this.service.dropIndex\n      };\n      if (isPresent(this.service.dragTarget?.hint)) {\n        eventProps.hintElement = this.service.dragTarget.hint;\n      }\n      const eventArgs = new DropTargetEvent(eventProps);\n      this.ngZone.run(() => {\n        this[event].emit(eventArgs);\n      });\n    }\n    getDropIndex() {\n      return this.allDropTargets.indexOf(this.currentDropTargetElement);\n    }\n    clearPreviousTargets() {\n      this.previousDropTargets.forEach(dropTarget => {\n        const idx = this.service.dropTargets.findIndex(serviceDropTarget => serviceDropTarget.element === dropTarget);\n        if (idx > -1) {\n          this.service.dropTargets.splice(idx, 1);\n        }\n      });\n      this.previousDropTargets = [];\n    }\n  }\n  _class13 = DropTargetContainerDirective;\n  _defineProperty(DropTargetContainerDirective, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵdirectiveInject(DragStateService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DropTargetContainerDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class13,\n    selectors: [[\"\", \"kendoDropTargetContainer\", \"\"]],\n    inputs: {\n      dropTargetFilter: \"dropTargetFilter\",\n      dropDisabled: \"dropDisabled\"\n    },\n    outputs: {\n      onDragEnter: \"onDragEnter\",\n      onDragOver: \"onDragOver\",\n      onDragLeave: \"onDragLeave\",\n      onDrop: \"onDrop\"\n    },\n    exportAs: [\"kendoDropTargetContainer\"],\n    standalone: true\n  }));\n  return DropTargetContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the Kendo UI DropTarget directive for Angular.\n */\nlet DropTargetDirective = /*#__PURE__*/(() => {\n  var _class14;\n  class DropTargetDirective {\n    constructor(service, element, ngZone) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      /**\n       * Fires when a DragTarget element enters the DropTarget.\n       */\n      _defineProperty(this, \"onDragEnter\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element is being dragged over the DropTarget.\n       */\n      _defineProperty(this, \"onDragOver\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element leaves the DropTarget.\n       */\n      _defineProperty(this, \"onDragLeave\", new EventEmitter());\n      /**\n       * Fires when a DragTarget element is dropped over the DropTarget.\n       */\n      _defineProperty(this, \"onDrop\", new EventEmitter());\n      _defineProperty(this, \"dropTarget\", void 0);\n      this.service = service;\n      this.element = element;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n    }\n    ngOnInit() {\n      this.initializeDropTarget();\n      this.service.dropTargets.push(this.dropTarget);\n    }\n    /**\n     * @hidden\n     */\n    handleDragEnter(event) {\n      if (!this.service.dragTarget) {\n        return;\n      }\n      this.service.dropTarget = this.dropTarget;\n      this.emitZoneAwareEvent('onDragEnter', event);\n    }\n    /**\n     * @hidden\n     */\n    handleDragLeave(event) {\n      this.service.dropTarget = null;\n      if (!this.service.dragTarget) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDragLeave', event);\n    }\n    /**\n     * @hidden\n     */\n    handleDragOver(event) {\n      if (!this.service.dragTarget) {\n        return;\n      }\n      this.emitZoneAwareEvent('onDragOver', event);\n    }\n    /**\n     * @hidden\n     */\n    handleDrop(event) {\n      this.emitZoneAwareEvent('onDrop', event);\n      this.service.dropTarget = null;\n    }\n    initializeDropTarget() {\n      this.dropTarget = {\n        element: this.element.nativeElement,\n        onDragEnter: this.handleDragEnter.bind(this),\n        onDragLeave: this.handleDragLeave.bind(this),\n        onDragOver: this.handleDragOver.bind(this),\n        onDrop: this.handleDrop.bind(this)\n      };\n    }\n    emitZoneAwareEvent(event, normalizedEvent) {\n      const eventProps = {\n        dropTarget: this.element.nativeElement,\n        dragTarget: this.service.dragTarget?.element,\n        dragEvent: normalizedEvent,\n        dragData: this.service.dragData\n      };\n      if (isPresent(this.service.dragTarget?.hint)) {\n        eventProps.hintElement = this.service.dragTarget.element;\n      }\n      const eventArgs = new DropTargetEvent(eventProps);\n      this.ngZone.run(() => {\n        this[event].emit(eventArgs);\n      });\n    }\n  }\n  _class14 = DropTargetDirective;\n  _defineProperty(DropTargetDirective, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵdirectiveInject(DragStateService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(DropTargetDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class14,\n    selectors: [[\"\", \"kendoDropTarget\", \"\"]],\n    outputs: {\n      onDragEnter: \"onDragEnter\",\n      onDragOver: \"onDragOver\",\n      onDragLeave: \"onDragLeave\",\n      onDrop: \"onDrop\"\n    },\n    exportAs: [\"kendoDropTarget\"],\n    standalone: true\n  }));\n  return DropTargetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `Drag and Drop` related components and directives\n */\nconst KENDO_DRAGANDDROP = [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent];\n/**\n* Utility array that contains all `@progress/kendo-angular-utils` related components and directives.\n* > As of now, `KENDO_UTILS` includes only the `KENDO_DRAGANDDROP` utility array and their usage is equivalent.\n*/\nconst KENDO_UTILS = [...KENDO_DRAGANDDROP];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Utils components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Utils module\n * import { UtilsModule } from '@progress/kendo-angular-utils';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, UtilsModule], // import Utils module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet UtilsModule = /*#__PURE__*/(() => {\n  var _class15;\n  class UtilsModule {}\n  _class15 = UtilsModule;\n  _defineProperty(UtilsModule, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)();\n  });\n  _defineProperty(UtilsModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class15\n  }));\n  _defineProperty(UtilsModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return UtilsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Drag and Drop directives.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the DragAndDrop module\n * import { DragAndDropModule } from '@progress/kendo-angular-utils';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, DragAndDropModule], // import DragAndDropModule module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet DragAndDropModule = /*#__PURE__*/(() => {\n  var _class16;\n  class DragAndDropModule {}\n  _class16 = DragAndDropModule;\n  _defineProperty(DragAndDropModule, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)();\n  });\n  _defineProperty(DragAndDropModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class16\n  }));\n  _defineProperty(DragAndDropModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return DragAndDropModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A service that allows changing the current adaptive settings dynamically. Use the public `notify` method to implement this.\n */\nlet AdaptiveSettingsService = /*#__PURE__*/(() => {\n  var _class17;\n  class AdaptiveSettingsService {\n    constructor() {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"changes\", new Subject());\n    }\n    /**\n     * Notifies subscribers that the adaptive settings were changed.\n     *\n     * @param adaptiveSettings - (Optional) A new value for the adaptive settings token.\n     */\n    notify(adaptiveSettings) {\n      this.changes.next(adaptiveSettings);\n    }\n  }\n  _class17 = AdaptiveSettingsService;\n  _defineProperty(AdaptiveSettingsService, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)();\n  });\n  _defineProperty(AdaptiveSettingsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class17,\n    factory: _class17.ɵfac\n  }));\n  return AdaptiveSettingsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A token that specifies the AdaptiveSettings of the Kendo UI for Angular components.\n *\n * ```ts\n * import { NgModule } from '@angular/core';\n *\n * @NgModule({\n * ...\n * providers: [{ provide: ADAPTIVE_SETTINGS, useValue: { small: 400, medium: 600 }}]\n * })\n * export class AppModule {}\n * ```\n *\n */\nconst ADAPTIVE_SETTINGS = new InjectionToken('Kendo UI Adaptive-Settings token');\nconst DEFAULT_ADAPTIVE_SETTINGS = {\n  small: 500,\n  medium: 768\n};\n/**\n * The service responsible for handling changes in the adaptive settings. Should be included in the providers array when implementing the functionality in a standalone component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the AdaptiveService\n * import { AdaptiveService } from '@progress/kendo-angular-utils';\n *\n * // Define a standalone component\n * @Component({\n *  selector: my-component,\n *  standalone: true,\n *  imports: [ ... ],\n *  providers: [AdaptiveService, { provide: ADAPTIVE_SETTINGS , useValue: { small: 300 } }],\n *  template: ...\n * })\n * export class AppComponent {}\n * ```\n */\nlet AdaptiveService = /*#__PURE__*/(() => {\n  var _class18;\n  class AdaptiveService {\n    constructor(_adaptiveSettings, adaptiveSettingsService) {\n      _defineProperty(this, \"_adaptiveSettings\", void 0);\n      /**\n       * Notifies subscribers of the initial adaptive settings, and upon each call to `notify`.\n       * @hidden\n       */\n      _defineProperty(this, \"changes\", new BehaviorSubject(this.adaptiveSettings || {\n        small: 500,\n        medium: 700\n      }));\n      _defineProperty(this, \"subs\", new Subscription());\n      this._adaptiveSettings = _adaptiveSettings;\n      if (adaptiveSettingsService) {\n        this.subs.add(adaptiveSettingsService.changes.pipe(map(adaptiveSettings => isPresent$1(adaptiveSettings) ? adaptiveSettings : this._adaptiveSettings), tap(adaptiveSettings => this._adaptiveSettings = adaptiveSettings)).subscribe(adaptiveSettings => this.changes.next(adaptiveSettings)));\n      }\n      if (isPresent$1(this.adaptiveSettings) && !areObjectsEqual(this.adaptiveSettings, DEFAULT_ADAPTIVE_SETTINGS)) {\n        this.changes.next(this.adaptiveSettings);\n      }\n    }\n    /**\n     * @hidden\n     */\n    get adaptiveSettings() {\n      return this._adaptiveSettings;\n    }\n    /**\n     * @hidden\n     */\n    get size() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const settings = Object.assign(DEFAULT_ADAPTIVE_SETTINGS, this.adaptiveSettings);\n      if (window.innerWidth > settings.medium) {\n        return 'large';\n      } else if (window.innerWidth > settings.small) {\n        return 'medium';\n      } else {\n        return 'small';\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n  }\n  _class18 = AdaptiveService;\n  _defineProperty(AdaptiveService, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵinject(ADAPTIVE_SETTINGS, 8), i0.ɵɵinject(AdaptiveSettingsService, 8));\n  });\n  _defineProperty(AdaptiveService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class18,\n    factory: _class18.ɵfac,\n    providedIn: 'root'\n  }));\n  return AdaptiveService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ADAPTIVE_SETTINGS, AdaptiveService, AdaptiveSettingsService, DragAndDropModule, DragHandleDirective, DragTargetContainerDirective, DragTargetDirective, DragTargetDragEndEvent, DragTargetDragEvent, DragTargetDragReadyEvent, DragTargetDragStartEvent, DragTargetPressEvent, DragTargetReleaseEvent, DropTargetContainerDirective, DropTargetDirective, DropTargetEvent, HintComponent, KENDO_DRAGANDDROP, KENDO_UTILS, UtilsModule };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}