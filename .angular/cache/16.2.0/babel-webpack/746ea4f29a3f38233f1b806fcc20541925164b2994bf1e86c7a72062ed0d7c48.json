{"ast":null,"code":"import BaseNode from '../core/base-node';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nimport renderStyle from './utils/render-style';\nimport NODE_MAP from './node-map';\nimport renderSVG from './utils/render-svg';\nimport { SVG_NS, NONE } from './constants';\nimport { support, htmlEncode } from '../common';\nimport { defined } from '../util';\nimport { PATTERN } from '../core/constants';\nconst TRANSFORM = \"transform\";\nconst DefinitionMap = {\n  clip: \"clip-path\",\n  fill: \"fill\"\n};\nfunction isDefinition(type, value) {\n  return type === \"clip\" || type === \"fill\" && (!value || value.nodeType === \"Gradient\" || value.nodeType === PATTERN);\n}\nfunction baseUrl() {\n  const base = document.getElementsByTagName(\"base\")[0];\n  let href = document.location.href;\n  let url = \"\";\n  if (base && !(support.browser || {}).msie) {\n    const hashIndex = href.indexOf(\"#\");\n    if (hashIndex !== -1) {\n      href = href.substring(0, hashIndex);\n    }\n    url = href;\n  }\n  return url;\n}\nclass Node extends BaseNode {\n  constructor(srcElement, options) {\n    super(srcElement);\n    this.definitions = {};\n    this.options = options;\n  }\n  destroy() {\n    if (this.element) {\n      this.element._kendoNode = null;\n      this.element = null;\n    }\n    this.clearDefinitions();\n    super.destroy();\n  }\n  load(elements, pos) {\n    for (let i = 0; i < elements.length; i++) {\n      const srcElement = elements[i];\n      const children = srcElement.children;\n      const childNode = new NODE_MAP[srcElement.nodeType](srcElement, this.options);\n      if (defined(pos)) {\n        this.insertAt(childNode, pos);\n      } else {\n        this.append(childNode);\n      }\n      childNode.createDefinitions();\n      if (children && children.length > 0) {\n        childNode.load(children);\n      }\n      const element = this.element;\n      if (element) {\n        childNode.attachTo(element, pos);\n      }\n    }\n  }\n  root() {\n    let root = this;\n    while (root.parent) {\n      root = root.parent;\n    }\n    return root;\n  }\n  attachTo(domElement, pos) {\n    const container = document.createElement(\"div\");\n    renderSVG(container, \"<svg xmlns='\" + SVG_NS + \"' version='1.1'>\" + this.render() + \"</svg>\");\n    const element = container.firstChild.firstChild;\n    if (element) {\n      if (defined(pos)) {\n        domElement.insertBefore(element, domElement.childNodes[pos] || null);\n      } else {\n        domElement.appendChild(element);\n      }\n      this.setElement(element);\n    }\n  }\n  setElement(element) {\n    if (this.element) {\n      this.element._kendoNode = null;\n    }\n    this.element = element;\n    this.element._kendoNode = this;\n    const nodes = this.childNodes;\n    for (let i = 0; i < nodes.length; i++) {\n      let childElement = element.childNodes[i];\n      nodes[i].setElement(childElement);\n    }\n  }\n  clear() {\n    this.clearDefinitions();\n    if (this.element) {\n      this.element.innerHTML = \"\";\n    }\n    const children = this.childNodes;\n    for (let i = 0; i < children.length; i++) {\n      children[i].destroy();\n    }\n    this.childNodes = [];\n  }\n  removeSelf() {\n    if (this.element) {\n      const parentNode = this.element.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this.element);\n      }\n      this.element = null;\n    }\n    super.removeSelf();\n  }\n  template() {\n    return this.renderChildren();\n  }\n  render() {\n    return this.template();\n  }\n  renderChildren() {\n    const nodes = this.childNodes;\n    let output = \"\";\n    for (let i = 0; i < nodes.length; i++) {\n      output += nodes[i].render();\n    }\n    return output;\n  }\n  optionsChange(e) {\n    const {\n      field,\n      value\n    } = e;\n    if (field === \"visible\") {\n      this.css(\"display\", value ? \"\" : NONE);\n    } else if (DefinitionMap[field] && isDefinition(field, value)) {\n      this.updateDefinition(field, value);\n    } else if (field === \"opacity\") {\n      this.attr(\"opacity\", value);\n    } else if (field === \"cursor\") {\n      this.css(\"cursor\", value);\n    } else if (field === \"id\") {\n      if (value) {\n        this.attr(\"id\", value);\n      } else {\n        this.removeAttr(\"id\");\n      }\n    }\n    super.optionsChange(e);\n  }\n  accessibilityOptionsChange(e) {\n    const {\n      field,\n      value\n    } = e;\n    if (field === \"role\") {\n      if (value) {\n        this.attr(\"role\", value);\n      } else {\n        this.removeAttr(\"role\");\n      }\n    } else if (field === \"ariaLabel\") {\n      if (value) {\n        this.attr(\"aria-label\", htmlEncode(value));\n      } else {\n        this.removeAttr(\"aria-label\");\n      }\n    } else if (field === \"ariaRoleDescription\") {\n      if (value) {\n        this.attr(\"aria-roledescription\", htmlEncode(value));\n      } else {\n        this.removeAttr(\"aria-roledescription\");\n      }\n    } else if (field === \"ariaChecked\") {\n      if (defined(value)) {\n        this.attr(\"aria-checked\", value);\n      } else {\n        this.removeAttr(\"aria-checked\");\n      }\n    } else if (field === \"className\") {\n      this.className(value);\n    }\n  }\n  attr(name, value) {\n    if (this.element) {\n      this.element.setAttribute(name, value);\n    }\n  }\n  allAttr(attrs) {\n    for (let i = 0; i < attrs.length; i++) {\n      this.attr(attrs[i][0], attrs[i][1]);\n    }\n  }\n  toggleAttr(name, value) {\n    if (value) {\n      this.attr(name, value);\n    } else {\n      this.removeAttr(name);\n    }\n  }\n  css(name, value) {\n    if (this.element) {\n      this.element.style[name] = value;\n    }\n  }\n  allCss(styles) {\n    for (let i = 0; i < styles.length; i++) {\n      this.css(styles[i][0], styles[i][1]);\n    }\n  }\n  className(value) {\n    if (this.element) {\n      this.element.classList.remove(...this.element.classList);\n      value.split(\" \").forEach(item => {\n        this.element.classList.add(item);\n      });\n    }\n  }\n  removeAttr(name) {\n    if (this.element) {\n      this.element.removeAttribute(name);\n    }\n  }\n  mapTransform(transform) {\n    const attrs = [];\n    if (transform) {\n      attrs.push([TRANSFORM, \"matrix(\" + transform.matrix().toString(6) + \")\"]);\n    }\n    return attrs;\n  }\n  renderTransform() {\n    return renderAllAttr(this.mapTransform(this.srcElement.transform()));\n  }\n  transformChange(value) {\n    if (value) {\n      this.allAttr(this.mapTransform(value));\n    } else {\n      this.removeAttr(TRANSFORM);\n    }\n  }\n  mapStyle() {\n    const options = this.srcElement.options;\n    const style = [[\"cursor\", options.cursor]];\n    if (options.visible === false) {\n      style.push([\"display\", NONE]);\n    }\n    return style;\n  }\n  renderStyle() {\n    return renderAttr(\"style\", renderStyle(this.mapStyle(true)));\n  }\n  renderOpacity() {\n    return renderAttr(\"opacity\", this.srcElement.options.opacity);\n  }\n  renderId() {\n    return renderAttr(\"id\", this.srcElement.options.id);\n  }\n  renderClassName() {\n    return renderAttr(\"class\", this.srcElement.options.className);\n  }\n  renderRole() {\n    return renderAttr(\"role\", this.srcElement.options.role);\n  }\n  renderAriaLabel() {\n    let value = this.srcElement.options.ariaLabel;\n    if (value) {\n      value = htmlEncode(value);\n    }\n    return renderAttr(\"aria-label\", value);\n  }\n  renderAriaRoleDescription() {\n    let value = this.srcElement.options.ariaRoleDescription;\n    if (value) {\n      value = htmlEncode(value);\n    }\n    return renderAttr(\"aria-roledescription\", value);\n  }\n  renderAriaChecked() {\n    return renderAttr(\"aria-checked\", this.srcElement.options.ariaChecked);\n  }\n  createDefinitions() {\n    const srcElement = this.srcElement;\n    const definitions = this.definitions;\n    if (srcElement) {\n      const options = srcElement.options;\n      let hasDefinitions;\n      for (let field in DefinitionMap) {\n        let definition = options.get(field);\n        if (definition && isDefinition(field, definition)) {\n          definitions[field] = definition;\n          hasDefinitions = true;\n        }\n      }\n      if (hasDefinitions) {\n        this.definitionChange({\n          action: \"add\",\n          definitions: definitions\n        });\n      }\n    }\n  }\n  definitionChange(e) {\n    if (this.parent) {\n      this.parent.definitionChange(e);\n    }\n  }\n  updateDefinition(type, value) {\n    const definitions = this.definitions;\n    const current = definitions[type];\n    const attr = DefinitionMap[type];\n    const definition = {};\n    if (current) {\n      definition[type] = current;\n      this.definitionChange({\n        action: \"remove\",\n        definitions: definition\n      });\n      delete definitions[type];\n    }\n    if (!value) {\n      if (current) {\n        this.removeAttr(attr);\n      }\n    } else {\n      definition[type] = value;\n      this.definitionChange({\n        action: \"add\",\n        definitions: definition\n      });\n      definitions[type] = value;\n      this.attr(attr, this.refUrl(value.id));\n    }\n  }\n  clearDefinitions() {\n    const definitions = this.definitions;\n    this.definitionChange({\n      action: \"remove\",\n      definitions: definitions\n    });\n    this.definitions = {};\n  }\n  renderDefinitions() {\n    return renderAllAttr(this.mapDefinitions());\n  }\n  mapDefinitions() {\n    const definitions = this.definitions;\n    const attrs = [];\n    for (let field in definitions) {\n      attrs.push([DefinitionMap[field], this.refUrl(definitions[field].id)]);\n    }\n    return attrs;\n  }\n  refUrl(id) {\n    const skipBaseHref = (this.options || {}).skipBaseHref;\n    const baseHref = this.baseUrl().replace(/'/g, \"\\\\'\");\n    const base = skipBaseHref ? '' : baseHref;\n    return `url(${base}#${id})`;\n  }\n  baseUrl() {\n    return baseUrl();\n  }\n}\nexport default Node;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}