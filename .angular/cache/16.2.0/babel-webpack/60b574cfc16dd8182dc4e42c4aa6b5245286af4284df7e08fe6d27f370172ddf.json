{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, Optional, EventEmitter, isDevMode, Component, Input, Output, ViewChild, TemplateRef, NgModule } from '@angular/core';\nimport { siblingContainer, parents, addScroll, align, boundingOffset, offset, positionWithScroll, removeScroll, restrictToView, scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeBatchService, KENDO_RESIZESENSOR } from '@progress/kendo-angular-common';\nimport { fromEvent, merge, from } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport * as i1 from '@angular/animations';\nimport { style, animate } from '@angular/animations';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { NgClass, NgTemplateOutlet, NgIf } from '@angular/common';\n\n/**\n * @hidden\n */\nconst _c0 = [\"container\"];\nfunction _class7_ng_template_4_Template(rf, ctx) {}\nconst _c1 = [\"*\"];\nconst eitherRect = (rect, offset) => {\n  if (!rect) {\n    return {\n      height: 0,\n      left: offset.left,\n      top: offset.top,\n      width: 0\n    };\n  }\n  return rect;\n};\n/**\n * @hidden\n */\nconst replaceOffset = (rect, offset) => {\n  if (!offset) {\n    return rect;\n  }\n  const result = {\n    height: rect.height,\n    left: offset.left,\n    top: offset.top,\n    width: rect.width\n  };\n  return result;\n};\n/**\n * @hidden\n */\nconst removeStackingOffset = (rect, stackingOffset) => {\n  if (!stackingOffset) {\n    return rect;\n  }\n  const result = {\n    height: rect.height,\n    left: rect.left - stackingOffset.left,\n    top: rect.top - stackingOffset.top,\n    width: rect.width\n  };\n  return result;\n};\n/**\n * @hidden\n */\nconst isDifferentOffset = (oldOffset, newOffset) => {\n  const {\n    left: oldLeft,\n    top: oldTop\n  } = oldOffset;\n  const {\n    left: newLeft,\n    top: newTop\n  } = newOffset;\n  return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\nconst hasBoundingRect = elem => !!elem.getBoundingClientRect;\n/**\n * @hidden\n */\nconst OVERFLOW_REGEXP = /auto|scroll/;\nconst overflowElementStyle = element => {\n  return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\nconst overflowComputedStyle = element => {\n  const styles = window.getComputedStyle(element);\n  return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\nconst overflowStyle = element => {\n  return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nconst scrollableParents = element => {\n  const parentElements = [];\n  if (!isDocumentAvailable() || !isWindowAvailable()) {\n    return parentElements;\n  }\n  let parent = element.parentElement;\n  while (parent) {\n    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n      parentElements.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  parentElements.push(window);\n  return parentElements;\n};\n/**\n * @hidden\n */\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction memoize(fun) {\n  let result;\n  let called = false;\n  return (...args) => {\n    if (called) {\n      return result;\n    }\n    result = fun(...args);\n    called = true;\n    return result;\n  };\n}\n/**\n * @hidden\n */\nconst hasRelativeStackingContext = memoize(() => {\n  if (!isDocumentAvailable() && document.body !== null) {\n    return false;\n  }\n  const top = 10;\n  const parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  const childElement = document.createElement(\"div\");\n  childElement.style.position = 'fixed';\n  childElement.style.top = `${top}px`;\n  childElement.textContent = 'child';\n  parent.appendChild(childElement);\n  document.body.appendChild(parent);\n  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n});\n/**\n * @hidden\n */\nconst zIndex = (anchor, container) => {\n  if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n    return null;\n  }\n  const sibling = siblingContainer(anchor, container);\n  if (!sibling) {\n    return null;\n  }\n  const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n    const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n    const current = parseInt(zIndexStyle, 10);\n    return current > index ? current : index;\n  }, 0);\n  return result ? result + 1 : null;\n};\n/**\n * @hidden\n */\nconst scaleRect = (rect, scale) => {\n  if (!rect || scale === 1) {\n    return rect;\n  }\n  return {\n    height: rect.height / scale,\n    left: rect.left / scale,\n    top: rect.top / scale,\n    width: rect.width / scale\n  };\n};\nconst STYLES = ['font-size', 'font-family', 'font-stretch', 'font-style', 'font-weight', 'line-height'];\n/**\n * @hidden\n */\nlet DOMService = /*#__PURE__*/(() => {\n  var _class;\n  class DOMService {\n    constructor() {\n      _defineProperty(this, \"_dummy\", void 0);\n    }\n    addOffset(current, addition) {\n      return {\n        left: current.left + addition.left,\n        top: current.top + addition.top\n      };\n    }\n    addScroll(rect, scroll) {\n      return addScroll(rect, scroll);\n    }\n    align(settings) {\n      return align(settings);\n    }\n    boundingOffset(el) {\n      return boundingOffset(el);\n    }\n    getFontStyles(el) {\n      const window = this.getWindow();\n      if (!window || !el) {\n        return [];\n      }\n      const computedStyles = window.getComputedStyle(el);\n      return STYLES.map(key => ({\n        key: key,\n        value: computedStyles[key]\n      }));\n    }\n    getWindow() {\n      return isWindowAvailable() ? window : null;\n    }\n    hasOffsetParent(el) {\n      if (!el || !isDocumentAvailable()) {\n        return false;\n      }\n      return !!this.nativeElement(el).offsetParent;\n    }\n    offset(el) {\n      if (!el || !isDocumentAvailable()) {\n        return null;\n      }\n      return offset(el);\n    }\n    offsetAtPoint(el, currentLocation) {\n      if (!el || !isDocumentAvailable()) {\n        return null;\n      }\n      const element = this.nativeElement(el);\n      const {\n        left,\n        top,\n        transition\n      } = element.style;\n      element.style.transition = 'none';\n      element.style.left = `${currentLocation.left}px`;\n      element.style.top = `${currentLocation.top}px`;\n      const currentOffset = offset(element);\n      element.style.left = left;\n      element.style.top = top;\n      // prevents elements with transition to be animated because of the change\n      this._dummy = element.offsetHeight;\n      element.style.transition = transition;\n      return currentOffset;\n    }\n    nativeElement(el) {\n      if (!el || !isDocumentAvailable()) {\n        return null;\n      }\n      return el.nativeElement || el;\n    }\n    position(element, popup, scale = 1) {\n      if (!element || !popup) {\n        return null;\n      }\n      return positionWithScroll(element, this.nativeElement(popup), scale);\n    }\n    removeScroll(rect, scroll) {\n      return removeScroll(rect, scroll);\n    }\n    restrictToView(settings) {\n      return restrictToView(settings);\n    }\n    scrollPosition(el) {\n      return scrollPosition(this.nativeElement(el));\n    }\n    scrollableParents(el) {\n      return scrollableParents(el);\n    }\n    stackingElementOffset(el) {\n      const relativeContextElement = this.getRelativeContextElement(el);\n      if (!relativeContextElement) {\n        return null;\n      }\n      return offset(relativeContextElement);\n    }\n    stackingElementScroll(el) {\n      const relativeContextElement = this.getRelativeContextElement(el);\n      if (!relativeContextElement) {\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n      return {\n        x: relativeContextElement.scrollLeft,\n        y: relativeContextElement.scrollTop\n      };\n    }\n    getRelativeContextElement(el) {\n      if (!el || !hasRelativeStackingContext()) {\n        return null;\n      }\n      let parent = this.nativeElement(el).parentElement;\n      while (parent) {\n        if (window.getComputedStyle(parent).transform !== 'none') {\n          return parent;\n        }\n        parent = parent.parentElement;\n      }\n      return null;\n    }\n    useRelativePosition(el) {\n      return !!this.getRelativeContextElement(el);\n    }\n    windowViewPort(el) {\n      return getWindowViewPort(this.nativeElement(el));\n    }\n    zIndex(anchor, container) {\n      return zIndex(anchor, this.nativeElement(container));\n    }\n    zoomLevel() {\n      if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return 1;\n      }\n      return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n    isZoomed() {\n      return this.zoomLevel() > 1;\n    }\n  }\n  _class = DOMService;\n  _defineProperty(DOMService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)();\n  });\n  _defineProperty(DOMService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return DOMService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file shared/app.module.ts %}\n * {% embed_file shared/main.ts %}\n * {% endmeta %}\n *\n *\n */\nconst SCALE = new InjectionToken('Popup Document Scale');\n\n/**\n * @hidden\n */\nlet AlignService = /*#__PURE__*/(() => {\n  var _class2;\n  class AlignService {\n    constructor(_dom, scale = 1) {\n      _defineProperty(this, \"_dom\", void 0);\n      _defineProperty(this, \"scale\", void 0);\n      this._dom = _dom;\n      this.scale = scale;\n    }\n    alignElement(settings) {\n      const {\n        anchor,\n        element,\n        anchorAlign,\n        elementAlign,\n        margin,\n        offset,\n        positionMode\n      } = settings;\n      const scale = this.scale || 1;\n      const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n      const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset, scale) : this.relativeRect(anchor, element, offset, scale);\n      const elementRect = scaleRect(this._dom.offset(element.nativeElement), scale);\n      const result = this._dom.align({\n        anchorAlign: anchorAlign,\n        anchorRect: anchorRect,\n        elementAlign: elementAlign,\n        elementRect: elementRect,\n        margin\n      });\n      return result;\n    }\n    absoluteRect(anchor, element, offset, scale) {\n      const scrollPos = this.elementScrollPosition(anchor, element);\n      const rect = eitherRect(this._dom.offset(anchor), offset);\n      const stackScale = 2 * scale;\n      const stackScroll = this._dom.stackingElementScroll(element);\n      if (scale !== 1 && stackScroll) {\n        stackScroll.x /= stackScale;\n        stackScroll.y /= stackScale;\n      }\n      const stackOffset = this._dom.stackingElementOffset(element);\n      if (scale !== 1 && stackOffset) {\n        stackOffset.left /= stackScale;\n        stackOffset.top /= stackScale;\n      }\n      return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n    elementScrollPosition(anchor, element) {\n      return anchor ? {\n        x: 0,\n        y: 0\n      } : this._dom.scrollPosition(element);\n    }\n    relativeRect(anchor, element, offset, scale) {\n      const rect = eitherRect(this._dom.position(anchor, element, scale), offset);\n      return scaleRect(rect, scale);\n    }\n  }\n  _class2 = AlignService;\n  _defineProperty(AlignService, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(DOMService), i0.ɵɵinject(SCALE, 8));\n  });\n  _defineProperty(AlignService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return AlignService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet PositionService = /*#__PURE__*/(() => {\n  var _class3;\n  class PositionService {\n    constructor(_dom, scale = 1) {\n      _defineProperty(this, \"_dom\", void 0);\n      _defineProperty(this, \"scale\", void 0);\n      this._dom = _dom;\n      this.scale = scale;\n    }\n    positionElement(settings) {\n      const {\n        anchor,\n        currentLocation,\n        element,\n        anchorAlign,\n        elementAlign,\n        collisions,\n        margin\n      } = settings;\n      const dom = this._dom;\n      const scale = this.scale || 1;\n      const elementOffset = dom.offsetAtPoint(element, currentLocation);\n      const elementRect = scaleRect(elementOffset, scale);\n      const anchorOffset = scaleRect(dom.offset(anchor), scale);\n      const anchorRect = eitherRect(anchorOffset, currentLocation);\n      const viewPort = settings.viewPort || dom.windowViewPort(element);\n      viewPort.width = viewPort.width / scale;\n      viewPort.height = viewPort.height / scale;\n      const result = dom.restrictToView({\n        anchorAlign,\n        anchorRect,\n        collisions,\n        elementAlign,\n        elementRect,\n        margin,\n        viewPort\n      });\n      const offset = dom.addOffset(currentLocation, result.offset);\n      return {\n        flip: result.flip,\n        flipped: result.flipped,\n        offset: offset\n      };\n    }\n  }\n  _class3 = PositionService;\n  _defineProperty(PositionService, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵinject(DOMService), i0.ɵɵinject(SCALE, 8));\n  });\n  _defineProperty(PositionService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  }));\n  return PositionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ResizeService = /*#__PURE__*/(() => {\n  var _class4;\n  class ResizeService {\n    constructor(_dom, _zone) {\n      _defineProperty(this, \"_dom\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this._dom = _dom;\n      this._zone = _zone;\n    }\n    subscribe(callback) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this._zone.runOutsideAngular(() => {\n        this.subscription = fromEvent(this._dom.getWindow(), \"resize\").pipe(auditTime(FRAME_DURATION)).subscribe(() => callback());\n      });\n    }\n    unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n      this.subscription.unsubscribe();\n    }\n    isUnsubscribed() {\n      return this.subscription && this.subscription.closed;\n    }\n  }\n  _class4 = ResizeService;\n  _defineProperty(ResizeService, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵinject(DOMService), i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(ResizeService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac\n  }));\n  return ResizeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\nlet ScrollableService = /*#__PURE__*/(() => {\n  var _class5;\n  class ScrollableService {\n    constructor(_dom, _zone) {\n      _defineProperty(this, \"_dom\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this._dom = _dom;\n      this._zone = _zone;\n    }\n    forElement(element) {\n      this.unsubscribe();\n      this.element = element;\n      return this;\n    }\n    subscribe(callback) {\n      if (!callback || !isDocumentAvailable() || !this.element) {\n        return;\n      }\n      const parents = this._dom.scrollableParents(this.element);\n      this._zone.runOutsideAngular(() => {\n        const observables = parents.map(p => fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)));\n        const subscriber = e => {\n          const target = e.target;\n          const isParent = parents.filter(p => p === target).length > 0;\n          const isDocument = target === document;\n          const isWindow = target === window;\n          if (isParent || isDocument || isWindow) {\n            callback(this.isVisible(this.element, target));\n          }\n        };\n        this.subscription = merge(...observables).subscribe(subscriber);\n      });\n    }\n    unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n      this.subscription.unsubscribe();\n    }\n    isVisible(elem, container) {\n      const elemRect = this._dom.boundingOffset(elem);\n      const containerRect = this._dom.boundingOffset(this._dom.nativeElement(container));\n      if (THRESHOLD_DIFF < containerRect.top - elemRect.bottom) {\n        return false;\n      }\n      if (THRESHOLD_DIFF < elemRect.top - containerRect.bottom) {\n        return false;\n      }\n      if (THRESHOLD_DIFF < elemRect.left - containerRect.right) {\n        return false;\n      }\n      if (THRESHOLD_DIFF < containerRect.left - elemRect.right) {\n        return false;\n      }\n      return true;\n    }\n  }\n  _class5 = ScrollableService;\n  _defineProperty(ScrollableService, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵinject(DOMService), i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(ScrollableService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac\n  }));\n  return ScrollableService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\nanimationTypes.expand = direction => {\n  const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n  const startScale = 0;\n  const endScale = 1;\n  let origin;\n  if (direction === DOWN) {\n    origin = 'top';\n  } else if (direction === LEFT) {\n    origin = RIGHT;\n  } else if (direction === RIGHT) {\n    origin = LEFT;\n  } else {\n    origin = 'bottom';\n  }\n  return {\n    start: {\n      transform: `${scale}(${startScale})`,\n      transformOrigin: origin\n    },\n    end: {\n      transform: `${scale}(${endScale})`\n    }\n  };\n};\nanimationTypes.slide = direction => {\n  const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n  const start = direction === RIGHT || direction === DOWN ? -100 : 100;\n  const end = 0;\n  return {\n    start: {\n      transform: `${translate}(${start}%)`\n    },\n    end: {\n      transform: `${translate}(${end}%)`\n    }\n  };\n};\nanimationTypes.fade = () => {\n  return {\n    start: {\n      opacity: 0\n    },\n    end: {\n      opacity: 1\n    }\n  };\n};\nanimationTypes.zoom = () => {\n  const start = 0;\n  const end = 1;\n  return {\n    start: {\n      transform: `scale(${start})`\n    },\n    end: {\n      transform: `scale(${end})`\n    }\n  };\n};\n/**\n * @hidden\n */\nlet AnimationService = /*#__PURE__*/(() => {\n  var _class6;\n  class AnimationService {\n    constructor(animationBuilder) {\n      _defineProperty(this, \"animationBuilder\", void 0);\n      _defineProperty(this, \"start\", new EventEmitter());\n      _defineProperty(this, \"end\", new EventEmitter());\n      _defineProperty(this, \"flip\", void 0);\n      _defineProperty(this, \"player\", void 0);\n      this.animationBuilder = animationBuilder;\n    }\n    play(element, options, flip) {\n      if (!this.flip || this.flip.horizontal !== flip.horizontal || this.flip.vertical !== flip.vertical) {\n        this.flip = flip;\n        const type = options.type || DEFAULT_TYPE;\n        const statesFn = animationTypes[type];\n        if (statesFn) {\n          const direction = this.getDirection(flip, options);\n          const states = statesFn(direction);\n          this.playStates(element, states, options);\n        } else if (isDevMode()) {\n          throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.stopPlayer();\n    }\n    playStates(element, states, options) {\n      this.stopPlayer();\n      const duration = options.duration || DEFAULT_DURATION;\n      const factory = this.animationBuilder.build([style(states.start), animate(`${duration}ms ease-in`, style(states.end))]);\n      const player = this.player = factory.create(element);\n      player.onDone(() => {\n        this.end.emit();\n        this.stopPlayer();\n      });\n      this.start.emit();\n      player.play();\n    }\n    getDirection(flip, options) {\n      let direction = options.direction || DOWN;\n      if (flip.horizontal) {\n        if (direction === LEFT) {\n          direction = RIGHT;\n        } else if (direction === RIGHT) {\n          direction = LEFT;\n        }\n      }\n      if (flip.vertical) {\n        if (direction === DOWN) {\n          direction = UP;\n        } else if (direction === UP) {\n          direction = DOWN;\n        }\n      }\n      return direction;\n    }\n    stopPlayer() {\n      if (this.player) {\n        this.player.destroy();\n        this.player = null;\n      }\n    }\n  }\n  _class6 = AnimationService;\n  _defineProperty(AnimationService, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵinject(i1.AnimationBuilder));\n  });\n  _defineProperty(AnimationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  }));\n  return AnimationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-popup',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163484,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst DEFAULT_OFFSET = {\n  left: -10000,\n  top: 0\n};\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\nlet PopupComponent = /*#__PURE__*/(() => {\n  var _class7;\n  class PopupComponent {\n    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"_alignService\", void 0);\n      _defineProperty(this, \"domService\", void 0);\n      _defineProperty(this, \"_positionService\", void 0);\n      _defineProperty(this, \"_resizeService\", void 0);\n      _defineProperty(this, \"_scrollableService\", void 0);\n      _defineProperty(this, \"animationService\", void 0);\n      _defineProperty(this, \"_renderer\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      /**\n       * Controls the Popup animation. By default, the opening and closing animations\n       * are enabled ([see example]({% slug animations_popup %})).\n       */\n      _defineProperty(this, \"animate\", true);\n      /**\n       * Specifies the element that will be used as an anchor. The Popup opens next to that element.\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-components)).\n       */\n      _defineProperty(this, \"anchor\", void 0);\n      /**\n       * Specifies the anchor pivot point\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n       */\n      _defineProperty(this, \"anchorAlign\", {\n        horizontal: 'left',\n        vertical: 'bottom'\n      });\n      /**\n       * Configures the collision behavior of the Popup\n       * ([see example]({% slug viewportboundarydetection_popup %})).\n       */\n      _defineProperty(this, \"collision\", {\n        horizontal: 'fit',\n        vertical: 'flip'\n      });\n      /**\n       * Specifies the pivot point of the Popup\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n       */\n      _defineProperty(this, \"popupAlign\", {\n        horizontal: 'left',\n        vertical: 'top'\n      });\n      /**\n       * Controls whether the component will copy the `anchor` font styles.\n       */\n      _defineProperty(this, \"copyAnchorStyles\", false);\n      /**\n       * Specifies a list of CSS classes that will be added to the internal\n       * animated element ([see example]({% slug appearance_popup %})).\n       *\n       * > To style the content of the Popup, use this property binding.\n       */\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      _defineProperty(this, \"popupClass\", void 0);\n      /**\n       * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n       * To make the Popup acquire absolute positioning, set this option to `absolute`.\n       *\n       * > If you need to support mobile browsers with the zoom option,\n       * use the `absolute` positioning of the Popup.\n       *\n       * @example\n       * ```html\n       * <style>\n       *  .parent-content {\n       *     position: relative;\n       *     width: 200px;\n       *     height: 200px;\n       *     overflow: auto;\n       *     margin: 200px auto;\n       *     border: 1px solid red;\n       *  }\n       *  .content {\n       *     position: relative;\n       *     width: 100px;\n       *     height: 100px;\n       *     overflow: auto;\n       *     margin: 300px;\n       *     border: 1px solid blue;\n       *  }\n       *  .anchor {\n       *     position: absolute;\n       *     top: 200px;\n       *     left: 200px;\n       *  }\n       * </style>\n       * ```\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *   <div class=\"example-config\">\n       *      Position mode:\n       *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n       *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n       *   </div>\n       *   <div class=\"example-config\">\n       *       Append to\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n       *           Root component\n       *       </label>\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n       *           <span [style.color]=\"'red'\">Red Container</span>\n       *       </label>\n       *       <label>\n       *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n       *           <span [style.color]=\"'blue'\">Blue Container</span>\n       *       </label>\n       *   </div>\n       *   <div class=\"example\">\n       *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n       *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n       *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n       *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n       *             <ul>\n       *                 <li>Item1</li>\n       *                 <li>Item2</li>\n       *                 <li>Item3</li>\n       *             </ul>\n       *           </kendo-popup>\n       *           <span [style.position]=\"'absolute'\" [style.top.px]=\"400\" [style.left.px]=\"400\">Bottom/Right</span>\n       *         </div>\n       *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n       *           <ul>\n       *               <li>Item1</li>\n       *               <li>Item2</li>\n       *               <li>Item3</li>\n       *           </ul>\n       *         </kendo-popup>\n       *         <span [style.position]=\"'absolute'\" [style.top.px]=\"600\" [style.left.px]=\"600\">Bottom/Right</span>\n       *     </div>\n       *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n       *       <ul>\n       *           <li>Item1</li>\n       *           <li>Item2</li>\n       *           <li>Item3</li>\n       *       </ul>\n       *     </kendo-popup>\n       *   </div>\n       * `\n       * })\n       * class AppComponent {\n       *   public checked: number = 3;\n       *   public mode: string = 'absolute';\n       *   public show: boolean = true;\n       * }\n       * ```\n       */\n      _defineProperty(this, \"positionMode\", 'fixed');\n      /**\n       * Specifies the absolute position of the element\n       * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n       * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n       * The boundary detection is applied by using the window viewport.\n       */\n      _defineProperty(this, \"offset\", DEFAULT_OFFSET);\n      /**\n       * Specifies the margin value that will be added to the popup dimensions in pixels and leaves a blank space\n       * between the popup and the anchor ([see example]({% slug alignmentpositioning_popup %}#toc-adding-a-margin)).\n       */\n      _defineProperty(this, \"margin\", void 0);\n      /**\n       * Fires when the anchor is scrolled outside the screen boundaries.\n       * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n       */\n      _defineProperty(this, \"anchorViewportLeave\", new EventEmitter());\n      /**\n       * Fires after the component is closed.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the component is opened and the opening animation ends.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the component is opened and the Popup is positioned.\n       */\n      _defineProperty(this, \"positionChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"contentContainer\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"resizeSensor\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"content\", void 0);\n      _defineProperty(this, \"resolvedPromise\", Promise.resolve(null));\n      _defineProperty(this, \"_currentOffset\", void 0);\n      _defineProperty(this, \"animationSubscriptions\", void 0);\n      _defineProperty(this, \"repositionSubscription\", void 0);\n      _defineProperty(this, \"initialCheck\", true);\n      this.container = container;\n      this._alignService = _alignService;\n      this.domService = domService;\n      this._positionService = _positionService;\n      this._resizeService = _resizeService;\n      this._scrollableService = _scrollableService;\n      this.animationService = animationService;\n      this._renderer = _renderer;\n      this._zone = _zone;\n      validatePackage(packageMetadata);\n      this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n      this.updateFixedClass();\n    }\n    ngOnInit() {\n      this.reposition = this.reposition.bind(this);\n      this._resizeService.subscribe(this.reposition);\n      this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n      this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n      this._scrollableService.forElement(this.domService.nativeElement(this.anchor) || this.container.nativeElement).subscribe(this.onScroll.bind(this));\n      this.currentOffset = DEFAULT_OFFSET;\n      this.setZIndex();\n      this.copyFontStyles();\n      this.updateFixedClass();\n      this.reposition();\n    }\n    ngOnChanges(changes) {\n      if (changes.copyAnchorStyles) {\n        this.copyFontStyles();\n      }\n      if (changes.positionMode) {\n        this.updateFixedClass();\n      }\n    }\n    ngAfterViewInit() {\n      if (!this.animate) {\n        this.resolvedPromise.then(() => {\n          this.onAnimationEnd();\n        });\n      }\n      this.reposition();\n    }\n    ngAfterViewChecked() {\n      if (this.initialCheck) {\n        this.initialCheck = false;\n        return;\n      }\n      this._zone.runOutsideAngular(() => {\n        // workarounds https://github.com/angular/angular/issues/19094\n        // uses promise because it is executed synchronously after the content is updated\n        // does not use onStable in case the current zone is not the angular one.\n        this.unsubscribeReposition();\n        this.repositionSubscription = from(this.resolvedPromise).subscribe(this.reposition);\n      });\n    }\n    ngOnDestroy() {\n      this.anchorViewportLeave.complete();\n      this.positionChange.complete();\n      this.close.emit();\n      this.close.complete();\n      this._resizeService.unsubscribe();\n      this._scrollableService.unsubscribe();\n      this.animationSubscriptions.unsubscribe();\n      this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      this.reposition();\n    }\n    onAnimationStart() {\n      this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n    onAnimationEnd() {\n      this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n      this.open.emit();\n      this.open.complete();\n    }\n    get currentOffset() {\n      return this._currentOffset;\n    }\n    set currentOffset(offset) {\n      this.setContainerStyle('left', `${offset.left}px`);\n      this.setContainerStyle('top', `${offset.top}px`);\n      this._currentOffset = offset;\n    }\n    setZIndex() {\n      if (this.anchor) {\n        this.setContainerStyle('z-index', String(this.domService.zIndex(this.domService.nativeElement(this.anchor), this.container)));\n      }\n    }\n    reposition() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const {\n        flip,\n        offset\n      } = this.position();\n      if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset)) {\n        this.currentOffset = offset;\n        if (hasObservers(this.positionChange)) {\n          this._zone.run(() => this.positionChange.emit({\n            offset,\n            flip\n          }));\n        }\n      }\n      if (this.animate) {\n        this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n      }\n      this.resizeSensor.acceptSize();\n    }\n    position() {\n      const alignedOffset = this._alignService.alignElement({\n        anchor: this.domService.nativeElement(this.anchor),\n        anchorAlign: this.anchorAlign,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin,\n        offset: this.offset,\n        positionMode: this.positionMode\n      });\n      return this._positionService.positionElement({\n        anchor: this.domService.nativeElement(this.anchor),\n        anchorAlign: this.anchorAlign,\n        collisions: this.collision,\n        currentLocation: alignedOffset,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin\n      });\n    }\n    onScroll(isInViewPort) {\n      const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n      if (isInViewPort || !hasLeaveObservers) {\n        this.reposition();\n      } else if (hasLeaveObservers) {\n        this._zone.run(() => {\n          this.anchorViewportLeave.emit();\n        });\n      }\n    }\n    copyFontStyles() {\n      if (!this.anchor || !this.copyAnchorStyles) {\n        return;\n      }\n      this.domService.getFontStyles(this.domService.nativeElement(this.anchor)).forEach(s => this.setContainerStyle(s.key, s.value));\n    }\n    updateFixedClass() {\n      const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n      this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n    setContainerStyle(name, value) {\n      this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n    unsubscribeReposition() {\n      if (this.repositionSubscription) {\n        this.repositionSubscription.unsubscribe();\n      }\n    }\n  }\n  _class7 = PopupComponent;\n  _defineProperty(PopupComponent, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(AlignService), i0.ɵɵdirectiveInject(DOMService), i0.ɵɵdirectiveInject(PositionService), i0.ɵɵdirectiveInject(ResizeService), i0.ɵɵdirectiveInject(ScrollableService), i0.ɵɵdirectiveInject(AnimationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(PopupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class7,\n    selectors: [[\"kendo-popup\"]],\n    viewQuery: function _class7_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(ResizeSensorComponent, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);\n      }\n    },\n    inputs: {\n      animate: \"animate\",\n      anchor: \"anchor\",\n      anchorAlign: \"anchorAlign\",\n      collision: \"collision\",\n      popupAlign: \"popupAlign\",\n      copyAnchorStyles: \"copyAnchorStyles\",\n      popupClass: \"popupClass\",\n      positionMode: \"positionMode\",\n      offset: \"offset\",\n      margin: \"margin\"\n    },\n    outputs: {\n      anchorViewportLeave: \"anchorViewportLeave\",\n      close: \"close\",\n      open: \"open\",\n      positionChange: \"positionChange\"\n    },\n    exportAs: [\"kendo-popup\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 6,\n    vars: 4,\n    consts: [[1, \"k-child-animation-container\"], [1, \"k-popup\", 3, \"ngClass\"], [\"container\", \"\"], [3, \"ngTemplateOutlet\", \"ngIf\"], [3, \"rateLimit\", \"resize\"]],\n    template: function _class7_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1, 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵtemplate(4, _class7_ng_template_4_Template, 0, 0, \"ng-template\", 3);\n        i0.ɵɵelementStart(5, \"kendo-resize-sensor\", 4);\n        i0.ɵɵlistener(\"resize\", function _class7_Template_kendo_resize_sensor_resize_5_listener() {\n          return ctx.onResize();\n        });\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.popupClass);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.content)(\"ngIf\", ctx.content);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"rateLimit\", 100);\n      }\n    },\n    dependencies: [NgClass, NgTemplateOutlet, NgIf, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return PopupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst removeElement = element => {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`](slug:service_popup) class.\n *\n * In case you are using standalone components:\n *\n * @example\n *\n * ```ts\n * import { Component } from '@angular/core';\n * import { KENDO_POPUP, PopupService } from '@progress/kendo-angular-popup';\n *\n * @Component({\n *   standalone: true,\n *   imports: [KENDO_POPUP],\n *   providers: [PopupService, {\n *     provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *         //return the container ElementRef, where the popup will be injected\n *         return { nativeElement: document.body } as ElementRef;\n *       }\n *   }],\n *   selector: 'app-root',\n *   templateUrl: './app.component.html',\n * })\n * export class AppComponent {}\n * ```\n *\n * In case you are using an NgModule-based application:\n *\n * @example\n *\n * ```ts-no-run\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { ElementRef, NgModule } from '@angular/core';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nconst POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\nlet PopupService = /*#__PURE__*/(() => {\n  var _class8;\n  class PopupService {\n    /**\n     * Gets the root view container into which the component will be injected.\n     *\n     * @returns {ComponentRef<any>}\n     */\n    get rootViewContainer() {\n      // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n      const rootComponents = this.applicationRef.components || [];\n      if (rootComponents[0]) {\n        return rootComponents[0];\n      }\n      throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See https://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n    get rootViewContainerNode() {\n      return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n    constructor(applicationRef, componentFactoryResolver, injector, container) {\n      _defineProperty(this, \"applicationRef\", void 0);\n      _defineProperty(this, \"componentFactoryResolver\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      this.applicationRef = applicationRef;\n      this.componentFactoryResolver = componentFactoryResolver;\n      this.injector = injector;\n      this.container = container;\n    }\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    open(options = {}) {\n      const {\n        component,\n        nodes\n      } = this.contentFrom(options.content);\n      const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n      const popupInstance = popupComponentRef.instance;\n      this.projectComponentInputs(popupComponentRef, options);\n      popupComponentRef.changeDetectorRef.detectChanges();\n      if (component) {\n        component.changeDetectorRef.detectChanges();\n      }\n      const popupElement = this.getComponentRootNode(popupComponentRef);\n      return {\n        close: () => {\n          if (component) {\n            component.destroy();\n          }\n          popupComponentRef.destroy();\n          // Issue in Chrome causes https://github.com/telerik/kendo-angular/issues/4434\n          // To be fixed in Chrome, remove try..catch afterwards\n          // https://chromestatus.com/feature/5128696823545856\n          // https://issues.chromium.org/issues/41484175\n          try {\n            // Angular will not remove the element unless the change detection is triggered\n            removeElement(popupElement);\n          } catch {/* noop */}\n        },\n        content: component,\n        popup: popupComponentRef,\n        popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n        popupClose: popupInstance.close,\n        popupElement: popupElement,\n        popupOpen: popupInstance.open,\n        popupPositionChange: popupInstance.positionChange\n      };\n    }\n    appendPopup(nodes, container) {\n      const popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n      if (!container) {\n        this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n      }\n      return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n    getComponentRootNode(componentRef) {\n      return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    getComponentFactory(componentClass) {\n      return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    createComponent(componentClass, nodes, container) {\n      const factory = this.getComponentFactory(componentClass);\n      if (container) {\n        return container.createComponent(factory, undefined, this.injector, nodes);\n      } else {\n        const component = factory.create(this.injector, nodes);\n        this.applicationRef.attachView(component.hostView);\n        return component;\n      }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n    projectComponentInputs(component, options) {\n      Object.getOwnPropertyNames(options).filter(prop => prop !== 'content' || options.content instanceof TemplateRef).map(prop => {\n        component.instance[prop] = options[prop];\n      });\n      return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n    contentFrom(content) {\n      if (!content || content instanceof TemplateRef) {\n        return {\n          component: null,\n          nodes: [[]]\n        };\n      }\n      const component = this.createComponent(content);\n      const nodes = component ? [component.location.nativeElement] : [];\n      return {\n        component: component,\n        nodes: [nodes // <ng-content>\n        ]\n      };\n    }\n  }\n  _class8 = PopupService;\n  _defineProperty(PopupService, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(POPUP_CONTAINER, 8));\n  });\n  _defineProperty(PopupService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class8,\n    factory: _class8.ɵfac,\n    providedIn: 'root'\n  }));\n  return PopupService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `@progress/kendo-angular-popup` related components and directives\n */\nconst KENDO_POPUP = [PopupComponent];\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet PopupModule = /*#__PURE__*/(() => {\n  var _class9;\n  class PopupModule {}\n  _class9 = PopupModule;\n  _defineProperty(PopupModule, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)();\n  });\n  _defineProperty(PopupModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class9\n  }));\n  _defineProperty(PopupModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService],\n    imports: [KENDO_RESIZESENSOR, KENDO_POPUP]\n  }));\n  return PopupModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { KENDO_POPUP, POPUP_CONTAINER, PopupComponent, PopupModule, PopupService, SCALE };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}