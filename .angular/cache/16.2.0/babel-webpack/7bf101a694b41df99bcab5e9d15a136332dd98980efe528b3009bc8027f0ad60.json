{"ast":null,"code":"import { intersect } from \"./algorithms\";\nimport { getWindow, autoScrollVelocity, scrollableViewPort, getScrollableParent, isPointerInsideContainer, getDocument } from \"./utils\";\n/** @hidden */\nexport var DRAG_AND_DROP_DISPATCH_ACTION = /*#__PURE__*/function (DRAG_AND_DROP_DISPATCH_ACTION) {\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_DOWN\"] = \"pointerdown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_MOVE\"] = \"pointermove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_UP\"] = \"pointerup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_CANCEL\"] = \"pointercancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_DOWN\"] = \"mousedown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_MOVE\"] = \"mousemove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_UP\"] = \"mouseup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CONTEXT_MENU\"] = \"contextmenu\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_START\"] = \"touchstart\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_MOVE\"] = \"touchmove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_END\"] = \"touchend\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_CANCEL\"] = \"touchcancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"SCROLL\"] = \"scroll\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"START\"] = \"KENDO_DRAG_AND_DROP_START\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOVE\"] = \"KENDO_DRAG_AND_DROP_MOVE\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"END\"] = \"KENDO_DRAG_AND_DROP_END\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CANCEL\"] = \"KENDO_DRAG_AND_DROP_CANCEL\";\n  return DRAG_AND_DROP_DISPATCH_ACTION;\n}(DRAG_AND_DROP_DISPATCH_ACTION || {});\nconst isTouchEvent = event => /^touch/.test(event.type);\nconst isScrollEvent = event => /^(scroll)/.test(event.type);\n/** @hidden */\nexport const normalizeEvent = (event, state) => isTouchEvent(event) ? {\n  pageX: event.changedTouches[0].pageX,\n  pageY: event.changedTouches[0].pageY,\n  clientX: event.changedTouches[0].clientX,\n  clientY: event.changedTouches[0].clientY,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  offsetX: state.offset.x,\n  offsetY: state.offset.y,\n  type: event.type,\n  originalEvent: event,\n  isTouch: true,\n  altKey: false,\n  ctrlKey: false,\n  shiftKey: false,\n  metaKey: false\n} : isScrollEvent(event) ? {\n  pageX: state.pageOffset.x,\n  pageY: state.pageOffset.y,\n  clientX: state.clientOffset.x,\n  clientY: state.clientOffset.y,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  offsetX: state.offset.x,\n  offsetY: state.offset.y,\n  type: event.type,\n  originalEvent: event,\n  altKey: false,\n  ctrlKey: false,\n  shiftKey: false,\n  metaKey: false\n} : {\n  pageX: event.pageX,\n  pageY: event.pageY,\n  clientX: event.clientX,\n  clientY: event.clientY,\n  offsetX: event.offsetX,\n  offsetY: event.offsetY,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  type: event.type,\n  ctrlKey: event.ctrlKey,\n  shiftKey: event.shiftKey,\n  altKey: event.altKey,\n  metaKey: event.metaKey,\n  originalEvent: event\n};\nconst noop = () => {};\n/** @hidden */\nexport const dispatchDragAndDrop = (state, action, callbacks = {}) => {\n  const {\n    onIsPressedChange = noop,\n    onIsScrollingChange = noop,\n    onVelocityChange = noop,\n    onOffsetChange = noop,\n    onPageOffsetChange = noop,\n    onClientOffsetChange = noop,\n    onScrollOffsetChange = noop,\n    onInitialScrollOffsetChange = noop\n  } = callbacks;\n  const drag = action.payload;\n  const element = drag.element;\n  const hint = drag.hint;\n  const autoScrollDirection = state.autoScrollDirection;\n  const overrideScrollableParent = state.scrollableParent;\n  const event = normalizeEvent(action.event, state);\n  switch (event.type) {\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {\n        break;\n      }\n    // In rare cases where the `which` attribute is available in the mouse event\n    // we check if the `left button` is explicitly clicked:\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/which#return_value\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event.originalEvent.which && event.originalEvent.which > 1 || state.ignoreMouse) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.START:\n      {\n        const scrollableParent = overrideScrollableParent || getScrollableParent(action.payload.element);\n        onInitialScrollOffsetChange(scrollableParent instanceof Window ? {\n          x: scrollableParent.scrollX,\n          y: scrollableParent.scrollY\n        } : {\n          x: scrollableParent.scrollLeft,\n          y: scrollableParent.scrollTop\n        });\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        onOffsetChange({\n          x: event.offsetX,\n          y: event.offsetY\n        });\n        onIsPressedChange(true);\n        if (drag.onPress) {\n          drag.onPress(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {\n        break;\n      }\n      const scrollableParent = overrideScrollableParent || getScrollableParent(element);\n      const scrollOffset = scrollableParent instanceof Window ? {\n        x: scrollableParent.scrollX,\n        y: scrollableParent.scrollY\n      } : {\n        x: scrollableParent.scrollLeft,\n        y: scrollableParent.scrollTop\n      };\n      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;\n      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;\n      onScrollOffsetChange({\n        x: event.scrollX,\n        y: event.scrollY\n      });\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE:\n      {\n        if (state.pressed) {\n          if (state.autoScroll && event.originalEvent.type !== 'scroll') {\n            if (element) {\n              const document = getDocument(element);\n              const scrollableParent = overrideScrollableParent || getScrollableParent(document.elementFromPoint(event.clientX, event.clientY));\n              const newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent, getWindow(element)));\n              onVelocityChange({\n                x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,\n                y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y\n              });\n              onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);\n            }\n          }\n          if (!state.drag && drag.onDragStart) {\n            drag.onDragStart(event);\n          }\n          if (drag.onDrag) {\n            drag.onDrag(event);\n          }\n          const dropElement = intersect(hint || element, state.drops.map(drop => drop && drop.element).filter(d => d !== (hint || element)));\n          const drop = state.drops.find(drop => drop.element === dropElement);\n          if (drop && dropElement && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement)) && dropElement !== element) {\n            if ((state.drop && state.drop.element) !== dropElement) {\n              if (state.drop && state.drop.onDragLeave) {\n                state.drop.onDragLeave(event);\n              }\n              if (drop.onDragEnter) {\n                drop.onDragEnter(event);\n              }\n            } else {\n              if (drop.onDragOver) {\n                drop.onDragOver(event);\n              }\n            }\n          } else if (state.drop && state.drop.onDragLeave) {\n            state.drop.onDragLeave(event);\n          }\n        }\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:\n    // the last finger has been lifted, and the user is not doing gesture.\n    // there might be a better way to handle this.\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.END:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onRelease) {\n          drag.onRelease(event);\n        }\n        if (state.drop && state.drop.onDrop) {\n          state.drop.onDrop(event);\n        }\n        if (state.drag && drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        if (state.drop && state.drop.onDragLeave) {\n          state.drop.onDragLeave(event);\n        }\n        break;\n      }\n    default:\n      break;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}