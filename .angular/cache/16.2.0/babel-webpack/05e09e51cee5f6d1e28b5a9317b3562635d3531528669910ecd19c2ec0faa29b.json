{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, Directive, Optional, Input, HostBinding, Component, forwardRef, isDevMode, ViewContainerRef, ChangeDetectionStrategy, ViewChild, Output, ContentChild, Host, NgModule } from '@angular/core';\nimport { isDocumentAvailable, Keys, anyChanged, hasObservers, isChanged, guid, ResizeBatchService } from '@progress/kendo-angular-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { Subject, Subscription, of, EMPTY, BehaviorSubject, merge } from 'rxjs';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { getter, setter } from '@progress/kendo-common';\nimport { caretAltDownIcon, caretAltRightIcon, caretAltLeftIcon, searchIcon, cancelIcon, insertMiddleIcon, insertBottomIcon, insertTopIcon, plusIcon } from '@progress/kendo-svg-icons';\nimport { CheckBoxComponent, TextBoxComponent, TextBoxPrefixTemplateDirective } from '@progress/kendo-angular-inputs';\nimport { trigger, transition, style, animate } from '@angular/animations';\nimport { filter, tap, switchMap, delay, takeUntil, catchError, finalize, take, map } from 'rxjs/operators';\nimport { NgFor, NgClass, NgIf, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault } from '@angular/common';\nimport { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\nimport { Draggable } from '@progress/kendo-draggable';\nimport { DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';\nimport { PopupService } from '@progress/kendo-angular-popup';\n\n/**\n * @hidden\n */\nconst _c0 = [\"kendoTreeViewGroup\", \"\"];\nfunction _class17_li_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵlistener(\"click\", function _class17_li_0_span_2_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      const index_r3 = ctx_r10.index;\n      const node_r2 = ctx_r10.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.expandNode(ctx_r9.nodeIndex(index_r3), node_r2, !ctx_r9.isExpanded(node_r2, ctx_r9.nodeIndex(index_r3))));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r12.$implicit;\n    const index_r3 = ctx_r12.index;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", !ctx_r4.isItemExpandable(node_r2, index_r3));\n    i0.ɵɵproperty(\"kendoTreeViewLoading\", ctx_r4.nodeIndex(index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r4.getFontIcon(node_r2, ctx_r4.nodeIndex(index_r3)))(\"svgIcon\", ctx_r4.getSvgIcon(node_r2, ctx_r4.nodeIndex(index_r3)));\n  }\n}\nfunction _class17_li_0_kendo_checkbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-checkbox\", 14, 15);\n    i0.ɵɵlistener(\"checkedStateChange\", function _class17_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkedStateChange_0_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const _r13 = i0.ɵɵreference(1);\n      const index_r3 = i0.ɵɵnextContext().index;\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.checkNode(ctx_r14.nodeIndex(index_r3), _r13));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r17.$implicit;\n    const index_r3 = ctx_r17.index;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"disabled\", ctx_r5.isItemDisabled(node_r2, index_r3))(\"size\", ctx_r5.size)(\"checkedState\", ctx_r5.getCheckBoxState(node_r2, ctx_r5.nodeIndex(index_r3)))(\"tabindex\", -1)(\"inputAttributes\", ctx_r5.getCheckboxAttributes(index_r3));\n  }\n}\nfunction _class17_li_0_ng_container_7_ng_template_1_Template(rf, ctx) {}\nconst _c1 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    index: a1\n  };\n};\nfunction _class17_li_0_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class17_li_0_ng_container_7_ng_template_1_Template, 0, 0, \"ng-template\", 16);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r19.$implicit;\n    const index_r3 = ctx_r19.index;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.nodeTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c1, node_r2, ctx_r6.nodeIndex(index_r3)));\n  }\n}\nfunction _class17_li_0_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const node_r2 = i0.ɵɵnextContext().$implicit;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.nodeText(node_r2), \" \");\n  }\n}\nfunction _class17_li_0_ul_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 17);\n  }\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r21.$implicit;\n    const index_r3 = ctx_r21.index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"size\", ctx_r8.size)(\"nodes\", ctx_r8.fetchChildren)(\"loadOnDemand\", ctx_r8.loadOnDemand)(\"checkboxes\", ctx_r8.checkboxes)(\"expandIcons\", ctx_r8.expandIcons)(\"selectable\", ctx_r8.selectable)(\"touchActions\", ctx_r8.touchActions)(\"children\", ctx_r8.children)(\"hasChildren\", ctx_r8.hasChildren)(\"isChecked\", ctx_r8.isChecked)(\"isDisabled\", ctx_r8.isDisabled)(\"hasCheckbox\", ctx_r8.hasCheckbox)(\"disabled\", ctx_r8.isItemDisabled(node_r2, index_r3))(\"expandDisabledNodes\", ctx_r8.expandDisabledNodes)(\"isExpanded\", ctx_r8.isExpanded)(\"isSelected\", ctx_r8.isSelected)(\"isVisible\", ctx_r8.isVisible)(\"nodeTemplateRef\", ctx_r8.nodeTemplateRef)(\"loadMoreButtonTemplateRef\", ctx_r8.loadMoreButtonTemplateRef)(\"parentIndex\", ctx_r8.nodeIndex(index_r3))(\"parentDataItem\", node_r2)(\"textField\", ctx_r8.nextFields)(\"loadMoreService\", ctx_r8.loadMoreService)(\"@toggle\", true)(\"trackBy\", ctx_r8.trackBy)(\"disableParentNodesOnly\", ctx_r8.disableParentNodesOnly);\n  }\n}\nfunction _class17_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 2)(1, \"div\", 3);\n    i0.ɵɵtemplate(2, _class17_li_0_span_2_Template, 2, 5, \"span\", 4);\n    i0.ɵɵtemplate(3, _class17_li_0_kendo_checkbox_3_Template, 2, 5, \"kendo-checkbox\", 5);\n    i0.ɵɵelementStart(4, \"span\", 6)(5, \"span\", 7);\n    i0.ɵɵelementContainerStart(6, 8);\n    i0.ɵɵtemplate(7, _class17_li_0_ng_container_7_Template, 2, 5, \"ng-container\", 9);\n    i0.ɵɵtemplate(8, _class17_li_0_ng_container_8_Template, 2, 1, \"ng-container\", 10);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵtemplate(9, _class17_li_0_ul_9_Template, 1, 26, \"ul\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const node_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-hidden\", !ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)));\n    i0.ɵɵproperty(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"parentDataItem\", ctx_r0.parentDataItem)(\"parentIndex\", ctx_r0.parentIndex)(\"loadOnDemand\", ctx_r0.loadOnDemand)(\"checkable\", ctx_r0.checkboxes)(\"isChecked\", ctx_r0.isChecked(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isDisabled\", ctx_r0.isItemDisabled(node_r2, index_r3))(\"isVisible\", ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)))(\"expandable\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2))(\"isExpanded\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)))(\"selectable\", ctx_r0.selectable)(\"isSelected\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)));\n    i0.ɵɵattribute(\"aria-setsize\", ctx_r0.totalNodesCount)(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.setItemClasses(ctx_r0.data.length, index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.checkboxes && ctx_r0.hasCheckbox(node_r2, ctx_r0.nodeIndex(index_r3)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"touch-action\", ctx_r0.touchActions ? \"\" : \"none\");\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r0.isItemDisabled(node_r2, index_r3));\n    i0.ɵɵproperty(\"id\", ctx_r0.nodeIndex(index_r3))(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"initialSelection\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isSelected\", ctx_r0.isSelected);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r0.hasTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)) && ctx_r0.hasChildren(node_r2));\n  }\n}\nfunction _class17_li_1_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 23);\n  }\n}\nfunction _class17_li_1_5_ng_template_0_Template(rf, ctx) {}\nconst _c2 = function (a0) {\n  return {\n    index: a0\n  };\n};\nfunction _class17_li_1_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_li_1_5_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r23.loadMoreButtonTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c2, ctx_r23.loadMoreButtonIndex));\n  }\n}\nfunction _class17_li_1_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r24.loadMoreTitle, \" \");\n  }\n}\nfunction _class17_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 18)(1, \"div\", 19);\n    i0.ɵɵtemplate(2, _class17_li_1_span_2_Template, 1, 0, \"span\", 20);\n    i0.ɵɵelementStart(3, \"span\", 21)(4, \"span\", 7);\n    i0.ɵɵtemplate(5, _class17_li_1_5_Template, 1, 4, null, 22);\n    i0.ɵɵtemplate(6, _class17_li_1_ng_container_6_Template, 2, 1, \"ng-container\", 22);\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-treeview-load-more-checkboxes-container\", ctx_r1.checkboxes);\n    i0.ɵɵproperty(\"selectable\", false)(\"checkable\", false)(\"expandable\", false)(\"index\", ctx_r1.loadMoreButtonIndex)(\"parentDataItem\", ctx_r1.parentDataItem)(\"parentIndex\", ctx_r1.parentIndex);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loadingMoreNodes);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"index\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loadMoreButtonTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.loadMoreButtonTemplateRef);\n  }\n}\nconst _c3 = [\"assetsContainer\"];\nconst _c4 = [\"searchbox\"];\nfunction _class20_span_1_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r3.searchIcon);\n  }\n}\nfunction _class20_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 4)(1, \"kendo-textbox\", 5, 6);\n    i0.ɵɵlistener(\"valueChange\", function _class20_span_1_Template_kendo_textbox_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.filterChange.emit($event));\n    });\n    i0.ɵɵtemplate(3, _class20_span_1_ng_template_3_Template, 1, 1, \"ng-template\", 7);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r0.size)(\"value\", ctx_r0.filter)(\"clearButton\", true)(\"placeholder\", ctx_r0.filterInputPlaceholder);\n  }\n}\nfunction _class28_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 1);\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r0.statusIconClass)(\"svgIcon\", ctx_r0.statusSVGIcon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.text);\n  }\n}\nfunction _class28_1_ng_template_0_Template(rf, ctx) {}\nconst _c7 = function (a0, a1, a2, a3) {\n  return {\n    text: a0,\n    action: a1,\n    sourceItem: a2,\n    destinationItem: a3\n  };\n};\nfunction _class28_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class28_1_ng_template_0_Template, 0, 0, \"ng-template\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c7, ctx_r1.text, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\nfunction _class31_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelement(1, \"div\", 3)(2, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class31_1_ng_template_0_ng_template_0_Template(rf, ctx) {}\nfunction _class31_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class31_1_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\nconst _c8 = function (a0, a1, a2) {\n  return {\n    action: a0,\n    sourceItem: a1,\n    destinationItem: a2\n  };\n};\nfunction _class31_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class31_1_ng_template_0_Template, 1, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(2, _c8, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\nconst packageMetadata = {\n  name: '@progress/kendo-angular-treeview',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163665,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nclass DataChangeNotificationService {\n  constructor() {\n    _defineProperty(this, \"changes\", new EventEmitter());\n  }\n  notify() {\n    this.changes.emit();\n  }\n}\n\n/**\n * @hidden\n */\nconst hasChildren = () => false;\n/**\n * @hidden\n */\nconst isChecked = () => 'none';\n/**\n * @hidden\n */\nconst isDisabled = () => false;\n/**\n * @hidden\n */\nconst hasCheckbox = () => true;\n/**\n * @hidden\n */\nconst isExpanded = () => true;\n/**\n * @hidden\n */\nconst isSelected = () => false;\n/**\n * @hidden\n */\nconst isVisible = () => true;\n/**\n * @hidden\n */\nconst trackBy = (_, item) => item;\n\n/**\n * @hidden\n */\nlet ExpandStateService = /*#__PURE__*/(() => {\n  var _class2;\n  class ExpandStateService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n    }\n    expand(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: true\n      });\n    }\n    collapse(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: false\n      });\n    }\n  }\n  _class2 = ExpandStateService;\n  _defineProperty(ExpandStateService, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)();\n  });\n  _defineProperty(ExpandStateService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return ExpandStateService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet IndexBuilderService = /*#__PURE__*/(() => {\n  var _class3;\n  class IndexBuilderService {\n    constructor() {\n      _defineProperty(this, \"INDEX_SEPARATOR\", '_');\n    }\n    nodeIndex(index = '', parentIndex = '') {\n      return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ''}${index}`;\n    }\n    indexForLevel(index, level) {\n      return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);\n    }\n    lastLevelIndex(index = '') {\n      const parts = index.split(this.INDEX_SEPARATOR);\n      if (!parts.length) {\n        return NaN;\n      }\n      return parseInt(parts[parts.length - 1], 10);\n    }\n    level(index) {\n      return index.split(this.INDEX_SEPARATOR).length;\n    }\n  }\n  _class3 = IndexBuilderService;\n  _defineProperty(IndexBuilderService, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)();\n  });\n  _defineProperty(IndexBuilderService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  }));\n  return IndexBuilderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LoadingNotificationService = /*#__PURE__*/(() => {\n  var _class4;\n  class LoadingNotificationService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n    }\n    notifyLoaded(index) {\n      this.changes.next(index);\n    }\n  }\n  _class4 = LoadingNotificationService;\n  _defineProperty(LoadingNotificationService, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)();\n  });\n  _defineProperty(LoadingNotificationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac\n  }));\n  return LoadingNotificationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n/**\n * @hidden\n */\nconst match = (element, selector) => {\n  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;\n  if (!matcher) {\n    return false;\n  }\n  return matcher.call(element, selector.toLowerCase());\n};\n/**\n * @hidden\n */\nconst closestWithMatch = (element, selector) => {\n  if (!document.documentElement.contains(element)) {\n    return null;\n  }\n  let parent = element;\n  while (parent !== null && parent.nodeType === 1) {\n    if (match(parent, selector)) {\n      return parent;\n    }\n    parent = parent.parentElement || parent.parentNode;\n  }\n  return null;\n};\n/**\n * @hidden\n */\nconst noop = () => {};\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isBlank = value => value === null || value === undefined;\n/**\n * @hidden\n */\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\nconst isNullOrEmptyString = value => isBlank(value) || value.trim().length === 0;\n/**\n * @hidden\n */\nconst isBoolean = value => typeof value === 'boolean';\n/**\n * @hidden\n */\nconst closestNode = element => {\n  const selector = 'li.k-treeview-item';\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n  if (element.closest) {\n    return element.closest(selector);\n  } else {\n    return closestWithMatch(element, selector);\n  }\n};\n/**\n * @hidden\n */\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n    return focusable;\n  }\n  return false;\n};\n/**\n * @hidden\n */\nconst isContent = element => {\n  const scopeSelector = '.k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n  let node = element;\n  while (node && !match(node, scopeSelector)) {\n    node = node.parentNode;\n  }\n  if (node) {\n    return match(node, '.k-treeview-leaf:not(.k-treeview-load-more-button)');\n  }\n};\n/**\n * @hidden\n *\n * Returns the nested .k-treeview-leaf:not(.k-treeview-load-more-button) element.\n * If the passed parent item is itself a content node, it is returned.\n */\nconst getContentElement = parent => {\n  if (!isPresent(parent)) {\n    return null;\n  }\n  const selector = '.k-treeview-leaf:not(.k-treeview-load-more-button)';\n  if (match(parent, selector)) {\n    return parent;\n  }\n  return parent.querySelector(selector);\n};\n/**\n * @hidden\n */\nconst isLoadMoreButton = element => {\n  return isPresent(closestWithMatch(element, '.k-treeview-leaf.k-treeview-load-more-button'));\n};\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n  return node;\n};\n/**\n * @hidden\n */\nconst hasParent = (element, container) => {\n  return Boolean(closest(element, node => node === container));\n};\n/**\n * @hidden\n */\nconst focusableNode = element => element.nativeElement.querySelector('li[tabindex=\"0\"]');\n/**\n * @hidden\n */\nconst hasActiveNode = (target, node) => {\n  const closestItem = node || closestNode(target);\n  return closestItem && (closestItem === target || target.tabIndex < 0);\n};\n/**\n * @hidden\n */\nconst nodeId = node => node ? node.getAttribute('data-treeindex') : '';\n/**\n * @hidden\n */\nconst nodeIndex = item => (item || {}).index;\n/**\n * @hidden\n */\nconst dataItemsEqual = (first, second) => {\n  if (!isPresent(first) && !isPresent(second)) {\n    return true;\n  }\n  return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;\n};\n/**\n * @hidden\n */\nconst getDataItem = lookup => {\n  if (!isPresent(lookup)) {\n    return lookup;\n  }\n  return lookup.item.dataItem;\n};\n/**\n * @hidden\n */\nconst isArrayWithAtLeastOneItem = v => v && Array.isArray(v) && v.length !== 0;\n/**\n * @hidden\n * A recursive tree-filtering algorithm that returns:\n * - all child nodes of matching nodes\n * - a chain parent nodes from the match to the root node\n */\nconst filterTree = (items, term, {\n  operator,\n  ignoreCase,\n  mode\n}, textField, depth = 0) => {\n  const field = typeof textField === \"string\" ? textField : textField[depth];\n  items.forEach(wrapper => {\n    const matcher = typeof operator === \"string\" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;\n    const isMatch = matcher(wrapper.dataItem, term);\n    wrapper.isMatch = isMatch;\n    wrapper.visible = isMatch;\n    wrapper.containsMatches = false;\n    if (isMatch) {\n      setParentChain(wrapper.parent);\n    }\n    if (wrapper.children && wrapper.children.length > 0) {\n      if (mode === \"strict\" || !isMatch) {\n        filterTree(wrapper.children, term, {\n          operator,\n          ignoreCase,\n          mode\n        }, textField, depth + 1);\n      } else {\n        makeAllVisible(wrapper.children);\n      }\n    }\n  });\n};\nconst setParentChain = node => {\n  if (!isPresent(node)) {\n    return;\n  }\n  node.containsMatches = true;\n  node.visible = true;\n  if (isPresent(node.parent) && !node.parent.containsMatches) {\n    setParentChain(node.parent);\n  }\n};\nconst makeAllVisible = nodes => {\n  nodes.forEach(node => {\n    node.visible = true;\n    if (node.children) {\n      makeAllVisible(node.children);\n    }\n  });\n};\nconst operators = {\n  contains: (a, b) => a.indexOf(b) >= 0,\n  doesnotcontain: (a, b) => a.indexOf(b) === -1,\n  startswith: (a, b) => a.lastIndexOf(b, 0) === 0,\n  doesnotstartwith: (a, b) => a.lastIndexOf(b, 0) === -1,\n  endswith: (a, b) => a.indexOf(b, a.length - b.length) >= 0,\n  doesnotendwith: (a, b) => a.indexOf(b, a.length - b.length) < 0\n};\nconst matchByCase = (matcher, ignoreCase) => (a, b) => {\n  if (ignoreCase) {\n    return matcher(a.toLowerCase(), b.toLowerCase());\n  }\n  return matcher(a, b);\n};\nconst matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);\n/**\n * @hidden\n */\nconst buildTreeIndex = (parentIndex, itemIndex) => {\n  return [parentIndex, itemIndex].filter(part => isPresent(part)).join('_');\n};\n/**\n * @hidden\n */\nconst buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n  return {\n    dataItem,\n    index: buildTreeIndex(parentIndex, currentLevelIndex)\n  };\n};\n/**\n * @hidden\n *\n * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.\n */\nconst fetchLoadedDescendants = (lookup, filterExpression) => {\n  if (!isPresent(lookup) || lookup.children.length === 0) {\n    return [];\n  }\n  let descendants = lookup.children;\n  if (isPresent(filterExpression)) {\n    descendants = descendants.filter(filterExpression);\n  }\n  descendants.forEach(child => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));\n  return descendants;\n};\n/**\n * @hidden\n *\n * Compares two Seets to determine whether all unique elements in one, are present in the other.\n * Important:\n *  - it disregards the element order\n */\nconst sameValues = (as, bs) => {\n  if (as.size !== bs.size) {\n    return false;\n  }\n  return Array.from(as).every(v => bs.has(v));\n};\n/**\n * @hidden\n * Returns the size class based on the component and size input.\n */\nconst getSizeClass = (component, size) => {\n  const SIZE_CLASSES = {\n    'small': `k-${component}-sm`,\n    'medium': `k-${component}-md`,\n    'large': `k-${component}-lg`\n  };\n  return SIZE_CLASSES[size];\n};\nconst safe = node => node || {};\nconst safeChildren = node => safe(node).children || [];\nconst lastVisibleNode = nodes => {\n  if (!Array.isArray(nodes) || nodes.length === 0) {\n    return null;\n  }\n  const nodesCount = nodes.length;\n  const lastIndex = nodesCount - 1;\n  for (let index = lastIndex; index >= 0; index -= 1) {\n    const node = nodes[index];\n    if (node.visible) {\n      return node;\n    }\n  }\n  return null;\n};\n/**\n * @hidden\n */\nclass NavigationModel {\n  constructor() {\n    _defineProperty(this, \"ib\", new IndexBuilderService());\n    _defineProperty(this, \"nodes\", []);\n  }\n  firstVisibleNode() {\n    return (this.nodes || []).find(node => node.visible);\n  }\n  lastVisibleNode() {\n    let node = lastVisibleNode(this.nodes);\n    while (isPresent(node) && safeChildren(node).length > 0) {\n      const children = safeChildren(node);\n      const lastVisibleChild = lastVisibleNode(children);\n      if (!isPresent(lastVisibleChild)) {\n        return node;\n      }\n      node = lastVisibleChild;\n    }\n    return node;\n  }\n  closestNode(index) {\n    const {\n      prev\n    } = safe(this.findNode(index));\n    const sibling = prev || this.firstVisibleNode();\n    return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;\n  }\n  firstFocusableNode() {\n    return this.nodes.find(node => {\n      return !node.disabled && node.visible;\n    });\n  }\n  findNode(index) {\n    return this.find(index, this.nodes);\n  }\n  findParent(index) {\n    const parentLevel = this.ib.level(index) - 1;\n    return this.findNode(this.ib.indexForLevel(index, parentLevel));\n  }\n  findVisibleChild(index) {\n    const node = this.findNode(index);\n    const children = safeChildren(node);\n    return children.find(child => child.visible);\n  }\n  findVisiblePrev(item) {\n    const index = item.index;\n    const parent = this.findParent(index);\n    const levelIndex = this.ib.lastLevelIndex(index);\n    const prevNodes = this.container(parent).slice(0, levelIndex);\n    const prevNodesHidden = prevNodes.every(node => !node.visible);\n    if (levelIndex === 0 || prevNodesHidden) {\n      return parent;\n    }\n    const currentNode = this.findNode(index);\n    let prev = this.visibleSibling(currentNode, -1);\n    if (prev) {\n      let children = this.container(prev);\n      while (children.length > 0 && children.some(node => node.visible)) {\n        prev = lastVisibleNode(children);\n        children = this.container(prev);\n      }\n    }\n    return prev;\n  }\n  findVisibleNext(item) {\n    const children = this.container(item);\n    const hasVisibleChildren = children.some(child => child.visible);\n    if (children.length === 0 || !hasVisibleChildren) {\n      return this.visibleSibling(item, 1);\n    }\n    return children.find(child => child.visible);\n  }\n  registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n    const children = [];\n    const level = this.ib.level(index);\n    const parent = this.findParent(index);\n    if (parent || level === 1) {\n      const node = {\n        id,\n        children,\n        index,\n        parent,\n        disabled,\n        loadMoreButton,\n        visible\n      };\n      this.insert(node, parent);\n    }\n  }\n  unregisterItem(id, index) {\n    const node = this.find(index, this.nodes);\n    if (!node || node.id !== id) {\n      return;\n    }\n    const children = this.container(node.parent);\n    children.splice(children.indexOf(node), 1);\n  }\n  childLevel(nodes) {\n    const children = nodes.filter(node => isPresent(node));\n    if (!children || !children.length) {\n      return 1;\n    }\n    return this.ib.level(children[0].index);\n  }\n  container(node) {\n    return node ? node.children : this.nodes;\n  }\n  find(index, nodes) {\n    const childLevel = this.childLevel(nodes);\n    const indexToMatch = this.ib.indexForLevel(index, childLevel);\n    const isLeaf = childLevel === this.ib.level(index);\n    const node = nodes.find(n => n && n.index === indexToMatch);\n    if (!node) {\n      return null;\n    }\n    return isLeaf ? node : this.find(index, node.children);\n  }\n  insert(node, parent) {\n    const nodes = this.container(parent);\n    nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);\n  }\n  visibleSibling(node, offset) {\n    if (!node) {\n      return null;\n    }\n    const parent = this.findParent(node.index);\n    const container = this.container(parent);\n    let nextItemIndex = container.indexOf(node) + offset;\n    let nextItem = container[nextItemIndex];\n    while (isPresent(nextItem)) {\n      if (nextItem.visible) {\n        return nextItem;\n      }\n      nextItemIndex += offset;\n      nextItem = container[nextItemIndex];\n    }\n    return this.visibleSibling(parent, offset);\n  }\n}\n\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class6;\n  class NavigationService {\n    get model() {\n      return this._model;\n    }\n    set model(model) {\n      this._model = model;\n    }\n    get activeIndex() {\n      return nodeIndex(this.activeItem) || null;\n    }\n    get isActiveExpanded() {\n      return this.activeItem && this.activeItem.children.length > 0;\n    }\n    get isLoadMoreButton() {\n      return this.activeItem && this.activeItem.loadMoreButton;\n    }\n    get focusableItem() {\n      return this.activeItem || this.model.firstFocusableNode();\n    }\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"expands\", new Subject());\n      _defineProperty(this, \"moves\", new Subject());\n      _defineProperty(this, \"checks\", new Subject());\n      _defineProperty(this, \"selects\", new Subject());\n      _defineProperty(this, \"deselectAllButCurrentItem\", new Subject());\n      _defineProperty(this, \"loadMore\", new Subject());\n      _defineProperty(this, \"navigable\", true);\n      _defineProperty(this, \"selection\", 'single');\n      _defineProperty(this, \"isTreeViewActive\", false);\n      _defineProperty(this, \"actions\", {\n        [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem), true),\n        [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem), true),\n        [Keys.ArrowLeft]: () => !this.isLoadMoreButton && this.expand({\n          expand: this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent\n        }),\n        [Keys.ArrowRight]: () => !this.isLoadMoreButton && this.expand({\n          expand: !this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild\n        }),\n        [Keys.Home]: () => this.activate(this.model.firstVisibleNode(), true),\n        [Keys.End]: () => this.activate(this.model.lastVisibleNode(), true),\n        [Keys.Enter]: e => this.handleEnter(e),\n        [Keys.Space]: () => this.handleSpace()\n      });\n      _defineProperty(this, \"activeItem\", void 0);\n      _defineProperty(this, \"isFocused\", false);\n      _defineProperty(this, \"shouldScroll\", false);\n      _defineProperty(this, \"_model\", new NavigationModel());\n      this.localization = localization;\n      this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);\n      this.moveToParent = this.moveToParent.bind(this);\n    }\n    activate(item, shouldScroll = false) {\n      if (!this.navigable || !item || this.isActive(nodeIndex(item))) {\n        return;\n      }\n      this.isFocused = true;\n      this.activeItem = item || this.activeItem;\n      this.shouldScroll = shouldScroll;\n      this.notifyMove();\n    }\n    activateParent(index) {\n      this.activate(this.model.findParent(index));\n    }\n    activateIndex(index) {\n      if (!index) {\n        return;\n      }\n      this.activate(this.model.findNode(index));\n    }\n    activateClosest(index) {\n      if (!index || nodeIndex(this.focusableItem) !== index) {\n        return;\n      }\n      this.activeItem = this.model.closestNode(index);\n      this.notifyMove();\n    }\n    activateFocusable() {\n      if (this.activeItem) {\n        return;\n      }\n      this.activeItem = this.model.firstVisibleNode();\n      this.notifyMove();\n    }\n    deactivate() {\n      if (!this.navigable || !this.isFocused) {\n        return;\n      }\n      this.isFocused = false;\n      this.notifyMove();\n    }\n    checkIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.checks.next(index);\n      }\n    }\n    selectIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.selects.next(index);\n      }\n    }\n    notifyLoadMore(index) {\n      if (!isPresent(index)) {\n        return;\n      }\n      this.loadMore.next(index);\n    }\n    isActive(index) {\n      if (!index) {\n        return false;\n      }\n      return this.isFocused && this.activeIndex === index;\n    }\n    isFocusable(index) {\n      return nodeIndex(this.focusableItem) === index;\n    }\n    isDisabled(index) {\n      if (!index) {\n        return false;\n      }\n      return this.model.findNode(index).disabled;\n    }\n    registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n      const itemAtIndex = this.model.findNode(index);\n      if (isPresent(itemAtIndex)) {\n        this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);\n        if (this.isActive(index)) {\n          this.deactivate();\n        }\n      }\n      this.model.registerItem(id, index, disabled, loadMoreButton, visible);\n    }\n    updateItem(index, disabled, visible = true) {\n      const itemAtIndex = this.model.findNode(index);\n      if (isPresent(itemAtIndex)) {\n        if (this.isActive(index)) {\n          this.deactivate();\n        }\n      }\n      itemAtIndex.disabled = disabled;\n      itemAtIndex.visible = visible;\n    }\n    unregisterItem(id, index) {\n      if (this.isActive(index)) {\n        this.activateParent(index);\n      }\n      this.model.unregisterItem(id, index);\n    }\n    move(e) {\n      if (!this.navigable) {\n        return;\n      }\n      const moveAction = this.actions[e.keyCode];\n      if (!moveAction) {\n        return;\n      }\n      moveAction(e);\n      e.preventDefault();\n    }\n    expand({\n      expand,\n      intercept\n    }) {\n      const index = nodeIndex(this.activeItem);\n      if (!index || intercept(index)) {\n        return;\n      }\n      this.notifyExpand(expand);\n    }\n    moveToParent() {\n      if (this.isActiveExpanded) {\n        return false;\n      }\n      this.activate(this.model.findParent(nodeIndex(this.activeItem)));\n      return true;\n    }\n    moveToFirstVisibleChild() {\n      if (!this.isActiveExpanded) {\n        return false;\n      }\n      this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));\n      return true;\n    }\n    notifyExpand(expand) {\n      this.expands.next(this.navigationState(expand));\n    }\n    notifyMove() {\n      this.moves.next(this.navigationState());\n    }\n    navigationState(expand = false) {\n      return {\n        expand,\n        index: this.activeIndex,\n        isFocused: this.isFocused,\n        shouldScroll: this.shouldScroll\n      };\n    }\n    handleEnter(event) {\n      if (!this.navigable) {\n        return;\n      }\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        const isCtrlPressed = event.ctrlKey || event.metaKey;\n        if (isCtrlPressed) {\n          this.selectIndex(this.activeIndex);\n        } else {\n          if (this.selection === 'multiple') {\n            this.deselectAllButCurrentItem.next({\n              dataItem: this.activeItem,\n              index: this.activeIndex\n            });\n          } else {\n            this.selectIndex(this.activeIndex);\n          }\n        }\n      }\n    }\n    handleSpace() {\n      if (!this.navigable) {\n        return;\n      }\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        this.checkIndex(this.activeIndex);\n      }\n    }\n  }\n  _class6 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵinject(i1.LocalizationService));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet NodeChildrenService = /*#__PURE__*/(() => {\n  var _class7;\n  class NodeChildrenService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n    }\n    childrenLoaded(item, children) {\n      this.changes.next({\n        item,\n        children\n      });\n    }\n  }\n  _class7 = NodeChildrenService;\n  _defineProperty(NodeChildrenService, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)();\n  });\n  _defineProperty(NodeChildrenService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac\n  }));\n  return NodeChildrenService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).\n * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`\n * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.\n *\n *\n * The node data item and its hierarchical index are available as context variables:\n *\n * - `let-dataItem` (`any`) - available as implicit context variable\n * - `let-index=\"index\"` (`string`)\n *\n *\n * @example\n * ```ts\n *\n *  import { Component } from '@angular/core';\n *  @Component({\n *      selector: 'my-app',\n *      template: `\n *      <kendo-treeview\n *          [nodes]=\"data\"\n *          kendoTreeViewExpandable\n *\n *          kendoTreeViewHierarchyBinding\n *          childrenField=\"items\">\n *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index=\"index\">\n *          <span [style.fontWeight]=\"dataItem.items ? 'bolder': 'normal' \">{{ index }}: {{ dataItem.text }}</span>\n *        </ng-template>\n *      </kendo-treeview>\n *    `\n *  })\n *  export class AppComponent {\n *      public data: any[] = [\n *          {\n *              text: \"Inbox\",\n *              items: [{ text: \"Read Mail\" }]\n *          },\n *          {\n *              text: \"Drafts\"\n *          },\n *          {\n *              text: \"Search Folders\",\n *              items: [\n *                  { text: \"Categorized Mail\" },\n *                  { text: \"Large Mail\" },\n *                  { text: \"Unread Mail\"}\n *              ]\n *          },\n *          { text: \"Settings\" }\n *      ];\n *  }\n *\n * ```\n */\nlet NodeTemplateDirective = /*#__PURE__*/(() => {\n  var _class8;\n  class NodeTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class8 = NodeTemplateDirective;\n  _defineProperty(NodeTemplateDirective, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(NodeTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class8,\n    selectors: [[\"\", \"kendoTreeViewNodeTemplate\", \"\"]],\n    standalone: true\n  }));\n  return NodeTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template for the TreeView load more buttons.\n * To define a button template, nest an `<ng-template>`\n * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).\n *\n * The hierarchical index of the load more button node is available as a context variable:\n *\n * - `let-index=\"index\"` (`string`)\n */\nlet LoadMoreButtonTemplateDirective = /*#__PURE__*/(() => {\n  var _class9;\n  class LoadMoreButtonTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class9 = LoadMoreButtonTemplateDirective;\n  _defineProperty(LoadMoreButtonTemplateDirective, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(LoadMoreButtonTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class9,\n    selectors: [[\"\", \"kendoTreeViewLoadMoreButtonTemplate\", \"\"]],\n    standalone: true\n  }));\n  return LoadMoreButtonTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * An injection token used by the data binding directives to interface with\n * the TreeView or the DropDownTree components.\n */\nlet DataBoundComponent = /*#__PURE__*/(() => {\n  var _class10;\n  class DataBoundComponent {}\n  _class10 = DataBoundComponent;\n  _defineProperty(DataBoundComponent, \"\\u0275fac\", function _class10_Factory(t) {\n    return new (t || _class10)();\n  });\n  _defineProperty(DataBoundComponent, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class10,\n    factory: _class10.ɵfac\n  }));\n  return DataBoundComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * An injection token used by the expand-directive to interface with\n * the TreeView or the DropDownTree components.\n */\nlet ExpandableComponent = /*#__PURE__*/(() => {\n  var _class11;\n  class ExpandableComponent {}\n  _class11 = ExpandableComponent;\n  _defineProperty(ExpandableComponent, \"\\u0275fac\", function _class11_Factory(t) {\n    return new (t || _class11)();\n  });\n  _defineProperty(ExpandableComponent, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class11,\n    factory: _class11.ɵfac\n  }));\n  return ExpandableComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SelectionService = /*#__PURE__*/(() => {\n  var _class12;\n  class SelectionService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n      _defineProperty(this, \"firstIndex\", void 0);\n    }\n    isFirstSelected(index) {\n      return this.firstIndex === index;\n    }\n    setFirstSelected(index, selected) {\n      if (this.firstIndex === index && selected === false) {\n        this.firstIndex = null;\n      } else if (!this.firstIndex && selected) {\n        this.firstIndex = index;\n      }\n    }\n    select(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index\n      });\n    }\n  }\n  _class12 = SelectionService;\n  _defineProperty(SelectionService, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)();\n  });\n  _defineProperty(SelectionService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class12,\n    factory: _class12.ɵfac\n  }));\n  return SelectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INDEX_REGEX = /\\d+$/;\n/**\n * @hidden\n */\nlet TreeViewLookupService = /*#__PURE__*/(() => {\n  var _class13;\n  class TreeViewLookupService {\n    constructor() {\n      _defineProperty(this, \"map\", new Map());\n    }\n    reset() {\n      this.map.clear();\n    }\n    registerItem(item, parent) {\n      const currentLookup = {\n        children: [],\n        item,\n        parent: this.item(nodeIndex(parent))\n      };\n      this.map.set(item.index, currentLookup);\n    }\n    registerChildren(index, children) {\n      const item = this.item(index);\n      if (!item) {\n        return;\n      }\n      item.children = children;\n    }\n    unregisterItem(index, dataItem) {\n      const current = this.item(index);\n      if (current && current.item.dataItem === dataItem) {\n        this.map.delete(index);\n        if (current.parent && current.parent.children) {\n          current.parent.children = current.parent.children.filter(item => item.dataItem !== dataItem);\n        }\n      }\n    }\n    replaceItem(index, item, parent) {\n      if (!item) {\n        return;\n      }\n      this.unregisterItem(index, item.dataItem);\n      this.registerItem(item, parent);\n      this.addToParent(item, parent);\n    }\n    itemLookup(index) {\n      const item = this.item(index);\n      if (!item) {\n        return null;\n      }\n      return {\n        children: this.mapChildren(item.children),\n        item: item.item,\n        parent: item.parent\n      };\n    }\n    hasItem(index) {\n      return this.map.has(index);\n    }\n    item(index) {\n      return this.map.get(index) || null;\n    }\n    addToParent(item, parent) {\n      if (parent) {\n        const parentItem = this.item(parent.index);\n        const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);\n        parentItem.children = parentItem.children || [];\n        parentItem.children.splice(index, 0, item);\n      }\n    }\n    mapChildren(children = []) {\n      return children.map(c => {\n        const {\n          item,\n          parent,\n          children\n        } = this.item(c.index);\n        return {\n          children: this.mapChildren(children),\n          item,\n          parent\n        };\n      });\n    }\n  }\n  _class13 = TreeViewLookupService;\n  _defineProperty(TreeViewLookupService, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)();\n  });\n  _defineProperty(TreeViewLookupService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class13,\n    factory: _class13.ɵfac\n  }));\n  return TreeViewLookupService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * A directive which manages the expanded state of the TreeView.\n */\nlet TreeViewItemContentDirective = /*#__PURE__*/(() => {\n  var _class14;\n  class TreeViewItemContentDirective {\n    constructor(element, navigationService, selectionService, renderer) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"initialSelection\", false);\n      _defineProperty(this, \"isSelected\", isSelected);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.element = element;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.renderer = renderer;\n      this.subscriptions.add(this.navigationService.moves.subscribe(this.updateFocusClass.bind(this)));\n      this.subscriptions.add(this.navigationService.selects.pipe(filter(index => index === this.index)).subscribe(index => this.selectionService.select(index, this.dataItem)));\n      this.subscriptions.add(this.selectionService.changes.subscribe(() => {\n        this.updateSelectionClass(this.isSelected(this.dataItem, this.index));\n      }));\n    }\n    ngOnChanges(changes) {\n      if (changes['initialSelection']) {\n        this.updateSelectionClass(this.initialSelection);\n      }\n      if (changes['index']) {\n        this.updateFocusClass();\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    updateFocusClass() {\n      this.render(this.navigationService.isActive(this.index), 'k-focus');\n    }\n    updateSelectionClass(selected) {\n      this.render(selected, 'k-selected');\n    }\n    render(addClass, className) {\n      const action = addClass ? 'addClass' : 'removeClass';\n      this.renderer[action](this.element.nativeElement, className);\n    }\n  }\n  _class14 = TreeViewItemContentDirective;\n  _defineProperty(TreeViewItemContentDirective, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TreeViewItemContentDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class14,\n    selectors: [[\"\", \"kendoTreeViewItemContent\", \"\"]],\n    inputs: {\n      dataItem: \"dataItem\",\n      index: \"index\",\n      initialSelection: \"initialSelection\",\n      isSelected: \"isSelected\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return TreeViewItemContentDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LoadingIndicatorDirective = /*#__PURE__*/(() => {\n  var _class15;\n  class LoadingIndicatorDirective {\n    get loading() {\n      return this._loading;\n    }\n    set loading(value) {\n      this._loading = value;\n      this.cd.markForCheck();\n    }\n    constructor(expandService, loadingService, cd) {\n      _defineProperty(this, \"expandService\", void 0);\n      _defineProperty(this, \"loadingService\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"_loading\", false);\n      _defineProperty(this, \"subscription\", void 0);\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.cd = cd;\n    }\n    ngOnInit() {\n      const loadingNotifications = this.loadingService.changes.pipe(filter(index => index === this.index));\n      this.subscription = this.expandService.changes.pipe(filter(({\n        index\n      }) => index === this.index), tap(({\n        expand\n      }) => {\n        if (!expand && this.loading) {\n          this.loading = false;\n        }\n      }), filter(({\n        expand\n      }) => expand), switchMap(x => of(x).pipe(delay(100), takeUntil(loadingNotifications)))).subscribe(() => this.loading = true);\n      this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n  }\n  _class15 = LoadingIndicatorDirective;\n  _defineProperty(LoadingIndicatorDirective, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(LoadingNotificationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(LoadingIndicatorDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class15,\n    selectors: [[\"\", \"kendoTreeViewLoading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class15_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-i-loading\", ctx.loading);\n      }\n    },\n    inputs: {\n      index: [\"kendoTreeViewLoading\", \"index\"]\n    },\n    standalone: true\n  }));\n  return LoadingIndicatorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst buildItem = (index, dataItem) => ({\n  dataItem,\n  index\n});\nlet id = 0;\nconst TREE_ITEM_ROLE = 'treeitem';\nconst BUTTON_ROLE = 'button';\n/**\n * @hidden\n *\n * A directive which manages the expanded state of the TreeView.\n */\nlet TreeViewItemDirective = /*#__PURE__*/(() => {\n  var _class16;\n  class TreeViewItemDirective {\n    set isChecked(checked) {\n      if (checked === 'checked') {\n        this.ariaChecked = 'true';\n      } else if (checked === 'indeterminate') {\n        this.ariaChecked = 'mixed';\n      } else {\n        this.ariaChecked = 'false';\n      }\n    }\n    get isExpanded() {\n      return this._isExpanded || false;\n    }\n    set isExpanded(isExpanded) {\n      this._isExpanded = isExpanded;\n    }\n    get isSelected() {\n      return this._isSelected || false;\n    }\n    set isSelected(isSelected) {\n      this._isSelected = isSelected;\n    }\n    get isButton() {\n      return this.role === BUTTON_ROLE;\n    }\n    get treeItem() {\n      return buildItem(this.index, this.dataItem);\n    }\n    get parentTreeItem() {\n      return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;\n    }\n    constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"expandService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"lookupService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ib\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"parentDataItem\", void 0);\n      _defineProperty(this, \"parentIndex\", void 0);\n      _defineProperty(this, \"role\", TREE_ITEM_ROLE);\n      _defineProperty(this, \"loadOnDemand\", true);\n      _defineProperty(this, \"checkable\", void 0);\n      _defineProperty(this, \"selectable\", void 0);\n      _defineProperty(this, \"expandable\", void 0);\n      _defineProperty(this, \"isDisabled\", false);\n      _defineProperty(this, \"isVisible\", true);\n      _defineProperty(this, \"ariaChecked\", 'false');\n      _defineProperty(this, \"id\", id++);\n      _defineProperty(this, \"_isExpanded\", void 0);\n      _defineProperty(this, \"_isSelected\", void 0);\n      _defineProperty(this, \"isInitialized\", false);\n      _defineProperty(this, \"subscriptions\", []);\n      this.element = element;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.lookupService = lookupService;\n      this.renderer = renderer;\n      this.ib = ib;\n      this.subscribe();\n    }\n    ngOnInit() {\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.registerItem(this.treeItem, this.parentTreeItem);\n      }\n      this.registerNavigationItem();\n      this.isInitialized = true;\n      this.setAttribute('role', this.role);\n      this.setAriaAttributes();\n      this.updateTabIndex();\n    }\n    ngOnChanges(changes) {\n      const {\n        index\n      } = changes;\n      if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {\n        this.setAriaAttributes();\n      }\n      if (this.loadOnDemand && !this.isButton) {\n        this.moveLookupItem(changes);\n      }\n      this.moveNavigationItem(index);\n      if (anyChanged(['isDisabled', 'isVisible'], changes)) {\n        this.updateNodeAvailability();\n      }\n    }\n    ngOnDestroy() {\n      this.navigationService.unregisterItem(this.id, this.index);\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.unregisterItem(this.index, this.dataItem);\n      }\n      this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);\n    }\n    subscribe() {\n      this.subscriptions = [this.navigationService.moves.subscribe(navState => {\n        this.updateTabIndex();\n        this.focusItem(navState.shouldScroll);\n      }), this.navigationService.expands.pipe(filter(({\n        index\n      }) => index === this.index && !this.isDisabled)).subscribe(({\n        expand\n      }) => this.expand(expand))];\n    }\n    registerNavigationItem() {\n      this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);\n      this.activateItem();\n    }\n    activateItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      const navigationService = this.navigationService;\n      const selectionService = this.selectionService;\n      const index = this.index;\n      selectionService.setFirstSelected(index, this.isSelected);\n      if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {\n        navigationService.activateIndex(index);\n      }\n    }\n    expand(shouldExpand) {\n      this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);\n    }\n    isFocusable() {\n      return !this.isDisabled && this.navigationService.isFocusable(this.index);\n    }\n    focusItem(scrollIntoView = false) {\n      if (this.isInitialized && this.navigationService.isActive(this.index)) {\n        this.element.nativeElement.focus({\n          preventScroll: !scrollIntoView\n        });\n      }\n    }\n    moveLookupItem(changes = {}) {\n      const {\n        dataItem,\n        index,\n        parentDataItem,\n        parentIndex\n      } = changes;\n      if (index && index.firstChange ||\n      //skip first change\n      !dataItem && !index && !parentDataItem && !parentIndex) {\n        return;\n      }\n      const oldIndex = (index || {}).previousValue || this.index;\n      this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);\n    }\n    moveNavigationItem(indexChange = {}) {\n      const {\n        currentValue,\n        firstChange,\n        previousValue\n      } = indexChange;\n      if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {\n        this.navigationService.unregisterItem(this.id, previousValue);\n        this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);\n      }\n    }\n    updateNodeAvailability() {\n      const service = this.navigationService;\n      if (this.isDisabled || !this.isVisible && this.navigationService.isTreeViewActive) {\n        service.activateClosest(this.index); // activate before updating the item\n      } else {\n        service.activateFocusable();\n      }\n      service.updateItem(this.index, this.isDisabled, this.isVisible);\n    }\n    setAriaAttributes() {\n      this.setAttribute('aria-level', this.ib.level(this.index).toString());\n      // don't render attributes when the component configuration doesn't allow the specified state\n      this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);\n      this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);\n      this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);\n    }\n    updateTabIndex() {\n      this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');\n    }\n    setAttribute(attr, value) {\n      if (!isPresent(value)) {\n        this.renderer.removeAttribute(this.element.nativeElement, attr);\n        return;\n      }\n      this.renderer.setAttribute(this.element.nativeElement, attr, value);\n    }\n  }\n  _class16 = TreeViewItemDirective;\n  _defineProperty(TreeViewItemDirective, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(IndexBuilderService));\n  });\n  _defineProperty(TreeViewItemDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class16,\n    selectors: [[\"\", \"kendoTreeViewItem\", \"\"]],\n    inputs: {\n      dataItem: \"dataItem\",\n      index: \"index\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      role: \"role\",\n      loadOnDemand: \"loadOnDemand\",\n      checkable: \"checkable\",\n      selectable: \"selectable\",\n      expandable: \"expandable\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      isVisible: \"isVisible\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return TreeViewItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TOP_ITEM = 'k-treeview-top';\nconst MID_ITEM = 'k-treeview-mid';\nconst BOT_ITEM = 'k-treeview-bot';\n/**\n * @hidden\n */\nlet TreeViewGroupComponent = /*#__PURE__*/(() => {\n  var _class17;\n  class TreeViewGroupComponent {\n    get role() {\n      return this.parentIndex ? 'group' : 'tree';\n    }\n    getFontIcon(node, index) {\n      return this.isExpanded(node, index) ? 'caret-alt-down' : !this.localization.rtl ? 'caret-alt-right' : 'caret-alt-left';\n    }\n    getSvgIcon(node, index) {\n      return this.isExpanded(node, index) ? caretAltDownIcon : !this.localization.rtl ? caretAltRightIcon : caretAltLeftIcon;\n    }\n    get moreNodesAvailable() {\n      if (!isPresent(this.loadMoreService) || this.data.length === 0) {\n        return false;\n      }\n      return this.pageSize < this.totalNodesCount;\n    }\n    get pageSize() {\n      if (!isPresent(this.loadMoreService)) {\n        return null;\n      }\n      return this.loadMoreService.getGroupSize(this.parentDataItem);\n    }\n    set pageSize(pageSize) {\n      this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);\n    }\n    get data() {\n      if (isPresent(this.pageSize)) {\n        const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;\n        return this._data.slice(0, normalizedSizeValue);\n      }\n      return this._data;\n    }\n    set data(data) {\n      this._data = data;\n      this.registerLoadedNodes(this.data);\n    }\n    get loadMoreButtonIndex() {\n      if (!this.loadMoreService) {\n        return null;\n      }\n      return this.nodeIndex(this.data.length);\n    }\n    /**\n     * Represents the total number of nodes for the current level.\n     */\n    get totalNodesCount() {\n      if (!this.loadMoreService) {\n        return this.data.length;\n      }\n      return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);\n    }\n    constructor(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef, localization, renderer) {\n      _defineProperty(this, \"expandService\", void 0);\n      _defineProperty(this, \"loadingService\", void 0);\n      _defineProperty(this, \"indexBuilder\", void 0);\n      _defineProperty(this, \"treeViewLookupService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"nodeChildrenService\", void 0);\n      _defineProperty(this, \"dataChangeNotification\", void 0);\n      _defineProperty(this, \"changeDetectorRef\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"caretAltRightIcon\", caretAltRightIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"caretAltLeftIcon\", caretAltLeftIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"loadMoreTitle\", void 0);\n      _defineProperty(this, \"kGroupClass\", true);\n      _defineProperty(this, \"checkboxes\", void 0);\n      _defineProperty(this, \"expandIcons\", void 0);\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"selectable\", void 0);\n      _defineProperty(this, \"touchActions\", void 0);\n      _defineProperty(this, \"disableParentNodesOnly\", void 0);\n      _defineProperty(this, \"loadOnDemand\", true);\n      _defineProperty(this, \"trackBy\", void 0);\n      _defineProperty(this, \"nodes\", void 0);\n      _defineProperty(this, \"textField\", \"\");\n      _defineProperty(this, \"parentDataItem\", void 0);\n      _defineProperty(this, \"parentIndex\", void 0);\n      _defineProperty(this, \"nodeTemplateRef\", void 0);\n      _defineProperty(this, \"loadMoreButtonTemplateRef\", void 0);\n      _defineProperty(this, \"loadMoreService\", void 0);\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"expandDisabledNodes\", void 0);\n      _defineProperty(this, \"initialNodesLoaded\", false);\n      _defineProperty(this, \"loadingMoreNodes\", false);\n      _defineProperty(this, \"isItemExpandable\", (node, index) => this.expandDisabledNodes || !this.isItemDisabled(node, index));\n      _defineProperty(this, \"_data\", []);\n      _defineProperty(this, \"nodesSubscription\", void 0);\n      _defineProperty(this, \"loadMoreNodesSubscription\", void 0);\n      _defineProperty(this, \"singleRecordSubscriptions\", new Subscription());\n      _defineProperty(this, \"localizationSubscriptions\", new Subscription());\n      _defineProperty(this, \"isChecked\", () => 'none');\n      _defineProperty(this, \"isDisabled\", () => false);\n      _defineProperty(this, \"hasCheckbox\", () => true);\n      _defineProperty(this, \"isExpanded\", () => false);\n      _defineProperty(this, \"isVisible\", () => true);\n      _defineProperty(this, \"isSelected\", () => false);\n      _defineProperty(this, \"children\", () => of([]));\n      _defineProperty(this, \"hasChildren\", () => false);\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.indexBuilder = indexBuilder;\n      this.treeViewLookupService = treeViewLookupService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.dataChangeNotification = dataChangeNotification;\n      this.changeDetectorRef = changeDetectorRef;\n      this.localization = localization;\n      this.renderer = renderer;\n    }\n    get hasTemplate() {\n      return isPresent(this.nodeTemplateRef);\n    }\n    expandNode(index, dataItem, expand) {\n      if (expand) {\n        this.expandService.expand(index, dataItem);\n      } else {\n        this.expandService.collapse(index, dataItem);\n      }\n    }\n    checkNode(index, checkBox) {\n      this.navigationService.checkIndex(index);\n      this.navigationService.activateIndex(index);\n      if (checkBox?.input) {\n        this.renderer.removeClass(checkBox.input.nativeElement, 'k-focus');\n      }\n    }\n    nodeIndex(index) {\n      return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);\n    }\n    nodeText(dataItem) {\n      const textField = isArray(this.textField) ? this.textField[0] : this.textField;\n      return getter(textField)(dataItem);\n    }\n    getCheckBoxState(item, index) {\n      const state = this.isChecked(item, index);\n      if (state === 'indeterminate') {\n        return state;\n      }\n      return state === 'checked';\n    }\n    getCheckboxAttributes(index) {\n      return {\n        'aria-hidden': 'true',\n        role: 'none',\n        'aria-labelledby': this.nodeIndex(index)\n      };\n    }\n    ngOnDestroy() {\n      if (isPresent(this.nodesSubscription)) {\n        this.nodesSubscription.unsubscribe();\n      }\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n      this.singleRecordSubscriptions.unsubscribe();\n      this.localizationSubscriptions.unsubscribe();\n    }\n    ngOnInit() {\n      this.subscribeToNodesChange();\n      this.singleRecordSubscriptions.add(this.dataChangeNotification.changes.subscribe(this.subscribeToNodesChange.bind(this)));\n      this.singleRecordSubscriptions.add(this.navigationService.loadMore.pipe(filter(index => index === this.loadMoreButtonIndex)).subscribe(this.loadMoreNodes.bind(this)));\n      this.localizationSubscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));\n    }\n    ngOnChanges(changes) {\n      if (changes.parentIndex && this.loadOnDemand) {\n        this.setNodeChildren(this.mapToTreeItem(this.data));\n      }\n      if (this.localization.get('loadMore')) {\n        this.loadMoreTitle = this.localization.get('loadMore');\n      }\n    }\n    l10nChange() {\n      if (this.localization.get('loadMore')) {\n        this.loadMoreTitle = this.localization.get('loadMore');\n      }\n      this.changeDetectorRef.markForCheck();\n    }\n    fetchChildren(node, index) {\n      return this.children(node).pipe(catchError(() => {\n        this.loadingService.notifyLoaded(index);\n        return EMPTY;\n      }), tap(() => this.loadingService.notifyLoaded(index)));\n    }\n    get nextFields() {\n      if (isArray(this.textField)) {\n        return this.textField.length > 1 ? this.textField.slice(1) : this.textField;\n      }\n      return [this.textField];\n    }\n    loadMoreNodes() {\n      if (isPresent(this.loadMoreService.loadMoreNodes)) {\n        this.fetchMoreNodes();\n      } else {\n        this.loadMoreLocalNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n    isItemDisabled(node, index) {\n      return this.disabled && !this.disableParentNodesOnly || this.isDisabled(node, this.nodeIndex(index));\n    }\n    /**\n     * @hidden\n     */\n    setItemClasses(dataLength, index) {\n      if (dataLength === 1) {\n        return this.parentIndex ? BOT_ITEM : `${TOP_ITEM} ${BOT_ITEM}`;\n      }\n      if (index === 0) {\n        return TOP_ITEM;\n      }\n      if (index > 0 && index < dataLength - 1) {\n        return MID_ITEM;\n      }\n      return index === this.totalNodesCount - 1 ? BOT_ITEM : MID_ITEM;\n    }\n    loadMoreLocalNodes() {\n      const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n      this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);\n      this.registerLoadedNodes(this.data);\n      // forces the new items to be registered before the focus is changed\n      this.changeDetectorRef.detectChanges();\n      this.reselectItemAt(initialLoadMoreButtonIndex);\n    }\n    fetchMoreNodes() {\n      if (this.loadingMoreNodes) {\n        return;\n      }\n      this.loadingMoreNodes = true;\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n      this.loadMoreNodesSubscription = this.loadMoreService.loadMoreNodes({\n        dataItem: this.parentDataItem,\n        skip: this.data.length,\n        take: this.loadMoreService.getInitialPageSize(this.parentDataItem)\n      }).pipe(finalize(() => this.loadingMoreNodes = false)).subscribe(items => {\n        if (!(Array.isArray(items) && items.length > 0)) {\n          return;\n        }\n        const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n        this.pageSize += items.length;\n        this.data = this.data.concat(items);\n        if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {\n          // forces the new items to be registered before the focus is changed\n          this.changeDetectorRef.detectChanges();\n          this.reselectItemAt(initialLoadMoreButtonIndex);\n        }\n      });\n    }\n    setNodeChildren(children) {\n      this.treeViewLookupService.registerChildren(this.parentIndex, children);\n    }\n    mapToTreeItem(data) {\n      if (!this.parentIndex) {\n        return [];\n      }\n      return data.map((dataItem, idx) => ({\n        dataItem,\n        index: this.nodeIndex(idx)\n      }));\n    }\n    emitChildrenLoaded(children) {\n      if (!this.parentIndex) {\n        return;\n      }\n      // ignores the registered load-more button\n      const contentChildren = children.filter(item => item.dataItem);\n      this.nodeChildrenService.childrenLoaded({\n        dataItem: this.parentDataItem,\n        index: this.parentIndex\n      }, contentChildren);\n    }\n    subscribeToNodesChange() {\n      if (this.nodesSubscription) {\n        this.nodesSubscription.unsubscribe();\n      }\n      this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe(data => {\n        this.data = data;\n        this.initialNodesLoaded = true;\n      });\n    }\n    reselectItemAt(index) {\n      if (!isPresent(index)) {\n        return;\n      }\n      // make sure the old index is cleared first\n      this.navigationService.deactivate();\n      this.navigationService.activateIndex(index);\n    }\n    registerLoadedNodes(nodes = []) {\n      const mappedChildren = this.mapToTreeItem(nodes);\n      if (this.loadOnDemand) {\n        this.setNodeChildren(mappedChildren);\n      }\n      this.emitChildrenLoaded(mappedChildren);\n    }\n  }\n  _class17 = TreeViewGroupComponent;\n  _defineProperty(TreeViewGroupComponent, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(LoadingNotificationService), i0.ɵɵdirectiveInject(IndexBuilderService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(NodeChildrenService), i0.ɵɵdirectiveInject(DataChangeNotificationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TreeViewGroupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class17,\n    selectors: [[\"\", \"kendoTreeViewGroup\", \"\"]],\n    hostVars: 3,\n    hostBindings: function _class17_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-treeview-group\", ctx.kGroupClass);\n      }\n    },\n    inputs: {\n      checkboxes: \"checkboxes\",\n      expandIcons: \"expandIcons\",\n      disabled: \"disabled\",\n      selectable: \"selectable\",\n      touchActions: \"touchActions\",\n      disableParentNodesOnly: \"disableParentNodesOnly\",\n      loadOnDemand: \"loadOnDemand\",\n      trackBy: \"trackBy\",\n      nodes: \"nodes\",\n      textField: \"textField\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      nodeTemplateRef: \"nodeTemplateRef\",\n      loadMoreButtonTemplateRef: \"loadMoreButtonTemplateRef\",\n      loadMoreService: \"loadMoreService\",\n      size: \"size\",\n      expandDisabledNodes: \"expandDisabledNodes\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      hasCheckbox: \"hasCheckbox\",\n      isExpanded: \"isExpanded\",\n      isVisible: \"isVisible\",\n      isSelected: \"isSelected\",\n      children: \"children\",\n      hasChildren: \"hasChildren\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c0,\n    decls: 2,\n    vars: 3,\n    consts: [[\"class\", \"k-treeview-item\", \"kendoTreeViewItem\", \"\", 3, \"k-hidden\", \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"k-treeview-item\", \"kendoTreeViewItem\", \"\", \"role\", \"button\", 3, \"k-treeview-load-more-checkboxes-container\", \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\", 4, \"ngIf\"], [\"kendoTreeViewItem\", \"\", 1, \"k-treeview-item\", 3, \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\"], [3, \"ngClass\"], [\"class\", \"k-treeview-toggle\", 3, \"k-disabled\", \"kendoTreeViewLoading\", \"click\", 4, \"ngIf\"], [3, \"disabled\", \"size\", \"checkedState\", \"tabindex\", \"inputAttributes\", \"checkedStateChange\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-treeview-leaf\", 3, \"id\", \"dataItem\", \"index\", \"initialSelection\", \"isSelected\"], [1, \"k-treeview-leaf-text\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"size\", \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"hasCheckbox\", \"disabled\", \"expandDisabledNodes\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\", \"disableParentNodesOnly\", 4, \"ngIf\"], [1, \"k-treeview-toggle\", 3, \"kendoTreeViewLoading\", \"click\"], [3, \"name\", \"svgIcon\"], [3, \"disabled\", \"size\", \"checkedState\", \"tabindex\", \"inputAttributes\", \"checkedStateChange\"], [\"checkbox\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"size\", \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"hasCheckbox\", \"disabled\", \"expandDisabledNodes\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\", \"disableParentNodesOnly\"], [\"kendoTreeViewItem\", \"\", \"role\", \"button\", 1, \"k-treeview-item\", 3, \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\"], [1, \"k-treeview-bot\"], [\"class\", \"k-icon k-i-loading\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-treeview-leaf\", \"k-treeview-load-more-button\", 3, \"index\"], [4, \"ngIf\"], [1, \"k-icon\", \"k-i-loading\"]],\n    template: function _class17_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class17_li_0_Template, 10, 33, \"li\", 0);\n        i0.ɵɵtemplate(1, _class17_li_1_Template, 7, 14, \"li\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.data)(\"ngForTrackBy\", ctx.trackBy);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.initialNodesLoaded && ctx.moreNodesAvailable);\n      }\n    },\n    dependencies: [_class17, NgFor, TreeViewItemDirective, NgClass, NgIf, LoadingIndicatorDirective, IconWrapperComponent, CheckBoxComponent, TreeViewItemContentDirective, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [transition('void => *', [style({\n        height: 0\n      }), animate('0.1s ease-in', style({\n        height: \"*\"\n      }))]), transition('* => void', [style({\n        height: \"*\"\n      }), animate('0.1s ease-in', style({\n        height: 0\n      }))])])]\n    }\n  }));\n  return TreeViewGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TreeViewMessages = /*#__PURE__*/(() => {\n  var _class18;\n  class TreeViewMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The text of the `Load More` button title.\n       */\n      _defineProperty(this, \"loadMore\", void 0);\n    }\n  }\n  _class18 = TreeViewMessages;\n  _defineProperty(TreeViewMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class18_BaseFactory;\n    return function _class18_Factory(t) {\n      return (ɵ_class18_BaseFactory || (ɵ_class18_BaseFactory = i0.ɵɵgetInheritedFactory(_class18)))(t || _class18);\n    };\n  }());\n  _defineProperty(TreeViewMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class18,\n    selectors: [[\"kendo-treeview-messages-base\"]],\n    inputs: {\n      loadMore: \"loadMore\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return TreeViewMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  var _class19;\n  class LocalizedMessagesDirective extends TreeViewMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class19 = LocalizedMessagesDirective;\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class19,\n    selectors: [[\"\", \"kendoTreeViewLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TreeViewMessages,\n      useExisting: forwardRef(() => _class19)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId = 0;\nconst LOAD_MORE_DOC_LINK$1 = 'https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\nconst providers = [ExpandStateService, IndexBuilderService, TreeViewLookupService, LoadingNotificationService, NodeChildrenService, NavigationService, SelectionService, DataChangeNotificationService, LocalizationService, {\n  provide: L10N_PREFIX,\n  useValue: 'kendo.treeview'\n}, {\n  provide: DataBoundComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}, {\n  provide: ExpandableComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}];\n/**\n * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).\n *\n */\nlet TreeViewComponent = /*#__PURE__*/(() => {\n  var _class20;\n  class TreeViewComponent {\n    /** @hidden */\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * Determines whether the content animation is enabled.\n     */\n    set animate(value) {\n      this._animate = value;\n    }\n    get animate() {\n      return !this._animate;\n    }\n    /** @hidden */\n\n    /**\n     * @hidden\n     *\n     * Defines the template for each node.\n     * Takes precedence over nested templates in the TreeView tag.\n     */\n    set nodeTemplateRef(template) {\n      this._nodeTemplateRef = template;\n    }\n    get nodeTemplateRef() {\n      return this._nodeTemplateRef || this.nodeTemplateQuery;\n    }\n    /**\n     * @hidden\n     *\n     * Queries the template for a load-more button template declaration.\n     * Ignored if a `[loadMoreButtonTemplate]` value is explicitly provided.\n     */\n\n    /**\n     * @hidden\n     *\n     * Defines the template for each load-more button.\n     * Takes precedence over nested templates in the TreeView tag.\n     */\n    set loadMoreButtonTemplateRef(template) {\n      this._loadMoreButtonTemplateRef = template;\n    }\n    get loadMoreButtonTemplateRef() {\n      return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;\n    }\n    /**\n     * A function that defines how to track node changes.\n     * By default, the TreeView tracks the nodes by data item object reference.\n     *\n     * @example\n     * ```ts\n     *  @Component({\n     *      selector: 'my-app',\n     *      template: `\n     *          <kendo-treeview\n     *              [nodes]=\"data\"\n     *              textField=\"text\"\n     *              [trackBy]=\"trackBy\"\n     *          >\n     *          </kendo-treeview>\n     *      `\n     *  })\n     *  export class AppComponent {\n     *      public data: any[] = [\n     *          { text: \"Furniture\" },\n     *          { text: \"Decor\" }\n     *      ];\n     *\n     *      public trackBy(index: number, item: any): any {\n     *          return item.text;\n     *      }\n     *  }\n     * ```\n     */\n\n    /**\n     * The nodes which will be displayed by the TreeView\n     * ([see example]({% slug databinding_treeview %})).\n     */\n    set nodes(value) {\n      this.data.next(value || []);\n      this.dataChangeNotification.notify();\n    }\n    get nodes() {\n      return this.data.value;\n    }\n    /**\n     * The fields of the data item that provide the text content of the nodes\n     * ([see example]({% slug databinding_treeview %})). If the `textField` input is set\n     * to an array, each hierarchical level uses the field that corresponds to the same\n     * index in the array, or the last item in the array.\n     */\n\n    /**\n     * A function which determines if a specific node has child nodes\n     * ([see example]({% slug databinding_treeview %})).\n     */\n    get hasChildren() {\n      return this._hasChildren || hasChildren;\n    }\n    set hasChildren(callback) {\n      this._hasChildren = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is checked\n     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n     */\n    get isChecked() {\n      return this._isChecked || isChecked;\n    }\n    set isChecked(callback) {\n      this._isChecked = callback;\n      this.checkboxes = Boolean(this._isChecked);\n    }\n    /**\n     * A function which determines if a specific node is disabled.\n     */\n\n    /**\n     * A function which determines if a specific node is expanded.\n     */\n    get isExpanded() {\n      return this._isExpanded || isExpanded;\n    }\n    set isExpanded(callback) {\n      this._isExpanded = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is selected\n     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n     */\n    get isSelected() {\n      return this._isSelected || isSelected;\n    }\n    set isSelected(callback) {\n      this._isSelected = callback;\n      this.selectable = Boolean(this._isSelected);\n    }\n    /**\n     * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.\n     * Useful for custom filtering implementations.\n     */\n\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : 'medium';\n      if (this.size !== 'none') {\n        this.renderer.removeClass(this.element.nativeElement, getSizeClass('treeview', this.size));\n      }\n      this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', newSize));\n      this._size = size;\n    }\n    get size() {\n      return this._size;\n    }\n    get isActive() {\n      return this.navigationService.isTreeViewActive;\n    }\n    /**\n     * @hidden\n     */\n    get treeviewId() {\n      return `treeview_${this._nextId}`;\n    }\n    /**\n     * Indicates whether only parent nodes should be disabled or their child nodes as well\n     * @default false\n     */\n\n    constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"changeDetectorRef\", void 0);\n      _defineProperty(this, \"expandService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"nodeChildrenService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"treeViewLookupService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"dataChangeNotification\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"searchIcon\", searchIcon);\n      _defineProperty(this, \"classNames\", true);\n      _defineProperty(this, \"assetsContainer\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"searchbox\", void 0);\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n      _defineProperty(this, \"filterInputPlaceholder\", \"\");\n      /**\n       * Determines whether to allow expanding disabled nodes.\n       * @default false\n       */\n      _defineProperty(this, \"expandDisabledNodes\", void 0);\n      _defineProperty(this, \"fetchNodes\", () => this.data);\n      /**\n       * Fires when the children of the expanded node are loaded.\n       */\n      _defineProperty(this, \"childrenLoaded\", new EventEmitter());\n      /**\n       * Fires when the user blurs the component.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires when the user focuses the component.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires when the user expands a TreeView node.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the user collapses a TreeView node.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.\n       * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.\n       */\n      _defineProperty(this, \"nodeDragStart\", new EventEmitter());\n      /**\n       * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n      _defineProperty(this, \"nodeDrag\", new EventEmitter());\n      /**\n       * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.\n       * Used for the built-in auto-expand functionalities of the component and available for custom implementations.\n       */\n      _defineProperty(this, \"filterStateChange\", new EventEmitter());\n      /**\n       * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),\n       * the `addItem` and `removeItem` events will not be triggered.\n       *\n       * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was\n       * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.\n       * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.\n       */\n      _defineProperty(this, \"nodeDrop\", new EventEmitter());\n      /**\n       * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n      _defineProperty(this, \"nodeDragEnd\", new EventEmitter());\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView where the item is dropped.\n       */\n      _defineProperty(this, \"addItem\", new EventEmitter());\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView from where the item is dragged.\n       */\n      _defineProperty(this, \"removeItem\", new EventEmitter());\n      /**\n       * Fires when the user selects a TreeView node checkbox\n       * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n       */\n      _defineProperty(this, \"checkedChange\", new EventEmitter());\n      /**\n       * Fires when the user selects a TreeView node\n       * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n       */\n      _defineProperty(this, \"selectionChange\", new EventEmitter());\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires when the user clicks a TreeView node.\n       */\n      _defineProperty(this, \"nodeClick\", new EventEmitter());\n      /**\n       * Fires when the user double clicks a TreeView node.\n       */\n      _defineProperty(this, \"nodeDblClick\", new EventEmitter());\n      /**\n       * @hidden\n       *\n       * Queries the template for a node template declaration.\n       * Ignored if a `[nodeTemplate]` value is explicitly provided.\n       */\n      _defineProperty(this, \"nodeTemplateQuery\", void 0);\n      _defineProperty(this, \"loadMoreButtonTemplateQuery\", void 0);\n      _defineProperty(this, \"trackBy\", trackBy);\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"isDisabled\", isDisabled);\n      /**\n       * A function which determines if a specific node has a checkbox.\n       *\n       * > If there is no checkbox for a node, then this node is not checkable and is excluded from any built-in check functionality.\n       */\n      _defineProperty(this, \"hasCheckbox\", hasCheckbox);\n      _defineProperty(this, \"isVisible\", isVisible);\n      /**\n       * Determines whether the TreeView keyboard navigable is enabled.\n       */\n      _defineProperty(this, \"navigable\", true);\n      /**\n       * A function which provides the child nodes for a given parent node\n       * ([see example]({% slug databinding_treeview %})).\n       */\n      _defineProperty(this, \"children\", () => of([]));\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default true\n       */\n      _defineProperty(this, \"loadOnDemand\", true);\n      /**\n       * Renders the built-in input element for filtering the TreeView.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.\n       */\n      _defineProperty(this, \"filterable\", false);\n      /**\n       * Sets an initial value of the built-in input element used for filtering.\n       */\n      _defineProperty(this, \"filter\", '');\n      _defineProperty(this, \"disableParentNodesOnly\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"loadMoreService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"checkboxes\", false);\n      _defineProperty(this, \"expandIcons\", false);\n      _defineProperty(this, \"selectable\", false);\n      _defineProperty(this, \"touchActions\", true);\n      _defineProperty(this, \"data\", new BehaviorSubject([]));\n      _defineProperty(this, \"_animate\", true);\n      _defineProperty(this, \"_isChecked\", void 0);\n      _defineProperty(this, \"_isExpanded\", void 0);\n      _defineProperty(this, \"_isSelected\", void 0);\n      _defineProperty(this, \"_hasChildren\", void 0);\n      _defineProperty(this, \"_nodeTemplateRef\", void 0);\n      _defineProperty(this, \"_loadMoreButtonTemplateRef\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"domSubscriptions\", []);\n      _defineProperty(this, \"_nextId\", nextId);\n      this.element = element;\n      this.changeDetectorRef = changeDetectorRef;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.selectionService = selectionService;\n      this.treeViewLookupService = treeViewLookupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.dataChangeNotification = dataChangeNotification;\n      this.localization = localization;\n      validatePackage(packageMetadata);\n      nextId++;\n    }\n    ngOnChanges(changes) {\n      this.navigationService.navigable = Boolean(this.navigable);\n      // TODO: should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n      if (anyChanged(['nodes', 'children', 'hasChildren', 'loadOnDemand'], changes, false) && !this.loadOnDemand) {\n        this.preloadChildNodes();\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.domSubscriptions.forEach(subscription => subscription());\n    }\n    ngOnInit() {\n      this.subscriptions.add(this.nodeChildrenService.changes.subscribe(x => this.childrenLoaded.emit(x)));\n      this.subscriptions.add(this.expandService.changes.subscribe(({\n        index,\n        dataItem,\n        expand\n      }) => expand ? this.expand.emit({\n        index,\n        dataItem\n      }) : this.collapse.emit({\n        index,\n        dataItem\n      })));\n      this.subscriptions.add(this.navigationService.checks.subscribe(x => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));\n      this.subscriptions.add(this.selectionService.changes.subscribe(x => {\n        if (hasObservers(this.selectionChange)) {\n          this.ngZone.run(() => {\n            this.selectionChange.emit(x);\n          });\n        }\n      }));\n      if (this.element) {\n        this.ngZone.runOutsideAngular(() => {\n          this.attachDomHandlers();\n        });\n      }\n      if (this.size) {\n        this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', this.size));\n      }\n    }\n    ngAfterViewInit() {\n      if (this.searchbox) {\n        this.renderer.setAttribute(this.searchbox.input.nativeElement, 'role', 'searchbox');\n        this.renderer.setAttribute(this.searchbox.input.nativeElement, 'aria-controls', this.treeviewId);\n        this.renderer.setAttribute(this.searchbox.input.nativeElement, 'aria-label', 'searchbar');\n      }\n    }\n    /**\n     * Blurs the focused TreeView item.\n     */\n    blur() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const target = focusableNode(this.element);\n      if (document.activeElement === target) {\n        target.blur();\n      }\n    }\n    /**\n     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     *  @Component({\n     *      selector: 'my-app',\n     *      template: `\n     *      <button (click)=\"treeview.focus('1')\">Focuses the second node</button>\n     *      <kendo-treeview\n     *          #treeview\n     *          [nodes]=\"data\"\n     *          textField=\"text\"\n     *      >\n     *      </kendo-treeview>\n     *  `\n     *  })\n     *  export class AppComponent {\n     *      public data: any[] = [\n     *          { text: \"Furniture\" },\n     *          { text: \"Decor\" }\n     *      ];\n     *  }\n     * ```\n     */\n    focus(index) {\n      const focusIndex = index || nodeIndex(this.navigationService.focusableItem);\n      this.navigationService.activateIndex(focusIndex);\n      const target = focusableNode(this.element);\n      if (target) {\n        target.focus();\n      }\n    }\n    /**\n     * Based on the specified index, returns the TreeItemLookup node.\n     *\n     * @param index - The index of the node.\n     * @returns {TreeItemLookup} - The item that was searched (looked up).\n     */\n    itemLookup(index) {\n      return this.treeViewLookupService.itemLookup(index);\n    }\n    /**\n     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,\n     * causing all rendered child nodes to be fetched again.\n     */\n    rebindChildren() {\n      this.dataChangeNotification.notify();\n    }\n    /**\n     * Triggers the `expand` event for the provided node and displays it's loading indicator.\n     */\n    expandNode(item, index) {\n      this.expandService.expand(index, item);\n    }\n    /**\n     * Triggers the `collapse` event for the provided node.\n     */\n    collapseNode(item, index) {\n      this.expandService.collapse(index, item);\n    }\n    /**\n     * Gets the current page size of the checked data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @returns {number} - The page size of the checked data item children collection.\n     */\n    getNodePageSize(dataItem) {\n      this.verifyLoadMoreService();\n      return this.loadMoreService.getGroupSize(dataItem);\n    }\n    /**\n     * Sets the page size of the targeted data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @param pageSize {number} - The new page size.\n     */\n    setNodePageSize(dataItem, pageSize) {\n      this.verifyLoadMoreService();\n      this.loadMoreService.setGroupSize(dataItem, pageSize);\n    }\n    /**\n     * @hidden\n     *\n     * Clears the current TreeViewLookupService node map and re-registers all nodes anew.\n     * Child nodes are acquired through the provided `children` callback.\n     */\n    preloadChildNodes() {\n      this.treeViewLookupService.reset();\n      this.registerLookupItems(this.nodes);\n    }\n    attachDomHandlers() {\n      const element = this.element.nativeElement;\n      this.clickHandler = this.clickHandler.bind(this);\n      this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));\n    }\n    focusHandler(e) {\n      let focusItem;\n      if (match(e.target, '.k-treeview-item')) {\n        focusItem = e.target;\n      } else if (!isFocusable(e.target)) {\n        // with compliments to IE\n        focusItem = closestNode(e.target);\n      }\n      if (focusItem) {\n        const nodeIndex = nodeId(e.target);\n        if (this.navigationService.isDisabled(nodeIndex)) {\n          return;\n        }\n        this.navigationService.activateIndex(nodeIndex);\n        if (!this.isActive && hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n        this.navigationService.isTreeViewActive = true;\n      }\n    }\n    blurHandler(e) {\n      if (this.isActive && match(e.target, '.k-treeview-item') && (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {\n        this.navigationService.deactivate();\n        this.navigationService.isTreeViewActive = false;\n        if (hasObservers(this.onBlur)) {\n          this.ngZone.run(() => {\n            this.onBlur.emit();\n          });\n        }\n      }\n    }\n    clickHandler(e) {\n      const target = e.target;\n      if (e.type === 'contextmenu' && !hasObservers(this.nodeClick) || e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target) || e.type === 'dblclick' && !hasObservers(this.nodeDblClick) || isFocusable(target) || !isContent(target) && !isLoadMoreButton(target) || !hasParent(target, this.element.nativeElement)) {\n        return;\n      }\n      const index = nodeId(closestNode(target));\n      // the disabled check is probably not needed due to the k-disabled styles\n      if (!index || this.navigationService.isDisabled(index)) {\n        return;\n      }\n      this.ngZone.run(() => {\n        // record this value before emitting selectionChange (`this.navigationService.selectIndex`), as the treeview state may be changed on its emission\n        const lookup = this.treeViewLookupService.itemLookup(index);\n        if (e.type === 'click') {\n          const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;\n          if (loadMoreButton) {\n            this.navigationService.notifyLoadMore(index);\n            return;\n          } else {\n            this.navigationService.selectIndex(index);\n          }\n        }\n        const emitter = e.type === 'dblclick' ? this.nodeDblClick : this.nodeClick;\n        emitter.emit({\n          item: lookup.item,\n          originalEvent: e,\n          type: e.type\n        });\n      });\n    }\n    keydownHandler(e) {\n      if (this.isActive && this.navigable) {\n        this.ngZone.run(() => {\n          this.navigationService.move(e);\n        });\n      }\n    }\n    verifyLoadMoreService() {\n      if (isDevMode() && !isPresent(this.loadMoreService)) {\n        throw new Error(`To use the TreeView paging functionality, you need to assign the \\`kendoTreeViewLoadMore\\` directive. See ${LOAD_MORE_DOC_LINK$1}.`);\n      }\n    }\n    registerLookupItems(data, parentItem = null) {\n      if (!isPresent(data) || data.length === 0) {\n        return;\n      }\n      const parentIndex = nodeIndex(parentItem);\n      const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));\n      if (isPresent(parentItem)) {\n        this.treeViewLookupService.registerChildren(parentIndex, treeItems);\n      }\n      treeItems.forEach(item => {\n        this.treeViewLookupService.registerItem(item, parentItem);\n        if (this.hasChildren(item.dataItem)) {\n          this.children(item.dataItem).subscribe(children => this.registerLookupItems(children, item));\n        }\n      });\n    }\n  }\n  _class20 = TreeViewComponent;\n  _defineProperty(TreeViewComponent, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(NodeChildrenService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DataChangeNotificationService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TreeViewComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class20,\n    selectors: [[\"kendo-treeview\"]],\n    contentQueries: function _class20_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplateQuery = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadMoreButtonTemplateQuery = _t.first);\n      }\n    },\n    viewQuery: function _class20_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c3, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c4, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbox = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class20_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.animate);\n        i0.ɵɵclassProp(\"k-treeview\", ctx.classNames);\n      }\n    },\n    inputs: {\n      filterInputPlaceholder: \"filterInputPlaceholder\",\n      expandDisabledNodes: \"expandDisabledNodes\",\n      animate: \"animate\",\n      nodeTemplateRef: [\"nodeTemplate\", \"nodeTemplateRef\"],\n      loadMoreButtonTemplateRef: [\"loadMoreButtonTemplate\", \"loadMoreButtonTemplateRef\"],\n      trackBy: \"trackBy\",\n      nodes: \"nodes\",\n      textField: \"textField\",\n      hasChildren: \"hasChildren\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      hasCheckbox: \"hasCheckbox\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\",\n      isVisible: \"isVisible\",\n      navigable: \"navigable\",\n      children: \"children\",\n      loadOnDemand: \"loadOnDemand\",\n      filterable: \"filterable\",\n      filter: \"filter\",\n      size: \"size\",\n      disableParentNodesOnly: \"disableParentNodesOnly\"\n    },\n    outputs: {\n      childrenLoaded: \"childrenLoaded\",\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      expand: \"expand\",\n      collapse: \"collapse\",\n      nodeDragStart: \"nodeDragStart\",\n      nodeDrag: \"nodeDrag\",\n      filterStateChange: \"filterStateChange\",\n      nodeDrop: \"nodeDrop\",\n      nodeDragEnd: \"nodeDragEnd\",\n      addItem: \"addItem\",\n      removeItem: \"removeItem\",\n      checkedChange: \"checkedChange\",\n      selectionChange: \"selectionChange\",\n      filterChange: \"filterChange\",\n      nodeClick: \"nodeClick\",\n      nodeDblClick: \"nodeDblClick\"\n    },\n    exportAs: [\"kendoTreeView\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature(providers), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 5,\n    vars: 24,\n    consts: function () {\n      let i18n_5;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Load More button\n         * @meaning kendo.treeview.loadMore\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_6 = goog.getMsg(\"Load more...\");\n        i18n_5 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_6;\n      } else {\n        i18n_5 = $localize`:kendo.treeview.loadMore|The title of the Load More button:Load more...`;\n      }\n      return [[\"kendoTreeViewLocalizedMessages\", \"\", \"loadMore\", i18n_5], [\"class\", \"k-treeview-filter\", 4, \"ngIf\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"tree\", 1, \"k-treeview-lines\", 3, \"size\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"hasCheckbox\", \"disableParentNodesOnly\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"textField\", \"nodes\", \"loadMoreService\", \"trackBy\", \"expandDisabledNodes\"], [\"assetsContainer\", \"\"], [1, \"k-treeview-filter\"], [3, \"size\", \"value\", \"clearButton\", \"placeholder\", \"valueChange\"], [\"searchbox\", \"\"], [\"kendoTextBoxPrefixTemplate\", \"\"], [\"innerCssClass\", \"k-input-icon\", \"name\", \"search\", 3, \"svgIcon\"]];\n    },\n    template: function _class20_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, _class20_span_1_Template, 4, 4, \"span\", 1);\n        i0.ɵɵelement(2, \"ul\", 2);\n        i0.ɵɵelementContainer(3, null, 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.filterable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"loadOnDemand\", ctx.loadOnDemand)(\"checkboxes\", ctx.checkboxes)(\"expandIcons\", ctx.expandIcons)(\"selectable\", ctx.selectable)(\"touchActions\", ctx.touchActions)(\"children\", ctx.children)(\"hasChildren\", ctx.hasChildren)(\"isChecked\", ctx.isChecked)(\"isDisabled\", ctx.isDisabled)(\"hasCheckbox\", ctx.hasCheckbox)(\"disableParentNodesOnly\", ctx.disableParentNodesOnly)(\"isExpanded\", ctx.isExpanded)(\"isSelected\", ctx.isSelected)(\"isVisible\", ctx.isVisible)(\"nodeTemplateRef\", ctx.nodeTemplateRef == null ? null : ctx.nodeTemplateRef.templateRef)(\"loadMoreButtonTemplateRef\", ctx.loadMoreButtonTemplateRef == null ? null : ctx.loadMoreButtonTemplateRef.templateRef)(\"textField\", ctx.textField)(\"nodes\", ctx.fetchNodes)(\"loadMoreService\", ctx.loadMoreService)(\"trackBy\", ctx.trackBy)(\"expandDisabledNodes\", ctx.expandDisabledNodes);\n        i0.ɵɵattribute(\"id\", ctx.treeviewId);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, TreeViewGroupComponent],\n    encapsulation: 2\n  }));\n  return TreeViewComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst indexChecked = (keys, index) => keys.filter(k => k === index).length > 0;\nconst matchKey = index => k => {\n  if (index === k) {\n    return true;\n  }\n  if (!k.split) {\n    return false;\n  }\n  return k.split('_').reduce(({\n    key,\n    result\n  }, part) => {\n    key += part;\n    if (index === key || result) {\n      return {\n        result: true\n      };\n    }\n    key += \"_\";\n    return {\n      key,\n      result: false\n    };\n  }, {\n    key: \"\",\n    result: false\n  }).result;\n};\n/**\n * A directive which manages the in-memory checked state of the TreeView node\n * ([see example]({% slug checkboxes_treeview %})).\n */\nlet CheckDirective = /*#__PURE__*/(() => {\n  var _class21;\n  class CheckDirective {\n    /**\n     * @hidden\n     */\n    set isChecked(value) {\n      this.treeView.isChecked = value;\n    }\n    /**\n     * Defines the item key that will be stored in the `checkedKeys` collection.\n     */\n\n    get options() {\n      const defaultOptions = {\n        checkChildren: true,\n        checkParents: true,\n        enabled: true,\n        mode: \"multiple\",\n        uncheckCollapsedChildren: false\n      };\n      if (!isPresent(this.checkable) || typeof this.checkable === 'string') {\n        return defaultOptions;\n      }\n      const checkSettings = isBoolean(this.checkable) ? {\n        enabled: this.checkable\n      } : this.checkable;\n      return Object.assign(defaultOptions, checkSettings);\n    }\n    constructor(treeView, zone) {\n      _defineProperty(this, \"treeView\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"checkKey\", void 0);\n      /**\n       * Defines the collection that will store the checked keys\n       * ([see example]({% slug checkboxes_treeview %})).\n       */\n      _defineProperty(this, \"checkedKeys\", void 0);\n      /**\n       * Defines the checkable settings ([see example]({% slug checkboxes_treeview %}#toc-setup)).\n       * If no value is provided, the default [`CheckableSettings`]({% slug api_treeview_checkablesettings %}) are applied.\n       */\n      _defineProperty(this, \"checkable\", void 0);\n      /**\n       * Fires when the `checkedKeys` collection was updated.\n       */\n      _defineProperty(this, \"checkedKeysChange\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"checkActions\", {\n        'multiple': e => this.checkMultiple(e),\n        'single': e => this.checkSingle(e)\n      });\n      /**\n       * Reflectes the internal `checkedKeys` state.\n       */\n      _defineProperty(this, \"state\", new Set());\n      _defineProperty(this, \"clickSubscription\", void 0);\n      /**\n       * Holds the last emitted `checkedKeys` collection.\n       */\n      _defineProperty(this, \"lastChange\", void 0);\n      this.treeView = treeView;\n      this.zone = zone;\n      this.subscriptions.add(this.treeView.checkedChange.subscribe(e => this.check(e)));\n      const expandedItems = [];\n      this.subscriptions.add(this.treeView.childrenLoaded.pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap(item => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1)))).subscribe(() => this.addCheckedItemsChildren(expandedItems)));\n      this.treeView.isChecked = this.isItemChecked.bind(this);\n    }\n    ngOnChanges(changes) {\n      if (changes.checkable) {\n        this.treeView.checkboxes = this.options.enabled;\n        this.toggleCheckOnClick();\n      }\n      if (isChanged('checkedKeys', changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {\n        this.state = new Set(changes.checkedKeys.currentValue);\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.unsubscribeClick();\n    }\n    isItemChecked(dataItem, index) {\n      if (!this.checkKey) {\n        return this.isIndexChecked(index);\n      }\n      const hasKey = this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n      return hasKey ? 'checked' : 'none';\n    }\n    isIndexChecked(index) {\n      const checkedKeys = Array.from(this.state).filter(matchKey(index));\n      if (indexChecked(checkedKeys, index)) {\n        return 'checked';\n      }\n      const {\n        mode,\n        checkParents\n      } = this.options;\n      if (mode === 'multiple' && checkParents && checkedKeys.length) {\n        return 'indeterminate';\n      }\n      return 'none';\n    }\n    itemKey(item) {\n      if (!isPresent(this.checkKey)) {\n        return item.index;\n      }\n      if (typeof this.checkKey === \"string\" && isPresent(item.dataItem)) {\n        return item.dataItem[this.checkKey];\n      }\n      if (typeof this.checkKey === \"function\") {\n        return this.checkKey(item);\n      }\n    }\n    check(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.checkActions[mode] || noop;\n      if (!enabled) {\n        return;\n      }\n      performSelection(e);\n    }\n    checkSingle(node) {\n      const key = this.itemKey(node.item);\n      const hasKey = this.state.has(key);\n      this.state.clear();\n      if (!hasKey) {\n        this.state.add(key);\n      }\n      this.notify();\n    }\n    checkMultiple(node) {\n      this.checkNode(node);\n      if (this.options.checkParents) {\n        this.checkParents(node.parent);\n      }\n      this.notify();\n    }\n    toggleCheckOnClick() {\n      this.unsubscribeClick();\n      if (this.options.checkOnClick) {\n        this.clickSubscription = this.treeView.nodeClick.subscribe(args => {\n          if (args.type === 'click') {\n            const lookup = this.treeView.itemLookup(args.item.index);\n            this.check(lookup);\n          }\n        });\n      }\n    }\n    unsubscribeClick() {\n      if (this.clickSubscription) {\n        this.clickSubscription.unsubscribe();\n        this.clickSubscription = null;\n      }\n    }\n    checkNode(node) {\n      if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index) || !this.treeView.hasCheckbox(node.item.dataItem, node.item.index)) {\n        return;\n      }\n      const currentKey = this.itemKey(node.item);\n      if (!isPresent(currentKey)) {\n        return;\n      }\n      const pendingCheck = [currentKey];\n      if (this.options.checkChildren) {\n        const descendants = fetchLoadedDescendants(node, ({\n          item\n        }) => this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren ? this.treeView.isVisible(item.dataItem, item.index) : this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(item.dataItem, item.index));\n        pendingCheck.push(...descendants.filter(item => this.options.checkDisabledChildren || !this.treeView.isDisabled(item.item.dataItem, item.item.index) || this.treeView.hasCheckbox(item.item.dataItem, item.item.index)).map(({\n          item\n        }) => this.itemKey(item)));\n      }\n      const shouldCheck = !this.state.has(currentKey);\n      pendingCheck.forEach(key => {\n        if (shouldCheck) {\n          this.state.add(key);\n        } else {\n          this.state.delete(key);\n          if (this.options.uncheckCollapsedChildren && this.options.mode === 'multiple' && this.treeView.loadOnDemand) {\n            if (this.checkKey && this.treeView.hasChildren(node.item.dataItem)) {\n              this.uncheckChildren(node.item.dataItem, node.item.index);\n              return;\n            }\n            const checkedKeys = Array.from(this.state).filter(matchKey(node.item.index));\n            checkedKeys.forEach(key => this.state.delete(key));\n          }\n        }\n      });\n    }\n    uncheckChildren(dataItem, parentNodeIndex) {\n      this.treeView.children(dataItem).subscribe(children => children.forEach((item, index) => {\n        const nodeIndex = `${parentNodeIndex}_${index}`;\n        this.state.delete(this.itemKey({\n          dataItem: item,\n          index: nodeIndex\n        }));\n        if (this.treeView.hasChildren(item)) {\n          this.uncheckChildren(item, nodeIndex);\n        }\n      }));\n    }\n    checkParents(parent) {\n      if (!isPresent(parent)) {\n        return;\n      }\n      let currentParent = parent;\n      while (currentParent) {\n        const parentKey = this.itemKey(currentParent.item);\n        const isDisabled = this.treeView.isDisabled(currentParent.item.dataItem, currentParent.item.index);\n        const allChildrenSelected = currentParent.children.every(item => this.state.has(this.itemKey(item)));\n        const hasCheckbox = this.treeView.hasCheckbox(currentParent.item.dataItem, currentParent.item.index);\n        if (hasCheckbox && (!isDisabled || this.options.checkDisabledChildren) && allChildrenSelected) {\n          this.state.add(parentKey);\n        } else {\n          this.state.delete(parentKey);\n        }\n        currentParent = currentParent.parent;\n      }\n    }\n    allChildrenSelected(children) {\n      return children.every(item => {\n        const childrenSel = this.allChildrenSelected(item.children);\n        return this.state.has(this.itemKey(item.item)) && childrenSel;\n      });\n    }\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.checkedKeysChange.emit(this.lastChange);\n    }\n    addCheckedItemsChildren(lookups) {\n      if (!isPresent(lookups) || lookups.length === 0) {\n        return;\n      }\n      const initiallyCheckedItemsCount = this.state.size;\n      const disabledItems = new Set();\n      lookups.forEach(lookup => {\n        const itemKey = this.itemKey(lookup.item);\n        if (!this.state.has(itemKey)) {\n          return;\n        }\n        lookup.children.forEach(item => {\n          // ensure both the parent item and each child node is enabled\n          if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(lookup.item.dataItem, lookup.item.index) && this.treeView.hasCheckbox(item.dataItem, item.index) || this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren) {\n            this.state.add(this.itemKey(item));\n          }\n          if (this.treeView.disableParentNodesOnly && !this.options.checkDisabledChildren && (this.treeView.isDisabled(item.dataItem, item.index) || !this.treeView.hasCheckbox(item.dataItem, item.index))) {\n            disabledItems.add(this.itemKey(item));\n          }\n        });\n      });\n      disabledItems.forEach(item => this.state.delete(item));\n      const hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;\n      if (hasNewlyCheckedItems) {\n        this.zone.run(() => this.notify());\n      }\n    }\n  }\n  _class21 = CheckDirective;\n  _defineProperty(CheckDirective, \"\\u0275fac\", function _class21_Factory(t) {\n    return new (t || _class21)(i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(CheckDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class21,\n    selectors: [[\"\", \"kendoTreeViewCheckable\", \"\"]],\n    inputs: {\n      isChecked: \"isChecked\",\n      checkKey: [\"checkBy\", \"checkKey\"],\n      checkedKeys: \"checkedKeys\",\n      checkable: [\"kendoTreeViewCheckable\", \"checkable\"]\n    },\n    outputs: {\n      checkedKeysChange: \"checkedKeysChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return CheckDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which manages the disabled in-memory state of the TreeView node\n * ([see example]({% slug disabledstate_treeview %})).\n */\nlet DisableDirective = /*#__PURE__*/(() => {\n  var _class22;\n  class DisableDirective {\n    /**\n     * @hidden\n     */\n    set isDisabled(value) {\n      this.treeView.isDisabled = value;\n    }\n    /**\n     * Defines the item key that will be stored in the `disabledKeys` collection.\n     */\n\n    constructor(treeView, cdr) {\n      _defineProperty(this, \"treeView\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"disableKey\", void 0);\n      /**\n       * Defines the collection that will store the disabled keys.\n       */\n      _defineProperty(this, \"disabledKeys\", []);\n      this.treeView = treeView;\n      this.cdr = cdr;\n      this.treeView.isDisabled = (dataItem, index) => this.disabledKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      })) > -1;\n    }\n    ngOnChanges(changes = {}) {\n      const {\n        disabledKeys\n      } = changes;\n      if (disabledKeys && !disabledKeys.firstChange) {\n        this.cdr.markForCheck();\n      }\n    }\n    itemKey(e) {\n      if (!this.disableKey) {\n        return e.index;\n      }\n      if (typeof this.disableKey === \"string\") {\n        return e.dataItem[this.disableKey];\n      }\n      if (typeof this.disableKey === \"function\") {\n        return this.disableKey(e);\n      }\n    }\n  }\n  _class22 = DisableDirective;\n  _defineProperty(DisableDirective, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DisableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class22,\n    selectors: [[\"\", \"kendoTreeViewDisable\", \"\"]],\n    inputs: {\n      isDisabled: \"isDisabled\",\n      disableKey: [\"kendoTreeViewDisable\", \"disableKey\"],\n      disabledKeys: \"disabledKeys\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return DisableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which enables the update of the initially provided data array during drag-and-drop.\n *\n * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})\n * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide\n * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the\n * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n * handlers when the corresponding events are triggered by the TreeView component.\n */\nlet DragAndDropEditingDirective = /*#__PURE__*/(() => {\n  var _class23;\n  class DragAndDropEditingDirective {\n    /**\n     * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)\n     * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.\n     */\n    set editService(service) {\n      this.treeview.editService = service;\n    }\n    constructor(treeview) {\n      _defineProperty(this, \"treeview\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.treeview = treeview;\n      this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));\n      this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    handleAdd(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n      this.treeview.editService.add(args);\n    }\n    handleRemove(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n      this.treeview.editService.remove(args);\n    }\n  }\n  _class23 = DragAndDropEditingDirective;\n  _defineProperty(DragAndDropEditingDirective, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(TreeViewComponent));\n  });\n  _defineProperty(DragAndDropEditingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class23,\n    selectors: [[\"\", \"kendoTreeViewDragAndDropEditing\", \"\"]],\n    inputs: {\n      editService: \"editService\"\n    },\n    standalone: true\n  }));\n  return DragAndDropEditingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Describes the attempted drop action during dragging.\n * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.\n * By default, this value defines the rendered icon in the drag clue.\n */\nvar DropAction = /*#__PURE__*/function (DropAction) {\n  DropAction[DropAction[\"Add\"] = 0] = \"Add\";\n  DropAction[DropAction[\"InsertTop\"] = 1] = \"InsertTop\";\n  DropAction[DropAction[\"InsertBottom\"] = 2] = \"InsertBottom\";\n  DropAction[DropAction[\"InsertMiddle\"] = 3] = \"InsertMiddle\";\n  DropAction[DropAction[\"Invalid\"] = 4] = \"Invalid\";\n  return DropAction;\n}(DropAction || {});\n/**\n * Describes where the dragged item is dropped relative to the drop target item.\n */\nvar DropPosition = /*#__PURE__*/function (DropPosition) {\n  DropPosition[DropPosition[\"Over\"] = 0] = \"Over\";\n  DropPosition[DropPosition[\"Before\"] = 1] = \"Before\";\n  DropPosition[DropPosition[\"After\"] = 2] = \"After\";\n  return DropPosition;\n}(DropPosition || {});\n/**\n * @hidden\n */\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"Up\"] = -1] = \"Up\";\n  ScrollDirection[ScrollDirection[\"Down\"] = 1] = \"Down\";\n  return ScrollDirection;\n}(ScrollDirection || {});\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.\n */\nclass TreeItemDropEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer, originalEvent) {\n    super();\n    /**\n     * A reference of the TreeView from which the dragged item originates.\n     */\n    _defineProperty(this, \"sourceTree\", void 0);\n    /**\n     * A reference of the TreeView onto which the dragged item is dropped.\n     */\n    _defineProperty(this, \"destinationTree\", void 0);\n    /**\n     * The look-up info for the dragged item.\n     */\n    _defineProperty(this, \"sourceItem\", void 0);\n    /**\n     * The look-up info for the item onto which the dragged item is dropped.\n     */\n    _defineProperty(this, \"destinationItem\", void 0);\n    /**\n     * Describes where the dragged item is dropped relative to the drop target item.\n     */\n    _defineProperty(this, \"dropPosition\", void 0);\n    /**\n     * The original pointer event holding details about the current pointer position.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    /**\n     * @hidden\n     */\n    _defineProperty(this, \"isValid\", true);\n    Object.assign(this, initializer);\n    this.originalEvent = originalEvent;\n  }\n  /**\n   * Specifies if the drop action should be marked as valid.\n   * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n   * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue\n   * will be animated back to the source item to indicate the action is marked as invalid.\n   */\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n}\n\n/**\n * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.\n */\nclass TreeItemDragStartEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer) {\n    super();\n    /**\n     * The look-up info for the dragged item.\n     */\n    _defineProperty(this, \"sourceItem\", void 0);\n    /**\n     * The original pointer event holding details about the current pointer position.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    Object.assign(this, initializer);\n  }\n}\n\n/**\n * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.\n */\nclass TreeItemDragEvent {\n  /** @hidden */\n  constructor() {\n    /**\n     * The look-up info for the dragged item.\n     */\n    _defineProperty(this, \"sourceItem\", void 0);\n    /**\n     * The look-up info for the item that the dragged node is placed over if there is such.\n     */\n    _defineProperty(this, \"destinationItem\", void 0);\n    /**\n     * The original pointer event holding details about the current pointer position.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n  }\n}\n\n/**\n * @hidden\n */\nlet DragClueComponent = /*#__PURE__*/(() => {\n  var _class28;\n  class DragClueComponent {\n    get statusIconClass() {\n      switch (this.action) {\n        case DropAction.Add:\n          return 'plus';\n        case DropAction.InsertTop:\n          return 'insert-top';\n        case DropAction.InsertBottom:\n          return 'insert-bottom';\n        case DropAction.InsertMiddle:\n          return 'insert-middle';\n        case DropAction.Invalid:\n        default:\n          return 'cancel';\n      }\n    }\n    get statusSVGIcon() {\n      switch (this.action) {\n        case DropAction.Add:\n          return plusIcon;\n        case DropAction.InsertTop:\n          return insertTopIcon;\n        case DropAction.InsertBottom:\n          return insertBottomIcon;\n        case DropAction.InsertMiddle:\n          return insertMiddleIcon;\n        case DropAction.Invalid:\n        default:\n          return cancelIcon;\n      }\n    }\n    constructor(cdr) {\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      /**\n       * The text value of the dragged TreeView item.\n       */\n      _defineProperty(this, \"text\", void 0);\n      /**\n       * The attempted operation according to the current drop target.\n       */\n      _defineProperty(this, \"action\", void 0);\n      /**\n       * The look-up info for the currently dragged item.\n       */\n      _defineProperty(this, \"sourceItem\", void 0);\n      /**\n       * The look-up info for the destination item (if hovering a valid drop target).\n       */\n      _defineProperty(this, \"destinationItem\", void 0);\n      /**\n       * Defines the drag clue content template.\n       */\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"posistionStyle\", 'fixed');\n      this.cdr = cdr;\n    }\n    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n  }\n  _class28 = DragClueComponent;\n  _defineProperty(DragClueComponent, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DragClueComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class28,\n    selectors: [[\"kendo-treeview-drag-clue\"]],\n    hostVars: 6,\n    hostBindings: function _class28_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"position\", ctx.posistionStyle);\n        i0.ɵɵclassProp(\"k-header\", ctx.hostClasses)(\"k-drag-clue\", ctx.hostClasses);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [\"innerCssClass\", \"k-drag-status\", 3, \"name\", \"svgIcon\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class28_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class28_ng_container_0_Template, 4, 3, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class28_1_Template, 1, 7, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return DragClueComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DragAndDropAssetService = /*#__PURE__*/(() => {\n  var _class29;\n  class DragAndDropAssetService {\n    constructor() {\n      _defineProperty(this, \"_componentRef\", void 0);\n    }\n    get componentRef() {\n      if (!isPresent(this._componentRef)) {\n        throw new Error('The `initalize` method must be called before calling other service methods.');\n      }\n      return this._componentRef;\n    }\n    set componentRef(componentRef) {\n      this._componentRef = componentRef;\n    }\n    get element() {\n      return this.componentRef.location.nativeElement;\n    }\n    ngOnDestroy() {\n      if (!isPresent(this._componentRef)) {\n        return;\n      }\n      this.element.parentElement.removeChild(this.element);\n      this.componentRef.destroy();\n      this.componentRef = null;\n    }\n    show() {\n      this.element.style.display = '';\n    }\n    hide() {\n      this.element.style.display = 'none';\n    }\n    move(left, top, offset = 0) {\n      this.element.style.left = `${left + offset}px`;\n      this.element.style.top = `${top + offset}px`;\n    }\n  }\n  _class29 = DragAndDropAssetService;\n  _defineProperty(DragAndDropAssetService, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)();\n  });\n  _defineProperty(DragAndDropAssetService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class29,\n    factory: _class29.ɵfac\n  }));\n  return DragAndDropAssetService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Checks if the browser supports relative stacking context.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n */\nconst hasRelativeStackingContext = memoize(() => {\n  if (!(isDocumentAvailable() && isPresent(document.body))) {\n    return false;\n  }\n  const top = 10;\n  const parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  const innerDiv = document.createElement('div');\n  innerDiv.innerText = 'child';\n  innerDiv.style.position = 'fixed';\n  innerDiv.style.top = `${top}px`;\n  parent.appendChild(innerDiv);\n  document.body.appendChild(parent);\n  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n});\n/**\n * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.\n */\nfunction memoize(fn) {\n  let result;\n  let called = false;\n  return (...args) => {\n    if (called) {\n      return result;\n    }\n    result = fn(...args);\n    called = true;\n    return result;\n  };\n}\n/**\n * @hidden\n *\n * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.\n * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;\n */\nconst getContainerOffset = element => {\n  if (!(element && hasRelativeStackingContext())) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n  let offsetParent = element.parentElement;\n  while (offsetParent) {\n    if (window.getComputedStyle(offsetParent).transform !== 'none') {\n      break;\n    }\n    offsetParent = offsetParent.parentElement;\n  }\n  if (offsetParent) {\n    const rect = offsetParent.getBoundingClientRect();\n    return {\n      left: rect.left - offsetParent.scrollLeft,\n      top: rect.top - offsetParent.scrollTop\n    };\n  }\n  return {\n    left: 0,\n    top: 0\n  };\n};\n/**\n * @hidden\n */\nconst getDropAction = (dropPosition, dropTarget) => {\n  if (!(isPresent(dropPosition) && isPresent(dropTarget))) {\n    return DropAction.Invalid;\n  }\n  switch (dropPosition) {\n    case DropPosition.Over:\n      return DropAction.Add;\n    case DropPosition.Before:\n      return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;\n    case DropPosition.After:\n      return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;\n    default:\n      return DropAction.Invalid;\n  }\n};\n/**\n * @hidden\n */\nconst getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {\n  if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {\n    return;\n  }\n  // the .k-treeview-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right\n  const item = closestWithMatch(target, '.k-treeview-top, .k-treeview-mid, .k-treeview-bot');\n  if (!isPresent(item)) {\n    return;\n  }\n  // the content element (.k-treeview-leaf:not(.k-treeview-load-more-button)) holds just the treeview item text\n  const content = getContentElement(item);\n  const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));\n  if (!isPresent(content) || content === draggedItem || targetChildOfDraggedItem) {\n    return;\n  }\n  const itemViewPortCoords = content.getBoundingClientRect();\n  /*\n      if the user is hovering a treeview item, split the item height into four parts:\n          - dropping into the top quarter should insert the dragged item before the drop target\n          - dropping into the bottom quarter should insert the dragged item after the drop target\n          - dropping into the second or third quarter should add the item as child node of the drop target\n       if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:\n          - dropping should insert before or after\n  */\n  const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);\n  // clear any possible container offset created by parent elements with `transform` css property set\n  const pointerPosition = clientY - containerOffset.top;\n  const itemTop = itemViewPortCoords.top - containerOffset.top;\n  if (pointerPosition < itemTop + itemDivisionHeight) {\n    return DropPosition.Before;\n  }\n  if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {\n    return DropPosition.After;\n  }\n  return DropPosition.Over;\n};\n/**\n * @hidden\n */\nconst treeItemFromEventTarget = (treeView, dropTarget) => {\n  if (!(isPresent(treeView) && isPresent(dropTarget))) {\n    return null;\n  }\n  const node = closestNode(dropTarget);\n  const index = nodeId(node);\n  const lookup = treeView.itemLookup(index);\n  if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {\n    return null;\n  }\n  return lookup;\n};\n/**\n * @hidden\n *\n * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.\n */\nconst collapseEmptyParent = (parent, parentNodes, treeview) => {\n  if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {\n    treeview.collapseNode(parent.item.dataItem, parent.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Expands the node if it's dropped into and it's not yet expanded.\n */\nconst expandDropTarget = (dropTarget, treeView) => {\n  if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {\n    treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Extracts the event target from the viewport coords. Required for touch devices\n * where the `event.target` of a `pointermove` event is always the initially dragged item.\n */\nconst getDropTarget = event => {\n  if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {\n    return event.target;\n  }\n  return document.elementFromPoint(event.clientX, event.clientY);\n};\n/**\n * @hidden\n *\n * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.\n */\nconst updateMovedItemIndex = (newIndex, originalIndex) => {\n  const movedItemNewIndexParts = newIndex.split('_');\n  const originalItemIndexParts = originalIndex.split('_');\n  // if the original item was moved from a deeper level, there's no need for index correction\n  // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved\n  if (movedItemNewIndexParts.length < originalItemIndexParts.length) {\n    return newIndex;\n  }\n  // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies\n  // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved\n  // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved\n  const originalItemParentPathLength = originalItemIndexParts.length - 1;\n  const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');\n  const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_');\n  // check if the the index of the level where the original item is taken from is greater than the one of the moved item\n  // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved\n  // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved\n  const originalItemIndexLevel = originalItemIndexParts.length - 1;\n  const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);\n  const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);\n  if (originalItemParentPath === movedItemParentPath && movedItemLevelIndex > originalItemLevelIndex) {\n    // if the removed item causes the dropped item to be moved a position up - decrement the index at that level\n    movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);\n    return movedItemNewIndexParts.join('_');\n  }\n  return newIndex;\n};\n/**\n * @hidden\n */\nconst SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');\n/**\n * @hidden\n *\n * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.\n */\nconst getScrollableContainer = node => {\n  while (isPresent(node) && node.nodeName !== 'HTML') {\n    const hasOverflow = node.scrollHeight > node.clientHeight;\n    const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);\n    if (hasOverflow && hasScrollbar) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return node;\n};\n/**\n * @hidden\n *\n * Checks if the top of the scrollable element is reached.\n * Floors the scrollTop value.\n */\nconst isTopReached = element => Math.floor(element.scrollTop) <= 0;\n/**\n * @hidden\n *\n * Checks if the bottom of the scrollable element is reached.\n * Ceils the scrollTop value.\n */\nconst isBottomReached = element => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;\n/**\n * @hidden\n *\n * Scrolls the element in the given direction by the provided step.\n *\n * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),\n * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.\n *\n * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.\n */\nconst scrollElementBy = (element, step, direction) => {\n  if (!(isPresent(element) && isDocumentAvailable())) {\n    return;\n  }\n  const initialScrollTop = element.scrollTop;\n  let currentStep = step;\n  let iterations = 0;\n  while (initialScrollTop === element.scrollTop && !(direction === ScrollDirection.Up && isTopReached(element)) && !(direction === ScrollDirection.Down && isBottomReached(element)) && iterations < 20 // as the bulgarian saying goes - to ties our underpants\n  ) {\n    element.scrollTop += currentStep * direction;\n    currentStep += 1;\n    iterations += 1;\n  }\n};\n\n/**\n * @hidden\n */\nconst CLUE_OFFSET = 10;\n/**\n * @hidden\n */\nconst RETURN_ANIMATION_DURATION = 200;\n/**\n * @hidden\n */\nlet DragClueService = /*#__PURE__*/(() => {\n  var _class30;\n  class DragClueService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      _defineProperty(this, \"componentFactoryResolver\", void 0);\n      _defineProperty(this, \"returnAnimation\", void 0);\n      _defineProperty(this, \"scrollInterval\", void 0);\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n      const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);\n      this.componentRef = container.createComponent(clueComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n    ngOnDestroy() {\n      this.cancelReturnAnimation();\n      this.cancelScroll();\n      super.ngOnDestroy();\n    }\n    move(left, top) {\n      super.move(left, top, CLUE_OFFSET);\n    }\n    animateDragClueToElementPosition(target) {\n      if (!(isPresent(target) && isPresent(this.element.animate))) {\n        this.hide();\n        return;\n      }\n      const targetElementViewPortCoords = target.getBoundingClientRect();\n      const clueElementViewPortCoords = this.element.getBoundingClientRect();\n      this.returnAnimation = this.element.animate([{\n        transform: 'translate(0, 0)'\n      }, {\n        transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)`\n      }], RETURN_ANIMATION_DURATION);\n      this.returnAnimation.onfinish = () => this.hide();\n    }\n    cancelReturnAnimation() {\n      if (!isPresent(this.returnAnimation)) {\n        return;\n      }\n      this.returnAnimation.cancel();\n      this.returnAnimation = null;\n    }\n    updateDragClueData(action, sourceItem, destinationItem) {\n      const dragClue = this.componentRef.instance;\n      if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {\n        return;\n      }\n      dragClue.action = action;\n      dragClue.sourceItem = sourceItem;\n      dragClue.destinationItem = destinationItem;\n      dragClue.detectChanges();\n    }\n    updateText(text) {\n      if (text === this.componentRef.instance.text) {\n        return;\n      }\n      this.componentRef.instance.text = text;\n      this.componentRef.instance.detectChanges();\n    }\n    /**\n     * Triggers the first scrollable parent to scroll upwards or downwards.\n     * Uses setInterval, so should be called outside the angular zone.\n     */\n    scrollIntoView({\n      step,\n      interval\n    }) {\n      this.cancelScroll();\n      const scrollableContainer = getScrollableContainer(this.element);\n      if (!isPresent(scrollableContainer)) {\n        return;\n      }\n      const containerRect = scrollableContainer.getBoundingClientRect();\n      const clueRect = this.element.getBoundingClientRect();\n      // if the beginning of the scrollable container is above the current viewport, fall-back to 0\n      const firstVisibleClientTopPart = Math.max(containerRect.top, 0);\n      // start scrolling up when the first visible item is dragged over\n      const topLimit = firstVisibleClientTopPart + clueRect.height;\n      // if the end of the scrollable container is beneath the current viewport, fall-back to its client height\n      // add the distance from the start of the viewport to the beginning of the container to ensure scrolling bottom begins when the actual end of the container is reached\n      const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);\n      if (clueRect.top < topLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval);\n      } else if (clueRect.bottom > bottomLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval);\n      }\n    }\n    /**\n     * Cancels out the on-going scroll animation, if present.\n     */\n    cancelScroll() {\n      if (isPresent(this.scrollInterval)) {\n        clearInterval(this.scrollInterval);\n        this.scrollInterval = null;\n      }\n    }\n  }\n  _class30 = DragClueService;\n  _defineProperty(DragClueService, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)(i0.ɵɵinject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(DragClueService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class30,\n    factory: _class30.ɵfac\n  }));\n  return DragClueService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DropHintComponent = /*#__PURE__*/(() => {\n  var _class31;\n  class DropHintComponent {\n    constructor(changeDetectorRef) {\n      _defineProperty(this, \"changeDetectorRef\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * Defines the drag hint content template.\n       */\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"position\", 'fixed');\n      _defineProperty(this, \"pointerEvents\", 'none');\n      /**\n       * The attempted operation according to the current drop target.\n       */\n      _defineProperty(this, \"action\", void 0);\n      /**\n       * The look-up info for the currently dragged item.\n       */\n      _defineProperty(this, \"sourceItem\", void 0);\n      /**\n       * The look-up info for the destination item.\n       */\n      _defineProperty(this, \"destinationItem\", void 0);\n      this.changeDetectorRef = changeDetectorRef;\n    }\n    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n    detectChanges() {\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n  _class31 = DropHintComponent;\n  _defineProperty(DropHintComponent, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DropHintComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class31,\n    selectors: [[\"kendo-treeview-drop-hint\"]],\n    hostVars: 6,\n    hostBindings: function _class31_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"position\", ctx.position)(\"pointer-events\", ctx.pointerEvents);\n        i0.ɵɵclassProp(\"k-drop-hint-container\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"k-drop-hint k-drop-hint-h\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-drop-hint\", \"k-drop-hint-h\"], [1, \"k-drop-hint-start\"], [1, \"k-drop-hint-line\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class31_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class31_div_0_Template, 3, 0, \"div\", 0);\n        i0.ɵɵtemplate(1, _class31_1_Template, 1, 6, null, 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return DropHintComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DropHintService = /*#__PURE__*/(() => {\n  var _class32;\n  class DropHintService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      _defineProperty(this, \"componentFactoryResolver\", void 0);\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n      const hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);\n      this.componentRef = container.createComponent(hintComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n    updateDropHintData(action, sourceItem, destinationItem) {\n      const dropHint = this.componentRef.instance;\n      if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {\n        return;\n      }\n      dropHint.action = action;\n      dropHint.sourceItem = sourceItem;\n      dropHint.destinationItem = destinationItem;\n      dropHint.detectChanges();\n    }\n  }\n  _class32 = DropHintService;\n  _defineProperty(DropHintService, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)(i0.ɵɵinject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(DropHintService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class32,\n    factory: _class32.ɵfac\n  }));\n  return DropHintService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,\n * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n *\n *\n * The text, attempted drop action, source item and destination item are available as context variables in the template:\n *\n *\n * - `let-text=\"text\"` (`string`)\n * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n */\nlet DragClueTemplateDirective = /*#__PURE__*/(() => {\n  var _class33;\n  class DragClueTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class33 = DragClueTemplateDirective;\n  _defineProperty(DragClueTemplateDirective, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DragClueTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class33,\n    selectors: [[\"\", \"kendoTreeViewDragClueTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DragClueTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,\n * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n *\n * The attempted drop action, source item and destination item are available as context variables in the template:\n *\n * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n */\nlet DropHintTemplateDirective = /*#__PURE__*/(() => {\n  var _class34;\n  class DropHintTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class34 = DropHintTemplateDirective;\n  _defineProperty(DropHintTemplateDirective, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DropHintTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class34,\n    selectors: [[\"\", \"kendoTreeViewDropHintTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DropHintTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SCROLL_SETTINGS = {\n  enabled: true,\n  step: 1,\n  interval: 1\n};\n/**\n * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances\n * ([see example]({% slug draganddrop_treeview %})).\n *\n * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),\n * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),\n * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),\n * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n * events when the corresponding actions occur on the respective TreeView instance.\n */\nlet DragAndDropDirective = /*#__PURE__*/(() => {\n  var _class35;\n  class DragAndDropDirective {\n    get scrollSettings() {\n      const userProvidedSettings = typeof this.autoScroll === 'boolean' ? {\n        enabled: this.autoScroll\n      } : this.autoScroll;\n      return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);\n    }\n    /**\n     * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.\n     * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n     */\n\n    constructor(element, zone, treeview, dragClueService, dropHintService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"treeview\", void 0);\n      _defineProperty(this, \"dragClueService\", void 0);\n      _defineProperty(this, \"dropHintService\", void 0);\n      /**\n       * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.\n       * If enabled, the `removeItem` event will not be fired on the source TreeView\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"allowCopy\", false);\n      /**\n       * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       */\n      _defineProperty(this, \"dropZoneTreeViews\", []);\n      /**\n       * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.\n       * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.\n       *\n       * @default 5\n       */\n      _defineProperty(this, \"startDragAfter\", 5);\n      /**\n       * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).\n       * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.\n       *\n       * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.\n       * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"autoScroll\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dragClueTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dropHintTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"userSelectStyle\", 'none');\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"draggedItem\", void 0);\n      /**\n       * The pointer event of the last successful item pointerdown event (the draggable `press` event).\n       * Used for determining whether the `startDragAfter` distance is covered and for the `nodeDragStart` event args.\n       * Used also as a flag for whether a drag attempt is pending. Should be set to `null` once the dragging begins.\n       */\n      _defineProperty(this, \"pendingDragStartEvent\", void 0);\n      _defineProperty(this, \"containerOffset\", {\n        top: 0,\n        left: 0\n      });\n      this.element = element;\n      this.zone = zone;\n      this.treeview = treeview;\n      this.dragClueService = dragClueService;\n      this.dropHintService = dropHintService;\n      this.treeview.touchActions = false;\n    }\n    ngAfterContentInit() {\n      this.initalizeDraggable();\n      this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);\n      this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);\n    }\n    ngOnDestroy() {\n      this.draggable.destroy();\n    }\n    /**\n     * @hidden\n     */\n    handlePress({\n      originalEvent\n    }) {\n      if (!isContent(originalEvent.target)) {\n        return;\n      }\n      // store the drag target on press, show it only when it's actually dragged\n      this.draggedItem = closestWithMatch(originalEvent.target, '.k-treeview-leaf');\n      // record the current pointer down coords - copared to the `startDragAfter` value to calculate whether to initiate dragging\n      this.pendingDragStartEvent = originalEvent;\n    }\n    /**\n     * @hidden\n     */\n    handleDrag({\n      originalEvent,\n      clientX,\n      clientY\n    }) {\n      if (this.shouldInitiateDragStart({\n        clientX,\n        clientY\n      })) {\n        this.initiateDragStart();\n      }\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        return;\n      }\n      const dropTarget = getDropTarget(originalEvent);\n      if (hasObservers(this.treeview.nodeDrag)) {\n        this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));\n      }\n      const targetTreeView = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);\n      const dropHintAnchor = closestWithMatch(dropTarget, '.k-treeview-top, .k-treeview-mid, .k-treeview-bot');\n      const dropAction = getDropAction(dropPosition, dropTarget);\n      const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);\n      this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);\n      this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.scrollIntoView(this.scrollSettings);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleRelease({\n      originalEvent,\n      clientY\n    }) {\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.cancelScroll();\n      }\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        this.pendingDragStartEvent = null;\n        this.draggedItem = null;\n        return;\n      }\n      const dropTarget = getDropTarget(originalEvent);\n      const sourceTree = this.treeview;\n      const destinationTree = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);\n      const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);\n      if (isPresent(destinationItem) && isPresent(dropPosition)) {\n        this.zone.run(() => this.notifyDrop({\n          sourceItem,\n          destinationItem,\n          dropPosition,\n          sourceTree,\n          destinationTree\n        }, originalEvent));\n      } else {\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n      if (hasObservers(this.treeview.nodeDragEnd)) {\n        this.zone.run(() => this.notifyDragEnd({\n          sourceItem,\n          destinationItem,\n          originalEvent\n        }));\n      }\n      this.dropHintService.hide();\n      this.draggedItem = null;\n    }\n    updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {\n      if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {\n        this.dropHintService.hide();\n        return;\n      }\n      const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();\n      const insertBefore = dropPosition === DropPosition.Before;\n      const top = insertBefore ? anchorViewPortCoords.top : anchorViewPortCoords.top + anchorViewPortCoords.height;\n      this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem);\n      // clear any possible container offset created by parent elements with `transform` css property set\n      this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);\n      this.dropHintService.show();\n    }\n    updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {\n      // clear any possible container offset created by parent elements with `transform` css property set\n      this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);\n      this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);\n      this.dragClueService.show();\n    }\n    initalizeDraggable() {\n      this.draggable = new Draggable({\n        press: this.handlePress.bind(this),\n        drag: this.handleDrag.bind(this),\n        release: this.handleRelease.bind(this)\n      });\n      this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n    }\n    notifyDragStart(originalEvent, dropTarget) {\n      const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);\n      const event = new TreeItemDragStartEvent({\n        sourceItem,\n        originalEvent\n      });\n      this.treeview.nodeDragStart.emit(event);\n      return event;\n    }\n    notifyDrag(originalEvent, dropTarget) {\n      const dragEvent = {\n        sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),\n        destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),\n        originalEvent\n      };\n      this.treeview.nodeDrag.emit(dragEvent);\n    }\n    notifyDrop(args, originalEvent) {\n      const event = new TreeItemDropEvent(args, originalEvent);\n      args.destinationTree.nodeDrop.emit(event);\n      // disable the animations on drop and restore them afterwards (if they were initially turned on)\n      this.disableAnimationsForNextTick(args.destinationTree);\n      if (args.sourceTree !== args.destinationTree) {\n        this.disableAnimationsForNextTick(args.sourceTree);\n      }\n      if (!event.isDefaultPrevented() && event.isValid) {\n        this.dragClueService.hide();\n        // order matters in a flat data binding scenario (first add, then remove)\n        args.destinationTree.addItem.emit(args);\n        if (!(originalEvent.ctrlKey && this.allowCopy)) {\n          args.sourceTree.removeItem.emit(args);\n        }\n      } else if (event.isDefaultPrevented()) {\n        // directly hide the clue if the default is prevented\n        this.dragClueService.hide();\n      } else if (!event.isValid) {\n        // animate the clue back to the source item position if marked as invalid\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n    }\n    notifyDragEnd(dragEndEvent) {\n      this.treeview.nodeDragEnd.emit(dragEndEvent);\n    }\n    getTargetTreeView(dropTarget) {\n      const treeViewTagName = this.treeview.element.nativeElement.tagName;\n      const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);\n      return [this.treeview, ...this.dropZoneTreeViews].find(treeView => isPresent(treeView) && treeView.element.nativeElement === targetTreeView);\n    }\n    disableAnimationsForNextTick(treeView) {\n      // the treeView.animate getter returns `true` when the animations are turned off\n      // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)\n      if (treeView.animate) {\n        return;\n      }\n      treeView.animate = false;\n      this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));\n    }\n    shouldInitiateDragStart(currentPointerCoords) {\n      if (!isPresent(this.pendingDragStartEvent)) {\n        return false;\n      }\n      const distanceFromPointerDown = Math.sqrt(Math.pow(this.pendingDragStartEvent.clientX - currentPointerCoords.clientX, 2) + Math.pow(this.pendingDragStartEvent.clientY - currentPointerCoords.clientY, 2));\n      return distanceFromPointerDown >= this.startDragAfter;\n    }\n    initiateDragStart() {\n      if (hasObservers(this.treeview.nodeDragStart)) {\n        const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));\n        if (dragStartEvent.isDefaultPrevented()) {\n          this.pendingDragStartEvent = null;\n          this.draggedItem = null;\n          return;\n        }\n      }\n      this.dragClueService.cancelReturnAnimation();\n      this.dragClueService.updateText(this.draggedItem.innerText);\n      this.containerOffset = getContainerOffset(this.draggedItem);\n      this.pendingDragStartEvent = null;\n    }\n  }\n  _class35 = DragAndDropDirective;\n  _defineProperty(DragAndDropDirective, \"\\u0275fac\", function _class35_Factory(t) {\n    return new (t || _class35)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(DragClueService), i0.ɵɵdirectiveInject(DropHintService));\n  });\n  _defineProperty(DragAndDropDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class35,\n    selectors: [[\"\", \"kendoTreeViewDragAndDrop\", \"\"]],\n    contentQueries: function _class35_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function _class35_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"user-select\", ctx.userSelectStyle)(\"-ms-user-select\", ctx.userSelectStyle)(\"-moz-user-select\", ctx.userSelectStyle)(\"-webkit-user-select\", ctx.userSelectStyle);\n      }\n    },\n    inputs: {\n      allowCopy: \"allowCopy\",\n      dropZoneTreeViews: \"dropZoneTreeViews\",\n      startDragAfter: \"startDragAfter\",\n      autoScroll: \"autoScroll\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DragClueService, DropHintService])]\n  }));\n  return DragAndDropDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_FILTER_EXPAND_SETTINGS = {\n  maxAutoExpandResults: -1,\n  expandMatches: false,\n  expandedOnClear: \"none\"\n};\n/**\n * A directive which manages the expanded state of the TreeView.\n * ([see example]({% slug expandedstate_treeview %})).\n */\nlet ExpandDirective = /*#__PURE__*/(() => {\n  var _class36;\n  class ExpandDirective {\n    /**\n     * @hidden\n     */\n    set isExpanded(value) {\n      this.component.isExpanded = value;\n    }\n    /**\n     * Defines the item key that will be stored in the `expandedKeys` collection.\n     */\n\n    get filterExpandSettings() {\n      const settings = isBoolean(this.expandOnFilter) ? {\n        enabled: this.expandOnFilter\n      } : {\n        ...this.expandOnFilter,\n        enabled: true\n      };\n      return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);\n    }\n    /**\n     * Fires when the `expandedKeys` collection was updated.\n     */\n\n    constructor(component) {\n      _defineProperty(this, \"component\", void 0);\n      _defineProperty(this, \"expandKey\", void 0);\n      /**\n       * Whether or not to auto-expand the nodes leading from the root node to each filter result.\n       * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.\n       * @default false\n       */\n      _defineProperty(this, \"expandOnFilter\", false);\n      _defineProperty(this, \"expandedKeysChange\", new EventEmitter());\n      /**\n       * Defines the collection that will store the expanded keys.\n       */\n      _defineProperty(this, \"expandedKeys\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      /**\n       * Reflectes the internal `expandedKeys` state.\n       */\n      _defineProperty(this, \"state\", new Set());\n      _defineProperty(this, \"originalExpandedKeys\", new Set());\n      _defineProperty(this, \"isFiltered\", false);\n      /**\n       * Holds the last emitted `expandedKeys` collection.\n       */\n      _defineProperty(this, \"lastChange\", void 0);\n      /**\n       * Fills array with the correct expand keys according to wrapper metadata.\n       */\n      _defineProperty(this, \"updateExpandedNodes\", (collection, node, autoExpandMatches) => {\n        if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.updateExpandedNodes(collection, child, autoExpandMatches);\n          });\n        }\n      });\n      /**\n       * Fills array with the expand key of every node.\n       */\n      _defineProperty(this, \"getEveryExpandKey\", (collection, node) => {\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.getEveryExpandKey(collection, child);\n          });\n        }\n      });\n      this.component = component;\n      this.subscriptions.add(merge(this.component.expand.pipe(map(e => ({\n        expand: true,\n        ...e\n      }))), this.component.collapse.pipe(map(e => ({\n        expand: false,\n        ...e\n      })))).subscribe(this.toggleExpand.bind(this)));\n      if (this.component.filterStateChange) {\n        this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));\n      }\n      this.component.isExpanded = (dataItem, index) => this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n    }\n    ngOnChanges(changes) {\n      if (isChanged('expandedKeys', changes, false) && changes['expandedKeys'].currentValue !== this.lastChange) {\n        this.state = new Set(changes['expandedKeys'].currentValue);\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    itemKey(e) {\n      if (this.expandKey) {\n        if (typeof this.expandKey === \"string\") {\n          return e.dataItem[this.expandKey];\n        }\n        if (typeof this.expandKey === \"function\") {\n          return this.expandKey(e);\n        }\n      }\n      return e.index;\n    }\n    toggleExpand({\n      index,\n      dataItem,\n      expand\n    }) {\n      const key = this.itemKey({\n        index,\n        dataItem\n      });\n      const isExpanded = this.state.has(key);\n      let notify = false;\n      if (isExpanded && !expand) {\n        this.state.delete(key);\n        notify = true;\n      } else if (!isExpanded && expand) {\n        this.state.add(key);\n        notify = true;\n      }\n      if (notify) {\n        this.notify();\n      }\n    }\n    handleAutoExpand({\n      nodes,\n      matchCount,\n      term\n    }) {\n      if (!this.filterExpandSettings.enabled) {\n        return;\n      }\n      const {\n        maxAutoExpandResults,\n        expandMatches: autoExpandMatches,\n        expandedOnClear\n      } = this.filterExpandSettings;\n      if (!this.isFiltered) {\n        this.originalExpandedKeys = new Set(this.state);\n      }\n      const exitingFilteredState = this.isFiltered && !term;\n      const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;\n      const exitAutoExpandedState = exitingFilteredState || maxExceeded;\n      if (exitAutoExpandedState) {\n        switch (expandedOnClear) {\n          case \"initial\":\n            {\n              if (!sameValues(this.state, this.originalExpandedKeys)) {\n                this.state = this.originalExpandedKeys;\n                this.notify();\n              }\n              break;\n            }\n          case \"all\":\n            {\n              this.state = new Set(nodes.reduce((acc, rootNode) => {\n                this.getEveryExpandKey(acc, rootNode);\n                return acc;\n              }, []));\n              this.notify();\n              break;\n            }\n          case \"unchanged\":\n            {\n              break;\n            }\n          case \"none\":\n          default:\n            {\n              if (this.state.size !== 0) {\n                this.state.clear();\n                this.notify();\n              }\n              break;\n            }\n        }\n        this.isFiltered = false;\n        return;\n      }\n      const indicesToExpand = new Set(nodes.reduce((acc, rootNode) => {\n        this.updateExpandedNodes(acc, rootNode, autoExpandMatches);\n        return acc;\n      }, []));\n      if (!sameValues(this.state, indicesToExpand)) {\n        this.state = indicesToExpand;\n        this.notify();\n      }\n      this.isFiltered = true;\n    }\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.expandedKeysChange.emit(this.lastChange);\n    }\n  }\n  _class36 = ExpandDirective;\n  _defineProperty(ExpandDirective, \"\\u0275fac\", function _class36_Factory(t) {\n    return new (t || _class36)(i0.ɵɵdirectiveInject(ExpandableComponent));\n  });\n  _defineProperty(ExpandDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class36,\n    selectors: [[\"\", \"kendoTreeViewExpandable\", \"\"]],\n    inputs: {\n      isExpanded: \"isExpanded\",\n      expandKey: [\"expandBy\", \"expandKey\"],\n      expandOnFilter: \"expandOnFilter\",\n      expandedKeys: \"expandedKeys\"\n    },\n    outputs: {\n      expandedKeysChange: \"expandedKeysChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return ExpandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n * Performs the right-to-left function composition. Functions must have a unary.\n */\nconst compose = (...args) => data => args.reduceRight((acc, curr) => curr(acc), data);\n\n/**\n * @hidden\n */\nconst copyPageSize = (treeview, source, target) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n  const sourceGroupSize = treeview.getNodePageSize(source);\n  treeview.setNodePageSize(target, sourceGroupSize);\n};\n/**\n * @hidden\n */\nconst incrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize + 1);\n};\n/**\n * @hidden\n */\nconst decrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize - 1);\n};\n\n/**\n * @hidden\n */\nclass FlatEditingService {\n  constructor(flatBinding) {\n    _defineProperty(this, \"flatBinding\", void 0);\n    _defineProperty(this, \"movedItemNewIndex\", void 0);\n    this.flatBinding = flatBinding;\n  }\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);\n      const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));\n      // insert after the last visible child\n      const targetIndex = lastChildNodeIndex + 1;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);\n      // rebind the treeview data before searching for the focus target index\n      this.rebindData();\n      const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);\n    } else {\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);\n      const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);\n      // rebind the treeview data before searching for the focus target index\n      this.rebindData();\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      const parentContainer = destinationItem.parent ? this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) : destinationTree.nodes;\n      const focusTarget = parentContainer.indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);\n    }\n    if (sourceTree !== destinationTree) {\n      this.addChildNodes(clonedSourceDataItem, sourceTree);\n    }\n    // increment the parent page size => an item is moved into it\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent);\n    // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);\n    // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    }\n    // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceDataItem = getDataItem(sourceItem);\n    const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);\n    this.flatBinding.originalData.splice(sourceItemIndex, 1);\n    if (sourceTree !== destinationTree) {\n      this.removeChildNodes(sourceDataItem, sourceTree);\n    }\n    this.rebindData();\n    // emit collapse for the parent node if its last child node was spliced\n    const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];\n    collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);\n    // decrement source item parent page size => an item has been removed from it\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));\n    // reload the treeview nodes\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    }\n    // if the source and destination trees are different we want to focus only the moved item in the destination tree\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      // after the source item is removed from its original position, the candidate index might have to be corrected\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n  addChildNodes(dataItem, source) {\n    const itemChildren = this.fetchAllDescendantNodes(dataItem, source);\n    this.flatBinding.originalData.push(...itemChildren);\n  }\n  removeChildNodes(dataItem, source) {\n    const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);\n    sourceChildren.forEach(item => {\n      const index = this.flatBinding.originalData.indexOf(item);\n      this.flatBinding.originalData.splice(index, 1);\n    });\n  }\n  fetchAllDescendantNodes(node, treeview) {\n    let nodes = this.fetchChildNodes(node, treeview);\n    nodes.forEach(node => nodes = nodes.concat(this.fetchAllDescendantNodes(node, treeview) || []));\n    return nodes;\n  }\n  fetchChildNodes(node, treeview) {\n    if (!node) {\n      return [];\n    }\n    let nodes = [];\n    treeview.children(node).pipe(take(1)).subscribe(children => nodes = nodes.concat(children || []));\n    return nodes;\n  }\n  getLastVisibleChildNodeIndex(treeview, data, node) {\n    if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {\n      return data.length;\n    }\n    const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);\n    const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);\n    const lastNode = visibleChildren[visibleChildren.length - 1];\n    const lastNodeIndex = data.indexOf(lastNode);\n    return lastNodeIndex;\n  }\n  rebindData() {\n    this.flatBinding.nodes = this.flatBinding.originalData;\n    this.flatBinding.updateNodes(this.flatBinding.originalData);\n  }\n}\n\n/**\n * @hidden\n */\nconst DEFAULT_FILTER_SETTINGS = {\n  operator: 'contains',\n  ignoreCase: true,\n  mode: \"lenient\"\n};\n\n/**\n * @hidden\n */\nlet FilteringBase = /*#__PURE__*/(() => {\n  var _class38;\n  class FilteringBase {\n    /**\n     * The settings which are applied when performing a filter on the component's data.\n     */\n    set filterSettings(settings) {\n      this._filterSettings = {\n        ...DEFAULT_FILTER_SETTINGS,\n        ...settings\n      };\n    }\n    get filterSettings() {\n      return this._filterSettings;\n    }\n    /**\n     * Applies a filter and changes the visibility of the component's nodes accordingly.\n     */\n    set filter(term) {\n      this.handleFilterChange(term);\n    }\n    constructor(component) {\n      _defineProperty(this, \"component\", void 0);\n      /**\n       * Stores the unfiltered nodes\n       */\n      _defineProperty(this, \"filterData\", void 0);\n      _defineProperty(this, \"visibleNodes\", new Set());\n      _defineProperty(this, \"_filterSettings\", DEFAULT_FILTER_SETTINGS);\n      this.component = component;\n    }\n    /**\n     * @hidden\n     */\n    handleFilterChange(term) {\n      if (!this.filterData) {\n        return;\n      }\n      this.resetNodesVisibility(this.filterData);\n      if (term) {\n        filterTree(this.filterData, term, this.filterSettings, this.component.textField);\n      }\n      this.updateVisibleNodes(this.filterData);\n      if (isPresent(this.component.filterStateChange)) {\n        this.component.filterStateChange.emit({\n          nodes: this.filterData,\n          matchCount: this.visibleNodes.size,\n          term,\n          filterSettings: this.filterSettings\n        });\n      }\n    }\n    updateVisibleNodes(items) {\n      items.forEach(wrapper => {\n        if (wrapper.visible) {\n          this.visibleNodes.add(wrapper.dataItem);\n        }\n        if (wrapper.children) {\n          this.updateVisibleNodes(wrapper.children);\n        }\n      });\n    }\n    resetNodesVisibility(items) {\n      this.visibleNodes.clear();\n      items.forEach(wrapper => {\n        wrapper.visible = true;\n        if (wrapper.children) {\n          this.resetNodesVisibility(wrapper.children);\n        }\n      });\n    }\n  }\n  _class38 = FilteringBase;\n  _defineProperty(FilteringBase, \"\\u0275fac\", function _class38_Factory(t) {\n    return new (t || _class38)(i0.ɵɵdirectiveInject(DataBoundComponent));\n  });\n  _defineProperty(FilteringBase, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class38,\n    inputs: {\n      filterSettings: \"filterSettings\",\n      filter: \"filter\"\n    }\n  }));\n  return FilteringBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst findChildren = (prop, nodes, value) => nodes.filter(x => prop(x) === value);\nconst indexBuilder$1 = new IndexBuilderService();\nconst mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of the child nodes.\n */\nlet FlatDataBindingDirective = /*#__PURE__*/(() => {\n  var _class39;\n  class FlatDataBindingDirective extends FilteringBase {\n    /**\n     * The nodes which will be displayed by the TreeView.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it can be accessed via `super` call (typescript v5)\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(component) {\n      super(component);\n      _defineProperty(this, \"component\", void 0);\n      _defineProperty(this, \"_nodes\", void 0);\n      /**\n       * Represents the parent field whose value will be matched with the parent node.\n       */\n      _defineProperty(this, \"parentIdField\", void 0);\n      /**\n       * Represents the unique field which identifies a node.\n       */\n      _defineProperty(this, \"idField\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"loadOnDemand\", true);\n      _defineProperty(this, \"originalData\", []);\n      this.component = component;\n      this.component.isVisible = node => this.visibleNodes.has(node);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      if (isPresent(this.parentIdField) && isPresent(this.idField)) {\n        const fetchChildren = node => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));\n        this.component.hasChildren = node => fetchChildren(node).length > 0;\n        this.component.children = node => of(fetchChildren(node));\n        this.component.editService = new FlatEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (isChanged('parentIdField', changes, false)) {\n        this.nodes = this.originalData;\n        this.updateNodes(this.originalData);\n      }\n      if (isChanged('nodes', changes, false)) {\n        this.updateNodes(changes['nodes'].currentValue);\n      }\n      // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n    updateNodes(values) {\n      this.originalData = values || [];\n      if (!isNullOrEmptyString(this.parentIdField)) {\n        const prop = getter(this.parentIdField);\n        this.component.nodes = this.originalData.filter(compose(isBlank, prop));\n        this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);\n        this.updateVisibleNodes(this.filterData);\n      } else {\n        this.component.nodes = this.originalData.slice(0);\n      }\n    }\n  }\n  _class39 = FlatDataBindingDirective;\n  _defineProperty(FlatDataBindingDirective, \"\\u0275fac\", function _class39_Factory(t) {\n    return new (t || _class39)(i0.ɵɵdirectiveInject(DataBoundComponent));\n  });\n  _defineProperty(FlatDataBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class39,\n    selectors: [[\"\", \"kendoTreeViewFlatDataBinding\", \"\"]],\n    inputs: {\n      nodes: \"nodes\",\n      parentIdField: \"parentIdField\",\n      idField: \"idField\",\n      loadOnDemand: \"loadOnDemand\",\n      isVisible: \"isVisible\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return FlatDataBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass HierarchyEditingService {\n  constructor(hierarchyBinding) {\n    _defineProperty(this, \"hierarchyBinding\", void 0);\n    _defineProperty(this, \"movedItemNewIndex\", void 0);\n    this.hierarchyBinding = hierarchyBinding;\n  }\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationChildren = this.childrenFor(getDataItem(destinationItem));\n      // add the moved node just before the load more button if load more is enabled\n      const targetIndex = isPresent(destinationTree.loadMoreService) ? Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) :\n      // the page size might be greater than the actual children array length\n      destinationChildren.length;\n      destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);\n      setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);\n    } else {\n      const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);\n    }\n    // increment the parent page size => an item is moved into it\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent);\n    // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);\n    // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    }\n    // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);\n    const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));\n    sourceParentNodes.splice(sourceItemIndex, 1);\n    // emit collapse for the parent node if its last child node was spliced\n    collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);\n    // decrement source item parent page size => an item has been removed from it\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));\n    // reload the treeview nodes\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    }\n    // if the source and destination trees are different we want to focus only the moved item in the destination tree\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      // after the source item is removed from its original position, the candidate index might have to be corrected\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n  getParentNodes(node, treeView) {\n    return isPresent(node.parent) ? this.childrenFor(getDataItem(node.parent)) : treeView.nodes;\n  }\n  childrenFor(dataItem) {\n    return getter(this.hierarchyBinding.childrenField)(dataItem) || [];\n  }\n}\nconst indexBuilder = new IndexBuilderService();\nconst mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of child nodes.\n */\nlet HierarchyBindingDirective = /*#__PURE__*/(() => {\n  var _class41;\n  class HierarchyBindingDirective extends FilteringBase {\n    /**\n     * The field name which holds the data items of the child component.\n     */\n    set childrenField(value) {\n      if (!value) {\n        throw new Error(\"'childrenField' cannot be empty\");\n      }\n      this._childrenField = value;\n    }\n    /**\n     * The field name which holds the data items of the child component.\n     */\n    get childrenField() {\n      return this._childrenField;\n    }\n    /**\n     * The nodes which will be displayed by the TreeView.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it can be accessed via `super` call (typescript v5)\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(component, dragAndDropDirective) {\n      super(component);\n      _defineProperty(this, \"component\", void 0);\n      _defineProperty(this, \"dragAndDropDirective\", void 0);\n      _defineProperty(this, \"_nodes\", void 0);\n      _defineProperty(this, \"loadOnDemand\", true);\n      _defineProperty(this, \"_childrenField\", void 0);\n      _defineProperty(this, \"originalData\", []);\n      this.component = component;\n      this.dragAndDropDirective = dragAndDropDirective;\n      const shouldFilter = !isPresent(this.dragAndDropDirective);\n      this.component.isVisible = shouldFilter ? node => this.visibleNodes.has(node) : isVisible;\n    }\n    ngOnInit() {\n      if (isPresent(this.childrenField)) {\n        this.component.children = item => of(getter(this.childrenField)(item));\n        this.component.hasChildren = item => {\n          const children = getter(this.childrenField)(item);\n          return Boolean(children && children.length);\n        };\n        this.component.editService = new HierarchyEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n    ngOnChanges(changes) {\n      if (isChanged('childrenField', changes, false)) {\n        this.nodes = this.originalData;\n        this.updateNodes(this.originalData);\n      }\n      if (isChanged('nodes', changes, false)) {\n        this.updateNodes(changes['nodes'].currentValue);\n      }\n      // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n    updateNodes(values) {\n      this.originalData = values || [];\n      this.filterData = mapToWrappers(values, this.childrenField) || [];\n      this.updateVisibleNodes(this.filterData);\n    }\n  }\n  _class41 = HierarchyBindingDirective;\n  _defineProperty(HierarchyBindingDirective, \"\\u0275fac\", function _class41_Factory(t) {\n    return new (t || _class41)(i0.ɵɵdirectiveInject(DataBoundComponent), i0.ɵɵdirectiveInject(DragAndDropDirective, 9));\n  });\n  _defineProperty(HierarchyBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class41,\n    selectors: [[\"\", \"kendoTreeViewHierarchyBinding\", \"\"]],\n    inputs: {\n      childrenField: \"childrenField\",\n      nodes: \"nodes\",\n      isVisible: \"isVisible\",\n      loadOnDemand: \"loadOnDemand\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return HierarchyBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst LOAD_MORE_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\n/**\n * A directive that enables the display of only a limited amount of nodes per level\n * ([see example]({% slug loadmorebutton_treeview %})).\n */\nlet LoadMoreDirective = /*#__PURE__*/(() => {\n  var _class42;\n  class LoadMoreDirective {\n    /**\n     * Specifies the callback that will be called when the load more button is clicked.\n     * Providing a function is only required when additional nodes are fetched on demand\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).\n     */\n    set loadMoreNodes(loadMoreNodes) {\n      if (typeof loadMoreNodes === 'string') {\n        return;\n      }\n      this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;\n    }\n    /**\n     * Specifies the initial number of nodes that will be rendered on each level.\n     * Every time the load more button is clicked, the data item page size will be incremented with this number.\n     */\n\n    constructor(treeview) {\n      _defineProperty(this, \"treeview\", void 0);\n      _defineProperty(this, \"pageSize\", void 0);\n      /**\n       * Specifies the total number of root nodes.\n       * Used when additional nodes are fetched on demand\n       * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).\n       */\n      _defineProperty(this, \"totalRootNodes\", void 0);\n      /**\n       * Specifies which field holds information about the total number of child nodes of the data item.\n       * Used when additional nodes are fetched on demand\n       * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).\n       */\n      _defineProperty(this, \"totalField\", void 0);\n      /**\n       * Keeps track of the current page size of each node over expand/collapse cycles.\n       */\n      _defineProperty(this, \"pageSizes\", new Map());\n      /**\n       * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.\n       */\n      _defineProperty(this, \"rootLevelId\", guid());\n      this.treeview = treeview;\n      this.treeview.loadMoreService = {\n        getInitialPageSize: this.getInitalPageSize.bind(this),\n        getGroupSize: this.getGroupSize.bind(this),\n        setGroupSize: this.setGroupSize.bind(this),\n        getTotalNodesCount: this.getTotalNodesCount.bind(this)\n      };\n    }\n    ngOnChanges() {\n      this.verifySettings();\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (!isPresent(this.pageSize)) {\n        throw new Error(`To use the TreeView \\`kendoTreeViewLoadMore\\` directive, you need to assign a \\`pageSize\\` value. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n      const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;\n      if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {\n        throw new Error(`The passed value to the \\`kendoTreeViewLoadMore\\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n      if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {\n        throw new Error(`When a function to fetch additional nodes is provided to the \\`kendoTreeViewLoadMore\\` directive, the \\`totalField\\` and \\`totalRootNodes\\` values must also be provided. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n    }\n    getGroupSize(dataItem) {\n      const itemKey = dataItem || this.rootLevelId;\n      return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;\n    }\n    setGroupSize(dataItem, pageSize) {\n      const itemKey = dataItem || this.rootLevelId;\n      const normalizedSizeValue = pageSize > 0 ? pageSize : 0;\n      this.pageSizes.set(itemKey, normalizedSizeValue);\n    }\n    getTotalNodesCount(dataItem, loadedNodesCount) {\n      if (isPresent(dataItem) && isPresent(this.totalField)) {\n        return dataItem[this.totalField];\n      } else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {\n        return this.totalRootNodes;\n      } else {\n        return loadedNodesCount;\n      }\n    }\n    getInitalPageSize() {\n      return this.pageSize;\n    }\n  }\n  _class42 = LoadMoreDirective;\n  _defineProperty(LoadMoreDirective, \"\\u0275fac\", function _class42_Factory(t) {\n    return new (t || _class42)(i0.ɵɵdirectiveInject(TreeViewComponent));\n  });\n  _defineProperty(LoadMoreDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class42,\n    selectors: [[\"\", \"kendoTreeViewLoadMore\", \"\"]],\n    inputs: {\n      loadMoreNodes: [\"kendoTreeViewLoadMore\", \"loadMoreNodes\"],\n      pageSize: \"pageSize\",\n      totalRootNodes: \"totalRootNodes\",\n      totalField: \"totalField\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return LoadMoreDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n */\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class43;\n  class CustomMessagesComponent extends TreeViewMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class43 = CustomMessagesComponent;\n  _defineProperty(CustomMessagesComponent, \"\\u0275fac\", function _class43_Factory(t) {\n    return new (t || _class43)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(CustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class43,\n    selectors: [[\"kendo-treeview-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TreeViewMessages,\n      useExisting: forwardRef(() => _class43)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class43_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return CustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which manages the in-memory selection state of the TreeView node\n * ([see example]({% slug selection_treeview %})).\n */\nlet SelectDirective = /*#__PURE__*/(() => {\n  var _class44;\n  class SelectDirective {\n    /**\n     * @hidden\n     */\n    set isSelected(value) {\n      this.treeView.isSelected = value;\n    }\n    /**\n     * Defines the item key that will be stored in the `selectedKeys` collection.\n     */\n\n    get getAriaMultiselectable() {\n      return this.options.mode === 'multiple';\n    }\n    get options() {\n      const defaultOptions = {\n        enabled: true,\n        mode: 'single'\n      };\n      if (!isPresent(this.selection) || typeof this.selection === 'string') {\n        return defaultOptions;\n      }\n      const selectionSettings = isBoolean(this.selection) ? {\n        enabled: this.selection\n      } : this.selection;\n      return Object.assign(defaultOptions, selectionSettings);\n    }\n    constructor(treeView, navigationService) {\n      _defineProperty(this, \"treeView\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"selectKey\", void 0);\n      /**\n       * Defines the current selection mode\n       * ([see example](slug:selection_treeview#toc-modes)).\n       */\n      _defineProperty(this, \"selection\", void 0);\n      /**\n       * Defines the collection that will store the selected keys\n       * ([see example](slug:selection_treeview#toc-modes)).\n       */\n      _defineProperty(this, \"selectedKeys\", void 0);\n      /**\n       * Fires when the `selectedKeys` collection was updated.\n       */\n      _defineProperty(this, \"selectedKeysChange\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"selectActions\", {\n        'multiple': e => this.selectMultiple(e),\n        'single': e => this.selectSingle(e)\n      });\n      /**\n       * Reflectes the internal `selectedKeys` state.\n       */\n      _defineProperty(this, \"state\", new Set());\n      /**\n       * Holds the last emitted `selectedKeys` collection.\n       */\n      _defineProperty(this, \"lastChange\", void 0);\n      this.treeView = treeView;\n      this.navigationService = navigationService;\n      this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));\n      this.treeView.isSelected = (dataItem, index) => this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n      this.navigationService.deselectAllButCurrentItem.subscribe(node => {\n        this.selectSingle(node);\n      });\n    }\n    ngOnChanges(changes) {\n      if (isChanged('selectedKeys', changes, false) && changes['selectedKeys'].currentValue !== this.lastChange) {\n        this.state = new Set(changes['selectedKeys'].currentValue);\n      }\n      const isSelectionBooleanTrue = typeof this.selection === 'boolean' && this.selection;\n      this.navigationService.selection = isSelectionBooleanTrue ? 'single' : this.selection?.mode;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    itemKey(e) {\n      if (!this.selectKey) {\n        return e.index;\n      }\n      if (typeof this.selectKey === 'string') {\n        return e.dataItem[this.selectKey];\n      }\n      if (typeof this.selectKey === 'function') {\n        return this.selectKey(e);\n      }\n    }\n    select(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.selectActions[mode] || noop;\n      if (!enabled) {\n        return;\n      }\n      performSelection(e);\n    }\n    selectSingle(node) {\n      const key = this.itemKey(node);\n      if (!this.state.has(key)) {\n        this.state.clear();\n        this.state.add(key);\n        this.notify();\n      }\n    }\n    selectMultiple(node) {\n      const key = this.itemKey(node);\n      const isSelected = this.state.has(key);\n      if (!isPresent(key)) {\n        return;\n      }\n      if (isSelected) {\n        this.state.delete(key);\n      } else {\n        this.state.add(key);\n      }\n      this.notify();\n    }\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.selectedKeysChange.emit(this.lastChange);\n    }\n  }\n  _class44 = SelectDirective;\n  _defineProperty(SelectDirective, \"\\u0275fac\", function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(NavigationService));\n  });\n  _defineProperty(SelectDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class44,\n    selectors: [[\"\", \"kendoTreeViewSelectable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function _class44_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-multiselectable\", ctx.getAriaMultiselectable);\n      }\n    },\n    inputs: {\n      isSelected: \"isSelected\",\n      selectKey: [\"selectBy\", \"selectKey\"],\n      selection: [\"kendoTreeViewSelectable\", \"selection\"],\n      selectedKeys: \"selectedKeys\"\n    },\n    outputs: {\n      selectedKeysChange: \"selectedKeysChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return SelectDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `@progress/kendo-angular-treeview` related components and directives\n */\nconst KENDO_TREEVIEW = [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent];\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi']) definition for the TreeView component.\n */\nlet TreeViewModule = /*#__PURE__*/(() => {\n  var _class45;\n  class TreeViewModule {}\n  _class45 = TreeViewModule;\n  _defineProperty(TreeViewModule, \"\\u0275fac\", function _class45_Factory(t) {\n    return new (t || _class45)();\n  });\n  _defineProperty(TreeViewModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class45\n  }));\n  _defineProperty(TreeViewModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],\n    imports: [TreeViewComponent]\n  }));\n  return TreeViewModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CheckDirective, CustomMessagesComponent, DataBoundComponent, DisableDirective, DragAndDropDirective, DragAndDropEditingDirective, DragClueService, DragClueTemplateDirective, DropAction, DropHintService, DropHintTemplateDirective, DropPosition, ExpandDirective, ExpandableComponent, FlatDataBindingDirective, HierarchyBindingDirective, KENDO_TREEVIEW, LoadMoreButtonTemplateDirective, LoadMoreDirective, LocalizedMessagesDirective, NodeTemplateDirective, SelectDirective, TreeItemDragEvent, TreeItemDragStartEvent, TreeItemDropEvent, TreeViewComponent, TreeViewModule };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}