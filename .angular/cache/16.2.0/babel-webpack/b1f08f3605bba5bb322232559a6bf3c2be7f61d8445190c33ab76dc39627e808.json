{"ast":null,"code":"import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap, padZero, unpadZero } from '../dateinput/utils';\nimport { extend, isPresent, cropTwoDigitYear, setYears, parseToInt, clamp, areDatePartsEqualTo, isNumber, isValidDate, isParseableToInt } from './utils';\nimport { Constants } from './constants';\nconst MONTH_INDEX_FEBRUARY = 1;\nconst DEFAULT_LEAP_YEAR = 2000;\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst MONTH_PART_WITH_WORDS_THRESHOLD = 2;\nconst MONTH_SYMBOL = \"M\";\n// JS months start from 0 (January) instead of 1 (January)\nconst JS_MONTH_OFFSET = 1;\nexport class DateObject {\n  set value(value) {\n    if (value && !(value instanceof Date)) {\n      // throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n      return;\n    }\n    this._value = value;\n    this.resetInvalidDate();\n  }\n  get value() {\n    return this._value;\n  }\n  get localeId() {\n    let localeId = Constants.defaultLocaleId;\n    const cldrKeys = Object.keys(this.intl.cldr);\n    for (let i = 0; i < cldrKeys.length; i++) {\n      const key = cldrKeys[i];\n      const value = this.intl.cldr[key];\n      if (value.name && value.calendar && value.numbers && value.name !== Constants.defaultLocaleId) {\n        localeId = value.name;\n        break;\n      }\n    }\n    return localeId;\n  }\n  constructor({\n    intlService,\n    formatPlaceholder,\n    format,\n    cycleTime = false,\n    twoDigitYearMax = Constants.twoDigitYearMax,\n    value = null,\n    autoCorrectParts = true,\n    toggleDayPeriod = false\n  }) {\n    this.year = true;\n    this.month = true;\n    this.date = true;\n    this.hours = true;\n    this.minutes = true;\n    this.seconds = true;\n    this.milliseconds = true;\n    this.dayperiod = true;\n    this.leadingZero = null;\n    this.typedMonthPart = '';\n    this.knownParts = 'adHhmMsEyS';\n    this.symbols = {\n      'E': 'E',\n      'H': 'H',\n      'M': 'M',\n      'a': 'a',\n      'd': 'd',\n      'h': 'h',\n      'm': 'm',\n      's': 's',\n      'y': 'y',\n      'S': 'S'\n    };\n    this._value = this.getDefaultDate();\n    this.cycleTime = false;\n    this._partiallyInvalidDate = {\n      startDate: null,\n      invalidDateParts: {\n        'E': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'H': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'M': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'a': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'd': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'h': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'm': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        's': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'y': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'S': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        }\n      }\n    };\n    this.setOptions({\n      intlService,\n      formatPlaceholder,\n      format,\n      cycleTime,\n      twoDigitYearMax,\n      value,\n      autoCorrectParts,\n      toggleDayPeriod\n    });\n    if (!value) {\n      this._value = this.getDefaultDate();\n      const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n      for (let i = 0; i < sampleFormat.length; i++) {\n        this.setExisting(sampleFormat[i], false);\n      }\n    } else {\n      this._value = cloneDate(value);\n    }\n  }\n  /**\n   * @hidden\n   */\n  setOptions(options) {\n    this.intl = options.intlService;\n    this.formatPlaceholder = options.formatPlaceholder || 'wide';\n    this.format = options.format;\n    this.cycleTime = options.cycleTime;\n    this.monthNames = this.allFormattedMonths(this.localeId);\n    this.dayPeriods = this.allDayPeriods(this.localeId);\n    this.twoDigitYearMax = options.twoDigitYearMax;\n    this.autoCorrectParts = options.autoCorrectParts;\n    this.toggleDayPeriod = options.toggleDayPeriod;\n  }\n  setValue(value) {\n    if (!value) {\n      this._value = this.getDefaultDate();\n      this.modifyExisting(false);\n    } else if (!isEqual(value, this._value)) {\n      this._value = cloneDate(value);\n      this.modifyExisting(true);\n    }\n    this.resetInvalidDate();\n  }\n  /**\n   * @hidden\n   */\n  hasValue() {\n    const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n    return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);\n  }\n  /**\n   * @hidden\n   */\n  getValue() {\n    for (let i = 0; i < this.knownParts.length; i++) {\n      if (!this.getExisting(this.knownParts[i])) {\n        return null;\n      }\n    }\n    return cloneDate(this.value);\n  }\n  /**\n   * @hidden\n   */\n  createDefaultDate() {\n    // use the leap year 2000 that has 29th February\n    // and a month that has 31 days\n    // so that the default date can accommodate maximum date values\n    // it is better to use a fixed date instead of new Date()\n    // as otherwise the\n    return createDate(DEFAULT_LEAP_YEAR, 0, 31);\n  }\n  /**\n   * @hidden\n   */\n  getDefaultDate() {\n    return getDate(this.createDefaultDate());\n  }\n  /**\n   * @hidden\n   */\n  getFormattedDate(format) {\n    return this.intl.formatDate(this.getValue(), format, this.localeId);\n  }\n  /**\n   * @hidden\n   */\n  getTextAndFormat(customFormat = \"\") {\n    const format = customFormat || this.format;\n    let text = this.intl.formatDate(this.value, format, this.localeId);\n    const mask = this.dateFormatString(this.value, format);\n    if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {\n      let partiallyInvalidText = \"\";\n      const formattedDate = this.intl.formatDate(this.value, format, this.localeId);\n      const formattedDates = this.getFormattedInvalidDates(format);\n      for (let i = 0; i < formattedDate.length; i++) {\n        const symbol = mask.symbols[i];\n        if (mask.partMap[i].type === \"literal\") {\n          partiallyInvalidText += text[i];\n        } else if (this.getInvalidDatePartValue(symbol)) {\n          const partsForSegment = this.getPartsForSegment(mask, i);\n          if (symbol === \"M\") {\n            const datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n            if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n              partiallyInvalidText += formattedDates[symbol][i];\n            } else {\n              if (this.getInvalidDatePartValue(symbol)) {\n                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                partiallyInvalidText += formattedDatePart;\n                // add -1 as the first character in the segment is at index i\n                i += partsForSegment.length - 1;\n              } else {\n                partiallyInvalidText += formattedDates[symbol][i];\n              }\n            }\n          } else {\n            if (this.getInvalidDatePartValue(symbol)) {\n              const datePartText = this.getInvalidDatePartValue(symbol).toString();\n              const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n              partiallyInvalidText += formattedDatePart;\n              // add -1 as the first character in the segment is at index i\n              i += partsForSegment.length - 1;\n            } else {\n              partiallyInvalidText += formattedDates[symbol][i];\n            }\n          }\n        } else {\n          partiallyInvalidText += text[i];\n        }\n      }\n      text = partiallyInvalidText;\n    }\n    const result = this.merge(text, mask);\n    return result;\n  }\n  /**\n   * @hidden\n   */\n  getFormattedInvalidDates(customFormat = \"\") {\n    const format = customFormat || this.format;\n    const formattedDatesForSymbol = {\n      'E': '',\n      'H': '',\n      'M': '',\n      'a': '',\n      'd': '',\n      'h': '',\n      'm': '',\n      's': '',\n      'y': '',\n      'S': ''\n    };\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      const date = this.getInvalidDatePart(key).date;\n      if (date) {\n        const formattedInvalidDate = this.intl.formatDate(date, format, this.localeId);\n        formattedDatesForSymbol[key] = formattedInvalidDate;\n      }\n    });\n    return formattedDatesForSymbol;\n  }\n  modifyExisting(value) {\n    const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n    for (let i = 0; i < sampleFormat.length; i++) {\n      this.setExisting(sampleFormat[i], value);\n    }\n  }\n  /**\n   * @hidden\n   */\n  getExisting(symbol) {\n    switch (symbol) {\n      case 'y':\n        return this.year;\n      case 'M':\n      case 'L':\n        return this.month;\n      case 'd':\n        return this.date;\n      case 'E':\n        return this.date && this.month && this.year;\n      case 'h':\n      case 'H':\n        return this.hours;\n      case 't':\n      case 'a':\n        return this.dayperiod;\n      case 'm':\n        return this.minutes;\n      case 's':\n        return this.seconds;\n      case \"S\":\n        return this.milliseconds;\n      default:\n        return true;\n    }\n  }\n  setExisting(symbol, value) {\n    switch (symbol) {\n      case 'y':\n        // allow 2/29 dates\n        this.year = value;\n        if (value === false) {\n          this._value.setFullYear(DEFAULT_LEAP_YEAR);\n        }\n        break;\n      case 'M':\n        // make sure you can type 31 in the day part\n        this.month = value;\n        if (value === false) {\n          if (this.autoCorrectParts) {\n            this._value.setMonth(0);\n          }\n        }\n        break;\n      case 'd':\n        this.date = value;\n        break;\n      case 'h':\n      case 'H':\n        this.hours = value;\n        break;\n      case 't':\n      case 'a':\n        this.dayperiod = value;\n        break;\n      case 'm':\n        this.minutes = value;\n        break;\n      case 's':\n        this.seconds = value;\n        break;\n      case \"S\":\n        this.milliseconds = value;\n        break;\n      default:\n        break;\n    }\n    if (this.getValue()) {\n      this.resetInvalidDate();\n    }\n  }\n  modifyPart(symbol, offset) {\n    if (!isPresent(symbol) || !isPresent(offset) || offset === 0) {\n      return;\n    }\n    let newValue = cloneDate(this.value);\n    let timeModified = false;\n    let invalidDateFound;\n    const isMonth = symbol === \"M\";\n    const isDay = symbol === \"d\" || symbol === \"E\";\n    const symbolExists = this.getExisting(symbol);\n    if (!this.autoCorrectParts && (isDay || isMonth)) {\n      const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n      const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n      let year = invalidDateParts.y.value || newValue.getFullYear();\n      let month = invalidDateParts.M.value || newValue.getMonth();\n      let day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n      const hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n      const minutes = invalidDateParts.m.value || newValue.getMinutes();\n      const seconds = invalidDateParts.s.value || newValue.getSeconds();\n      const milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n      switch (symbol) {\n        case 'y':\n          year += offset;\n          break;\n        case 'M':\n          month += offset;\n          break;\n        case 'd':\n        case 'E':\n          day += offset;\n          break;\n        // case 'h':\n        // case 'H': hour += offset; break;\n        // case 'm': minutes += offset; break;\n        // case 's': seconds += offset; break;\n        // case 'S': milliseconds += offset; break;\n        default:\n          break;\n      }\n      if (symbol === \"M\") {\n        if (month < 0 || month > 11) {\n          if (symbolExists) {\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return;\n          }\n        }\n        if (!symbolExists) {\n          if (month < 0) {\n            month = clamp(11 + (month % 11 + 1), 0, 11);\n          } else {\n            const monthValue = isPresent(invalidDatePartValue) ? month : (offset - JS_MONTH_OFFSET) % 12;\n            month = clamp(monthValue, 0, 11);\n          }\n          month = clamp(month, 0, 11);\n        }\n        month = clamp(month, 0, 11);\n      } else if (symbol === \"d\") {\n        if (symbolExists) {\n          if (day <= 0 || day > 31) {\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return;\n          }\n        } else if (!symbolExists) {\n          if (isPresent(invalidDatePartValue)) {\n            if (day <= 0 || day > 31) {\n              this.setExisting(symbol, false);\n              this.resetInvalidDateSymbol(symbol);\n              return;\n            }\n          }\n          if (offset < 0) {\n            const dayValue = isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset % 31));\n            day = clamp(dayValue, 1, 31);\n          } else {\n            const dayValue = isPresent(invalidDatePartValue) ? day : offset % 31;\n            day = clamp(dayValue, 1, 31);\n          }\n          day = clamp(day, 1, 31);\n        }\n      }\n      const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n      const newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;\n      const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n      if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {\n        newValue = cloneDate(dateCandidate);\n        this.markDatePartsAsExisting();\n      } else if (isMonth && newValueCandidate) {\n        if (newValueCandidate.getMonth() === month) {\n          if (this.getExisting(\"d\")) {\n            if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n            } else {\n              invalidDateFound = true;\n              this.setInvalidDatePart(symbol, {\n                value: month,\n                date: cloneDate(newValueCandidate),\n                startDateOffset: offset,\n                startDate: cloneDate(this.value)\n              });\n              this.setExisting(symbol, false);\n            }\n          } else if (dateCandidateExists) {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(dateCandidate);\n            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n              // changing from 28/Feb to 29/Feb to 29/March\n              this.setExisting(\"d\", true);\n              this.resetInvalidDateSymbol(\"d\");\n            }\n          } else {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(newValueCandidate);\n          }\n        } else {\n          invalidDateFound = true;\n          this.setInvalidDatePart(symbol, {\n            value: month,\n            date: cloneDate(newValueCandidate),\n            startDateOffset: offset,\n            startDate: cloneDate(this.value)\n          });\n          this.setExisting(symbol, false);\n        }\n      } else if (isDay && newValueCandidate) {\n        if (newValueCandidate.getDate() === day) {\n          if (this.getExisting(\"M\")) {\n            if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n            } else {\n              invalidDateFound = true;\n              this.setInvalidDatePart(symbol, {\n                value: day,\n                date: cloneDate(newValueCandidate),\n                startDateOffset: offset,\n                startDate: cloneDate(this.value)\n              });\n              this.setExisting(symbol, false);\n            }\n          } else if (dateCandidateExists) {\n            newValue = cloneDate(dateCandidate);\n            this.resetInvalidDateSymbol(symbol);\n            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n              // changing from 31/Jan to 31/Feb to 28/Feb\n              this.setExisting(\"M\", true);\n              this.resetInvalidDateSymbol(\"M\");\n            }\n          } else {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(newValueCandidate);\n          }\n        } else {\n          invalidDateFound = true;\n          this.setInvalidDatePart(symbol, {\n            value: day,\n            date: cloneDate(this.value),\n            startDateOffset: offset,\n            startDate: cloneDate(this.value)\n          });\n          this.setExisting(symbol, false);\n        }\n      }\n    } else {\n      const hours = newValue.getHours();\n      switch (symbol) {\n        case 'y':\n          newValue.setFullYear(newValue.getFullYear() + offset);\n          break;\n        case 'M':\n          newValue = addMonths(this.value, offset);\n          break;\n        case 'd':\n        case 'E':\n          newValue.setDate(newValue.getDate() + offset);\n          break;\n        case 'h':\n        case 'H':\n          newValue.setHours(newValue.getHours() + offset);\n          timeModified = true;\n          break;\n        case 'm':\n          newValue.setMinutes(newValue.getMinutes() + offset);\n          timeModified = true;\n          break;\n        case 's':\n          newValue.setSeconds(newValue.getSeconds() + offset);\n          timeModified = true;\n          break;\n        case \"S\":\n          newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n          break;\n        case 'a':\n          if (this.toggleDayPeriod) {\n            newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);\n          } else {\n            newValue.setHours(newValue.getHours() + 12 * offset);\n          }\n          timeModified = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (this.shouldNormalizeCentury()) {\n      newValue = this.normalizeCentury(newValue);\n    }\n    if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {\n      // todo: blazor has this fix, but this fails a unit test\n      // newValue.setDate(this._value.getDate());\n      // newValue.setMonth(this._value.getMonth());\n      // newValue.setFullYear(this._value.getFullYear());\n    }\n    if (!invalidDateFound) {\n      this.setExisting(symbol, true);\n      this._value = newValue;\n      if (this.getValue()) {\n        this.resetInvalidDate();\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  parsePart({\n    symbol,\n    currentChar,\n    resetSegmentValue,\n    cycleSegmentValue,\n    rawTextValue: rawInputValue,\n    isDeleting,\n    originalFormat\n  }) {\n    const isInCaretMode = !cycleSegmentValue;\n    const dateParts = this.dateFormatString(this.value, this.format);\n    const datePartsLiterals = dateParts.partMap.filter(x => x.type === \"literal\").map((x, index) => {\n      return {\n        datePartIndex: index,\n        type: x.type,\n        pattern: x.pattern,\n        literal: \"\"\n      };\n    });\n    const flatDateParts = dateParts.partMap.map(x => {\n      return {\n        type: x.type,\n        pattern: x.pattern,\n        text: \"\"\n      };\n    });\n    for (let i = 0; i < datePartsLiterals.length; i++) {\n      const datePart = datePartsLiterals[i];\n      for (let j = 0; j < datePart.pattern.length; j++) {\n        if (datePartsLiterals[i + j]) {\n          datePartsLiterals[i + j].literal = datePart.pattern[j];\n        }\n      }\n      i += datePart.pattern.length - 1;\n    }\n    for (let i = 0; i < flatDateParts.length; i++) {\n      const datePart = flatDateParts[i];\n      for (let j = 0; j < datePart.pattern.length; j++) {\n        if (flatDateParts[i + j]) {\n          flatDateParts[i + j].text = datePart.pattern[j];\n        }\n      }\n      i += datePart.pattern.length - 1;\n    }\n    const shouldResetPart = isInCaretMode && symbol === \"M\" && dateParts.partMap.filter(x => x.type === \"month\").some(x => x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD);\n    const parseResult = {\n      value: null,\n      switchToNext: false,\n      resetPart: shouldResetPart,\n      hasInvalidDatePart: false\n    };\n    if (!currentChar) {\n      if (isInCaretMode) {\n        for (let i = 0; i < datePartsLiterals.length; i++) {\n          const literal = datePartsLiterals[i].literal;\n          const rawValueStartsWithLiteral = rawInputValue.startsWith(literal);\n          const rawValueEndsWithLiteral = rawInputValue.endsWith(literal);\n          const rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;\n          if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {\n            this.resetLeadingZero();\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return extend(parseResult, {\n              value: null,\n              switchToNext: false\n            });\n          }\n        }\n      } else {\n        this.resetLeadingZero();\n        this.setExisting(symbol, false);\n        this.resetInvalidDateSymbol(symbol);\n        return extend(parseResult, {\n          value: null,\n          switchToNext: false\n        });\n      }\n    }\n    const baseDate = this.intl.formatDate(this.value, this.format, this.localeId);\n    const baseFormat = dateParts.symbols;\n    let replaced = false;\n    let prefix = '';\n    let current = '';\n    let datePartText = '';\n    let basePrefix = '';\n    let baseSuffix = '';\n    let suffix = '';\n    let convertedBaseFormat = \"\";\n    for (let i = 0; i < flatDateParts.length; i++) {\n      convertedBaseFormat += flatDateParts[i].text;\n    }\n    const hasFixedFormat = this.format === baseFormat || this.format === convertedBaseFormat || this.format === originalFormat || this.format.length === originalFormat.length;\n    const datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);\n    const datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);\n    const segmentLength = datePartEndIndex - datePartStartIndex + 1;\n    const formatToTextLengthDiff = originalFormat.length - rawInputValue.length;\n    if (isInCaretMode || !isInCaretMode && !this.autoCorrectParts) {\n      for (let i = 0; i < baseDate.length; i++) {\n        if (baseFormat[i] === symbol) {\n          const existing = this.getExisting(symbol);\n          current += existing ? baseDate[i] : '0';\n          if (formatToTextLengthDiff > 0) {\n            if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n              datePartText += rawInputValue[i] || \"\";\n            }\n          } else {\n            datePartText += rawInputValue[i] || \"\";\n          }\n          replaced = true;\n        } else if (!replaced) {\n          prefix += baseDate[i];\n          basePrefix += baseDate[i];\n        } else {\n          suffix += baseDate[i];\n          baseSuffix += baseDate[i];\n        }\n      }\n      if (hasFixedFormat) {\n        if (convertedBaseFormat.length < rawInputValue.length) {\n          datePartText += currentChar;\n        } else if (!isDeleting && originalFormat.length > rawInputValue.length) {\n          // let the parsing to determine if the incomplete value is valid\n        }\n        if (datePartText.length > segmentLength) {\n          return extend(parseResult, {\n            value: null,\n            switchToNext: false\n          });\n        }\n      }\n      if (!hasFixedFormat || hasFixedFormat && !this.autoCorrectParts) {\n        current = \"\";\n        datePartText = \"\";\n        prefix = \"\";\n        suffix = \"\";\n        replaced = false;\n        for (let i = 0; i < originalFormat.length; i++) {\n          if (originalFormat[i] === symbol) {\n            const existing = this.getExisting(symbol);\n            current += existing ? baseDate[i] || \"\" : '0';\n            if (formatToTextLengthDiff > 0) {\n              if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                datePartText += rawInputValue[i] || \"\";\n              }\n            } else {\n              datePartText += rawInputValue[i] || \"\";\n            }\n            replaced = true;\n          } else if (!replaced) {\n            prefix += rawInputValue[i] || \"\";\n          } else {\n            suffix += rawInputValue[i - formatToTextLengthDiff] || \"\";\n          }\n        }\n        if (originalFormat.length < rawInputValue.length) {\n          datePartText += currentChar;\n        }\n      }\n    }\n    if (!isInCaretMode) {\n      if (this.autoCorrectParts) {\n        current = \"\";\n        datePartText = \"\";\n        prefix = \"\";\n        suffix = \"\";\n        replaced = false;\n        for (let i = 0; i < baseDate.length; i++) {\n          if (baseFormat[i] === symbol) {\n            const existing = this.getExisting(symbol);\n            current += existing ? baseDate[i] : '0';\n            replaced = true;\n          } else if (!replaced) {\n            prefix += baseDate[i];\n          } else {\n            suffix += baseDate[i];\n          }\n        }\n      } else {\n        current = resetSegmentValue ? datePartText : current;\n      }\n    }\n    let parsedDate = null;\n    const month = this.matchMonth(currentChar);\n    const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n    const isZeroCurrentChar = currentChar === '0';\n    const leadingZero = this.leadingZero || {};\n    if (isZeroCurrentChar) {\n      if (datePartText === \"0\") {\n        datePartText = current;\n      }\n      const valueNumber = parseToInt(resetSegmentValue ? currentChar : (isInCaretMode ? datePartText : current) + currentChar);\n      if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol) && symbol !== \"a\") {\n        this.incrementLeadingZero(symbol);\n      }\n    } else {\n      this.resetLeadingZero();\n    }\n    const partPattern = this.partPattern(dateParts.partMap, symbol);\n    const patternValue = partPattern ? partPattern.pattern : null;\n    const patternLength = this.patternLength(patternValue) || patternValue.length;\n    if (isInCaretMode) {\n      if (isDeleting && !datePartText) {\n        this.setExisting(symbol, false);\n        return extend(parseResult, {\n          value: null,\n          switchToNext: false\n        });\n      }\n    }\n    const currentMaxLength = current.length - 3;\n    let tryParse = true;\n    let middle = isInCaretMode ? datePartText : current;\n    for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n      if (!tryParse) {\n        break;\n      }\n      middle = resetSegmentValue ? currentChar : isInCaretMode ? datePartText : current.substring(i) + currentChar;\n      if (isInCaretMode || !this.autoCorrectParts) {\n        tryParse = false;\n        middle = unpadZero(middle);\n        // middle = padZero(segmentLength - middle.length) + middle;\n        middle = padZero(patternLength - middle.length) + middle;\n      }\n      const middleNumber = parseInt(middle, 10);\n      const candidateDateString = prefix + middle + suffix;\n      parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);\n      // if the format does not include year/month/day, e.g. hh:mm:ss\n      // then the exact date cannot be inferred as there is no data for it\n      // thus the today's date is used, but revert to the original date\n      // to keep other parts of the date unchanged\n      if (parsedDate && this.value && dateParts.partMap.every(x => x.type !== \"year\" && x.type !== \"month\" && x.type != \"day\")) {\n        parsedDate.setFullYear(this.value.getFullYear());\n        parsedDate.setMonth(this.value.getMonth());\n        parsedDate.setDate(this.value.getDate());\n      }\n      let autoCorrectedPrefixAndSuffix = false;\n      if (isInCaretMode && !isValidDate(parsedDate)) {\n        // if part of the date is not available, e.g. \"d\"\n        // but an expanded format like \"F\" is used\n        // the element value can be \"EEEE, February 1, 2022 3:04:05 AM\"\n        // which is not parsable by intl\n        // use the base prefix and suffix, e.g. convert the candidate date string\n        // to \"Thursday, February 1, 2022 3:04:05 AM\"\n        // as \"EEEE, February...\" is not parsable\n        if (this.autoCorrectParts) {\n          parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n          autoCorrectedPrefixAndSuffix = true;\n        }\n      }\n      const isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || isInCaretMode && isDeleting && currentChar === \"\";\n      if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {\n        if (symbol === MONTH_SYMBOL && !month) {\n          // JS months start from 0 (January) instead of 1 (January)\n          const monthNumber = middleNumber - JS_MONTH_OFFSET;\n          if (monthNumber > -1 && monthNumber < 12) {\n            parsedDate = cloneDate(this.value);\n            parsedDate.setMonth(monthNumber);\n            if (parsedDate.getMonth() !== monthNumber) {\n              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n            }\n          }\n        }\n        if (symbol === 'y') {\n          parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n          if ((isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) && this.date && parsedDate.getDate() !== this.value.getDate()) {\n            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n          }\n        }\n      }\n      if (isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) {\n        // move to next segment if the part will overflow with next char\n        // when start from empty date (01, then 010), padded zeros should be trimmed\n        const peekResult = this.isPeekDateOverflowingDatePart({\n          useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,\n          middle,\n          patternValue,\n          basePrefix,\n          baseSuffix,\n          prefix,\n          suffix,\n          symbol,\n          patternLength,\n          leadingZero\n        });\n        let switchToNext = peekResult.switchToNext;\n        if (this.shouldNormalizeCentury()) {\n          parsedDate = this.normalizeCentury(parsedDate);\n        }\n        if (symbol === 'H' && parsedDate.getHours() >= 12) {\n          this.setExisting('a', true);\n        }\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        this.resetInvalidDateSymbol(symbol);\n        if (!this.autoCorrectParts) {\n          if (symbol === \"M\") {\n            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n              // changing from 28/Feb to 29/Feb to 29/March\n              this.setExisting(\"d\", true);\n              this.resetInvalidDateSymbol(\"d\");\n            }\n          } else if (symbol === \"d\") {\n            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n              // changing from 31/Jan to 31/Feb to 28/Feb\n              this.setExisting(\"M\", true);\n              this.resetInvalidDateSymbol(\"M\");\n            }\n          }\n          if (!this.hasInvalidDatePart()) {\n            this.markDatePartsAsExisting();\n            if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {\n              if (symbol === \"M\") {\n                // skip processing the month\n              } else if (symbol === \"d\") {\n                if (peekResult.parsedPeekedValue === 30 && this.value.getMonth() === MONTH_INDEX_FEBRUARY) {\n                  // the peekValue cannot be constructed\n                  // as there cannot be more than 29 days in February\n                  // still the segment should not be switched as autoCorrectParts=\"false\"\n                  // should allow typing \"30\"\n                  switchToNext = false;\n                }\n              }\n            }\n          }\n        }\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: switchToNext\n        });\n      }\n    }\n    if (month) {\n      parsedDate = this.intl.parseDate(prefix + month + suffix, this.format, this.localeId);\n      if (parsedDate) {\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: false\n        });\n      }\n    }\n    if (dayPeriod) {\n      parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format) || this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);\n      if (parsedDate) {\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: true\n        });\n      }\n    }\n    if (isZeroCurrentChar && symbol !== \"a\") {\n      this.setExisting(symbol, false);\n    }\n    if (!this.autoCorrectParts) {\n      let datePartValue;\n      let textToParse = isInCaretMode ? datePartText : middle;\n      let parsedValue = parseToInt(textToParse);\n      if (isNumber(parsedValue) && isParseableToInt(textToParse)) {\n        if (symbol === \"d\" && (parsedValue <= 0 || parsedValue > 31) || symbol === \"M\" && (parsedValue <= 0 || parsedValue > 11)) {\n          if (isInCaretMode) {\n            return extend(parseResult, {\n              value: null,\n              switchToNext: false\n            });\n          } else {\n            // the value overflows the possible value range\n            // thus reset the segment value regardless of the \"resetSegmentValue\" flag\n            // otherwise the input is ignored and you cannot change the value,\n            // e.g. \"03->(press 2)->02\" will not work and the user will be blocked on \"03\"\n            textToParse = currentChar;\n            parsedValue = parseToInt(textToParse);\n          }\n        }\n        if (!isNumber(parsedValue) || !isParseableToInt(textToParse)) {\n          return extend(parseResult, {\n            value: null,\n            switchToNext: false\n          });\n        }\n        datePartValue = symbol === \"M\" ? parsedValue - JS_MONTH_OFFSET : parsedValue;\n        const isMonth = symbol === \"M\";\n        const isDay = symbol === \"d\";\n        let newValue = cloneDate(this._value);\n        const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n        const year = invalidDateParts.y.value || newValue.getFullYear();\n        /* tslint:disable:no-shadowed-variable */\n        const month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();\n        /* tslint:enable:no-shadowed-variable */\n        const day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n        const hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n        const minutes = invalidDateParts.m.value || newValue.getMinutes();\n        const seconds = invalidDateParts.s.value || newValue.getSeconds();\n        const milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n        const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n        const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n        const newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;\n        let invalidDateFound = false;\n        if (isMonth && newValueCandidate) {\n          if (newValueCandidate.getMonth() === month) {\n            if (this.getExisting(\"d\")) {\n              if (dateCandidateExists) {\n                newValue = cloneDate(dateCandidate);\n                this.resetInvalidDateSymbol(symbol);\n              } else {\n                invalidDateFound = true;\n                this.setInvalidDatePart(symbol, {\n                  value: month,\n                  date: cloneDate(newValueCandidate),\n                  startDate: cloneDate(this.value)\n                });\n                this.setExisting(symbol, false);\n              }\n            } else if (dateCandidateExists) {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(dateCandidate);\n              if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                // changing from 28/Feb to 29/Feb to 29/March\n                this.setExisting(\"d\", true);\n                this.resetInvalidDateSymbol(\"d\");\n              }\n            } else {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(newValueCandidate);\n            }\n          } else {\n            invalidDateFound = true;\n            this.setInvalidDatePart(symbol, {\n              value: month,\n              date: cloneDate(newValueCandidate),\n              startDate: cloneDate(this.value)\n            });\n            this.setExisting(symbol, false);\n          }\n        } else if (isDay && newValueCandidate) {\n          if (newValueCandidate.getDate() === day) {\n            if (this.getExisting(\"M\")) {\n              if (dateCandidateExists) {\n                newValue = cloneDate(dateCandidate);\n                this.resetInvalidDateSymbol(symbol);\n              } else {\n                invalidDateFound = true;\n                this.setInvalidDatePart(symbol, {\n                  value: day,\n                  date: cloneDate(newValueCandidate),\n                  startDate: cloneDate(this.value)\n                });\n                this.setExisting(symbol, false);\n              }\n            } else if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n              if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                // changing from 31/Jan to 31/Feb to 28/Feb\n                this.setExisting(\"M\", true);\n                this.resetInvalidDateSymbol(\"M\");\n              }\n            } else {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(newValueCandidate);\n            }\n          } else {\n            invalidDateFound = true;\n            this.setInvalidDatePart(symbol, {\n              value: day,\n              date: cloneDate(this.value),\n              startDate: cloneDate(this.value)\n            });\n            this.setExisting(symbol, false);\n          }\n        }\n        if (!invalidDateFound) {\n          this.setExisting(symbol, true);\n          if (isInCaretMode && !isValidDate(parsedDate)) {\n            const valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n            if (isValidDate(valueCandidate)) {\n              this._value = valueCandidate;\n            }\n          } else {\n            this._value = newValue;\n          }\n          if (this.getValue()) {\n            this.resetInvalidDate();\n          }\n        }\n        let switchToNext = false;\n        if (symbol === \"M\") {\n          if (parsedValue >= 2 || textToParse.length >= 2) {\n            switchToNext = true;\n          } else {\n            switchToNext = false;\n          }\n        } else {\n          if (hasFixedFormat) {\n            const peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({\n              useBasePrefixAndSuffix: !this.autoCorrectParts,\n              middle,\n              patternValue,\n              basePrefix,\n              baseSuffix,\n              prefix,\n              suffix,\n              symbol,\n              patternLength,\n              leadingZero\n            }).switchToNext;\n            switchToNext = peekDateSwitchToNext;\n          } else {\n            switchToNext = textToParse.length > segmentLength;\n          }\n        }\n        return extend(parseResult, {\n          value: null,\n          switchToNext: switchToNext,\n          hasInvalidDatePart: invalidDateFound\n        });\n      }\n    }\n    return extend(parseResult, {\n      value: null,\n      switchToNext: false\n    });\n  }\n  /**\n   * @hidden\n   */\n  symbolMap(symbol) {\n    return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];\n  }\n  /**\n   * @hidden\n   */\n  resetLeadingZero() {\n    const hasLeadingZero = this.leadingZero !== null;\n    this.setLeadingZero(null);\n    return hasLeadingZero;\n  }\n  setLeadingZero(leadingZero) {\n    this.leadingZero = leadingZero;\n  }\n  /**\n   * @hidden\n   */\n  getLeadingZero() {\n    return this.leadingZero || {};\n  }\n  /**\n   * @hidden\n   */\n  normalizeCentury(date) {\n    if (!isPresent(date)) {\n      return date;\n    }\n    const twoDigitYear = cropTwoDigitYear(date);\n    const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n    const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n    return normalizedDate;\n  }\n  incrementLeadingZero(symbol) {\n    const leadingZero = this.leadingZero || {};\n    leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n    this.leadingZero = leadingZero;\n  }\n  /**\n   * @hidden\n   */\n  isAbbrMonth(parts, symbol) {\n    const pattern = this.partPattern(parts, symbol);\n    return pattern.type === 'month' && pattern.names;\n  }\n  /**\n   * @hidden\n   */\n  partPattern(parts, symbol) {\n    return parts.filter(part => part.pattern.indexOf(symbol) !== -1)[0];\n  }\n  /**\n   * @hidden\n   */\n  peek(value, pattern) {\n    const peekValue = value.replace(/^0*/, '') + '0';\n    return padZero(pattern.length - peekValue.length) + peekValue;\n  }\n  /**\n   * @hidden\n   */\n  matchMonth(typedChar) {\n    this.typedMonthPart += typedChar.toLowerCase();\n    if (this.monthNames.length === 0) {\n      return '';\n    }\n    while (this.typedMonthPart.length > 0) {\n      for (let i = 0; i < this.monthNames.length; i++) {\n        if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n          return this.monthNames[i];\n        }\n      }\n      const monthAsNum = parseInt(this.typedMonthPart, 10);\n      /* ensure they exact match */\n      if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {\n        return this.monthNames[monthAsNum - 1];\n      }\n      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n    }\n    return '';\n  }\n  /**\n   * @hidden\n   */\n  matchDayPeriod(typedChar, symbol) {\n    const lowerChart = typedChar.toLowerCase();\n    if (symbol === 'a' && this.dayPeriods) {\n      if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.am;\n      } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.pm;\n      }\n    }\n    return '';\n  }\n  /**\n   * @hidden\n   */\n  allFormattedMonths(locale = \"en\") {\n    const dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n      }\n    }\n    return [];\n  }\n  /**\n   * @hidden\n   */\n  allDayPeriods(locale = \"en\") {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n      }\n    }\n    return null;\n  }\n  /**\n   * @hidden\n   */\n  patternLength(pattern) {\n    if (pattern[0] === 'y') {\n      return 4;\n    }\n    if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n      return 2;\n    }\n    return 0;\n  }\n  /**\n   * @hidden\n   */\n  dateFormatString(date, format) {\n    const dateFormatParts = this.intl.splitDateFormat(format, this.localeId);\n    const parts = [];\n    const partMap = [];\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      let partLength = this.intl.formatDate(date, {\n        pattern: dateFormatParts[i].pattern\n      }, this.localeId).length;\n      while (partLength > 0) {\n        parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);\n        partMap.push(dateFormatParts[i]);\n        partLength--;\n      }\n    }\n    const returnValue = new Mask();\n    returnValue.symbols = parts.join('');\n    returnValue.partMap = partMap;\n    return returnValue;\n  }\n  /**\n   * @hidden\n   */\n  merge(text, mask) {\n    // Important: right to left.\n    let resultText = '';\n    let resultFormat = '';\n    const format = mask.symbols;\n    let processTextSymbolsEnded = false;\n    let ignoreFormatSymbolsCount = 0;\n    const formattedDates = this.getFormattedInvalidDates(format);\n    for (let formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {\n      const partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);\n      if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {\n        if (this.autoCorrectParts) {\n          resultText = text[formatSymbolIndex] + resultText;\n        } else {\n          if (text.length !== format.length) {\n            if (processTextSymbolsEnded) {\n              resultText = text[formatSymbolIndex] + resultText;\n            } else if (ignoreFormatSymbolsCount > 0) {\n              resultText = text[formatSymbolIndex] + resultText;\n              ignoreFormatSymbolsCount--;\n              if (ignoreFormatSymbolsCount <= 0) {\n                processTextSymbolsEnded = true;\n              }\n            } else {\n              resultText = (text[formatSymbolIndex + text.length - format.length] || \"\") + resultText;\n            }\n          } else {\n            resultText = text[formatSymbolIndex] + resultText;\n          }\n        }\n        resultFormat = format[formatSymbolIndex] + resultFormat;\n      } else {\n        const symbol = format[formatSymbolIndex];\n        let formatSymbolIndexModifier = 0;\n        if (this.autoCorrectParts || !this.autoCorrectParts && !this.getInvalidDatePartValue(symbol)) {\n          while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {\n            formatSymbolIndex--;\n          }\n          formatSymbolIndex++;\n        }\n        if (this.leadingZero && this.leadingZero[symbol]) {\n          resultText = '0' + resultText;\n        } else {\n          if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {\n            let datePartText = this.getInvalidDatePartValue(symbol).toString();\n            if (symbol === \"M\") {\n              datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n              if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                resultText = formattedDates[symbol][formatSymbolIndex] + resultText;\n              } else {\n                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                resultText = formattedDatePart + resultText;\n                formatSymbolIndexModifier = partsForSegment.length - 1;\n                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n              }\n            } else {\n              const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n              resultText = formattedDatePart + resultText;\n              formatSymbolIndexModifier = partsForSegment.length - 1;\n              ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n            }\n          } else {\n            resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;\n          }\n        }\n        while (resultFormat.length < resultText.length) {\n          resultFormat = format[formatSymbolIndex] + resultFormat;\n        }\n        if (formatSymbolIndexModifier !== 0) {\n          formatSymbolIndex = formatSymbolIndex - formatSymbolIndexModifier + (text.length - format.length);\n        }\n      }\n    }\n    return {\n      text: resultText,\n      format: resultFormat\n    };\n  }\n  /**\n   * @hidden\n   */\n  dateFieldName(part) {\n    const formatPlaceholder = this.formatPlaceholder || 'wide';\n    if (formatPlaceholder[part.type]) {\n      return formatPlaceholder[part.type];\n    }\n    if (formatPlaceholder === 'formatPattern') {\n      return part.pattern;\n    }\n    return this.intl.dateFieldName(Object.assign(part, {\n      nameType: formatPlaceholder\n    }));\n  }\n  /**\n   * @hidden\n   */\n  getNormalizedCenturyBase(twoDigitYear) {\n    return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;\n  }\n  /**\n   * @hidden\n   */\n  shouldNormalizeCentury() {\n    return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n  }\n  resetInvalidDate() {\n    this._partiallyInvalidDate.startDate = null;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      this.resetInvalidDatePart(key);\n    });\n  }\n  resetInvalidDateSymbol(symbol) {\n    this.resetInvalidDatePart(symbol);\n    let shouldResetInvalidDate = true;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      if (this._partiallyInvalidDate.invalidDateParts[key] && isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n        shouldResetInvalidDate = false;\n      }\n    });\n    if (shouldResetInvalidDate) {\n      this.resetInvalidDate();\n    }\n  }\n  resetInvalidDatePart(symbol) {\n    if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n      this._partiallyInvalidDate.invalidDateParts[symbol] = {\n        value: null,\n        date: null,\n        startDateOffset: 0\n      };\n    }\n  }\n  /**\n   * @hidden\n   */\n  getInvalidDatePart(symbol) {\n    const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n    return invalidDatePart || {};\n  }\n  /**\n   * @hidden\n   */\n  getInvalidDatePartValue(symbol) {\n    const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n    return (invalidDatePart || {}).value;\n  }\n  setInvalidDatePart(symbol, {\n    value = null,\n    date = null,\n    startDateOffset = 0,\n    startDate = null\n  }) {\n    if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n      this._partiallyInvalidDate.invalidDateParts[symbol].value = value;\n      this._partiallyInvalidDate.invalidDateParts[symbol].date = date;\n      this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;\n      this._partiallyInvalidDate.startDate = startDate;\n    }\n  }\n  /**\n   * @hidden\n   */\n  hasInvalidDatePart() {\n    let hasInvalidDatePart = false;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      if (this._partiallyInvalidDate.invalidDateParts[key] && isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n        hasInvalidDatePart = true;\n      }\n    });\n    return hasInvalidDatePart;\n  }\n  /**\n   * @hidden\n   */\n  modifyDateSymbolWithOffset(date, symbol, offset) {\n    let newValue = cloneDate(date);\n    let timeModified = false;\n    switch (symbol) {\n      case 'y':\n        newValue.setFullYear(newValue.getFullYear() + offset);\n        break;\n      case 'M':\n        newValue = addMonths(this.value, offset);\n        break;\n      case 'd':\n      case 'E':\n        newValue.setDate(newValue.getDate() + offset);\n        break;\n      case 'h':\n      case 'H':\n        newValue.setHours(newValue.getHours() + offset);\n        timeModified = true;\n        break;\n      case 'm':\n        newValue.setMinutes(newValue.getMinutes() + offset);\n        timeModified = true;\n        break;\n      case 's':\n        newValue.setSeconds(newValue.getSeconds() + offset);\n        timeModified = true;\n        break;\n      case \"S\":\n        newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n        break;\n      case 'a':\n        newValue.setHours(newValue.getHours() + 12 * offset);\n        timeModified = true;\n        break;\n      default:\n        break;\n    }\n    return {\n      date: newValue,\n      timeModified: timeModified\n    };\n  }\n  /**\n   * @hidden\n   */\n  modifyDateSymbolWithValue(date, symbol, value) {\n    let newValue = cloneDate(date);\n    switch (symbol) {\n      case 'y':\n        newValue.setFullYear(value);\n        break;\n      case 'M':\n        newValue = addMonths(date, value - date.getMonth());\n        break;\n      case 'd':\n      case 'E':\n        newValue.setDate(value);\n        break;\n      case 'h':\n      case 'H':\n        newValue.setHours(value);\n        break;\n      case 'm':\n        newValue.setMinutes(value);\n        break;\n      case 's':\n        newValue.setSeconds(value);\n        break;\n      case \"S\":\n        newValue.setMilliseconds(value);\n        break;\n      case 'a':\n        newValue.setHours(value);\n        break;\n      default:\n        break;\n    }\n    return newValue;\n  }\n  markDatePartsAsExisting() {\n    this.modifyExisting(true);\n  }\n  /**\n   * @hidden\n   */\n  getPartsForSegment(mask, partIndex) {\n    const segmentPart = mask.partMap[partIndex];\n    const partsForSegment = [];\n    for (let maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {\n      const part = mask.partMap[maskPartIndex];\n      if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n        partsForSegment.push(part);\n      } else {\n        break;\n      }\n    }\n    for (let maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {\n      const part = mask.partMap[maskPartIndex];\n      if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n        partsForSegment.unshift(part);\n      } else {\n        break;\n      }\n    }\n    return partsForSegment;\n  }\n  /**\n   * @hidden\n   */\n  isPeekDateOverflowingDatePart({\n    useBasePrefixAndSuffix,\n    middle,\n    patternValue,\n    basePrefix,\n    baseSuffix,\n    prefix,\n    suffix,\n    symbol,\n    patternLength,\n    leadingZero\n  }) {\n    // move to next segment if the part will overflow with next char\n    // when start from empty date (01, then 010), padded zeros should be trimmed\n    const peekedValue = this.peek(middle, patternValue);\n    const peekedDateString = useBasePrefixAndSuffix ? `${basePrefix}${peekedValue}${baseSuffix}` : `${prefix}${peekedValue}${suffix}`;\n    const peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);\n    const leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;\n    const patternSatisfied = leadingZeroOffset + unpadZero(middle).length >= patternLength;\n    const parsedPeekedValue = parseToInt(peekedValue);\n    const switchToNext = peekedDate === null || (leadingZero[symbol] ? patternValue.length <= middle.length : patternSatisfied);\n    return {\n      peekedDate,\n      peekedDateString,\n      peekedValue,\n      parsedPeekedValue,\n      switchToNext\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}