{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, Directive, Optional, isDevMode, Component, SkipSelf, Host, Input, ViewChild, HostBinding, ViewChildren, ContentChildren, EventEmitter, Output, ContentChild, HostListener, Inject, QueryList, NgZone, forwardRef, ElementRef, ViewEncapsulation, TemplateRef, NgModule } from '@angular/core';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { Keys, shouldShowValidationUI, WatermarkOverlayComponent, isDocumentAvailable, anyChanged, isObjectPresent, removeHTMLAttributes, parseAttributes, setHTMLAttributes, DraggableDirective, PreventableEvent as PreventableEvent$1, guid, ResizeSensorComponent, hasObservers, isPresent as isPresent$1, focusableSelector, isChanged } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1$2 from '@angular/animations';\nimport { trigger, state, style, transition, animate, AUTO_STYLE } from '@angular/animations';\nimport { Subject, BehaviorSubject, Subscription, of } from 'rxjs';\nimport { chevronUpIcon, chevronDownIcon, caretAltLeftIcon, caretAltRightIcon, caretAltUpIcon, caretAltDownIcon, xIcon, checkCircleIcon, exclamationCircleIcon, chevronRightIcon } from '@progress/kendo-svg-icons';\nimport { IconWrapperComponent } from '@progress/kendo-angular-icons';\nimport { NgIf, NgTemplateOutlet, NgFor, NgStyle, NgClass } from '@angular/common';\nimport { delay, takeUntil, map, tap, filter, switchMap, take } from 'rxjs/operators';\nimport { ButtonComponent } from '@progress/kendo-angular-buttons';\nimport { ProgressBarComponent } from '@progress/kendo-angular-progressbar';\nimport { Draggable } from '@progress/kendo-draggable';\nimport { DatePipe } from '@progress/kendo-angular-intl';\n\n/**\n * @hidden\n */\nconst _c0 = [\"header\"];\nconst _c1 = [\"contentWrapper\"];\nfunction _class4_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 6);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r1.iconClasses)(\"customFontClass\", ctx_r1.customIconClasses)(\"svgIcon\", ctx_r1.svgIcon);\n  }\n}\nfunction _class4_img_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"src\", ctx_r2.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class4_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 8);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.title);\n  }\n}\nfunction _class4_5_ng_template_0_Template(rf, ctx) {}\nconst _c2 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n  return {\n    title: a0,\n    id: a1,\n    icon: a2,\n    iconClass: a3,\n    svgIcon: a4,\n    imageUrl: a5,\n    selected: a6,\n    expanded: a7,\n    disabled: a8,\n    focused: a9,\n    content: a10\n  };\n};\nconst _c3 = function (a0) {\n  return {\n    item: a0\n  };\n};\nfunction _class4_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class4_5_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.titleTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(14, _c3, i0.ɵɵpureFunctionV(2, _c2, [ctx_r4.title, ctx_r4.id, ctx_r4.icon, ctx_r4.iconClass, ctx_r4.svgIcon, ctx_r4.imageUrl, ctx_r4.selected, ctx_r4.expanded, ctx_r4.disabled, ctx_r4.focused, ctx_r4.content])));\n  }\n}\nfunction _class4_kendo_icon_wrapper_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r5.expanded ? \"chevron-up\" : \"chevron-down\")(\"svgIcon\", ctx_r5.expanderSVGIcon)(\"innerCssClass\", ctx_r5.dirInnerCssClasses);\n  }\n}\nfunction _class4_div_7_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r9.contentOverflow)(\"height\", ctx_r9.contentHeight);\n  }\n}\nfunction _class4_div_7_div_3_ng_template_1_Template(rf, ctx) {}\nconst _c4 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    title: a0,\n    id: a1,\n    icon: a2,\n    imageUrl: a3,\n    disabled: a4,\n    content: a5\n  };\n};\nconst _c5 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nfunction _class4_div_7_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, _class4_div_7_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r10.contentOverflow)(\"height\", ctx_r10.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r10.contentTemplate.first.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(13, _c5, i0.ɵɵpureFunction6(6, _c4, ctx_r10.title, ctx_r10.id, ctx_r10.icon, ctx_r10.imageUrl, ctx_r10.disabled, ctx_r10.content)));\n  }\n}\nfunction _class4_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-panelbar-item\", 18);\n  }\n  if (rf & 2) {\n    const item_r15 = i0.ɵɵnextContext().$implicit;\n    const ctx_r16 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"title\", item_r15.title)(\"id\", item_r15.id)(\"icon\", item_r15.icon)(\"iconClass\", item_r15.iconClass)(\"svgIcon\", item_r15.svgIcon)(\"imageUrl\", item_r15.imageUrl)(\"selected\", !!item_r15.selected)(\"expanded\", !!item_r15.expanded)(\"disabled\", !!item_r15.disabled)(\"template\", ctx_r16.template)(\"items\", item_r15.children)(\"content\", item_r15.content);\n  }\n}\nfunction _class4_div_7_div_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class4_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template, 1, 12, \"kendo-panelbar-item\", 17);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r15 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r15.hidden);\n  }\n}\nfunction _class4_div_7_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, _class4_div_7_div_4_ng_container_1_Template, 2, 1, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r11.contentOverflow)(\"height\", ctx_r11.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r11.items);\n  }\n}\nfunction _class4_div_7_div_5_ng_template_1_Template(rf, ctx) {}\nfunction _class4_div_7_div_5_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(3);\n    i0.ɵɵtextInterpolate(ctx_r19.content);\n  }\n}\nfunction _class4_div_7_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, _class4_div_7_div_5_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵtemplate(2, _class4_div_7_div_5_ng_template_2_Template, 1, 1, \"ng-template\", 19);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r12.contentOverflow)(\"height\", ctx_r12.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r12.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(14, _c5, i0.ɵɵpureFunction6(7, _c4, ctx_r12.title, ctx_r12.id, ctx_r12.icon, ctx_r12.imageUrl, ctx_r12.disabled, ctx_r12.content)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.template);\n  }\n}\nfunction _class4_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", null, 11);\n    i0.ɵɵtemplate(2, _class4_div_7_div_2_Template, 2, 4, \"div\", 12);\n    i0.ɵɵtemplate(3, _class4_div_7_div_3_Template, 2, 15, \"div\", 13);\n    i0.ɵɵtemplate(4, _class4_div_7_div_4_Template, 2, 5, \"div\", 12);\n    i0.ɵɵtemplate(5, _class4_div_7_div_5_Template, 3, 16, \"div\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@toggle\", ctx_r6.state);\n    i0.ɵɵattribute(\"role\", \"group\")(\"aria-hidden\", !ctx_r6.disabled && !ctx_r6.expanded);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasChildItems && !(ctx_r6.items == null ? null : ctx_r6.items.length));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasContent && !ctx_r6.content);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasItems);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.content);\n  }\n}\nconst _c6 = [[[\"kendo-panelbar-item\"]]];\nconst _c7 = [\"kendo-panelbar-item\"];\nfunction _class12_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"contentChildItems && !items\"]);\n  }\n}\nfunction _class12_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-panelbar-item\", 5);\n  }\n  if (rf & 2) {\n    const item_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", item_r4.title)(\"id\", item_r4.id)(\"icon\", item_r4.icon)(\"iconClass\", item_r4.iconClass)(\"svgIcon\", item_r4.svgIcon)(\"imageUrl\", item_r4.imageUrl)(\"selected\", !!item_r4.selected)(\"expanded\", !!item_r4.expanded)(\"disabled\", !!item_r4.disabled)(\"template\", ctx_r5.templateRef)(\"items\", item_r4.children)(\"content\", item_r4.content);\n  }\n}\nfunction _class12_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class12_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template, 1, 12, \"kendo-panelbar-item\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r4 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r4.hidden);\n  }\n}\nfunction _class12_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class12_ng_template_1_ng_container_0_Template, 2, 1, \"ng-container\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.items);\n  }\n}\nfunction _class12_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n}\nfunction _class14_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\nfunction _class14_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 2);\n  }\n}\nconst _c8 = [\"*\"];\nfunction _class15_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵlistener(\"click\", function _class15_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.togglePrevious());\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r0.previousArrowClass())(\"svgIcon\", ctx_r0.previousSVGArrowClass());\n  }\n}\nfunction _class15_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵlistener(\"click\", function _class15_div_2_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.toggleNext());\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r1.nextArrowClass())(\"svgIcon\", ctx_r1.nextSVGArrowClass());\n  }\n}\nconst _c9 = function (a0, a1) {\n  return {\n    width: a0,\n    height: a1\n  };\n};\nfunction _class16_ng_container_1_kendo_splitter_bar_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-splitter-bar\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    const index_r2 = ctx_r5.index;\n    const pane_r1 = ctx_r5.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"index\", index_r2)(\"orientation\", ctx_r4.orientation)(\"ngClass\", pane_r1.splitterBarClass || ctx_r4.splitterBarClass)(\"ngStyle\", i0.ɵɵpureFunction2(4, _c9, ctx_r4.orientation === \"horizontal\" ? ctx_r4.splitbarWidth + \"px\" : undefined, ctx_r4.orientation === \"vertical\" ? ctx_r4.splitbarWidth + \"px\" : undefined));\n  }\n}\nfunction _class16_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class16_ng_container_1_kendo_splitter_bar_1_Template, 1, 7, \"kendo-splitter-bar\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const last_r3 = ctx.last;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !last_r3);\n  }\n}\nconst _c10 = [[[\"kendo-splitter-pane\"]]];\nconst _c11 = [\"kendo-splitter-pane\"];\nconst _c12 = [\"kendoTabStripScrollableButton\", \"\"];\nconst _c13 = [\"kendoTabStripTab\", \"\"];\nfunction _class27_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5)(1, \"span\", 6);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.tab.title);\n  }\n}\nfunction _class27_ng_container_0_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class27_ng_container_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtemplate(1, _class27_ng_container_0_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.tab.tabTitle.templateRef);\n  }\n}\nfunction _class27_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class27_ng_container_0_span_1_Template, 3, 1, \"span\", 4);\n    i0.ɵɵtemplate(2, _class27_ng_container_0_span_2_Template, 2, 1, \"span\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.tab.tabTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.tab.tabTitle);\n  }\n}\nfunction _class27_ng_template_1_Template(rf, ctx) {}\nfunction _class27_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function _class27_button_3_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.closeTab(ctx_r7.index));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r3.closeButtonClasses)(\"iconClass\", ctx_r3.customCloseButtonClasses)(\"svgIcon\", ctx_r3.closeSVGIconClass)(\"title\", ctx_r3.closeButtonTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r3.closeButtonTitle);\n  }\n}\nconst _c14 = [\"tablist\"];\nconst _c15 = [\"prevScrollButton\"];\nconst _c16 = [\"nextScrollButton\"];\nconst _c17 = [\"tabHeaderContainer\"];\nfunction _class30_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class30_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class30_ng_container_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class30_ng_container_1_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n    const _r4 = i0.ɵɵreference(6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n  }\n}\nfunction _class30_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class30_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵtemplate(2, _class30_ng_container_1_ng_container_2_Template, 2, 1, \"ng-container\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    const _r2 = i0.ɵɵreference(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showContentArea);\n  }\n}\nfunction _class30_ng_container_2_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class30_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class30_ng_container_2_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n    const _r4 = i0.ɵɵreference(6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n  }\n}\nfunction _class30_ng_container_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class30_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class30_ng_container_2_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n    i0.ɵɵtemplate(2, _class30_ng_container_2_ng_container_2_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    const _r2 = i0.ɵɵreference(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showContentArea);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\nconst _c24 = function (a0, a1, a2) {\n  return {\n    \"k-button-sm\": a0,\n    \"k-button-md\": a1,\n    \"k-button-lg\": a2\n  };\n};\nfunction _class30_ng_template_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12, 13);\n    i0.ɵɵlistener(\"tabScroll\", function _class30_ng_template_3_span_1_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.tabScroll.emit($event));\n    })(\"onClick\", function _class30_ng_template_3_span_1_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r23.onScrollButtonClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r14.scrollable)(\"tabPosition\", ctx_r14.tabPosition)(\"prev\", true)(\"title\", ctx_r14.localization.get(\"previousTabButton\"))(\"ngClass\", i0.ɵɵpureFunction3(5, _c24, ctx_r14.size === \"small\", ctx_r14.size === \"medium\" || !ctx_r14.size, ctx_r14.size === \"large\"));\n  }\n}\nfunction _class30_ng_template_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12, 14);\n    i0.ɵɵlistener(\"tabScroll\", function _class30_ng_template_3_span_2_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r25.tabScroll.emit($event));\n    })(\"onClick\", function _class30_ng_template_3_span_2_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r27.onScrollButtonClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r15.scrollable)(\"tabPosition\", ctx_r15.tabPosition)(\"prev\", false)(\"title\", ctx_r15.localization.get(\"nextTabButton\"))(\"ngClass\", i0.ɵɵpureFunction3(5, _c24, ctx_r15.size === \"small\", ctx_r15.size === \"medium\" || !ctx_r15.size, ctx_r15.size === \"large\"));\n  }\n}\nfunction _class30_ng_template_3_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r32 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"li\", 15, 16);\n    i0.ɵɵlistener(\"tabClose\", function _class30_ng_template_3_ng_container_5_Template_li_tabClose_1_listener($event) {\n      i0.ɵɵrestoreView(_r32);\n      const ctx_r31 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r31.tabClose.emit($event));\n    })(\"click\", function _class30_ng_template_3_ng_container_5_Template_li_click_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r32);\n      const i_r29 = restoredCtx.index;\n      const ctx_r33 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r33.onTabClick($event, i_r29));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const tab_r28 = ctx.$implicit;\n    const i_r29 = ctx.index;\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-first\", i_r29 === 0)(\"k-last\", i_r29 === ctx_r17.tabs.length - 1);\n    i0.ɵɵproperty(\"ngClass\", tab_r28.cssClass)(\"ngStyle\", tab_r28.cssStyle)(\"tab\", tab_r28)(\"index\", i_r29)(\"tabStripClosable\", ctx_r17.closable)(\"tabStripCloseIcon\", ctx_r17.closeIcon)(\"customTabstripCloseIcon\", ctx_r17.closeIconClass)(\"closeSVGIcon\", ctx_r17.closeSVGIcon)(\"id\", ctx_r17.getTabId(i_r29));\n    i0.ɵɵattribute(\"aria-controls\", ctx_r17.showContentArea && tab_r28.selected ? ctx_r17.getTabPanelId(i_r29) : undefined);\n  }\n}\nfunction _class30_ng_template_3_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12, 13);\n    i0.ɵɵlistener(\"tabScroll\", function _class30_ng_template_3_span_6_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r35.tabScroll.emit($event));\n    })(\"onClick\", function _class30_ng_template_3_span_6_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r37 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r37.onScrollButtonClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r18.scrollable)(\"tabPosition\", ctx_r18.tabPosition)(\"prev\", true)(\"title\", ctx_r18.localization.get(\"previousTabButton\"))(\"ngClass\", i0.ɵɵpureFunction3(5, _c24, ctx_r18.size === \"small\", ctx_r18.size === \"medium\" || !ctx_r18.size, ctx_r18.size === \"large\"));\n  }\n}\nfunction _class30_ng_template_3_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r40 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12, 14);\n    i0.ɵɵlistener(\"tabScroll\", function _class30_ng_template_3_span_7_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r39 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r39.tabScroll.emit($event));\n    })(\"onClick\", function _class30_ng_template_3_span_7_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r41 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r41.onScrollButtonClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r19.scrollable)(\"tabPosition\", ctx_r19.tabPosition)(\"prev\", false)(\"title\", ctx_r19.localization.get(\"nextTabButton\"))(\"ngClass\", i0.ɵɵpureFunction3(5, _c24, ctx_r19.size === \"small\", ctx_r19.size === \"medium\" || !ctx_r19.size, ctx_r19.size === \"large\"));\n  }\n}\nconst _c25 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    \"k-tabstrip-items-start\": a0,\n    \"k-tabstrip-items-center\": a1,\n    \"k-tabstrip-items-end\": a2,\n    \"k-tabstrip-items-stretched\": a3,\n    \"k-tabstrip-items-justify\": a4,\n    \"k-tabstrip-items-scroll\": a5\n  };\n};\nfunction _class30_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtemplate(1, _class30_ng_template_3_span_1_Template, 2, 9, \"span\", 8);\n    i0.ɵɵtemplate(2, _class30_ng_template_3_span_2_Template, 2, 9, \"span\", 8);\n    i0.ɵɵelementStart(3, \"ul\", 9, 10);\n    i0.ɵɵtemplate(5, _class30_ng_template_3_ng_container_5_Template, 3, 14, \"ng-container\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, _class30_ng_template_3_span_6_Template, 2, 9, \"span\", 8);\n    i0.ɵɵtemplate(7, _class30_ng_template_3_span_7_Template, 2, 9, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-tabstrip-items-wrapper-scroll\", ctx_r3.mouseScrollEnabled);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.itemsWrapperClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons.visible && ctx_r3.hasScrollButtons.position !== \"end\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons.visible && ctx_r3.hasScrollButtons.position === \"start\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction6(10, _c25, ctx_r3.tabAlignment === \"start\", ctx_r3.tabAlignment === \"center\", ctx_r3.tabAlignment === \"end\", ctx_r3.tabAlignment === \"stretched\", ctx_r3.tabAlignment === \"justify\", ctx_r3.mouseScrollEnabled));\n    i0.ɵɵattribute(\"aria-orientation\", ctx_r3.tabPosition === \"left\" || ctx_r3.tabPosition === \"right\" ? \"vertical\" : \"horizontal\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.tabs);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons.visible && ctx_r3.hasScrollButtons.position === \"end\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons.visible && ctx_r3.hasScrollButtons.position !== \"start\");\n  }\n}\nfunction _class30_ng_template_5_ng_template_0_div_0_ng_template_1_Template(rf, ctx) {}\nfunction _class30_ng_template_5_ng_template_0_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 19);\n    i0.ɵɵtemplate(1, _class30_ng_template_5_ng_template_0_div_0_ng_template_1_Template, 0, 0, \"ng-template\", 20);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext();\n    const tab_r43 = ctx_r47.$implicit;\n    const i_r44 = ctx_r47.index;\n    const ctx_r45 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"@state\", tab_r43.selected && ctx_r45.animate ? \"active\" : \"inactive\")(\"ngClass\", !ctx_r45.keepTabContent || tab_r43.selected ? \"k-tabstrip-content k-active\" : \"k-tabstrip-content\")(\"tabIndex\", 0)(\"id\", ctx_r45.getTabPanelId(i_r44));\n    i0.ɵɵattribute(\"aria-hidden\", !tab_r43.selected)(\"aria-labelledby\", ctx_r45.getTabId(i_r44))(\"aria-disabled\", tab_r43.disabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r43.tabContent == null ? null : tab_r43.tabContent.templateRef);\n  }\n}\nfunction _class30_ng_template_5_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class30_ng_template_5_ng_template_0_div_0_Template, 2, 8, \"div\", 18);\n  }\n  if (rf & 2) {\n    const tab_r43 = ctx.$implicit;\n    const ctx_r42 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", tab_r43.selected || ctx_r42.keepTabContent);\n  }\n}\nfunction _class30_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class30_ng_template_5_ng_template_0_Template, 1, 1, \"ng-template\", 17);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r5.tabs);\n  }\n}\nfunction _class30_kendo_resize_sensor_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r49 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 21);\n    i0.ɵɵlistener(\"resize\", function _class30_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r49);\n      const ctx_r48 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r48.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class30_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 22);\n  }\n}\nconst _c26 = [\"kendoDrawerItem\", \"\"];\nfunction _class38_0_ng_template_0_Template(rf, ctx) {}\nconst _c27 = function (a0, a1, a2, a3) {\n  return {\n    $implicit: a0,\n    isItemExpanded: a1,\n    hasChildren: a2,\n    level: a3\n  };\n};\nfunction _class38_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_0_ng_template_0_Template, 0, 0, \"ng-template\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c27, ctx_r0.item, ctx_r0.viewItem.isExpanded, ctx_r0.viewItem.hasChildren, ctx_r0.viewItem.level));\n  }\n}\nfunction _class38_ng_template_1_ng_container_0_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"name\", ctx_r6.iconClasses)(\"customFontClass\", ctx_r6.customIconClasses)(\"svgIcon\", ctx_r6.item.svgIcon)(\"innerCssClass\", ctx_r6.innerCssClasses);\n  }\n}\nfunction _class38_ng_template_1_ng_container_0_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 9);\n  }\n}\nfunction _class38_ng_template_1_ng_container_0_kendo_icon_wrapper_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"name\", ctx_r8.viewItem.isExpanded ? \"arrow-chevron-up\" : \"arrow-chevron-down\")(\"svgIcon\", ctx_r8.viewItem.isExpanded ? ctx_r8.arrowUpIcon : ctx_r8.arrowDownIcon);\n  }\n}\nfunction _class38_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class38_ng_template_1_ng_container_0_kendo_icon_wrapper_1_Template, 1, 4, \"kendo-icon-wrapper\", 4);\n    i0.ɵɵelementStart(2, \"span\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, _class38_ng_template_1_ng_container_0_span_4_Template, 1, 0, \"span\", 6);\n    i0.ɵɵtemplate(5, _class38_ng_template_1_ng_container_0_kendo_icon_wrapper_5_Template, 1, 2, \"kendo-icon-wrapper\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.item.icon || ctx_r4.item.iconClass || ctx_r4.item.svgIcon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.item.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.viewItem.hasChildren);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.viewItem.hasChildren);\n  }\n}\nfunction _class38_ng_template_1_ng_container_1_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"name\", ctx_r9.iconClasses)(\"customFontClass\", ctx_r9.customIconClasses)(\"svgIcon\", ctx_r9.item.svgIcon)(\"innerCssClass\", ctx_r9.innerCssClasses);\n  }\n}\nfunction _class38_ng_template_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class38_ng_template_1_ng_container_1_kendo_icon_wrapper_1_Template, 1, 4, \"kendo-icon-wrapper\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.item.icon || ctx_r5.item.iconClass || ctx_r5.item.svgIcon);\n  }\n}\nfunction _class38_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_ng_template_1_ng_container_0_Template, 6, 4, \"ng-container\", 3);\n    i0.ɵɵtemplate(1, _class38_ng_template_1_ng_container_1_Template, 2, 1, \"ng-container\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.expanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.mini && !ctx_r2.expanded);\n  }\n}\nconst _c28 = [\"kendoDrawerList\", \"\"];\nfunction _class39_ng_container_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"li\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    const v_r1 = ctx_r5.$implicit;\n    const idx_r2 = ctx_r5.index;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"k-drawer-item \", ctx_r3.expanded ? \" k-level-\" + v_r1.level : \"\", \"\");\n    i0.ɵɵproperty(\"viewItem\", v_r1)(\"index\", idx_r2)(\"mini\", ctx_r3.mini)(\"expanded\", ctx_r3.expanded)(\"itemTemplate\", ctx_r3.itemTemplate)(\"ngClass\", v_r1.item.cssClass)(\"ngStyle\", v_r1.item.cssStyle)(\"tabindex\", v_r1.index === 0 ? \"0\" : \"-1\");\n    i0.ɵɵattribute(\"data-kendo-drawer-index\", v_r1.index);\n  }\n}\nfunction _class39_ng_container_0_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 4);\n    i0.ɵɵtext(1, \" \\xA0 \");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const v_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", v_r1.item.cssClass)(\"ngStyle\", v_r1.item.cssStyle);\n  }\n}\nfunction _class39_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class39_ng_container_0_li_1_Template, 1, 12, \"li\", 1);\n    i0.ɵɵtemplate(2, _class39_ng_container_0_li_2_Template, 2, 2, \"li\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const v_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !v_r1.item.separator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", v_r1.item.separator);\n  }\n}\nfunction _class40_div_0_ng_container_1_1_ng_template_0_Template(rf, ctx) {}\nfunction _class40_div_0_ng_container_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class40_div_0_ng_container_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.headerTemplate == null ? null : ctx_r4.headerTemplate.templateRef);\n  }\n}\nfunction _class40_div_0_ng_container_1_3_ng_template_0_Template(rf, ctx) {}\nfunction _class40_div_0_ng_container_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class40_div_0_ng_container_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.footerTemplate == null ? null : ctx_r5.footerTemplate.templateRef);\n  }\n}\nfunction _class40_div_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class40_div_0_ng_container_1_1_Template, 1, 1, null, 3);\n    i0.ɵɵelementStart(2, \"ul\", 4);\n    i0.ɵɵlistener(\"select\", function _class40_div_0_ng_container_1_Template_ul_select_2_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r8.onSelect($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class40_div_0_ng_container_1_3_Template, 1, 1, null, 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"mini\", ctx_r2.mini)(\"expanded\", ctx_r2.expanded)(\"view\", ctx_r2.viewItems)(\"itemTemplate\", ctx_r2.itemTemplate == null ? null : ctx_r2.itemTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.footerTemplate);\n  }\n}\nfunction _class40_div_0_2_ng_template_0_Template(rf, ctx) {}\nfunction _class40_div_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class40_div_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.drawerTemplate == null ? null : ctx_r3.drawerTemplate.templateRef);\n  }\n}\nfunction _class40_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, _class40_div_0_ng_container_1_Template, 4, 6, \"ng-container\", 3);\n    i0.ɵɵtemplate(2, _class40_div_0_2_Template, 1, 1, null, 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.drawerWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.drawerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.drawerTemplate);\n  }\n}\nfunction _class40_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n}\nfunction _class41_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function _class41_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.closeDrawer());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c29 = [\"stepLink\"];\nconst _c30 = [\"kendoStepperStep\", \"\"];\nfunction _class49_2_ng_template_0_Template(rf, ctx) {}\nconst _c31 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    index: a1\n  };\n};\nfunction _class49_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class49_2_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.stepTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r1.step, ctx_r1.index));\n  }\n}\nfunction _class49_ng_container_3_span_1_1_ng_template_0_Template(rf, ctx) {}\nfunction _class49_ng_container_3_span_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class49_ng_container_3_span_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.indicatorTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r6.step, ctx_r6.index));\n  }\n}\nfunction _class49_ng_container_3_span_1_ng_container_2_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", ctx_r9.indicatorIconClass)(\"customFontClass\", ctx_r9.customIndicatorIconClass)(\"svgIcon\", ctx_r9.SVGIndicatorIcon);\n  }\n}\nfunction _class49_ng_container_3_span_1_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r10.indicatorText);\n  }\n}\nfunction _class49_ng_container_3_span_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class49_ng_container_3_span_1_ng_container_2_kendo_icon_wrapper_1_Template, 1, 3, \"kendo-icon-wrapper\", 7);\n    i0.ɵɵtemplate(2, _class49_ng_container_3_span_1_ng_container_2_span_2_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.showIndicatorIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.showIndicatorIcon);\n  }\n}\nfunction _class49_ng_container_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtemplate(1, _class49_ng_container_3_span_1_1_Template, 1, 5, null, 2);\n    i0.ɵɵtemplate(2, _class49_ng_container_3_span_1_ng_container_2_Template, 3, 2, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"transition-duration\", ctx_r4.transitionDuration, \"ms\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.indicatorTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.indicatorTemplate);\n  }\n}\nfunction _class49_ng_container_3_span_2_1_ng_template_0_Template(rf, ctx) {}\nfunction _class49_ng_container_3_span_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class49_ng_container_3_span_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r11.labelTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r11.step, ctx_r11.index));\n  }\n}\nfunction _class49_ng_container_3_span_2_ng_container_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r14.step.label);\n  }\n}\nfunction _class49_ng_container_3_span_2_ng_container_2_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 16);\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", ctx_r15.validationIconClasses)(\"customFontClass\", ctx_r15.customValidationIconClasses)(\"svgIcon\", ctx_r15.validationSVGIcon);\n  }\n}\nfunction _class49_ng_container_3_span_2_ng_container_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 17);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\"(\", ctx_r16.optionalText, \")\");\n  }\n}\nfunction _class49_ng_container_3_span_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class49_ng_container_3_span_2_ng_container_2_span_1_Template, 2, 1, \"span\", 12);\n    i0.ɵɵtemplate(2, _class49_ng_container_3_span_2_ng_container_2_kendo_icon_wrapper_2_Template, 1, 3, \"kendo-icon-wrapper\", 13);\n    i0.ɵɵtemplate(3, _class49_ng_container_3_span_2_ng_container_2_span_3_Template, 2, 1, \"span\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.showLabelText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.showLabelIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.step.optional);\n  }\n}\nfunction _class49_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtemplate(1, _class49_ng_container_3_span_2_1_Template, 1, 5, null, 2);\n    i0.ɵɵtemplate(2, _class49_ng_container_3_span_2_ng_container_2_Template, 4, 3, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.labelTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.labelTemplate);\n  }\n}\nfunction _class49_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class49_ng_container_3_span_1_Template, 3, 4, \"span\", 4);\n    i0.ɵɵtemplate(2, _class49_ng_container_3_span_2_Template, 3, 2, \"span\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.showIndicator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.showLabel);\n  }\n}\nconst _c32 = [\"kendoStepperList\", \"\"];\nfunction _class50_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"li\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const step_r1 = ctx.$implicit;\n    const idx_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"max-width\", ctx_r0.maxStepWidth, \"%\")(\"max-height\", ctx_r0.maxStepHeight, \"%\");\n    i0.ɵɵclassProp(\"k-step-first\", idx_r2 === 0)(\"k-step-last\", idx_r2 === ctx_r0.steps.length - 1)(\"k-step-done\", idx_r2 < ctx_r0.currentStep)(\"k-step-current\", idx_r2 === ctx_r0.currentStep)(\"k-step-optional\", step_r1.optional)(\"k-disabled\", step_r1.disabled)(\"k-focus\", idx_r2 === ctx_r0.focusedStep || !ctx_r0.isPresent(ctx_r0.focusedStep) && idx_r2 === ctx_r0.currentStep);\n    i0.ɵɵproperty(\"type\", ctx_r0.stepType)(\"step\", step_r1)(\"index\", idx_r2)(\"current\", ctx_r0.currentStep)(\"successIcon\", ctx_r0.successIcon)(\"successSVGIcon\", ctx_r0.successSVGIcon)(\"errorIcon\", ctx_r0.errorIcon)(\"errorSVGIcon\", ctx_r0.errorSVGIcon)(\"svgIcon\", ctx_r0.svgIcon)(\"indicatorTemplate\", ctx_r0.indicatorTemplate)(\"labelTemplate\", ctx_r0.labelTemplate)(\"stepTemplate\", ctx_r0.stepTemplate)(\"ngClass\", step_r1.cssClass)(\"ngStyle\", step_r1.cssStyle);\n    i0.ɵɵattribute(\"data-kendo-stepper-index\", idx_r2);\n  }\n}\nconst _c35 = function () {\n  return {\n    position: \"start\",\n    visible: false\n  };\n};\nfunction _class53_kendo_progressbar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-progressbar\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"animation\", ctx_r0.progressAnimation)(\"max\", ctx_r0.steps.length - 1)(\"label\", i0.ɵɵpureFunction0(8, _c35))(\"orientation\", ctx_r0.orientation)(\"reverse\", !ctx_r0.isHorizontal)(\"value\", ctx_r0.currentStep)(\"ngStyle\", ctx_r0.progressBarStyling);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\nfunction _class58_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"customAvatar\"]);\n  }\n}\nfunction _class58_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 2);\n    i0.ɵɵelement(2, \"img\", 3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵpropertyInterpolate(\"src\", ctx_r1.imageSrc, i0.ɵɵsanitizeUrl);\n    i0.ɵɵproperty(\"alt\", ctx_r1.textFor(\"avatarAlt\"))(\"ngStyle\", ctx_r1.cssStyle);\n  }\n}\nfunction _class58_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 4);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.cssStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.initials.substring(0, 2));\n  }\n}\nfunction _class58_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 5);\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r3.cssStyle)(\"name\", ctx_r3.icon)(\"customFontClass\", ctx_r3.iconClass)(\"svgIcon\", ctx_r3.svgIcon);\n  }\n}\nfunction _class64_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!actionsArray && !actionsTemplate\"]);\n  }\n}\nfunction _class64_ng_container_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function _class64_ng_container_1_button_1_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r6);\n      const action_r4 = restoredCtx.$implicit;\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r5.onClick(action_r4));\n    });\n    i0.ɵɵelementStart(1, \"span\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const action_r4 = ctx.$implicit;\n    i0.ɵɵclassProp(\"k-button-solid\", !action_r4.flat)(\"k-button-flat\", action_r4.flat)(\"k-button-solid-base\", !action_r4.primary && !action_r4.flat)(\"k-button-solid-primary\", action_r4.primary && !action_r4.flat)(\"k-button-flat-base\", !action_r4.primary && action_r4.flat)(\"k-button-flat-primary\", action_r4.primary && action_r4.flat);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(action_r4.text);\n  }\n}\nfunction _class64_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class64_ng_container_1_button_1_Template, 3, 13, \"button\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.actionsArray);\n  }\n}\nfunction _class64_2_ng_template_0_Template(rf, ctx) {}\nfunction _class64_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class64_2_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.actionsTemplate);\n  }\n}\nconst _c38 = [\"content\"];\nfunction _class72_ng_container_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r4.title);\n  }\n}\nfunction _class72_ng_container_2_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.subtitle, \" \");\n  }\n}\nfunction _class72_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class72_ng_container_2_div_1_Template, 2, 1, \"div\", 8);\n    i0.ɵɵelement(2, \"span\", 9);\n    i0.ɵɵtemplate(3, _class72_ng_container_2_div_3_Template, 2, 1, \"div\", 10);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.subtitle);\n  }\n}\nfunction _class72_3_ng_template_0_Template(rf, ctx) {}\nfunction _class72_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class72_3_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.titleTemplate == null ? null : ctx_r2.titleTemplate.templateRef);\n  }\n}\nfunction _class79_kendo_tilelayout_item_header_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-tilelayout-item-header\")(1, \"h5\", 1);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r0.titleId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\nfunction _class79_ng_container_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n  }\n  if (rf & 2) {\n    const dir_r3 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMapInterpolate1(\"k-resize-handle k-cursor-\", dir_r3, \"-resize\");\n    i0.ɵɵproperty(\"rtl\", ctx_r2.rtl)(\"resizeDirection\", dir_r3);\n  }\n}\nfunction _class79_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class79_ng_container_2_div_1_Template, 1, 5, \"div\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.resizeDirections);\n  }\n}\nconst _c39 = [\"hint\"];\nfunction _class80_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n  }\n}\nconst _c40 = [\"callout\"];\nfunction _class91_div_3_2_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0, \" > \");\n  }\n}\nfunction _class91_div_3_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class91_div_3_2_ng_template_0_Template, 1, 0, \"ng-template\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.headerTemplate == null ? null : ctx_r2.headerTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r2.event, ctx_r2.index));\n  }\n}\nfunction _class91_div_3_div_3_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 12);\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"icon\", ctx_r8.calloutFontIcon)(\"svgIcon\", ctx_r8.calloutSvgIcon);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\nfunction _class91_div_3_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"span\", 10);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class91_div_3_div_3_button_3_Template, 1, 3, \"button\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.event.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.collapsible && ctx_r3.orientation === \"vertical\");\n  }\n}\nfunction _class91_div_3_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r4.event.subtitle);\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0, \" > \");\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class91_div_3_kendo_card_body_5_1_ng_template_0_Template, 1, 0, \"ng-template\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.bodyTemplate == null ? null : ctx_r9.bodyTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r9.event, ctx_r9.index));\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_div_2_p_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"p\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r12.event.description);\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_div_2_ng_container_2_img_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 19);\n  }\n  if (rf & 2) {\n    const image_r14 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"src\", image_r14.src, i0.ɵɵsanitizeUrl)(\"alt\", image_r14.alt);\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_div_2_ng_container_2_img_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 20);\n  }\n  if (rf & 2) {\n    const image_r14 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"src\", image_r14.src, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class91_div_3_kendo_card_body_5_div_2_ng_container_2_img_1_Template, 1, 2, \"img\", 17);\n    i0.ɵɵtemplate(2, _class91_div_3_kendo_card_body_5_div_2_ng_container_2_img_2_Template, 1, 1, \"img\", 18);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const image_r14 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", image_r14.alt);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !image_r14.alt);\n  }\n}\nfunction _class91_div_3_kendo_card_body_5_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, _class91_div_3_kendo_card_body_5_div_2_p_1_Template, 2, 1, \"p\", 5);\n    i0.ɵɵtemplate(2, _class91_div_3_kendo_card_body_5_div_2_ng_container_2_Template, 3, 2, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.event.description);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r10.event.images);\n  }\n}\nconst _c41 = function (a0) {\n  return {\n    animationDuration: a0\n  };\n};\nconst _c42 = function (a0, a1) {\n  return {\n    value: a0,\n    params: a1\n  };\n};\nfunction _class91_div_3_kendo_card_body_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-card-body\");\n    i0.ɵɵlistener(\"@toggle.start\", function _class91_div_3_kendo_card_body_5_Template_kendo_card_body_animation_toggle_start_0_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r19.animationStart());\n    })(\"@toggle.done\", function _class91_div_3_kendo_card_body_5_Template_kendo_card_body_animation_toggle_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.animationDone($event));\n    });\n    i0.ɵɵtemplate(1, _class91_div_3_kendo_card_body_5_1_Template, 1, 5, null, 5);\n    i0.ɵɵtemplate(2, _class91_div_3_kendo_card_body_5_div_2_Template, 3, 2, \"div\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"@toggle\", i0.ɵɵpureFunction2(5, _c42, ctx_r5.expanded ? \"expanded\" : \"collapsed\", i0.ɵɵpureFunction1(3, _c41, ctx_r5.animationDuration || 0)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.bodyTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.bodyTemplate);\n  }\n}\nfunction _class91_div_3_kendo_card_actions_6_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0, \" > \");\n  }\n}\nfunction _class91_div_3_kendo_card_actions_6_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class91_div_3_kendo_card_actions_6_1_ng_template_0_Template, 1, 0, \"ng-template\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.actionsTemplate == null ? null : ctx_r22.actionsTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c31, ctx_r22.event, ctx_r22.index));\n  }\n}\nfunction _class91_div_3_kendo_card_actions_6_ng_container_2_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 22);\n    i0.ɵɵlistener(\"click\", function _class91_div_3_kendo_card_actions_6_ng_container_2_a_1_Template_a_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext(4);\n      return i0.ɵɵresetView(ctx_r27.onActionClick($event));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const action_r26 = ctx.$implicit;\n    i0.ɵɵproperty(\"href\", action_r26.url, i0.ɵɵsanitizeUrl)(\"target\", action_r26.target === \"blank\" ? \"_blank\" : \"_self\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", action_r26.text, \" \");\n  }\n}\nfunction _class91_div_3_kendo_card_actions_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class91_div_3_kendo_card_actions_6_ng_container_2_a_1_Template, 2, 3, \"a\", 21);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r23.event.actions);\n  }\n}\nfunction _class91_div_3_kendo_card_actions_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-card-actions\");\n    i0.ɵɵtemplate(1, _class91_div_3_kendo_card_actions_6_1_Template, 1, 5, null, 5);\n    i0.ɵɵtemplate(2, _class91_div_3_kendo_card_actions_6_ng_container_2_Template, 2, 1, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"@toggle\", i0.ɵɵpureFunction2(5, _c42, ctx_r6.expanded ? \"expanded\" : \"collapsed\", i0.ɵɵpureFunction1(3, _c41, ctx_r6.animationDuration || 0)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.actionsTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.actionsTemplate);\n  }\n}\nfunction _class91_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"kendo-card-header\");\n    i0.ɵɵtemplate(2, _class91_div_3_2_Template, 1, 5, null, 5);\n    i0.ɵɵtemplate(3, _class91_div_3_div_3_Template, 4, 2, \"div\", 6);\n    i0.ɵɵtemplate(4, _class91_div_3_div_4_Template, 2, 1, \"div\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class91_div_3_kendo_card_body_5_Template, 3, 8, \"kendo-card-body\", 5);\n    i0.ɵɵtemplate(6, _class91_div_3_kendo_card_actions_6_Template, 3, 8, \"kendo-card-actions\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.event.description || ctx_r1.event.images);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.event.actions);\n  }\n}\nconst _c43 = function (a0) {\n  return {\n    \"height\": a0\n  };\n};\nconst _c44 = function (a0, a1, a2) {\n  return {\n    \"k-callout-n\": a0,\n    \"k-callout-w\": a1,\n    \"k-callout-e\": a2\n  };\n};\nconst _c45 = [\"track\"];\nconst _c46 = [\"scrollableTrack\"];\nconst _c47 = [\"card\"];\nconst _c48 = [\"trackCircle\"];\nconst _c49 = [\"trackFlag\"];\nfunction _class92_ng_container_7_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 13, 14)(2, \"span\", 15);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const event_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r6.tabStyle());\n    i0.ɵɵattribute(\"role\", \"none\")(\"aria-hidden\", true);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(event_r4.isFlag);\n  }\n}\nfunction _class92_ng_container_7_li_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 21);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"kendoDate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const event_r4 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind2(2, 1, event_r4.date, ctx_r11.dateFormat), \" \");\n  }\n}\nfunction _class92_ng_container_7_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 16, 17);\n    i0.ɵɵlistener(\"click\", function _class92_ng_container_7_li_2_Template_li_click_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const index_r5 = i0.ɵɵnextContext().index;\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.navigateToEvent(index_r5));\n    });\n    i0.ɵɵelementStart(2, \"div\", 18);\n    i0.ɵɵtemplate(3, _class92_ng_container_7_li_2_span_3_Template, 3, 4, \"span\", 19);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(4, \"span\", 20);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r7.tabStyle());\n    i0.ɵɵattribute(\"role\", \"tab\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.showDateLabels);\n  }\n}\nfunction _class92_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class92_ng_container_7_li_1_Template, 4, 4, \"li\", 11);\n    i0.ɵɵtemplate(2, _class92_ng_container_7_li_2_Template, 5, 3, \"li\", 12);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const event_r4 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", event_r4.isFlag);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !event_r4.isFlag);\n  }\n}\nconst _c50 = function () {\n  return {};\n};\nconst _c51 = function (a0) {\n  return {\n    visibility: a0\n  };\n};\nfunction _class92_ul_9_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 24, 25);\n    i0.ɵɵlistener(\"transitionend\", function _class92_ul_9_li_1_Template_li_transitionend_0_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r20.onTransitionEnd());\n    });\n    i0.ɵɵelement(2, \"kendo-timeline-card\", 26);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const index_r18 = ctx.index;\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"event\", ctx_r16.selectedCardIndex === index_r18 ? ctx_r16.selectedEvent : null)(\"expanded\", true)(\"collapsible\", ctx_r16.collapsibleEvents)(\"calloutStyle\", ctx_r16.selectedCardIndex === index_r18 ? ctx_r16.calloutStyle : i0.ɵɵpureFunction0(12, _c50))(\"ngStyle\", i0.ɵɵpureFunction1(13, _c51, ctx_r16.selectedCardIndex === index_r18 ? \"visible\" : \"hidden\"))(\"tabIndex\", ctx_r16.selectedCardIndex === index_r18 ? \"0\" : \"-1\")(\"navigable\", ctx_r16.navigable)(\"index\", ctx_r16.selectedEventIndex)(\"headerTemplate\", ctx_r16.headerTemplate)(\"bodyTemplate\", ctx_r16.bodyTemplate)(\"actionsTemplate\", ctx_r16.actionsTemplate)(\"eventHeight\", ctx_r16.eventHeight);\n  }\n}\nconst _c52 = function () {\n  return {\n    \"transform-origin\": \"left top\"\n  };\n};\nfunction _class92_ul_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ul\", 22);\n    i0.ɵɵlistener(\"@eventsSlide.done\", function _class92_ul_9_Template_ul_animation_eventsSlide_done_0_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r22.onSlideDone());\n    });\n    i0.ɵɵtemplate(1, _class92_ul_9_li_1_Template, 3, 15, \"li\", 23);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@eventsSlide\", i0.ɵɵpureFunction2(5, _c42, ctx_r3.animationState, i0.ɵɵpureFunction1(3, _c41, ctx_r3.animationDuration || 0)))(\"ngStyle\", i0.ɵɵpureFunction0(8, _c52));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.eventsInInterval);\n  }\n}\nconst _c53 = function (a0) {\n  return {\n    transformValue: a0\n  };\n};\nconst _c54 = [\"dateWrap\"];\nconst _c55 = [\"innerDate\"];\nfunction _class93_ul_0_ng_container_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 10)(1, \"span\", 11);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const event_r2 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(event_r2.flag);\n  }\n}\nfunction _class93_ul_0_ng_container_1_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12, 13);\n    i0.ɵɵtext(2);\n    i0.ɵɵpipe(3, \"kendoDate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const event_r2 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind2(3, 1, event_r2.date, ctx_r6.dateFormat), \" \");\n  }\n}\nconst _c56 = function (a0) {\n  return {\n    \"k-reverse\": a0\n  };\n};\nfunction _class93_ul_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class93_ul_0_ng_container_1_li_1_Template, 3, 1, \"li\", 2);\n    i0.ɵɵelementStart(2, \"li\", 3)(3, \"div\", 4, 5);\n    i0.ɵɵtemplate(5, _class93_ul_0_ng_container_1_span_5_Template, 4, 4, \"span\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(6, \"span\", 7)(7, \"kendo-timeline-card\", 8, 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const event_r2 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", event_r2.flag);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(15, _c56, ctx_r1.alterMode && i_r3 % 2 === 0));\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showDateLabels);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"event\", event_r2)(\"expanded\", event_r2.expanded || !ctx_r1.collapsibleEvents)(\"collapsible\", ctx_r1.collapsibleEvents)(\"reversed\", ctx_r1.alterMode && i_r3 % 2 === 0)(\"tabIndex\", \"0\")(\"navigable\", ctx_r1.navigable)(\"animationDuration\", ctx_r1.animationDuration)(\"headerTemplate\", ctx_r1.headerTemplate)(\"bodyTemplate\", ctx_r1.bodyTemplate)(\"actionsTemplate\", ctx_r1.actionsTemplate)(\"index\", i_r3)(\"eventWidth\", ctx_r1.eventWidth);\n  }\n}\nfunction _class93_ul_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ul\");\n    i0.ɵɵtemplate(1, _class93_ul_0_ng_container_1_Template, 9, 17, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.events);\n  }\n}\nfunction _class95_kendo_timeline_vertical_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-timeline-vertical\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"events\", ctx_r0.events)(\"alterMode\", ctx_r0.alterMode)(\"collapsibleEvents\", ctx_r0.collapsibleEvents)(\"navigable\", ctx_r0.navigable)(\"showDateLabels\", ctx_r0.showDateLabels)(\"animationDuration\", ctx_r0.animationDuration)(\"eventWidth\", ctx_r0.eventWidth)(\"dateFormat\", ctx_r0.dateFormat)(\"headerTemplate\", ctx_r0.headerTemplate)(\"bodyTemplate\", ctx_r0.bodyTemplate)(\"actionsTemplate\", ctx_r0.actionsTemplate);\n  }\n}\nfunction _class95_kendo_timeline_horizontal_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-timeline-horizontal\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"events\", ctx_r1.events)(\"collapsibleEvents\", false)(\"navigable\", ctx_r1.navigable)(\"showDateLabels\", ctx_r1.showDateLabels)(\"animationDuration\", ctx_r1.animationDuration)(\"eventHeight\", ctx_r1.eventHeight)(\"dateFormat\", ctx_r1.dateFormat)(\"headerTemplate\", ctx_r1.headerTemplate)(\"bodyTemplate\", ctx_r1.bodyTemplate)(\"actionsTemplate\", ctx_r1.actionsTemplate);\n  }\n}\nconst packageMetadata = {\n  name: '@progress/kendo-angular-layout',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163639,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n\n/**\n * Represents the expand modes of the PanelBar.\n * By default, the expand mode is set to `multiple`.\n */\nvar PanelBarExpandMode = /*#__PURE__*/function (PanelBarExpandMode) {\n  /**\n   * Allows you to expand only one item at a time.\n   * When you expand an item, the item that was previously expanded is coll.\n   */\n  PanelBarExpandMode[PanelBarExpandMode[\"Single\"] = 0] = \"Single\";\n  /**\n   * Allows you to expand only one item at a time and requires you to set the `height` property.\n   * The expanded area occupies the entire height of the PanelBar.\n   */\n  PanelBarExpandMode[PanelBarExpandMode[\"Full\"] = 1] = \"Full\";\n  /**\n   * The default mode of the PanelBar.\n   * Allows you to expand more than one item at a time. Items can also be toggled.\n   */\n  PanelBarExpandMode[PanelBarExpandMode[\"Multiple\"] = 2] = \"Multiple\";\n  /**\n   * By default, the expand mode is set to `multiple`.\n   */\n  PanelBarExpandMode[PanelBarExpandMode[\"Default\"] = 2] = \"Default\";\n  return PanelBarExpandMode;\n}(PanelBarExpandMode || {});\n/**\n * @hidden\n */\nlet nextPanelbarId = 0;\n/**\n * @hidden\n */\nlet PanelBarService = /*#__PURE__*/(() => {\n  var _class;\n  class PanelBarService {\n    onKeepContent(keepContent) {\n      this.keepContentSource.next(keepContent);\n    }\n    onSelect(event) {\n      this.childSource.next(event);\n    }\n    onFocus() {\n      this.parentSource.next(true);\n    }\n    onBlur() {\n      this.parentSource.next(false);\n    }\n    constructor() {\n      _defineProperty(this, \"children$\", void 0);\n      _defineProperty(this, \"keepContent$\", void 0);\n      _defineProperty(this, \"parent$\", void 0);\n      _defineProperty(this, \"pbId\", void 0);\n      _defineProperty(this, \"animate\", void 0);\n      _defineProperty(this, \"expandMode\", void 0);\n      _defineProperty(this, \"itemClick\", void 0);\n      _defineProperty(this, \"childSource\", void 0);\n      _defineProperty(this, \"keepContentSource\", void 0);\n      _defineProperty(this, \"parentSource\", void 0);\n      this.parentSource = new Subject();\n      this.keepContentSource = new BehaviorSubject(false);\n      this.childSource = new Subject();\n      this.itemClick = new Subject();\n      this.parent$ = this.parentSource.asObservable();\n      this.children$ = this.childSource.asObservable();\n      this.keepContent$ = this.keepContentSource.asObservable();\n      this.pbId = nextPanelbarId++;\n    }\n  }\n  _class = PanelBarService;\n  _defineProperty(PanelBarService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)();\n  });\n  _defineProperty(PanelBarService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return PanelBarService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the content template of the declaratively initialized PanelBar items.\n * The content can be expanded or collapsed through the item.\n */\nlet PanelBarContentDirective = /*#__PURE__*/(() => {\n  var _class2;\n  class PanelBarContentDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class2 = PanelBarContentDirective;\n  _defineProperty(PanelBarContentDirective, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(PanelBarContentDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class2,\n    selectors: [[\"\", \"kendoPanelBarContent\", \"\"]],\n    standalone: true\n  }));\n  return PanelBarContentDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template directive of the PanelBar which helps to customize the item title\n * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).\n *\n * > The `kendoPanelBarItemTitle` directive overrides the PanelBarItem [title]({% slug api_layout_panelbaritemcomponent %}#toc-title) option.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *        <kendo-panelbar>\n *            <kendo-panelbar-item [expanded]=\"true\">\n *                <ng-template kendoPanelBarItemTitle>\n *                    Item Title\n *                </ng-template>\n *            </kendo-panelbar-item>\n *        </kendo-panelbar>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nlet PanelBarItemTitleDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class PanelBarItemTitleDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class3 = PanelBarItemTitleDirective;\n  _defineProperty(PanelBarItemTitleDirective, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(PanelBarItemTitleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"\", \"kendoPanelBarItemTitle\", \"\"]],\n    standalone: true\n  }));\n  return PanelBarItemTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId$1 = 0;\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\nconst ROUNDNESS = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\nconst SHAPE_TO_ROUNDED = {\n  rounded: 'large',\n  circle: 'full'\n};\n/**\n * @hidden\n */\nconst parsePanelBarItems = data => {\n  return data.map(item => {\n    if (!isPresent(item.id)) {\n      item.id = `default-${nextId$1++}`;\n    }\n    if (item.children) {\n      item.children = parsePanelBarItems(item.children);\n    }\n    return item;\n  });\n};\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isHorizontalArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight;\n/**\n * @hidden\n */\nconst isVerticalArrowKey = keyCode => keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;\n/**\n * @hidden\n */\nconst isArrowKey = keyCode => isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);\n/**\n * @hidden\n */\nconst isNavigationKey = keyCode => keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''\n      };\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n */\nconst mapShapeToRounded = shape => SHAPE_TO_ROUNDED[shape] || 'none';\n/**\n * @hidden\n */\nconst isNumber = value => typeof value === 'number' && isFinite(value);\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabindex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n    return focusable;\n  }\n  return false;\n};\n/**\n * @hidden\n */\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find(name => name === className));\n/**\n * @hidden\n */\nconst closestInScope = (target, predicate, scope, targetAttr) => {\n  while (target && target !== scope && !predicate(target, targetAttr)) {\n    target = target.parentNode;\n  }\n  if (target !== scope) {\n    return target;\n  }\n};\n/**\n * @hidden\n */\nconst itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);\nconst hasItemIndex = (item, indexAttr) => isPresent(item.getAttribute(indexAttr));\n/**\n * @hidden\n */\nconst closestItem = (target, targetAttr, scope) => closestInScope(target, hasItemIndex, scope, targetAttr);\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @hidden\n */\nlet nextId = 0;\n/**\n * Represents the items of the PanelBar.\n */\nlet PanelBarItemComponent = /*#__PURE__*/(() => {\n  var _class4;\n  class PanelBarItemComponent {\n    /**\n     * Defines an SVGIcon to be rendered.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      if (isDevMode() && icon && this.icon && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    /**\n     * Defines the location of the image that will be displayed next to the title\n     * ([see example]({% slug items_panelbar %}#toc-title-images)).\n     */\n\n    /**\n     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).\n     */\n    set expanded(value) {\n      const activeState = this.animate ? \"active\" : \"activeWithoutAnimation\";\n      this.state = value ? activeState : \"inactive\";\n      if (!this.keepContent) {\n        this.toggleExpandedChildAnimations(value);\n      }\n      this._expanded = value;\n    }\n    get expanded() {\n      return this._expanded;\n    }\n    /**\n     * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).\n     */\n\n    get animate() {\n      return this.eventService.animate;\n    }\n    get kStateExpandedClass() {\n      return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);\n    }\n    get itemId() {\n      return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;\n    }\n    get ariaExpanded() {\n      return this.hasChildItems || this.hasContent ? !this.disabled && this.expanded : null;\n    }\n    get ariaSelected() {\n      return !this.disabled && this.selected;\n    }\n    get ariaDisabled() {\n      return this.disabled ? true : null;\n    }\n    get headerClass() {\n      return this.parent ? null : true;\n    }\n    /**\n     * @hidden\n     */\n    get titleTemplate() {\n      return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;\n    }\n    constructor(parent, eventService, element, renderer) {\n      _defineProperty(this, \"parent\", void 0);\n      _defineProperty(this, \"eventService\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      /**\n       * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Allows the component to set the `\"id\"` property to each item.\n       * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.\n       */\n      _defineProperty(this, \"id\", `default-${nextId++}`);\n      /**\n       * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).\n       */\n      _defineProperty(this, \"icon\", '');\n      /**\n       * Defines  the icon that will be rendered next to the title by using a custom CSS class\n       * ([see example]({% slug items_panelbar %}#toc-title-icons)).\n       */\n      _defineProperty(this, \"iconClass\", '');\n      _defineProperty(this, \"imageUrl\", '');\n      /**\n       * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).\n       */\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"selected\", false);\n      /**\n       * Sets the content of the PanelBar item.\n       * By design, it is used when the\n       * [items]({% slug api_layout_panelbarcomponent %}#toc-items)\n       * property of the PanelBar is set.\n       */\n      _defineProperty(this, \"content\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"items\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"header\", void 0);\n      _defineProperty(this, \"contentWrapper\", void 0);\n      _defineProperty(this, \"contentHeight\", void 0);\n      _defineProperty(this, \"contentOverflow\", void 0);\n      _defineProperty(this, \"keepContent\", false);\n      _defineProperty(this, \"childrenItems\", void 0);\n      _defineProperty(this, \"hasChildItems\", false);\n      _defineProperty(this, \"hasItems\", false);\n      _defineProperty(this, \"hasContent\", false);\n      _defineProperty(this, \"state\", \"inactive\");\n      _defineProperty(this, \"role\", \"treeitem\");\n      _defineProperty(this, \"titleAttribute\", null);\n      // eslint-disable-line\n      _defineProperty(this, \"kItemClass\", true);\n      _defineProperty(this, \"viewChildItems\", void 0);\n      _defineProperty(this, \"contentItems\", void 0);\n      //ContentChild does not support descendants property, so we use ContentChildren for contentTemplate instead\n      _defineProperty(this, \"contentTemplate\", void 0);\n      _defineProperty(this, \"titleTemplates\", void 0);\n      _defineProperty(this, \"focused\", false);\n      _defineProperty(this, \"wrapperFocused\", false);\n      _defineProperty(this, \"subscriptions\", new Subscription(() => {}));\n      _defineProperty(this, \"_expanded\", false);\n      _defineProperty(this, \"level\", void 0);\n      _defineProperty(this, \"_svgIcon\", void 0);\n      this.parent = parent;\n      this.eventService = eventService;\n      this.element = element;\n      this.renderer = renderer;\n      this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));\n      this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));\n      this.wrapperFocused = parent ? parent.focused : false;\n      this.level = this.parent ? this.parent.level + 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n    headerHeight() {\n      return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);\n    }\n    ngOnInit() {\n      this.addLevelClass();\n    }\n    ngAfterContentChecked() {\n      this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;\n      this.hasChildItems = this.contentItems.filter(item => item !== this).length > 0 || this.hasItems;\n      this.hasContent = this.contentTemplate !== undefined && this.contentTemplate.length > 0 || this.content !== undefined;\n      this.validateConfiguration();\n    }\n    ngAfterViewChecked() {\n      if (this.items) {\n        this.childrenItems = this.viewChildItems.toArray();\n      } else {\n        this.childrenItems = this.contentItems.filter(item => item !== this);\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onItemAction() {\n      if (!this.disabled) {\n        this.eventService.onSelect(this);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(e) {\n      if (!isFocusable(e.target)) {\n        this.eventService.itemClick.next({\n          item: this.serialize(),\n          originalEvent: e\n        });\n        this.onItemAction();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get iconClasses() {\n      if (this.icon) {\n        return `${this.icon}`;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get customIconClasses() {\n      if (this.iconClass) {\n        return `${this.iconClass}`;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get dirInnerCssClasses() {\n      const dirClass = this.expanded ? 'k-panelbar-collapse' : 'k-panelbar-expand';\n      return `k-panelbar-toggle ${dirClass}`;\n    }\n    /**\n     * @hidden\n     */\n    get expanderSVGIcon() {\n      return this.expanded ? chevronUpIcon : chevronDownIcon;\n    }\n    /**\n     * @hidden\n     */\n    serialize() {\n      return {\n        content: this.content,\n        disabled: this.disabled,\n        expanded: this.expanded,\n        focused: this.focused,\n        icon: this.icon,\n        iconClass: this.iconClass,\n        svgIcon: this.svgIcon,\n        id: this.id,\n        imageUrl: this.imageUrl,\n        selected: this.selected,\n        title: this.title,\n        children: this.items\n      };\n    }\n    /**\n     * @hidden\n     */\n    subTreeViewItems() {\n      let subTree = [];\n      this.viewChildItems.forEach(item => {\n        subTree = subTree.concat(item.subTreeViewItems());\n        subTree.push(item);\n      });\n      return subTree;\n    }\n    /**\n     * @hidden\n     */\n    validateConfiguration() {\n      if (isDevMode()) {\n        if (this.content && this.contentTemplate !== undefined && this.contentTemplate.length > 0) {\n          throw new Error(\"Invalid configuration: mixed template components and component property.\");\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    toggleAnimationState(value) {\n      if (!this.animate) {\n        return;\n      }\n      this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';\n    }\n    /**\n     * @hidden\n     */\n    toggleExpandedChildAnimations(value) {\n      if (this.childrenItems) {\n        this.childrenItems.forEach(child => {\n          if (child.expanded) {\n            child.toggleAnimationState(value);\n            child.toggleExpandedChildAnimations(value);\n          }\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    addLevelClass() {\n      if (this.level >= 0) {\n        this.renderer.addClass(this.element.nativeElement, `k-level-${this.level}`);\n      }\n    }\n    onWrapperFocusChange(focused) {\n      this.wrapperFocused = focused;\n    }\n  }\n  _class4 = PanelBarItemComponent;\n  _defineProperty(PanelBarItemComponent, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵdirectiveInject(_class4, 13), i0.ɵɵdirectiveInject(PanelBarService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(PanelBarItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class4,\n    selectors: [[\"kendo-panelbar-item\"]],\n    contentQueries: function _class4_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, _class4, 4);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarContentDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemTitleDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItems = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleTemplates = _t);\n      }\n    },\n    viewQuery: function _class4_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_class4, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function _class4_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.itemId);\n        i0.ɵɵattribute(\"role\", ctx.role)(\"title\", ctx.titleAttribute)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-selected\", ctx.ariaSelected)(\"aria-disabled\", ctx.ariaDisabled);\n        i0.ɵɵclassProp(\"k-panelbar-item\", ctx.kItemClass)(\"k-expanded\", ctx.kStateExpandedClass)(\"k-panelbar-header\", ctx.headerClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      id: \"id\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      svgIcon: \"svgIcon\",\n      imageUrl: \"imageUrl\",\n      disabled: \"disabled\",\n      expanded: \"expanded\",\n      selected: \"selected\",\n      content: \"content\",\n      items: \"items\",\n      template: \"template\"\n    },\n    exportAs: [\"kendoPanelbarItem\"],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c7,\n    decls: 8,\n    vars: 14,\n    consts: [[3, \"click\"], [\"header\", \"\"], [\"innerCssClass\", \"k-panelbar-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-image k-panelbar-item-icon\", \"alt\", \"\", 3, \"src\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"name\", \"svgIcon\", \"innerCssClass\", 4, \"ngIf\"], [\"innerCssClass\", \"k-panelbar-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [\"alt\", \"\", 1, \"k-image\", \"k-panelbar-item-icon\", 3, \"src\"], [1, \"k-panelbar-item-text\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"name\", \"svgIcon\", \"innerCssClass\"], [\"contentWrapper\", \"\"], [\"class\", \"k-panelbar-group\", 3, \"overflow\", \"height\", 4, \"ngIf\"], [\"class\", \"k-panelbar-content\", 3, \"overflow\", \"height\", 4, \"ngIf\"], [1, \"k-panelbar-group\"], [1, \"k-panelbar-content\"], [4, \"ngFor\", \"ngForOf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\", 4, \"ngIf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\"], [3, \"ngIf\"]],\n    template: function _class4_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c6);\n        i0.ɵɵelementStart(0, \"span\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class4_Template_span_click_0_listener($event) {\n          return ctx.onItemClick($event);\n        });\n        i0.ɵɵtemplate(2, _class4_kendo_icon_wrapper_2_Template, 1, 3, \"kendo-icon-wrapper\", 2);\n        i0.ɵɵtemplate(3, _class4_img_3_Template, 1, 1, \"img\", 3);\n        i0.ɵɵtemplate(4, _class4_ng_container_4_Template, 3, 1, \"ng-container\", 4);\n        i0.ɵɵtemplate(5, _class4_5_Template, 1, 16, null, 4);\n        i0.ɵɵtemplate(6, _class4_kendo_icon_wrapper_6_Template, 1, 3, \"kendo-icon-wrapper\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, _class4_div_7_Template, 6, 7, \"div\", 4);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-link\", true)(\"k-selected\", !ctx.disabled && ctx.selected)(\"k-focus\", ctx.focused && ctx.wrapperFocused)(\"k-disabled\", ctx.disabled);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.iconClass || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasChildItems || ctx.hasContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.keepContent || !ctx.disabled && ctx.expanded && (ctx.hasChildItems || ctx.hasContent));\n      }\n    },\n    dependencies: [_class4, NgIf, IconWrapperComponent, NgTemplateOutlet, NgFor],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [state('inactive', style({\n        display: 'none'\n      })), transition('* => active', [style({\n        overflow: 'hidden',\n        display: 'block',\n        height: 0\n      }), animate(200, style({\n        height: AUTO_STYLE\n      }))]), transition('active => *', [style({\n        overflow: 'hidden',\n        height: AUTO_STYLE\n      }), animate(200, style({\n        height: 0,\n        display: 'none'\n      }))])])]\n    }\n  }));\n  return PanelBarItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template directive of the PanelBar which helps to customize the item content.\n */\nlet PanelBarItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class5;\n  class PanelBarItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class5 = PanelBarItemTemplateDirective;\n  _defineProperty(PanelBarItemTemplateDirective, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(PanelBarItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class5,\n    selectors: [[\"\", \"kendoPanelBarItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return PanelBarItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    _defineProperty(this, \"prevented\", false);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the `collapse` event of the PanelBar.\n */\nclass PanelBarCollapseEvent extends PreventableEvent {\n  constructor(...args) {\n    super(...args);\n    /**\n     * The item that will be collapsed.\n     */\n    _defineProperty(this, \"item\", void 0);\n  }\n}\n\n/**\n * Arguments for the `expand` event of the PanelBar.\n */\nclass PanelBarExpandEvent extends PreventableEvent {\n  constructor(...args) {\n    super(...args);\n    /**\n     * The item that will be expanded.\n     */\n    _defineProperty(this, \"item\", void 0);\n  }\n}\n\n/**\n * Arguments for the `select` event of the PanelBar.\n */\nclass PanelBarSelectEvent extends PreventableEvent {\n  constructor(...args) {\n    super(...args);\n    /**\n     * The item that will be selected.\n     */\n    _defineProperty(this, \"item\", void 0);\n  }\n}\n\n/**\n * Arguments for the `stateChange` event of the PanelBar.\n */\nclass PanelBarStateChangeEvent {\n  constructor() {\n    /**\n     * A collection of all modified items.\n     */\n    _defineProperty(this, \"items\", void 0);\n  }\n}\n\n/**\n * Arguments for the `itemClick` event of the PanelBar.\n */\nclass PanelBarItemClickEvent {\n  constructor() {\n    /**\n     * The clicked item.\n     */\n    _defineProperty(this, \"item\", void 0);\n    /**\n     * The DOM event that triggered the `itemClick` event.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n  }\n}\n\n/**\n * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).\n */\n// TODO: add styles as input prop\nlet PanelBarComponent = /*#__PURE__*/(() => {\n  var _class12;\n  class PanelBarComponent {\n    /**\n     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM\n     * ([see example]({% slug templates_panelbar %}#toc-collections)).\n     * By default, this option is set to `false`.\n     */\n    get keepItemContent() {\n      return this._keepItemContent;\n    }\n    set keepItemContent(keepItemContent) {\n      this._keepItemContent = keepItemContent;\n      this.eventService.onKeepContent(keepItemContent);\n    }\n    /**\n     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances\n     * ([see example]({% slug items_panelbar %})).\n     */\n    set items(data) {\n      if (data) {\n        this._items = parsePanelBarItems(data);\n      }\n    }\n    get items() {\n      return this._items;\n    }\n    /**\n     * Fires each time the user interacts with a PanelBar item\n     * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).\n     * The event data contains a collection of all items that are modified.\n     */\n\n    get hostHeight() {\n      return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';\n    }\n    get overflow() {\n      return this.expandMode === PanelBarExpandMode.Full ? 'hidden' : 'visible';\n    }\n    get dir() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    constructor(elementRef, eventService, localization) {\n      _defineProperty(this, \"localization\", void 0);\n      /**\n       * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).\n       *\n       * The available modes are:\n       * - `\"single\"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.\n       * - `\"multiple\"`&mdash;The default mode of the PanelBar.\n       * Expands more than one item at a time. Items can also be toggled.\n       * - `\"full\"`&mdash;Expands only one item at a time.\n       * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.\n       */\n      _defineProperty(this, \"expandMode\", PanelBarExpandMode.Default);\n      /**\n       * Allows the PanelBar to modify the selected state of the items.\n       */\n      _defineProperty(this, \"selectable\", true);\n      /**\n       * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).\n       */\n      _defineProperty(this, \"animate\", true);\n      /**\n       * Sets the height of the component when the `\"full\"` expand mode is used.\n       * This option is ignored in the `\"multiple\"` and `\"single\"` expand modes.\n       */\n      _defineProperty(this, \"height\", '400px');\n      _defineProperty(this, \"stateChange\", new EventEmitter());\n      /**\n       * Fires when an item is about to be selected.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will not be selected.\n       */\n      _defineProperty(this, \"select\", new EventEmitter());\n      /**\n       * Fires when an item is about to be expanded.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will remain collapsed.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when an item is about to be collapsed.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will remain expanded.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Fires when the user clicks an item ([see example]({% slug events_panelbar %})).\n       */\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"tabIndex\", 0);\n      _defineProperty(this, \"role\", 'tree');\n      _defineProperty(this, \"activeDescendant\", '');\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"contentItems\", void 0);\n      _defineProperty(this, \"contentChildItems\", void 0);\n      _defineProperty(this, \"viewChildItems\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"allItems\", void 0);\n      _defineProperty(this, \"childrenItems\", void 0);\n      _defineProperty(this, \"isViewInit\", true);\n      _defineProperty(this, \"focused\", false);\n      _defineProperty(this, \"_items\", void 0);\n      _defineProperty(this, \"_keepItemContent\", false);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"eventService\", void 0);\n      _defineProperty(this, \"keyBindings\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"updateChildrenHeight\", () => {\n        let childrenHeight = 0;\n        const panelbarHeight = this.elementRef.nativeElement.offsetHeight;\n        const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';\n        this.childrenItems.forEach(item => {\n          childrenHeight += item.headerHeight();\n        });\n        this.childrenItems.forEach(item => {\n          item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? panelbarHeight - childrenHeight + 'px' : 'auto';\n          item.contentOverflow = contentOverflow;\n        });\n      });\n      this.localization = localization;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      /* eslint-disable-line*/\n      this.keyBindings = this.computedKeys;\n      this.elementRef = elementRef;\n      this.eventService = eventService;\n      this.subs.add(this.eventService.children$.subscribe(event => this.onItemAction(event)));\n      this.subs.add(this.eventService.itemClick.subscribe(ev => this.itemClick.emit(ev)));\n    }\n    /**\n     * @hidden\n     */\n    invertKeys(original, inverted) {\n      return this.localization.rtl ? inverted : original;\n    }\n    get computedKeys() {\n      return {\n        [Keys.Space]: () => this.selectFocusedItem(),\n        [Keys.Enter]: () => this.selectFocusedItem(),\n        [Keys.ArrowUp]: () => this.focusPreviousItem(),\n        [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),\n        [Keys.ArrowDown]: () => this.focusNextItem(),\n        [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),\n        [Keys.End]: () => this.focusLastItem(),\n        [Keys.Home]: () => this.focusFirstItem()\n      };\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    ngOnInit() {\n      this.subs.add(this.localization.changes.subscribe(() => this.keyBindings = this.computedKeys));\n      this.eventService.animate = this.animate;\n      this.eventService.expandMode = this.expandMode;\n    }\n    ngAfterViewChecked() {\n      if (this.items) {\n        this.childrenItems = this.viewChildItems.toArray();\n        this.allItems = this.viewItems;\n      } else {\n        this.childrenItems = this.contentChildItems.toArray();\n        this.allItems = this.contentItems.toArray();\n      }\n      if (this.isViewInit && this.childrenItems.length) {\n        this.isViewInit = false;\n        setTimeout(() => this.updateChildrenHeight());\n      }\n      this.validateConfiguration();\n    }\n    ngOnChanges(changes) {\n      if (changes['height'] || changes['expandMode'] || changes['items']) {\n        // eslint-disable-line\n        if (this.childrenItems) {\n          setTimeout(this.updateChildrenHeight);\n        }\n      }\n      if (changes['animate']) {\n        this.eventService.animate = this.animate;\n      }\n      if (changes['expandMode']) {\n        this.eventService.expandMode = this.expandMode;\n      }\n    }\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    onComponentClick(event) {\n      const itemClicked = this.visibleItems().some(item => {\n        return item.header.nativeElement.contains(event.target);\n      });\n      if (!isFocusable(event.target) && !this.focused && itemClicked) {\n        this.elementRef.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onComponentFocus() {\n      this.eventService.onFocus();\n      this.focused = true;\n      if (this.allItems.length > 0) {\n        const visibleItems = this.visibleItems();\n        const focusedItems = visibleItems.filter(item => item.focused);\n        if (!focusedItems.length && visibleItems.length > 0) {\n          visibleItems[0].focused = true;\n          this.activeDescendant = visibleItems[0].itemId;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onComponentBlur() {\n      this.eventService.onBlur();\n      this.focused = false;\n      this.activeDescendant = '';\n    }\n    /**\n     * @hidden\n     */\n    onComponentKeyDown(event) {\n      if (event.target === this.elementRef.nativeElement) {\n        if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home || event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {\n          event.preventDefault();\n        }\n        const handler = this.keyBindings[event.keyCode];\n        //TODO: check if next item is disabled and skip operation?\n        if (handler) {\n          handler();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    emitEvent(event, item) {\n      let eventArgs;\n      switch (event) {\n        case 'select':\n          eventArgs = new PanelBarSelectEvent();\n          break;\n        case 'collapse':\n          eventArgs = new PanelBarCollapseEvent();\n          break;\n        default:\n          eventArgs = new PanelBarExpandEvent();\n          break;\n      }\n      eventArgs.item = item.serialize();\n      this[event].emit(eventArgs);\n      return eventArgs;\n    }\n    get viewItems() {\n      let treeItems = [];\n      this.viewChildItems.toArray().forEach(item => {\n        treeItems.push(item);\n        treeItems = treeItems.concat(item.subTreeViewItems());\n      });\n      return treeItems;\n    }\n    validateConfiguration() {\n      if (isDevMode()) {\n        if (this.items && this.contentItems && this.contentItems.length > 0) {\n          throw new Error('Invalid configuration: mixed template components and items property.');\n        }\n      }\n    }\n    onItemAction(item) {\n      if (!item) {\n        return;\n      }\n      const modifiedItems = new Array();\n      const selectPreventedItems = [];\n      this.allItems.forEach(currentItem => {\n        let selectedState = currentItem === item;\n        const focusedState = selectedState;\n        selectedState = this.selectable ? selectedState : currentItem.selected;\n        if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {\n          const isSelectPrevented = selectedState ? this.emitEvent('select', currentItem).isDefaultPrevented() : false;\n          if (!isSelectPrevented) {\n            currentItem.selected = selectedState;\n            currentItem.focused = focusedState;\n            this.activeDescendant = focusedState ? currentItem.itemId : '';\n            modifiedItems.push(currentItem);\n          } else {\n            selectPreventedItems.push(currentItem);\n          }\n        }\n      });\n      if (this.expandMode === PanelBarExpandMode.Multiple) {\n        if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {\n          const isEventPrevented = item.expanded ? this.emitEvent('collapse', item).isDefaultPrevented() : this.emitEvent('expand', item).isDefaultPrevented();\n          if (!isEventPrevented) {\n            item.expanded = !item.expanded;\n            if (modifiedItems.indexOf(item) < 0) {\n              modifiedItems.push(item);\n            }\n          }\n        }\n      } else {\n        const siblings = item.parent ? item.parent.childrenItems : this.childrenItems;\n        let preventedCollapseItem;\n        const expandedItems = [];\n        if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {\n          siblings.forEach(currentItem => {\n            const expandedState = currentItem === item;\n            if (currentItem.expanded !== expandedState) {\n              const isEventPrevented = currentItem.expanded ? this.emitEvent('collapse', currentItem).isDefaultPrevented() : this.emitEvent('expand', currentItem).isDefaultPrevented();\n              if (!isEventPrevented) {\n                currentItem.expanded = expandedState;\n                if (currentItem.expanded) {\n                  expandedItems.push(currentItem);\n                }\n                if (modifiedItems.indexOf(currentItem) < 0) {\n                  modifiedItems.push(currentItem);\n                }\n              } else if (isEventPrevented && currentItem.expanded) {\n                preventedCollapseItem = currentItem;\n              }\n            } else if (currentItem.expanded === expandedState && expandedState) {\n              const isCollapsePrevented = this.emitEvent('collapse', currentItem).isDefaultPrevented();\n              if (!isCollapsePrevented) {\n                currentItem.expanded = !currentItem.expanded;\n                if (modifiedItems.indexOf(currentItem) < 0) {\n                  modifiedItems.push(currentItem);\n                }\n              }\n            }\n          });\n          expandedItems.forEach(item => {\n            if (preventedCollapseItem && item.id !== preventedCollapseItem.id) {\n              item.expanded = false;\n              if (isDevMode()) {\n                const expandMode = PanelBarExpandMode[this.expandMode].toLowerCase();\n                console.warn(`\n                            The ${expandMode} expandMode allows the expansion of only one item at a time.\n                            See https://www.telerik.com/kendo-angular-ui-develop/components/layout/panelbar/expand-modes/`);\n              }\n            }\n          });\n        }\n      }\n      if (modifiedItems.length > 0) {\n        const eventArgs = new PanelBarStateChangeEvent();\n        eventArgs.items = modifiedItems.map(currentItem => currentItem.serialize());\n        this.stateChange.emit(eventArgs);\n      }\n    }\n    isVisible(item) {\n      const visibleItems = this.visibleItems();\n      return visibleItems.some(i => i === item);\n    }\n    getVisibleParent(item) {\n      const visibleItems = this.visibleItems();\n      if (!item.parent) {\n        return item;\n      }\n      return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);\n    }\n    focusItem(action) {\n      const visibleItems = this.visibleItems();\n      let currentIndex = visibleItems.findIndex(item => item.focused);\n      let currentItem = visibleItems[currentIndex];\n      let nextItem;\n      if (currentIndex === -1) {\n        const focusedItem = this.allItems.find(item => item.focused);\n        focusedItem.focused = false;\n        currentItem = this.getVisibleParent(focusedItem);\n        currentIndex = visibleItems.findIndex(item => item === currentItem);\n      }\n      switch (action) {\n        case 'lastItem':\n          nextItem = visibleItems[visibleItems.length - 1];\n          break;\n        case 'firstItem':\n          nextItem = visibleItems[0];\n          break;\n        case 'nextItem':\n          nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];\n          break;\n        case 'previousItem':\n          nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];\n          break;\n        default:\n      }\n      if (currentItem && nextItem && currentItem !== nextItem) {\n        this.moveFocus(currentItem, nextItem);\n      }\n    }\n    moveFocus(from, to) {\n      from.focused = false;\n      to.focused = true;\n      this.activeDescendant = to.itemId;\n      const modifiedItems = new Array(from.serialize(), to.serialize());\n      const eventArgs = new PanelBarStateChangeEvent();\n      eventArgs.items = modifiedItems;\n      this.stateChange.emit(eventArgs);\n    }\n    focusLastItem() {\n      this.focusItem('lastItem');\n    }\n    focusFirstItem() {\n      this.focusItem('firstItem');\n    }\n    focusNextItem() {\n      this.focusItem('nextItem');\n    }\n    focusPreviousItem() {\n      this.focusItem('previousItem');\n    }\n    expandItem() {\n      let currentItem = this.allItems.filter(item => item.focused)[0];\n      if (!this.isVisible(currentItem)) {\n        currentItem.focused = false;\n        currentItem = this.getVisibleParent(currentItem);\n      }\n      if (currentItem.hasChildItems || currentItem.hasContent) {\n        if (!currentItem.expanded) {\n          this.onItemAction(currentItem);\n        } else if (currentItem.hasChildItems) {\n          const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);\n          if (firstChildIndex > -1) {\n            this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);\n          }\n        }\n      }\n    }\n    collapseItem() {\n      const currentItem = this.allItems.filter(item => item.focused)[0];\n      if (currentItem.expanded) {\n        this.onItemAction(currentItem);\n      } else if (currentItem.parent) {\n        this.moveFocus(currentItem, currentItem.parent);\n      }\n    }\n    selectFocusedItem() {\n      let focusedItem = this.allItems.filter(item => item.focused)[0];\n      if (!this.isVisible(focusedItem)) {\n        focusedItem.focused = false;\n        focusedItem = this.getVisibleParent(focusedItem);\n      }\n      if (focusedItem) {\n        focusedItem.onItemAction();\n      }\n    }\n    visibleItems() {\n      return this.flatVisibleItems(this.childrenItems);\n    }\n    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {\n      listOfItems.forEach(item => {\n        flattedItems.push(item);\n        if (item.expanded && item.hasChildItems) {\n          this.flatVisibleItems(item.childrenItems, flattedItems);\n        }\n      });\n      return flattedItems;\n    }\n  }\n  _class12 = PanelBarComponent;\n  _defineProperty(PanelBarComponent, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PanelBarService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(PanelBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class12,\n    selectors: [[\"kendo-panelbar\"]],\n    contentQueries: function _class12_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItems = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentChildItems = _t);\n      }\n    },\n    viewQuery: function _class12_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(PanelBarItemComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function _class12_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class12_click_HostBindingHandler($event) {\n          return ctx.onComponentClick($event);\n        })(\"focus\", function _class12_focus_HostBindingHandler() {\n          return ctx.onComponentFocus();\n        })(\"blur\", function _class12_blur_HostBindingHandler() {\n          return ctx.onComponentBlur();\n        })(\"keydown\", function _class12_keydown_HostBindingHandler($event) {\n          return ctx.onComponentKeyDown($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabIndex\", ctx.tabIndex)(\"role\", ctx.role)(\"aria-activedescendant\", ctx.activeDescendant)(\"dir\", ctx.dir);\n        i0.ɵɵstyleProp(\"height\", ctx.hostHeight)(\"overflow\", ctx.overflow);\n        i0.ɵɵclassProp(\"k-panelbar\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      expandMode: \"expandMode\",\n      selectable: \"selectable\",\n      animate: \"animate\",\n      height: \"height\",\n      keepItemContent: \"keepItemContent\",\n      items: \"items\"\n    },\n    outputs: {\n      stateChange: \"stateChange\",\n      select: \"select\",\n      expand: \"expand\",\n      collapse: \"collapse\",\n      itemClick: \"itemClick\"\n    },\n    exportAs: [\"kendoPanelbar\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([PanelBarService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.panelbar'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c7,\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [3, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\", 4, \"ngIf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\"], [\"kendoWatermarkOverlay\", \"\"]],\n    template: function _class12_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c6);\n        i0.ɵɵtemplate(0, _class12_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, _class12_ng_template_1_Template, 1, 1, \"ng-template\", 1);\n        i0.ɵɵtemplate(2, _class12_div_2_Template, 1, 0, \"div\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.contentChildItems && !ctx.items);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.items == null ? null : ctx.items.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [NgIf, NgFor, PanelBarItemComponent, WatermarkOverlayComponent],\n    encapsulation: 2\n  }));\n  return PanelBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst shouldTogglePrev = (keyCode, prev, next) => {\n  const leftArrow = keyCode === Keys.ArrowLeft;\n  const upArrow = keyCode === Keys.ArrowUp;\n  const collapsePrev = !prev.collapsed && !next.collapsed && (leftArrow || upArrow);\n  const expandPrev = prev.collapsed && !(leftArrow || upArrow);\n  return collapsePrev || expandPrev;\n};\n/**\n * @hidden\n */\nconst shouldToggleNext = (keyCode, prev, next) => {\n  const leftArrow = keyCode === Keys.ArrowLeft;\n  const upArrow = keyCode === Keys.ArrowUp;\n  const collapseNext = !next.collapsed && !prev.collapsed && !(leftArrow || upArrow);\n  const expandNext = next.collapsed && (leftArrow || upArrow);\n  return collapseNext || expandNext;\n};\n/**\n * @hidden\n */\nconst shouldToggleOrResize = (keyCode, orientation) => {\n  const isHorizontal = orientation === 'horizontal';\n  const isHorizontalChange = isHorizontal && (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight);\n  const isVerticalChange = !isHorizontal && (keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown);\n  return isHorizontalChange || isVerticalChange;\n};\nconst MAX_PANE_HEIGHT = 33554400;\n/**\n * @hidden\n */\nlet SplitterService = /*#__PURE__*/(() => {\n  var _class13;\n  class SplitterService {\n    constructor(zone) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"panes\", void 0);\n      _defineProperty(this, \"splitterBars\", void 0);\n      _defineProperty(this, \"layoutChange\", new EventEmitter());\n      _defineProperty(this, \"resizeStep\", 10);\n      _defineProperty(this, \"fixedHeight\", void 0);\n      _defineProperty(this, \"containerSize\", () => {});\n      _defineProperty(this, \"rtl\", void 0);\n      this.zone = zone;\n    }\n    tryToggle(paneIndex) {\n      const pane = this.pane(paneIndex);\n      if (pane.collapsible) {\n        pane.collapsed = !pane.collapsed;\n        pane.collapsedChange.emit(pane.collapsed);\n        this.emit(this.layoutChange, {});\n        if (pane.collapsed) {\n          pane.detectChanges();\n        }\n      }\n      const notCollapsed = this.panes.filter(p => !p.collapsed);\n      const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);\n      notCollapsed.filter(p => p.fixedSize).forEach(pane => {\n        pane.forceExpand = allHaveFixedSize ? true : false;\n      });\n      return pane.collapsible;\n    }\n    togglePane(keyCode, index) {\n      const prev = this.pane(index);\n      const next = this.pane(index + 1);\n      if (shouldTogglePrev(keyCode, prev, next)) {\n        this.tryToggle(index);\n      } else if (shouldToggleNext(keyCode, prev, next)) {\n        this.tryToggle(index + 1);\n      }\n    }\n    resizePane(keyCode, index) {\n      const state = this.dragState(index);\n      const direction = keyCode === Keys.ArrowLeft || keyCode === (this.rtl ? Keys.ArrowDown : Keys.ArrowUp);\n      let step = direction ? -this.resizeStep : this.resizeStep;\n      if (this.rtl) {\n        step = -step;\n      }\n      this.setSize(state, step);\n    }\n    toggleContentOverlay(index, show) {\n      this.pane(index).toggleOverlay(show);\n      this.pane(index + 1).toggleOverlay(show);\n    }\n    dragState(splitbarIndex) {\n      const prev = this.pane(splitbarIndex);\n      const next = this.pane(splitbarIndex + 1);\n      const total = prev.computedSize + next.computedSize;\n      const px = s => this.toPixels(s);\n      return {\n        prev: {\n          index: splitbarIndex,\n          initialSize: prev.computedSize,\n          min: px(prev.min) || total - px(next.max) || 0,\n          max: px(prev.max) || total - px(next.min) || total\n        },\n        next: {\n          index: splitbarIndex + 1,\n          initialSize: next.computedSize,\n          min: px(next.min) || total - px(prev.max) || 0,\n          max: px(next.max) || total - px(prev.min) || total\n        }\n      };\n    }\n    setSize(state, delta) {\n      const clamp = (min, max, v) => Math.min(max, Math.max(min, v));\n      const resize = (paneState, change, modifyMax = false) => {\n        const pane = this.pane(paneState.index);\n        const splitterSize = this.containerSize();\n        const newSize = clamp(paneState.min, modifyMax ? MAX_PANE_HEIGHT : paneState.max, paneState.initialSize + change);\n        let size = \"\";\n        if (this.isPercent(pane.size)) {\n          size = 100 * newSize / splitterSize + \"%\";\n        } else {\n          size = newSize + \"px\";\n        }\n        pane.size = size;\n        pane.isResized = true;\n        this.emit(pane.sizeChange, size);\n      };\n      const prevPane = this.pane(state.prev.index);\n      const nextPane = this.pane(state.next.index);\n      const canResizeBothPanes = this.panes.length > 2;\n      const modifyPrevMax = prevPane.orientation === 'vertical' && !this.fixedHeight && !prevPane.max;\n      const modifyNextMax = prevPane.orientation === 'vertical' && !this.fixedHeight && !nextPane.max;\n      if (prevPane.fixedSize && nextPane.fixedSize || canResizeBothPanes) {\n        const bothVertical = prevPane.orientation === 'vertical' && nextPane.orientation === 'vertical';\n        if (bothVertical) {\n          if (modifyNextMax) {\n            resize(state.prev, delta, modifyPrevMax);\n          } else if (modifyPrevMax) {\n            resize(state.next, -delta, modifyNextMax);\n          } else {\n            resize(state.prev, delta, modifyNextMax);\n            resize(state.next, -delta, modifyPrevMax);\n          }\n        } else {\n          resize(state.prev, delta);\n          resize(state.next, -delta);\n        }\n      } else if (nextPane.fixedSize || nextPane.collapsible) {\n        resize(state.next, -delta, modifyNextMax);\n      } else {\n        resize(state.prev, delta, modifyPrevMax);\n      }\n      this.emit(this.layoutChange, {});\n    }\n    isDraggable(splitBarIndex) {\n      const prev = this.pane(splitBarIndex);\n      const next = this.pane(splitBarIndex + 1);\n      const betweenResizablePanes = prev?.resizable && next?.resizable;\n      const nearCollapsedPane = prev?.collapsed || next?.collapsed;\n      return betweenResizablePanes && !nearCollapsedPane;\n    }\n    isStatic(splitBarIndex) {\n      const prev = this.pane(splitBarIndex);\n      const next = this.pane(splitBarIndex + 1);\n      const betweenResizablePanes = prev?.resizable && next?.resizable;\n      const nearCollapsiblePane = prev?.collapsible || next?.collapsible;\n      return !betweenResizablePanes && !nearCollapsiblePane;\n    }\n    pane(index) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (!this.panes) {\n        throw new Error(\"Panes not initialized\");\n      }\n      if (index < 0 || index >= this.panes.length) {\n        throw new Error(\"Index out of range\");\n      }\n      return this.panes[index];\n    }\n    paneByIndex(pane) {\n      if (!this.panes) {\n        return -1;\n      }\n      return this.panes.findIndex(splitterPane => splitterPane === pane);\n    }\n    getPaneSplitterBar(pane) {\n      if (!this.splitterBars) {\n        return;\n      }\n      const paneIndex = this.paneByIndex(pane);\n      if (paneIndex < 0 || paneIndex >= this.splitterBars.length) {\n        return null;\n      }\n      return this.splitterBars[paneIndex];\n    }\n    configure({\n      panes,\n      orientation,\n      containerSize,\n      direction\n    }) {\n      this.panes = panes;\n      this.panes.forEach((pane, index) => {\n        pane.order = index * 2;\n        pane.orientation = orientation;\n      });\n      this.containerSize = containerSize;\n      this.rtl = direction === 'rtl';\n    }\n    isPercent(size) {\n      return /%$/.test(size);\n    }\n    toPixels(size) {\n      let result = parseFloat(size);\n      if (this.isPercent(size)) {\n        result = this.containerSize() * result / 100;\n      }\n      return result;\n    }\n    emit(emitter, args) {\n      if (emitter.observers.length) {\n        this.zone.run(() => emitter.emit(args));\n      }\n    }\n  }\n  _class13 = SplitterService;\n  _defineProperty(SplitterService, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(SplitterService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class13,\n    factory: _class13.ɵfac\n  }));\n  return SplitterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the pane component of the Splitter.\n */\nlet SplitterPaneComponent = /*#__PURE__*/(() => {\n  var _class14;\n  class SplitterPaneComponent {\n    /**\n     * @hidden\n     */\n    set order(paneOrder) {\n      this._order = paneOrder;\n      this.setOrderStyles();\n    }\n    get order() {\n      return this._order;\n    }\n    /**\n     * Sets the initial size of the pane.\n     * Accepts units in pixel and percentage values.\n     * Has to be between the `min` and `max` properties.\n     */\n    set size(newSize) {\n      this._size = newSize;\n      this.renderer.setStyle(this.nativeElement, '-ms-flex-preferred-size', newSize);\n      this.renderer.setStyle(this.nativeElement, 'flex-basis', newSize);\n      this.setStaticPaneClass();\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the HTML attributes of the splitter bar.\n     * The property accepts string key-value based pairs.\n     * Attributes which are essential for certain functionalities cannot be changed.\n     */\n    set splitterBarAttributes(attributes) {\n      this._splitterBarAttributes = attributes;\n      const splitterBar = this.splitterService.getPaneSplitterBar(this);\n      if (splitterBar) {\n        splitterBar.htmlAttributes = attributes;\n      }\n    }\n    get splitterBarAttributes() {\n      return this._splitterBarAttributes;\n    }\n    /**\n     * The CSS classes that will be rendered on the splitter bar.\n     * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n     */\n\n    /**\n     * @hidden\n     */\n    set containsSplitter(value) {\n      if (value) {\n        this.renderer.addClass(this.nativeElement, 'k-pane-flex');\n      } else {\n        this.renderer.removeClass(this.nativeElement, 'k-pane-flex');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n    get isHidden() {\n      return this.collapsed;\n    }\n    get scrollablePaneClass() {\n      return this.scrollable;\n    }\n    get fixedSize() {\n      return this.size && this.size.length > 0;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(element, renderer, cdr, splitterService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"splitterService\", void 0);\n      _defineProperty(this, \"splitterBarClass\", void 0);\n      /**\n       * Sets the minimum possible size of the pane.\n       * Accepts units in pixel and percentage values.\n       */\n      _defineProperty(this, \"min\", void 0);\n      /**\n       * Sets the maximum possible size of the pane.\n       * Accepts units in pixel and percentage values.\n       */\n      _defineProperty(this, \"max\", void 0);\n      /**\n       * Specifies if the user is allowed to resize the pane and provide space for other panes.\n       */\n      _defineProperty(this, \"resizable\", true);\n      /**\n       * Specifies if the user is allowed to hide the pane and provide space for other panes.\n       */\n      _defineProperty(this, \"collapsible\", false);\n      /**\n       * Specifies if overflowing content is scrollable or hidden.\n       */\n      _defineProperty(this, \"scrollable\", true);\n      /**\n       * Specifies if the pane is initially collapsed.\n       */\n      _defineProperty(this, \"collapsed\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"overlayContent\", false);\n      /**\n       * Fires each time the user resizes the Splitter pane.\n       * The event data contains the new pane size.\n       * Allows a two-way binding of the pane `size` property.\n       */\n      _defineProperty(this, \"sizeChange\", new EventEmitter());\n      /**\n       * Fires each time the `collapsed` property changes.\n       * The event data contains the new property state.\n       * Allows a two-way binding of the `collapsed` pane property.\n       */\n      _defineProperty(this, \"collapsedChange\", new EventEmitter());\n      _defineProperty(this, \"ariaRole\", 'group');\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"forceExpand\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isResized\", false);\n      _defineProperty(this, \"_size\", void 0);\n      _defineProperty(this, \"_order\", void 0);\n      _defineProperty(this, \"_splitterBarAttributes\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.splitterService = splitterService;\n    }\n    ngAfterViewChecked() {\n      if (this.isHidden) {\n        this.renderer.addClass(this.nativeElement, 'k-hidden');\n        this.renderer.addClass(this.nativeElement, 'hidden');\n      } else {\n        this.renderer.removeClass(this.nativeElement, 'k-hidden');\n        this.renderer.removeClass(this.nativeElement, 'hidden');\n      }\n      this.setStaticPaneClass();\n    }\n    ngOnChanges(changes) {\n      if (anyChanged(['resizable', 'collapsible'], changes)) {\n        this.setStaticPaneClass();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get computedSize() {\n      if (this.orientation === 'vertical') {\n        return this.nativeElement.offsetHeight;\n      } else {\n        return this.nativeElement.offsetWidth;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    toggleOverlay(show) {\n      this.overlayContent = show;\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n    setOrderStyles() {\n      this.renderer.setStyle(this.nativeElement, '-ms-flex-order', this.order);\n      this.renderer.setStyle(this.nativeElement, 'order', this.order);\n    }\n    setStaticPaneClass() {\n      if (this.forceExpand) {\n        this.renderer.removeClass(this.nativeElement, 'k-pane-static');\n        return;\n      }\n      if (!this.resizable && !this.collapsible || this.fixedSize) {\n        this.renderer.addClass(this.nativeElement, 'k-pane-static');\n      } else {\n        this.renderer.removeClass(this.nativeElement, 'k-pane-static');\n      }\n    }\n  }\n  _class14 = SplitterPaneComponent;\n  _defineProperty(SplitterPaneComponent, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(SplitterService));\n  });\n  _defineProperty(SplitterPaneComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class14,\n    selectors: [[\"kendo-splitter-pane\"]],\n    hostVars: 5,\n    hostBindings: function _class14_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.ariaRole);\n        i0.ɵɵclassProp(\"k-pane\", ctx.hostClass)(\"k-scrollable\", ctx.scrollablePaneClass);\n      }\n    },\n    inputs: {\n      order: \"order\",\n      size: \"size\",\n      splitterBarAttributes: \"splitterBarAttributes\",\n      splitterBarClass: \"splitterBarClass\",\n      min: \"min\",\n      max: \"max\",\n      resizable: \"resizable\",\n      collapsible: \"collapsible\",\n      scrollable: \"scrollable\",\n      collapsed: \"collapsed\",\n      orientation: \"orientation\",\n      containsSplitter: \"containsSplitter\",\n      overlayContent: \"overlayContent\"\n    },\n    outputs: {\n      sizeChange: \"sizeChange\",\n      collapsedChange: \"collapsedChange\"\n    },\n    exportAs: [\"kendoSplitterPane\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-splitter-overlay k-overlay\", 4, \"ngIf\"], [1, \"k-splitter-overlay\", \"k-overlay\"]],\n    template: function _class14_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class14_ng_container_0_Template, 2, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class14_div_1_Template, 1, 0, \"div\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.collapsed);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.overlayContent);\n      }\n    },\n    dependencies: [NgIf],\n    encapsulation: 2\n  }));\n  return SplitterPaneComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst stopPropagation = ({\n  originalEvent: event\n}) => {\n  event.stopPropagation();\n  event.preventDefault();\n};\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\nconst classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');\nconst createMoveStream = draggable => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease), map(({\n  pageX,\n  pageY\n}) => ({\n  originalX: mouseDown.pageX,\n  originalY: mouseDown.pageY,\n  pageX,\n  pageY\n})));\n/**\n * @hidden\n */\nlet SplitterBarComponent = /*#__PURE__*/(() => {\n  var _class15;\n  class SplitterBarComponent {\n    get hostOrientation() {\n      return this.orientation === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    get tabIndex() {\n      return this.splitterService.isStatic(this.index) ? -1 : 0;\n    }\n    get hostClasses() {\n      const isHorizontal = this.orientation === 'horizontal';\n      const isDraggable = this.splitterService.isDraggable(this.index);\n      const isStatic = this.splitterService.isStatic(this.index);\n      return classFromObject({\n        'k-focus': this.focused,\n        'k-splitbar': true,\n        'k-splitbar-horizontal': isHorizontal,\n        'k-splitbar-vertical': !isHorizontal,\n        'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,\n        'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,\n        'k-splitbar-static-horizontal': isHorizontal && isStatic,\n        'k-splitbar-static-vertical': !isHorizontal && isStatic,\n        'k-touch-action-none': isDraggable\n      });\n    }\n    get order() {\n      return 2 * this.index + 1;\n    }\n    set htmlAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.element.nativeElement);\n      }\n      this._htmlAttributes = attributes;\n      this.parsedAttributes = this.htmlAttributes ? parseAttributes(this.htmlAttributes, this.defaultAttributes) : this.htmlAttributes;\n      this.setHtmlAttributes();\n    }\n    get htmlAttributes() {\n      return this._htmlAttributes;\n    }\n    get defaultAttributes() {\n      return {\n        'aria-orientation': this.hostOrientation,\n        role: this.ariaRole\n      };\n    }\n    get mutableAttributes() {\n      return {\n        'tabindex': this.tabIndex\n      };\n    }\n    constructor(draggable, localization, splitterService, element, renderer, cdr) {\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"splitterService\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ariaRole\", 'separator');\n      _defineProperty(this, \"ariaLabel\", 'Splitter pane');\n      _defineProperty(this, \"focused\", false);\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"index\", 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"_htmlAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      this.draggable = draggable;\n      this.localization = localization;\n      this.splitterService = splitterService;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n    }\n    ngOnInit() {\n      let state;\n      const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitterService.isDraggable(this.index)), tap(() => state = this.splitterService.dragState(this.index)), tap(() => this.splitterService.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({\n        pageX,\n        pageY,\n        originalX,\n        originalY\n      }) => {\n        let delta;\n        if (this.orientation === 'vertical') {\n          delta = pageY - originalY;\n        } else if (this.direction === 'rtl') {\n          delta = originalX - pageX;\n        } else {\n          delta = pageX - originalX;\n        }\n        this.splitterService.setSize(state, delta);\n      });\n      this.subscriptions.add(listener);\n      this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitterService.toggleContentOverlay(this.index, false)));\n      const element = this.element.nativeElement;\n      this.subscriptions.add(this.renderer.listen(element, 'keydown', event => this.onKeyDown(event)));\n      this.subscriptions.add(this.renderer.listen(element, 'focusin', () => this.focused = true));\n      this.subscriptions.add(this.renderer.listen(element, 'focusout', () => this.focused = false));\n      this.subscriptions.add(this.renderer.listen(element, 'dblclick', () => this.togglePane()));\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    togglePrevious() {\n      this.splitterService.tryToggle(this.index);\n    }\n    toggleNext() {\n      this.splitterService.tryToggle(this.index + 1);\n    }\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    shouldShowIcon(iconName) {\n      const paneIndex = iconName === 'prev' ? this.index : this.index + 1;\n      const relatedPaneIndex = iconName === 'prev' ? this.index + 1 : this.index;\n      const pane = this.splitterService.pane(paneIndex);\n      const relatedPane = this.splitterService.pane(relatedPaneIndex);\n      const isCollapsible = pane?.collapsible;\n      return isCollapsible && !relatedPane?.isHidden;\n    }\n    previousArrowClass() {\n      const pane = this.splitterService.pane(this.index);\n      const isCollapsible = pane?.collapsible;\n      const isCollapsed = pane?.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      const isRTL = this.direction === 'rtl';\n      return classFromObject({\n        'caret-alt-left': isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL),\n        'caret-alt-right': isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL),\n        'caret-alt-up': isCollapsible && !isHorizontal && !isCollapsed,\n        'caret-alt-down': isCollapsible && !isHorizontal && isCollapsed\n      });\n    }\n    previousSVGArrowClass() {\n      const pane = this.splitterService.pane(this.index);\n      const isCollapsible = pane?.collapsible;\n      const isCollapsed = pane?.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      const isRTL = this.direction === 'rtl';\n      if (isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL)) {\n        return caretAltLeftIcon;\n      }\n      if (isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL)) {\n        return caretAltRightIcon;\n      }\n      if (isCollapsible && !isHorizontal && !isCollapsed) {\n        return caretAltUpIcon;\n      }\n      if (isCollapsible && !isHorizontal && isCollapsed) {\n        return caretAltDownIcon;\n      }\n    }\n    nextArrowClass() {\n      const pane = this.splitterService.pane(this.index + 1);\n      const isCollapsible = pane?.collapsible;\n      const isCollapsed = pane?.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      const isRTL = this.direction === 'rtl';\n      return classFromObject({\n        'caret-alt-right': isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL),\n        'caret-alt-left': isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL),\n        'caret-alt-down': isCollapsible && !isHorizontal && !isCollapsed,\n        'caret-alt-up': isCollapsible && !isHorizontal && isCollapsed\n      });\n    }\n    nextSVGArrowClass() {\n      const pane = this.splitterService.pane(this.index + 1);\n      const isCollapsible = pane?.collapsible;\n      const isCollapsed = pane?.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      const isRTL = this.direction === 'rtl';\n      if (isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL)) {\n        return caretAltRightIcon;\n      }\n      if (isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL)) {\n        return caretAltLeftIcon;\n      }\n      if (isCollapsible && !isHorizontal && !isCollapsed) {\n        return caretAltDownIcon;\n      }\n      if (isCollapsible && !isHorizontal && isCollapsed) {\n        return caretAltUpIcon;\n      }\n    }\n    togglePane() {\n      if (this.expandLast) {\n        this.toggleNext();\n      } else {\n        this.tryToggleNearest();\n      }\n      this.cdr.markForCheck();\n    }\n    get expandLast() {\n      const panes = this.splitterService.panes;\n      return panes.length === 2 && panes[1].collapsed;\n    }\n    onKeyDown(event) {\n      const keyCode = event.keyCode;\n      const shouldToggle = event.ctrlKey || event.metaKey;\n      if (keyCode === Keys.Enter) {\n        event.preventDefault();\n        this.togglePane();\n      } else if (shouldToggleOrResize(keyCode, this.orientation)) {\n        event.preventDefault();\n        if (shouldToggle) {\n          this.splitterService.togglePane(keyCode, this.index);\n        } else {\n          this.splitterService.resizePane(keyCode, this.index);\n        }\n      }\n    }\n    tryToggleNearest() {\n      const prev = this.index;\n      const next = this.index + 1;\n      if (!this.splitterService.tryToggle(prev)) {\n        this.splitterService.tryToggle(next);\n      }\n    }\n    setHtmlAttributes() {\n      const attributesToRender = {\n        ...this.mutableAttributes,\n        ...this.parsedAttributes\n      };\n      setHTMLAttributes(attributesToRender, this.renderer, this.element.nativeElement);\n    }\n  }\n  _class15 = SplitterBarComponent;\n  _defineProperty(SplitterBarComponent, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(SplitterService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(SplitterBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class15,\n    selectors: [[\"kendo-splitter-bar\"]],\n    hostVars: 12,\n    hostBindings: function _class15_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.ariaRole)(\"aria-label\", ctx.ariaLabel)(\"aria-orientation\", ctx.hostOrientation)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassMap(ctx.hostClasses);\n        i0.ɵɵstyleProp(\"-ms-flex-order\", ctx.order)(\"order\", ctx.order);\n        i0.ɵɵclassProp(\"k-focus\", ctx.focused);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      index: \"index\",\n      htmlAttributes: \"htmlAttributes\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 2,\n    consts: [[\"class\", \"k-collapse-prev\", 3, \"click\", 4, \"ngIf\"], [1, \"k-resize-handle\"], [\"class\", \"k-collapse-next\", 3, \"click\", 4, \"ngIf\"], [1, \"k-collapse-prev\", 3, \"click\"], [\"size\", \"xsmall\", 3, \"name\", \"svgIcon\"], [1, \"k-collapse-next\", 3, \"click\"]],\n    template: function _class15_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class15_div_0_Template, 2, 2, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵtemplate(2, _class15_div_2_Template, 2, 2, \"div\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldShowIcon(\"prev\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldShowIcon(\"next\"));\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return SplitterBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';\n/**\n * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).\n *\n * ```ts-preview\n *\n *  @Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-splitter [style.height.px]=\"280\">\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / left pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane>\n *            <h3>Inner splitter / center pane</h3>\n *            <p>Resizable only.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / right pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *        </kendo-splitter>\n *      `,\n *    styles: [ `\n *        h3 { font-size: 1.2em; }\n *        h3, p { margin: 10px; padding: 0; }\n *    ` ]\n *  })\n *  class AppComponent {}\n * ```\n */\nlet SplitterComponent = /*#__PURE__*/(() => {\n  var _class16;\n  class SplitterComponent {\n    /**\n     * The distance in pixels that the separator is moved with during keyboard navigation.\n     * @default 10\n     */\n    set resizeStep(value) {\n      this.splitterService.resizeStep = value;\n    }\n    get resizeStep() {\n      return this.splitterService.resizeStep;\n    }\n    /**\n     * The CSS classes that will be rendered on the splitter bars.\n     * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n     */\n\n    get hostClasses() {\n      return true;\n    }\n    get horizontalHostClasses() {\n      return this.orientation === 'horizontal';\n    }\n    get verticalHostClasses() {\n      return this.orientation === 'vertical';\n    }\n    get dir() {\n      return this.direction;\n    }\n    set splitbars(splitbars) {\n      this.splitterService.splitterBars = splitbars ? splitbars.toArray() : [];\n      if (!isPresent(splitbars) || !isPresent(this.panes)) {\n        return;\n      }\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const panesArray = this.panes.toArray();\n      const splitBarsArray = splitbars.toArray();\n      const components = [...panesArray, ...splitBarsArray].sort((a, b) => a.order - b.order);\n      const elements = components.map(component => component.element.nativeElement);\n      panesArray.forEach((pane, i) => {\n        const splitbar = splitBarsArray[i];\n        if (splitbar && pane.splitterBarAttributes) {\n          splitbar.htmlAttributes = pane.splitterBarAttributes;\n        }\n      });\n      elements.forEach(element => this.renderer.appendChild(this.element.nativeElement, element));\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(element, splitterService, localization, renderer, ngZone, enclosingPane) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"splitterService\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"enclosingPane\", void 0);\n      /**\n       * Specifies the orientation of the panes within the Splitter.\n       * Panes in a horizontal Splitter are placed horizontally.\n       * Panes in a vertical Splitter are placed vertically.\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      /**\n       * Sets the width or height (depending on the orientation) of the Splitter splitbars in pixels.\n       */\n      _defineProperty(this, \"splitbarWidth\", void 0);\n      _defineProperty(this, \"splitterBarClass\", void 0);\n      /**\n       * Fires after a Splitter pane is resized or collapsed.\n       * Useful for triggering layout calculations on components\n       * which are positioned inside the panes.\n       */\n      _defineProperty(this, \"layoutChange\", void 0);\n      _defineProperty(this, \"panes\", void 0);\n      _defineProperty(this, \"paneChangesSubscription\", void 0);\n      _defineProperty(this, \"_styleObserver\", void 0);\n      this.element = element;\n      this.splitterService = splitterService;\n      this.localization = localization;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.enclosingPane = enclosingPane;\n      validatePackage(packageMetadata);\n      if (enclosingPane) {\n        enclosingPane.containsSplitter = true;\n      }\n      // the handler only runs in NgZone if there are bound handlers\n      // this line merges both streams\n      this.layoutChange = this.splitterService.layoutChange;\n      this.configure = this.configure.bind(this);\n    }\n    ngAfterContentInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.reconfigure();\n      this.setFixedHeight();\n      const allHaveFixedSize = this.panes.length && Array.from(this.panes).every(p => p.fixedSize);\n      if (allHaveFixedSize && isDevMode()) {\n        throw new Error(`\n                The Splitter should have at least one pane without a set size.\n                See ${SIZING_DOC_LINK} for more information.\n            `);\n      }\n      this._styleObserver = new MutationObserver(() => {\n        this.ngZone.runOutsideAngular(() => {\n          this.setFixedHeight();\n        });\n      });\n      this._styleObserver.observe(this.element.nativeElement, {\n        attributeFilter: ['style']\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes.orientation && !changes.orientation.isFirstChange()) {\n        this.reconfigure();\n      }\n    }\n    ngOnDestroy() {\n      if (this.enclosingPane) {\n        this.enclosingPane.containsSplitter = false;\n      }\n      if (this._styleObserver) {\n        this._styleObserver.disconnect();\n        this._styleObserver = null;\n      }\n      this.unsubscribeChanges();\n    }\n    reconfigure() {\n      this.unsubscribeChanges();\n      this.configure();\n      this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);\n    }\n    unsubscribeChanges() {\n      if (this.paneChangesSubscription) {\n        this.paneChangesSubscription.unsubscribe();\n        this.paneChangesSubscription = null;\n      }\n    }\n    configure() {\n      this.splitterService.configure({\n        panes: this.panes.toArray(),\n        orientation: this.orientation,\n        containerSize: () => {\n          if (this.orientation === 'vertical') {\n            return this.element.nativeElement.clientHeight;\n          } else {\n            return this.element.nativeElement.clientWidth;\n          }\n        },\n        direction: this.direction\n      });\n    }\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    setFixedHeight() {\n      this.splitterService.fixedHeight = getComputedStyle(this.element.nativeElement).getPropertyValue('height') !== 'auto';\n    }\n  }\n  _class16 = SplitterComponent;\n  _defineProperty(SplitterComponent, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SplitterService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(SplitterPaneComponent, 9));\n  });\n  _defineProperty(SplitterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class16,\n    selectors: [[\"kendo-splitter\"]],\n    contentQueries: function _class16_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SplitterPaneComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panes = _t);\n      }\n    },\n    viewQuery: function _class16_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(SplitterBarComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.splitbars = _t);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function _class16_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-splitter\", ctx.hostClasses)(\"k-splitter-flex\", ctx.hostClasses)(\"k-splitter-horizontal\", ctx.horizontalHostClasses)(\"k-splitter-vertical\", ctx.verticalHostClasses);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      splitbarWidth: \"splitbarWidth\",\n      resizeStep: \"resizeStep\",\n      splitterBarClass: \"splitterBarClass\"\n    },\n    outputs: {\n      layoutChange: \"layoutChange\"\n    },\n    exportAs: [\"kendoSplitter\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([SplitterService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.spliter'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c11,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoDraggable\", \"\", 3, \"index\", \"orientation\", \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoDraggable\", \"\", 3, \"index\", \"orientation\", \"ngClass\", \"ngStyle\"]],\n    template: function _class16_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c10);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, _class16_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.panes);\n      }\n    },\n    dependencies: [NgFor, NgIf, SplitterBarComponent, DraggableDirective, NgStyle, NgClass],\n    encapsulation: 2\n  }));\n  return SplitterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the content template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip [ngStyle]=\"{'width': '400px'}\" [animate]=\"true\">\n *           <kendo-tabstrip-tab title=\"Paris\" [selected]=\"true\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab title=\"Sofia\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nlet TabContentDirective = /*#__PURE__*/(() => {\n  var _class17;\n  class TabContentDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class17 = TabContentDirective;\n  _defineProperty(TabContentDirective, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(TabContentDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class17,\n    selectors: [[\"\", \"kendoTabContent\", \"\"]],\n    standalone: true\n  }));\n  return TabContentDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the title template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.\n *\n * > The `kendoTabTitle` directive overrides the TabStripTab [title]({% slug api_layout_tabstriptabcomponent %}#toc-title) option.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip>\n *           <kendo-tabstrip-tab [selected]=\"true\">\n *             <ng-template kendoTabTitle>\n *               <h4>Custom Title</h4>\n *             </ng-template>\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab title=\"Sofia\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nlet TabTitleDirective = /*#__PURE__*/(() => {\n  var _class18;\n  class TabTitleDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class18 = TabTitleDirective;\n  _defineProperty(TabTitleDirective, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(TabTitleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class18,\n    selectors: [[\"\", \"kendoTabTitle\", \"\"]],\n    standalone: true\n  }));\n  return TabTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TabTemplateDirective = /*#__PURE__*/(() => {\n  var _class19;\n  class TabTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class19 = TabTemplateDirective;\n  _defineProperty(TabTemplateDirective, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(TabTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class19,\n    selectors: [[\"\", \"kendoTabTemplate\", \"\"]],\n    standalone: true\n  }));\n  return TabTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the tab component of the TabStrip.\n */\nlet TabStripTabComponent = /*#__PURE__*/(() => {\n  var _class20;\n  class TabStripTabComponent {\n    constructor() {\n      /**\n       * Sets the tab title ([see example](slug:tabs_tabstrip#toc-tab-titles)).\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Used to disable a tab ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).\n       *\n       * Defaults to `false`.\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * The CSS classes that will be rendered on the `tab` element.\n       * Supports the type of values that are supported by [ngClass](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"cssClass\", void 0);\n      /**\n       * The CSS styles that will be rendered on the `tab` element.\n       * Supports the type of values that are supported by [ngStyle](link:site.data.urls.angular['ngstyleapi']).\n       */\n      _defineProperty(this, \"cssStyle\", void 0);\n      /**\n       * Determines which tab will be selected upon the initial loading of the TabStrip\n       * ([see example](slug:tabs_tabstrip#toc-selected-tab)).\n       */\n      _defineProperty(this, \"selected\", void 0);\n      /**\n       * When set to `true`, a close button will be rendered inside the tab.\n       * This option overrides the value of the TabStrip `closable` option.\n       */\n      _defineProperty(this, \"closable\", void 0);\n      /**\n       * Defines the name for an existing font icon in the Kendo UI theme for the close icon.\n       * This option overrides the value of the TabStrip `closeIcon` option.\n       */\n      _defineProperty(this, \"closeIcon\", void 0);\n      /**\n       * Allows the usage of custom icons by defining a custom CSS class, or multiple classes separated by spaces.\n       * This option overrides the value of the TabStrip `closeIcon` option.\n       */\n      _defineProperty(this, \"closeIconClass\", void 0);\n      /**\n       * Defines an SVGIcon to be rendered for the close icon.\n       * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n       */\n      _defineProperty(this, \"closeSVGIcon\", void 0);\n      _defineProperty(this, \"_tabDirective\", new QueryList());\n      _defineProperty(this, \"_tabContent\", new QueryList());\n      // guards against nested tabstrip components; `descendants` is not defined by default;\n      _defineProperty(this, \"_tabTitleDirective\", void 0);\n      /**\n       * @hidden\n       *\n       * Currently only disabled tabs can be focused. Otherwise they will be\n       * immediately selected\n       */\n      _defineProperty(this, \"focused\", false);\n    }\n    get tabContent() {\n      return this._tabContent.first;\n    }\n    get tabTitle() {\n      return this._tabTitleDirective.first;\n    }\n    get tabTemplate() {\n      return this._tabDirective.first;\n    }\n  }\n  _class20 = TabStripTabComponent;\n  _defineProperty(TabStripTabComponent, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)();\n  });\n  _defineProperty(TabStripTabComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class20,\n    selectors: [[\"kendo-tabstrip-tab\"]],\n    contentQueries: function _class20_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TabTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TabContentDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TabTitleDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tabDirective = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tabContent = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tabTitleDirective = _t);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      disabled: \"disabled\",\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\",\n      selected: \"selected\",\n      closable: \"closable\",\n      closeIcon: \"closeIcon\",\n      closeIconClass: \"closeIconClass\",\n      closeSVGIcon: \"closeSVGIcon\"\n    },\n    exportAs: [\"kendoTabStripTab\"],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class20_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return TabStripTabComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `tabClose` event of the TabStrip.\n * The `tabClose` event fires when the close button of the tab is clicked.\n *\n */\nclass TabCloseEvent {\n  /**\n   * Constructs the event arguments for the `tabClose` event.\n   * @param index - The index of the closed tab.\n   * @param tab - The closed tab instance\n   */\n  constructor(index, tab) {\n    _defineProperty(this, \"index\", void 0);\n    _defineProperty(this, \"tab\", void 0);\n    this.index = index;\n    this.tab = tab;\n  }\n}\n\n/**\n * Arguments for the `select` event of the TabStrip.\n * The `select` event fires when a tab is selected (clicked).\n */\nclass SelectEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `select` event.\n   * @param index - The index of the selected tab.\n   * @param title - The title of the selected tab.\n   */\n  constructor(index, title) {\n    super();\n    _defineProperty(this, \"index\", void 0);\n    _defineProperty(this, \"title\", void 0);\n    this.index = index;\n    this.title = title;\n  }\n}\n\n/**\n * @hidden\n *\n * Checks if the current target is a TabStrip tab element\n */\nconst isTabElement = target => {\n  const targetId = target.getAttribute('id');\n  if (isPresent(targetId) || targetId.indexOf('k-tabstrip-tab-') >= 0) {\n    return true;\n  }\n  return false;\n};\n/**\n * @hidden\n *\n * Checks if the current tab is closable. Depends on the value of the TabStrip closable property.\n */\nconst isTabClosable = (tab, tabStripClosable) => {\n  if (tab.closable !== undefined) {\n    return tab.closable;\n  }\n  return tabStripClosable;\n};\n/**\n * @hidden\n *\n * Checks if the TabStrip scroll buttons will be rendered. Depends on the value of the TabStrip scrollable settings.\n */\nconst tabStripHasScrollButtons = scrollableSettings => {\n  const visible = scrollableSettings.enabled && scrollableSettings.scrollButtons !== 'hidden';\n  const position = scrollableSettings.scrollButtonsPosition;\n  return {\n    visible,\n    position\n  };\n};\n/**\n * @hidden\n *\n * Checks if the TabStrip mouse scroll will be enabled. Depends on the value of the TabStrip scrollable settings.\n */\nconst mouseScrollEnabled = scrollableSettings => {\n  return scrollableSettings.enabled && scrollableSettings.mouseScroll;\n};\n/**\n * @hidden\n *\n * Retrieves the current active tab element and its index.\n * This could either be the currently selected tab or the currently focused tab.\n */\nconst getActiveTab = tabs => {\n  let focusedTab;\n  let selectedTab;\n  let focusedIndex = -1;\n  let selectedIndex = -1;\n  tabs.forEach((tab, index) => {\n    if (tab.selected) {\n      selectedTab = tab;\n      selectedIndex = index;\n    } else if (tab.focused) {\n      focusedTab = tab;\n      focusedIndex = index;\n    }\n  });\n  return focusedIndex >= 0 ? {\n    tab: focusedTab,\n    index: focusedIndex\n  } : {\n    tab: selectedTab,\n    index: selectedIndex\n  };\n};\n/**\n * @hidden\n */\nconst getTabByIndex = (tabs, index) => {\n  const filtered = tabs.filter((_tab, i) => i === index);\n  if (filtered.length > 0) {\n    return filtered[0];\n  }\n  return null;\n};\n/**\n * @hidden\n */\nconst getTabHeaderByIndex = (tabHeaderContainers, index) => {\n  const filtered = tabHeaderContainers.filter((_tabHeader, i) => i === index);\n  if (filtered.length > 0) {\n    return filtered[0];\n  }\n  return null;\n};\n/**\n * @hidden\n */\nconst resetTabFocus = tabs => {\n  tabs.forEach(tab => {\n    tab.focused = false;\n  });\n};\n/**\n * @hidden\n */\nconst resetTabSelection = tabs => {\n  tabs.forEach(tab => {\n    tab.selected = false;\n  });\n};\n/**\n * @hidden\n */\nconst isTablistHorizontal = tabPosition => tabPosition === 'top' || tabPosition === 'bottom';\n/**\n * @hidden\n */\nconst getId$1 = (prefix, tabStripId, tabIndex) => {\n  return `${prefix}-${tabStripId}-${tabIndex}`;\n};\n\n/**\n * @hidden\n */\nlet TabStripService = /*#__PURE__*/(() => {\n  var _class23;\n  class TabStripService {\n    constructor(localization, ngZone) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"owner\", void 0);\n      this.localization = localization;\n      this.ngZone = ngZone;\n    }\n    onKeyDown(event) {\n      if (!isTabElement(event.target)) {\n        return;\n      }\n      const key = event.keyCode;\n      if (this.shouldHandleKey(key)) {\n        event.preventDefault();\n      } else {\n        return;\n      }\n      if (isNavigationKey(key) || isArrowKey(key)) {\n        this.onNavigate(key);\n      } else if (key === Keys.Delete) {\n        this.onDelete();\n      }\n    }\n    onTabSelect(tab, index) {\n      const selectArgs = new SelectEvent(index, tab.title);\n      this.owner.tabSelect.emit(selectArgs);\n      if (!selectArgs.isDefaultPrevented()) {\n        if (tab.selected) {\n          this.focusTabHeader(index);\n          return;\n        }\n        this.selectTab(tab, index);\n      }\n    }\n    selectTab(tab, index) {\n      resetTabSelection(this.owner.tabs);\n      this.focusTabHeader(index);\n      tab.selected = true;\n      if (this.owner.isScrollable) {\n        this.owner.scrollToSelectedTab();\n      }\n    }\n    onNavigate(keyCode) {\n      const {\n        tab: activeTab,\n        index: activeIndex\n      } = getActiveTab(this.owner.tabs);\n      if (!NgZone.isInAngularZone()) {\n        this.ngZone.run(() => {\n          if (activeIndex < 0) {\n            this.owner.selectTab(this.firstNavigatableIndex());\n            return;\n          }\n          activeTab.focused = false;\n          const nextIndex = this.computeNextIndex(activeIndex, keyCode);\n          this.activateTab(nextIndex);\n        });\n      }\n    }\n    onDelete() {\n      const {\n        tab: activeTab,\n        index: activeTabIndex\n      } = getActiveTab(this.owner.tabs);\n      if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {\n        this.ngZone.run(() => {\n          this.owner.tabClose.emit({\n            tab: activeTab,\n            index: activeTabIndex\n          });\n        });\n      }\n    }\n    activateTab(index) {\n      const tab = getTabByIndex(this.owner.tabs, index);\n      if (tab.disabled) {\n        this.focusTabHeader(index);\n        tab.focused = true;\n      } else {\n        this.onTabSelect(tab, index);\n      }\n    }\n    focusTabHeader(index) {\n      const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);\n      tabHeader.nativeElement.focus();\n    }\n    shouldHandleKey(keyCode) {\n      if (isNavigationKey(keyCode)) {\n        return true;\n      }\n      if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {\n        return true;\n      }\n      if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {\n        return true;\n      }\n      if (keyCode === Keys.Delete) {\n        return true;\n      }\n      return false;\n    }\n    computeNextIndex(activeIndex, keyCode) {\n      switch (keyCode) {\n        case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):\n        case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):\n          return this.prevNavigatableIndex(activeIndex);\n        case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):\n        case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):\n          return this.nextNavigatableIndex(activeIndex);\n        case Keys.Home:\n          return this.firstNavigatableIndex();\n        case Keys.End:\n          return this.lastNavigatableIndex();\n        default:\n          return;\n      }\n    }\n    invertKeys(original, inverted) {\n      return this.localization.rtl ? inverted : original;\n    }\n    firstNavigatableIndex() {\n      return 0;\n    }\n    lastNavigatableIndex() {\n      return this.owner.tabs.length - 1;\n    }\n    prevNavigatableIndex(selectedIndex) {\n      if (selectedIndex - 1 < 0) {\n        return this.lastNavigatableIndex();\n      }\n      return selectedIndex - 1;\n    }\n    nextNavigatableIndex(selectedIndex) {\n      if (selectedIndex + 1 >= this.owner.tabs.length) {\n        return this.firstNavigatableIndex();\n      }\n      return selectedIndex + 1;\n    }\n  }\n  _class23 = TabStripService;\n  _defineProperty(TabStripService, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵinject(i1.LocalizationService), i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(TabStripService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class23,\n    factory: _class23.ɵfac\n  }));\n  return TabStripService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst MOUSE_SCROLL_SPEED = 10;\n/**\n * @hidden\n */\nconst BUTTON_SCROLL_SPEED = 100;\n/**\n * @hidden\n */\nconst SCROLLABLE_CLASS = 'k-tabstrip-scrollable';\n/**\n * @hidden\n */\nconst HIDDEN_CLASS = 'k-hidden';\n/**\n * @hidden\n */\nconst DIRECTION_CLASSES = {\n  left: 'caret-alt-left',\n  right: 'caret-alt-right',\n  up: 'caret-alt-up',\n  down: 'caret-alt-down'\n};\n/**\n * @hidden\n */\nconst DEFAULT_SCROLL_BEHAVIOR = 'smooth';\n\n/**\n * @hidden\n */\nlet ScrollService = /*#__PURE__*/(() => {\n  var _class24;\n  class ScrollService {\n    get tablistElement() {\n      return this.owner.tablist.nativeElement;\n    }\n    get tabstripSize() {\n      const hostElement = this.owner.wrapper.nativeElement;\n      const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);\n      const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);\n      return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;\n    }\n    get tablistOverflowSize() {\n      if (!isDocumentAvailable()) {\n        return 0;\n      }\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight'] - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);\n      return overflowSize < 0 ? 0 : overflowSize;\n    }\n    get tabsOverflow() {\n      return this.tablistOverflowSize > 0;\n    }\n    constructor(ngZone, localization) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"owner\", void 0);\n      _defineProperty(this, \"position\", 0);\n      _defineProperty(this, \"scrollButtonActiveStateChange\", new Subject());\n      _defineProperty(this, \"isDisabled\", buttonType => this.owner[`${buttonType}ScrollButton`]?.host.nativeElement.classList.contains('k-disabled'));\n      this.ngZone = ngZone;\n      this.localization = localization;\n    }\n    toggleScrollButtonsState() {\n      const tabStrip = this.owner;\n      if (!tabStrip.hasScrollButtons) {\n        return;\n      }\n      const currentPrevButtonActive = !this.isDisabled('prev');\n      const currentNextButtonActive = !this.isDisabled('next');\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      const rtlDelta = this.localization.rtl && isHorizontal ? -1 : 1;\n      const calculatedPrevButtonActive = this.position * rtlDelta > 0 && this.tablistOverflowSize > 0;\n      const calculatedNextButtonActive = this.position * rtlDelta < this.tablistOverflowSize && this.tablistOverflowSize > 0;\n      if (calculatedPrevButtonActive !== currentPrevButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));\n      }\n      if (calculatedNextButtonActive !== currentNextButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));\n      }\n    }\n    scrollToSelectedTab() {\n      if (!this.tabsOverflow) {\n        return;\n      }\n      const {\n        index: activeIndex\n      } = getActiveTab(this.owner.tabs);\n      if (activeIndex === -1) {\n        return;\n      }\n      this.position += this.getScrollOffset(activeIndex);\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollLeft = this.position;\n      } else {\n        this.tablistElement.scrollTop = this.position;\n      }\n      this.toggleScrollButtonsState();\n      const tabStrip = this.owner;\n      if (!tabStrip.hasScrollButtons) {\n        return;\n      }\n      const isFirstTabActive = activeIndex === 0;\n      const isLastTabActive = activeIndex === this.owner.tabs.length - 1;\n      if (isFirstTabActive && !this.isDisabled('prev')) {\n        this.ngZone.run(() => this.toggleButtonActiveState('prev', false));\n      }\n      if (isLastTabActive && !this.isDisabled('next')) {\n        this.ngZone.run(() => this.toggleButtonActiveState('next', false));\n      }\n    }\n    getScrollOffset(activeIndex) {\n      if (!isDocumentAvailable()) {\n        return 0;\n      }\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;\n      const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();\n      const tablistRect = this.tablistElement.getBoundingClientRect();\n      const end = isHorizontal ? 'right' : 'bottom';\n      const start = isHorizontal ? 'left' : 'top';\n      const activeTabStart = activeTabRect[start];\n      const activeTabEnd = activeTabRect[end];\n      const tablistStart = tablistRect[start];\n      const tablistEnd = tablistRect[end];\n      const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;\n      const tabStartIsInVisibleRange = activeTabStart >= tablistStart;\n      const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;\n      if (isWholeTabVisible) {\n        return 0;\n      }\n      if (!tabEndIsInVisibleRange) {\n        return activeTabEnd - tablistEnd;\n      }\n      if (!tabStartIsInVisibleRange) {\n        return activeTabStart - tablistStart;\n      }\n    }\n    onScroll(e) {\n      this.position = isTablistHorizontal(this.owner.tabPosition) ? e.target.scrollLeft : e.target.scrollTop;\n      this.toggleScrollButtonsState();\n    }\n    scrollTabs(direction) {\n      this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);\n      if (isTablistHorizontal(this.owner.tabPosition) && this.tablistElement) {\n        this.tablistElement.scrollTo({\n          left: this.position,\n          behavior: DEFAULT_SCROLL_BEHAVIOR\n        });\n      } else {\n        this.tablistElement.scrollTo({\n          top: this.position,\n          behavior: DEFAULT_SCROLL_BEHAVIOR\n        });\n      }\n      this.toggleScrollButtonsState();\n    }\n    calculateListPosition(direction, scrollSpeed) {\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      if (direction === 'prev') {\n        if (this.localization.rtl && isHorizontal) {\n          this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;\n        } else {\n          this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;\n        }\n      } else if (direction === 'next' && this.position < this.tablistOverflowSize) {\n        if (this.position + scrollSpeed > this.tablistOverflowSize) {\n          this.position = this.tablistOverflowSize;\n          return;\n        }\n        if (this.localization.rtl && isHorizontal) {\n          this.position -= scrollSpeed;\n        } else {\n          this.position += scrollSpeed;\n        }\n      }\n    }\n    restoreScrollPosition() {\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollLeft = this.position;\n      } else {\n        this.tablistElement.scrollTop = this.position;\n      }\n      this.toggleScrollButtonsState();\n    }\n    toggleButtonActiveState(buttonType, active) {\n      this.scrollButtonActiveStateChange.next({\n        buttonType,\n        active\n      });\n    }\n  }\n  _class24 = ScrollService;\n  _defineProperty(ScrollService, \"\\u0275fac\", function _class24_Factory(t) {\n    return new (t || _class24)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.LocalizationService));\n  });\n  _defineProperty(ScrollService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class24,\n    factory: _class24.ɵfac\n  }));\n  return ScrollService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst normalizeSettings = ({\n  enabled = true,\n  scrollButtons = 'auto',\n  mouseScroll = true,\n  buttonScrollSpeed = BUTTON_SCROLL_SPEED,\n  mouseScrollSpeed = MOUSE_SCROLL_SPEED,\n  scrollButtonsPosition = 'split',\n  prevButtonIcon,\n  nextButtonIcon,\n  prevSVGButtonIcon,\n  nextSVGButtonIcon\n}) => ({\n  enabled,\n  scrollButtons,\n  mouseScroll,\n  buttonScrollSpeed,\n  mouseScrollSpeed,\n  scrollButtonsPosition,\n  prevButtonIcon,\n  nextButtonIcon,\n  prevSVGButtonIcon,\n  nextSVGButtonIcon\n});\n/**\n * @hidden\n */\nconst normalizeScrollableSettings = settings => normalizeSettings(settings === false ? {\n  enabled: false\n} : settings);\n\n/**\n * Arguments for the `tabScroll` event of the TabStrip.\n * The `tabScroll` event fires when the tabs are being scrolled.\n *\n */\nclass TabScrollEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The DOM event that triggered the tab scroll.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @hidden\n */\nlet TabStripScrollableButtonComponent = /*#__PURE__*/(() => {\n  var _class26;\n  class TabStripScrollableButtonComponent {\n    get prevClass() {\n      return this.prev;\n    }\n    get nextClass() {\n      return !this.prev;\n    }\n    get hostBoundingClientRect() {\n      return this.host.nativeElement.getBoundingClientRect();\n    }\n    get iconClass() {\n      return this.scrollButtonIconClass;\n    }\n    get customIconClass() {\n      return this.customScrollButtonIconClass;\n    }\n    get svgIcon() {\n      return this.scrollButtonSVGIcon;\n    }\n    constructor(host, renderer, ngZone, localization) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"prev\", false);\n      _defineProperty(this, \"tabPosition\", void 0);\n      _defineProperty(this, \"scrollable\", void 0);\n      _defineProperty(this, \"tabScroll\", new EventEmitter());\n      _defineProperty(this, \"onClick\", new EventEmitter());\n      _defineProperty(this, \"caretAltLeftIcon\", caretAltLeftIcon);\n      _defineProperty(this, \"caretAltRightIcon\", caretAltRightIcon);\n      _defineProperty(this, \"caretAltUpIcon\", caretAltUpIcon);\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"clickHandler\", scrollEvent => {\n        const tabStripScrollEvent = this.emitScrollEvent(scrollEvent);\n        const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();\n        if (isTabStripScrollEventPrevented) {\n          return;\n        }\n        const buttonType = this.prev ? 'prev' : 'next';\n        this.onClick.emit(buttonType);\n      });\n      this.host = host;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.localization = localization;\n    }\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));\n      });\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    toggle(show) {\n      this.renderer[show ? 'removeClass' : 'addClass'](this.host.nativeElement, HIDDEN_CLASS);\n    }\n    get scrollButtonIconClass() {\n      const defaultPrevIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.right : DIRECTION_CLASSES.up;\n      const defaultNextIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.left : DIRECTION_CLASSES.down;\n      if (typeof this.scrollable === 'object') {\n        const prevIcon = typeof this.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : '';\n        const nextIcon = typeof this.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : '';\n        if (prevIcon && this.prev) {\n          return prevIcon;\n        } else if (nextIcon && !this.prev) {\n          return nextIcon;\n        }\n      }\n    }\n    get customScrollButtonIconClass() {\n      if (typeof this.scrollable === 'object') {\n        const prevIcon = this.scrollable.prevButtonIcon;\n        const nextIcon = this.scrollable.nextButtonIcon;\n        if (prevIcon && this.prev) {\n          return `k-icon ${prevIcon}`;\n        }\n        if (nextIcon && !this.prev) {\n          return `k-icon ${nextIcon}`;\n        }\n      }\n    }\n    get scrollButtonSVGIcon() {\n      const defaultPrevSVGIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? this.caretAltLeftIcon : this.caretAltRightIcon : this.caretAltUpIcon;\n      const defaultNextSVGIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;\n      if (typeof this.scrollable === 'object') {\n        const prevIcon = this.scrollable.prevSVGButtonIcon !== undefined ? this.scrollable.prevSVGButtonIcon : defaultPrevSVGIcon;\n        const nextIcon = this.scrollable.nextSVGButtonIcon !== undefined ? this.scrollable.nextSVGButtonIcon : defaultNextSVGIcon;\n        if (prevIcon || nextIcon) {\n          return this.prev ? prevIcon : nextIcon;\n        }\n      }\n    }\n    emitScrollEvent(event) {\n      const scrollEvent = new TabScrollEvent({\n        originalEvent: event\n      });\n      this.tabScroll.emit(scrollEvent);\n      return scrollEvent;\n    }\n  }\n  _class26 = TabStripScrollableButtonComponent;\n  _defineProperty(TabStripScrollableButtonComponent, \"\\u0275fac\", function _class26_Factory(t) {\n    return new (t || _class26)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TabStripScrollableButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class26,\n    selectors: [[\"\", \"kendoTabStripScrollableButton\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class26_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-tabstrip-prev\", ctx.prevClass)(\"k-tabstrip-next\", ctx.nextClass);\n      }\n    },\n    inputs: {\n      prev: \"prev\",\n      tabPosition: \"tabPosition\",\n      scrollable: \"scrollable\"\n    },\n    outputs: {\n      tabScroll: \"tabScroll\",\n      onClick: \"onClick\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c12,\n    decls: 1,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"]],\n    template: function _class26_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-icon-wrapper\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"name\", ctx.iconClass)(\"customFontClass\", ctx.customIconClass)(\"svgIcon\", ctx.svgIcon);\n      }\n    },\n    dependencies: [IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return TabStripScrollableButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TabComponent = /*#__PURE__*/(() => {\n  var _class27;\n  class TabComponent {\n    get activeClass() {\n      return this.tab.selected;\n    }\n    get disabledClass() {\n      return this.tab.disabled;\n    }\n    get focusedClass() {\n      return this.tab.focused;\n    }\n    get tabIndex() {\n      return this.tab.selected || this.tab.focused ? 0 : -1;\n    }\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"tab\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"tabStripClosable\", void 0);\n      _defineProperty(this, \"tabStripCloseIcon\", void 0);\n      _defineProperty(this, \"customTabstripCloseIcon\", void 0);\n      _defineProperty(this, \"closeSVGIcon\", void 0);\n      _defineProperty(this, \"tabClose\", new EventEmitter());\n      _defineProperty(this, \"hostClasses\", true);\n      this.localization = localization;\n    }\n    get tabClosable() {\n      if (this.tab.closable !== undefined) {\n        return this.tab.closable;\n      }\n      return this.tabStripClosable;\n    }\n    get closeSVGIconClass() {\n      if (this.customCloseButtonClasses) {\n        return;\n      }\n      if (this.tab.closeSVGIcon) {\n        return this.tab.closeSVGIcon;\n      }\n      if (this.closeSVGIcon) {\n        return this.closeSVGIcon;\n      }\n      return xIcon;\n    }\n    get closeButtonClasses() {\n      if (!this.customTabstripCloseIcon && this.tabStripCloseIcon && !this.tab.closeIconClass) {\n        if (this.tab.closeIcon) {\n          return this.tab.closeIcon;\n        }\n        return this.tabStripCloseIcon;\n      }\n    }\n    get customCloseButtonClasses() {\n      if (this.customTabstripCloseIcon || this.tab.closeIconClass) {\n        if (this.tab.closeIconClass) {\n          return this.tab.closeIconClass;\n        }\n        return this.customTabstripCloseIcon;\n      }\n    }\n    get closeButtonTitle() {\n      return this.localization.get('closeTitle');\n    }\n    closeTab(index) {\n      const closeArgs = new TabCloseEvent(index, this.tab);\n      this.tabClose.emit(closeArgs);\n    }\n  }\n  _class27 = TabComponent;\n  _defineProperty(TabComponent, \"\\u0275fac\", function _class27_Factory(t) {\n    return new (t || _class27)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TabComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class27,\n    selectors: [[\"\", \"kendoTabStripTab\", \"\"]],\n    hostVars: 13,\n    hostBindings: function _class27_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-selected\", ctx.activeClass)(\"aria-disabled\", ctx.disabledClass)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"k-item\", ctx.hostClasses)(\"k-tabstrip-item\", ctx.hostClasses)(\"k-active\", ctx.activeClass)(\"k-disabled\", ctx.disabledClass)(\"k-focus\", ctx.focusedClass);\n      }\n    },\n    inputs: {\n      tab: \"tab\",\n      index: \"index\",\n      tabStripClosable: \"tabStripClosable\",\n      tabStripCloseIcon: \"tabStripCloseIcon\",\n      customTabstripCloseIcon: \"customTabstripCloseIcon\",\n      closeSVGIcon: \"closeSVGIcon\"\n    },\n    outputs: {\n      tabClose: \"tabClose\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c13,\n    decls: 4,\n    vars: 4,\n    consts: [[4, \"ngIf\", \"ngIfElse\"], [3, \"ngTemplateOutlet\"], [\"tabTemplate\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", \"role\", \"button\", \"fillMode\", \"flat\", \"class\", \"k-remove-tab k-icon-button\", 3, \"icon\", \"iconClass\", \"svgIcon\", \"title\", \"click\", 4, \"ngIf\"], [\"class\", \"k-link\", 4, \"ngIf\"], [1, \"k-link\"], [1, \"k-link-text\"], [\"kendoButton\", \"\", \"type\", \"button\", \"role\", \"button\", \"fillMode\", \"flat\", 1, \"k-remove-tab\", \"k-icon-button\", 3, \"icon\", \"iconClass\", \"svgIcon\", \"title\", \"click\"]],\n    template: function _class27_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class27_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class27_ng_template_1_Template, 0, 0, \"ng-template\", 1, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, _class27_button_3_Template, 1, 5, \"button\", 3);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.tab.tabTemplate)(\"ngIfElse\", _r1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.tab.tabTemplate == null ? null : ctx.tab.tabTemplate.templateRef);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.tabClosable);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, ButtonComponent],\n    encapsulation: 2\n  }));\n  return TabComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TabStripMessages = /*#__PURE__*/(() => {\n  var _class28;\n  class TabStripMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title for the **Close** button in the TabStrip tab.\n       */\n      _defineProperty(this, \"closeTitle\", void 0);\n      /**\n       * The title for the **Previous Tab** button when the Tabstrip is scrollable.\n       */\n      _defineProperty(this, \"previousTabButton\", void 0);\n      /**\n       * The title for the **Next Tab** button when the Tabstrip is scrollable.\n       */\n      _defineProperty(this, \"nextTabButton\", void 0);\n    }\n  }\n  _class28 = TabStripMessages;\n  _defineProperty(TabStripMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class28_BaseFactory;\n    return function _class28_Factory(t) {\n      return (ɵ_class28_BaseFactory || (ɵ_class28_BaseFactory = i0.ɵɵgetInheritedFactory(_class28)))(t || _class28);\n    };\n  }());\n  _defineProperty(TabStripMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class28,\n    selectors: [[\"kendo-tabstrip-messages-base\"]],\n    inputs: {\n      closeTitle: \"closeTitle\",\n      previousTabButton: \"previousTabButton\",\n      nextTabButton: \"nextTabButton\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return TabStripMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedTabStripMessagesDirective = /*#__PURE__*/(() => {\n  var _class29;\n  class LocalizedTabStripMessagesDirective extends TabStripMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class29 = LocalizedTabStripMessagesDirective;\n  _defineProperty(LocalizedTabStripMessagesDirective, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedTabStripMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class29,\n    selectors: [[\"\", \"kendoTabStripLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TabStripMessages,\n      useExisting: forwardRef(() => _class29)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedTabStripMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).\n */\nlet TabStripComponent = /*#__PURE__*/(() => {\n  var _class30;\n  class TabStripComponent {\n    /**\n     * Sets the height of the TabStrip.\n     */\n    set height(value) {\n      this._height = value;\n      this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);\n    }\n    get height() {\n      return this._height;\n    }\n    /**\n     * Enables the tab animation.\n     *\n     * @default true\n     */\n\n    /**\n     * Enables the scrolling of the tab list. When set to `true` and the total size of all tabs\n     * is greater than the size of the TabStrip container, scroll buttons will be rendered on each end of the tab list.\n     *\n     * By default, `scrollable` is `false`.\n     *\n     * @default false\n     */\n    set scrollable(value) {\n      this._scrollableSettings = normalizeScrollableSettings(value);\n      if (this.tablist) {\n        this.toggleScrollButtons(this.scrollService.tabsOverflow);\n        if (this.isScrollable && this.mouseScrollEnabled) {\n          this.attachTablistScrollHandler(this.tablist.nativeElement);\n        }\n      }\n    }\n    get scrollable() {\n      return this._scrollableSettings;\n    }\n    /**\n     * Specifies the size of the TabStrip.\n     * ([see example](slug:api_layout_tabstripcomponent#toc-size).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     */\n    set size(value) {\n      switch (value) {\n        case 'small':\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');\n          this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-sm');\n          break;\n        case 'medium':\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');\n          this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-md');\n          break;\n        case 'large':\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');\n          this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-lg');\n          break;\n        case 'none':\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');\n      }\n      this._size = value;\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.onResize());\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Defines the name for an existing font icon in the Kendo UI theme for the close icon.\n     */\n\n    /**\n     * Defines an SVGIcon to be rendered for the close icon.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set closeSVGIcon(icon) {\n      if (isDevMode() && icon && this.closeIcon && this.closeIcon !== 'x') {\n        throw new Error('Setting both closeIcon and svgIcon options at the same time is not supported.');\n      }\n      this._closeSVGIcon = icon;\n    }\n    get closeSVGIcon() {\n      return this._closeSVGIcon;\n    }\n    /**\n     * Determines whether the content associated with each tab will be rendered.\n     *\n     * @default true\n     */\n\n    get tabsAtTop() {\n      return this.tabPosition === 'top';\n    }\n    get tabsAtRight() {\n      return this.tabPosition === 'right';\n    }\n    get tabsAtBottom() {\n      return this.tabPosition === 'bottom';\n    }\n    get tabsAtLeft() {\n      return this.tabPosition === 'left';\n    }\n    get dir() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    get tabStripScrollable() {\n      return this._scrollableSettings.enabled;\n    }\n    get tabStripScrollableOverlay() {\n      return this._scrollableSettings.enabled && !this.hasScrollButtons.visible;\n    }\n    /**\n     * A query list of all declared tabs.\n     */\n\n    constructor(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"tabstripService\", void 0);\n      _defineProperty(this, \"scrollService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"animate\", true);\n      /**\n       * Sets the alignment of the tabs.\n       *\n       * @default: 'start'\n       */\n      _defineProperty(this, \"tabAlignment\", 'start');\n      /**\n       * Sets the position of the tabs. Defaults to `top`.\n       *\n       * @default 'top'\n       */\n      _defineProperty(this, \"tabPosition\", 'top');\n      /**\n       * When set to `true`, the component renders all tabs and they are persisted in the DOM.\n       * By default, `keepTabContent` is `false`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"keepTabContent\", false);\n      /**\n       * When set to `true`, a close button will be rendered inside each tab.\n       * By default, `closable` is `false`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"closable\", false);\n      _defineProperty(this, \"closeIcon\", 'x');\n      /**\n       * Allows defining a custom CSS class, or multiple classes separated by spaces, which will be applied to the close button.\n       */\n      _defineProperty(this, \"closeIconClass\", void 0);\n      _defineProperty(this, \"showContentArea\", true);\n      /**\n       * Fires each time the user selects a tab ([see example](slug:events_tabstrip)).\n       * The event data contains the index of the selected tab and its title.\n       */\n      _defineProperty(this, \"tabSelect\", new EventEmitter());\n      /**\n       * Fires each time the user closes a tab.\n       * The event data contains the index of the closed tab and its instance.\n       */\n      _defineProperty(this, \"tabClose\", new EventEmitter());\n      /**\n       * Fires each time the user scrolls the TabStrip list.\n       * The event is preventable.\n       */\n      _defineProperty(this, \"tabScroll\", new EventEmitter());\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"tabs\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"tablist\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"tabHeaderContainers\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prevScrollButton\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"nextScrollButton\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"localizationChangeSubscription\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"_height\", void 0);\n      _defineProperty(this, \"_scrollableSettings\", normalizeScrollableSettings(false));\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"subscriptionsArePresent\", false);\n      _defineProperty(this, \"_closeSVGIcon\", void 0);\n      _defineProperty(this, \"tabStripId\", guid());\n      _defineProperty(this, \"tabsChangesSub\", void 0);\n      _defineProperty(this, \"activeStateChangeSub\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      this.localization = localization;\n      this.renderer = renderer;\n      this.wrapper = wrapper;\n      this.tabstripService = tabstripService;\n      this.scrollService = scrollService;\n      this.ngZone = ngZone;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      this.tabstripService.owner = this;\n      this.scrollService.owner = this;\n      this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe(activeButtonSettings => {\n        if (this.hasScrollButtons.visible) {\n          const action = activeButtonSettings.active ? 'remove' : 'add';\n          this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, 'k-disabled');\n        }\n      }));\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        if (this.scrollService.tabsOverflow) {\n          this.toggleScrollButtons(true);\n        } else {\n          this.toggleScrollButtons(false);\n        }\n        setTimeout(() => {\n          this.scrollToSelectedTab();\n        });\n      });\n      this.initDomEvents();\n      this.tabsChangesSub = this.tabs.changes.subscribe(() => {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          this.toggleScrollButtons(this.scrollService.tabsOverflow);\n          this.scrollService.toggleScrollButtonsState();\n        });\n      });\n      this.isScrollable && !this.hasScrollButtons.visible && this.setScrollableOverlayClasses();\n    }\n    ngOnChanges(changes) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const positionChange = changes['tabPosition'];\n      if (positionChange) {\n        const tabsAtBottomChanged = positionChange.previousValue === 'bottom' || positionChange.currentValue === 'bottom';\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          if (tabsAtBottomChanged) {\n            if (this.subscriptionsArePresent) {\n              this.subscriptions.unsubscribe();\n              this.subscriptions = new Subscription();\n              this.subscriptionsArePresent = false;\n              this.activeStateChangeSub = this.scrollService.scrollButtonActiveStateChange.subscribe(activeButtonSettings => {\n                if (this.hasScrollButtons.visible) {\n                  const action = activeButtonSettings.active ? 'remove' : 'add';\n                  this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, 'k-disabled');\n                }\n              });\n            }\n            this.initDomEvents();\n          }\n          this.scrollService.restoreScrollPosition();\n        });\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n      if (this.tabsChangesSub) {\n        this.tabsChangesSub.unsubscribe();\n      }\n      if (this.activeStateChangeSub) {\n        this.activeStateChangeSub.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get isScrollable() {\n      return this._scrollableSettings.enabled;\n    }\n    /**\n     * @hidden\n     */\n    get hasScrollButtons() {\n      return tabStripHasScrollButtons(this._scrollableSettings);\n    }\n    /**\n     * @hidden\n     */\n    get mouseScrollEnabled() {\n      return mouseScrollEnabled(this._scrollableSettings);\n    }\n    /**\n     * @hidden\n     */\n    get itemsWrapperClass() {\n      return isTablistHorizontal(this.tabPosition) ? 'k-hstack' : 'k-vstack';\n    }\n    /**\n     * Allows the user to select a tab programmatically.\n     * @param {number} index - The index of the tab that will be selected.\n     */\n    selectTab(index) {\n      const tab = getTabByIndex(this.tabs, index);\n      if (!tab || tab.disabled) {\n        return;\n      }\n      this.tabstripService.selectTab(tab, index);\n      this.scrollToSelectedTab();\n    }\n    /**\n     * @hidden\n     */\n    getTabId(idx) {\n      return getId$1('k-tabstrip-tab', this.tabStripId, idx);\n    }\n    /**\n     * @hidden\n     */\n    getTabPanelId(idx) {\n      return getId$1('k-tabstrip-tabpanel', this.tabStripId, idx);\n    }\n    /**\n     * @hidden\n     */\n    onTabClick(originalEvent, tabIndex) {\n      if (isFocusable(originalEvent.target)) {\n        return;\n      }\n      const targetElement = originalEvent.target;\n      const isTargetCloseButton = hasClass(targetElement, 'k-remove-tab') || hasClass(targetElement.parentElement, 'k-remove-tab');\n      if (isTargetCloseButton) {\n        return;\n      }\n      const tab = getTabByIndex(this.tabs, tabIndex);\n      this.tabstripService.onTabSelect(tab, tabIndex);\n      this.scrollToSelectedTab();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      if (this.scrollService.tabsOverflow) {\n        this.toggleScrollButtons(true);\n      } else {\n        this.toggleScrollButtons(false);\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.scrollService.toggleScrollButtonsState();\n      });\n    }\n    /**\n     * @hidden\n     */\n    scrollToSelectedTab() {\n      if (this._scrollableSettings.enabled) {\n        this.scrollService.scrollToSelectedTab();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onScrollButtonClick(buttonType) {\n      this.scrollService.scrollTabs(buttonType);\n    }\n    initDomEvents() {\n      if (!this.wrapper || this.subscriptionsArePresent) {\n        return;\n      }\n      const tablist = this.tablist.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(tablist, 'keydown', ev => {\n          this.tabstripService.onKeyDown(ev);\n        }));\n      });\n      this.subscriptions.add(this.renderer.listen(tablist, 'focusout', () => {\n        resetTabFocus(this.tabs);\n      }));\n      if (this.isScrollable && this.mouseScrollEnabled) {\n        this.attachTablistScrollHandler(tablist);\n      }\n      this.subscriptionsArePresent = true;\n    }\n    toggleScrollButtons(tabsOverflow) {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        const scrollButtonsSetting = this._scrollableSettings.scrollButtons;\n        const scrollButtonsArePresent = this.prevScrollButton && this.nextScrollButton;\n        const shouldShowButtons = scrollButtonsArePresent && tabsOverflow;\n        const shouldHideButtons = scrollButtonsArePresent && !tabsOverflow && scrollButtonsSetting !== 'visible';\n        const alwaysVisible = scrollButtonsSetting === 'visible';\n        if (shouldHideButtons) {\n          this.prevScrollButton.toggle(false);\n          this.nextScrollButton.toggle(false);\n        } else if (shouldShowButtons || alwaysVisible) {\n          this.prevScrollButton.toggle(true);\n          this.nextScrollButton.toggle(true);\n        }\n        if (scrollButtonsArePresent) {\n          this.ngZone.runOutsideAngular(() => {\n            this.scrollService.toggleScrollButtonsState();\n          });\n        }\n      });\n    }\n    attachTablistScrollHandler(tablist) {\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(tablist, 'scroll', e => {\n          const scrollEvent = new TabScrollEvent({\n            originalEvent: e\n          });\n          this.tabScroll.emit(scrollEvent);\n          const isTabStripScrollEventPrevented = scrollEvent.isDefaultPrevented();\n          if (isTabStripScrollEventPrevented || !this.scrollService.tabsOverflow) {\n            return;\n          }\n          if (!this.hasScrollButtons.visible) {\n            this.setScrollableOverlayClasses();\n          }\n          this.scrollService.onScroll(e);\n        }));\n      });\n    }\n    setScrollableOverlayClasses() {\n      const wrapper = this.wrapper.nativeElement;\n      const container = this.tablist?.nativeElement;\n      if (!container) {\n        return;\n      }\n      const scrollOffset = isTablistHorizontal(this.tabPosition) ? container.scrollLeft : container.scrollTop;\n      if (scrollOffset === 0) {\n        this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-end');\n        this.renderer.addClass(wrapper, 'k-tabstrip-scrollable-start');\n      } else if (scrollOffset > 0 && scrollOffset < this.scrollService.tablistOverflowSize) {\n        this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-end');\n        this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-start');\n      } else {\n        this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-start');\n        this.renderer.addClass(wrapper, 'k-tabstrip-scrollable-end');\n      }\n    }\n  }\n  _class30 = TabStripComponent;\n  _defineProperty(TabStripComponent, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TabStripService), i0.ɵɵdirectiveInject(ScrollService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(TabStripComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class30,\n    selectors: [[\"kendo-tabstrip\"]],\n    contentQueries: function _class30_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TabStripTabComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabs = _t);\n      }\n    },\n    viewQuery: function _class30_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c14, 5);\n        i0.ɵɵviewQuery(_c15, 5);\n        i0.ɵɵviewQuery(_c16, 5);\n        i0.ɵɵviewQuery(_c17, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tablist = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabHeaderContainers = _t);\n      }\n    },\n    hostVars: 17,\n    hostBindings: function _class30_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-tabstrip\", ctx.hostClasses)(\"k-tabstrip-md\", ctx.hostClasses)(\"k-tabstrip-top\", ctx.tabsAtTop)(\"k-tabstrip-right\", ctx.tabsAtRight)(\"k-tabstrip-bottom\", ctx.tabsAtBottom)(\"k-tabstrip-left\", ctx.tabsAtLeft)(\"k-tabstrip-scrollable\", ctx.tabStripScrollable)(\"k-tabstrip-scrollable-overlay\", ctx.tabStripScrollableOverlay);\n      }\n    },\n    inputs: {\n      height: \"height\",\n      animate: \"animate\",\n      tabAlignment: \"tabAlignment\",\n      tabPosition: \"tabPosition\",\n      keepTabContent: \"keepTabContent\",\n      closable: \"closable\",\n      scrollable: \"scrollable\",\n      size: \"size\",\n      closeIcon: \"closeIcon\",\n      closeIconClass: \"closeIconClass\",\n      closeSVGIcon: \"closeSVGIcon\",\n      showContentArea: \"showContentArea\"\n    },\n    outputs: {\n      tabSelect: \"tabSelect\",\n      tabClose: \"tabClose\",\n      tabScroll: \"tabScroll\"\n    },\n    exportAs: [\"kendoTabStrip\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([TabStripService, ScrollService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.tabstrip'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 9,\n    vars: 4,\n    consts: function () {\n      let i18n_18;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Close** button in the TabStrip tab.\n         * @meaning kendo.tabstrip.closeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_19 = goog.getMsg(\"Close\");\n        i18n_18 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_19;\n      } else {\n        i18n_18 = $localize`:kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab.:Close`;\n      }\n      let i18n_20;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Previous Tab** button when the Tabstrip is scrollable.\n         * @meaning kendo.tabstrip.previousTabButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_21 = goog.getMsg(\"Previous Tab\");\n        i18n_20 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_21;\n      } else {\n        i18n_20 = $localize`:kendo.tabstrip.previousTabButton|The title for the **Previous Tab** button when the Tabstrip is scrollable.:Previous Tab`;\n      }\n      let i18n_22;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Next Tab** button when the Tabstrip is scrollable.\n         * @meaning kendo.tabstrip.nextTabButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_23 = goog.getMsg(\"Next Tab\");\n        i18n_22 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_23;\n      } else {\n        i18n_22 = $localize`:kendo.tabstrip.nextTabButton|The title for the **Next Tab** button when the Tabstrip is scrollable.:Next Tab`;\n      }\n      return [[\"kendoTabStripLocalizedMessages\", \"\", \"closeTitle\", i18n_18, \"previousTabButton\", i18n_20, \"nextTabButton\", i18n_22], [4, \"ngIf\"], [\"heading\", \"\"], [\"content\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [1, \"k-tabstrip-items-wrapper\", 3, \"ngClass\"], [\"role\", \"button\", \"kendoTabStripScrollableButton\", \"\", \"class\", \"k-icon-button k-button k-button-flat k-button-flat-base\", 3, \"scrollable\", \"tabPosition\", \"prev\", \"title\", \"ngClass\", \"tabScroll\", \"onClick\", 4, \"ngIf\"], [\"role\", \"tablist\", 1, \"k-reset\", \"k-tabstrip-items\", 3, \"ngClass\"], [\"tablist\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"role\", \"button\", \"kendoTabStripScrollableButton\", \"\", 1, \"k-icon-button\", \"k-button\", \"k-button-flat\", \"k-button-flat-base\", 3, \"scrollable\", \"tabPosition\", \"prev\", \"title\", \"ngClass\", \"tabScroll\", \"onClick\"], [\"prevScrollButton\", \"\"], [\"nextScrollButton\", \"\"], [\"kendoTabStripTab\", \"\", \"role\", \"tab\", 3, \"ngClass\", \"ngStyle\", \"tab\", \"index\", \"tabStripClosable\", \"tabStripCloseIcon\", \"customTabstripCloseIcon\", \"closeSVGIcon\", \"id\", \"tabClose\", \"click\"], [\"tabHeaderContainer\", \"\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"role\", \"tabpanel\", 3, \"ngClass\", \"tabIndex\", \"id\", 4, \"ngIf\"], [\"role\", \"tabpanel\", 3, \"ngClass\", \"tabIndex\", \"id\"], [3, \"ngTemplateOutlet\"], [3, \"resize\"], [\"kendoWatermarkOverlay\", \"\"]];\n    },\n    template: function _class30_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, _class30_ng_container_1_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, _class30_ng_container_2_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(3, _class30_ng_template_3_Template, 8, 17, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, _class30_ng_template_5_Template, 1, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, _class30_kendo_resize_sensor_7_Template, 1, 0, \"kendo-resize-sensor\", 4);\n        i0.ɵɵtemplate(8, _class30_div_8_Template, 1, 0, \"div\", 5);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.tabsAtBottom);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.tabsAtBottom);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.isScrollable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [LocalizedTabStripMessagesDirective, NgIf, NgTemplateOutlet, NgClass, TabStripScrollableButtonComponent, NgFor, TabComponent, NgStyle, ResizeSensorComponent, WatermarkOverlayComponent],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('state', [state('active', style({\n        opacity: 1\n      })), transition('* => active', [style({\n        opacity: 0\n      }), animate('400ms ease-in')])])]\n    }\n  }));\n  return TabStripComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\nlet TabStripCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class31;\n  class TabStripCustomMessagesComponent extends TabStripMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class31 = TabStripCustomMessagesComponent;\n  _defineProperty(TabStripCustomMessagesComponent, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TabStripCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class31,\n    selectors: [[\"kendo-tabstrip-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TabStripMessages,\n      useExisting: forwardRef(() => _class31)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class31_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return TabStripCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.\n * Using this template directive will override all other templates,\n * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.\n */\nlet DrawerTemplateDirective = /*#__PURE__*/(() => {\n  var _class32;\n  class DrawerTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class32 = DrawerTemplateDirective;\n  _defineProperty(DrawerTemplateDirective, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DrawerTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class32,\n    selectors: [[\"\", \"kendoDrawerTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DrawerTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the item content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.\n */\nlet DrawerItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class33;\n  class DrawerItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class33 = DrawerItemTemplateDirective;\n  _defineProperty(DrawerItemTemplateDirective, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DrawerItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class33,\n    selectors: [[\"\", \"kendoDrawerItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DrawerItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the header content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.\n */\nlet DrawerHeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class34;\n  class DrawerHeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class34 = DrawerHeaderTemplateDirective;\n  _defineProperty(DrawerHeaderTemplateDirective, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DrawerHeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class34,\n    selectors: [[\"\", \"kendoDrawerHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DrawerHeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the footer content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.\n */\nlet DrawerFooterTemplateDirective = /*#__PURE__*/(() => {\n  var _class35;\n  class DrawerFooterTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class35 = DrawerFooterTemplateDirective;\n  _defineProperty(DrawerFooterTemplateDirective, \"\\u0275fac\", function _class35_Factory(t) {\n    return new (t || _class35)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DrawerFooterTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class35,\n    selectors: [[\"\", \"kendoDrawerFooterTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DrawerFooterTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst defaultIsItemExpanded = _item => false;\n/**\n * @hidden\n */\nlet DrawerService = /*#__PURE__*/(() => {\n  var _class36;\n  class DrawerService {\n    constructor() {\n      _defineProperty(this, \"owner\", void 0);\n      _defineProperty(this, \"selectedIndices\", []);\n      _defineProperty(this, \"viewData\", void 0);\n      _defineProperty(this, \"focusIndex\", 0);\n      _defineProperty(this, \"originalItems\", []);\n      _defineProperty(this, \"idxCounter\", 0);\n      _defineProperty(this, \"isItemExpanded\", defaultIsItemExpanded);\n    }\n    init() {\n      this.resetViewData();\n      this.originalItems = this.owner.items || [];\n      const rootItems = this.originalItems.filter(item => !isPresent(item.parentId));\n      this.populateViewData(rootItems);\n    }\n    get view() {\n      return Array.from(this.viewData);\n    }\n    changeFocusedItem(items, keyName, renderer) {\n      const currentItem = items.get(this.focusIndex);\n      let nextItem;\n      if (keyName === 'arrowUp') {\n        if (this.focusIndex === 0) {\n          nextItem = items.get(items.length - 1);\n          this.focusIndex = items.length - 1;\n        } else {\n          nextItem = items.get(this.focusIndex - 1);\n          this.focusIndex = this.focusIndex - 1;\n        }\n      } else if (keyName === 'arrowDown') {\n        if (this.focusIndex === items.length - 1) {\n          nextItem = items.get(0);\n          this.focusIndex = 0;\n        } else {\n          nextItem = items.get(this.focusIndex + 1);\n          this.focusIndex = this.focusIndex + 1;\n        }\n      }\n      renderer.setAttribute(currentItem.nativeElement, 'tabindex', '-1');\n      renderer.setAttribute(nextItem.nativeElement, 'tabindex', '0');\n      nextItem.nativeElement.focus();\n    }\n    populateViewData(items, level = 0) {\n      items.forEach(item => {\n        this.setSelection(item);\n        const children = this.loadChildren(item);\n        const isExpanded = this.isItemExpanded(item);\n        this.viewData.add({\n          item: item,\n          index: this.idxCounter++,\n          level: level,\n          hasChildren: children.length > 0,\n          isExpanded: isExpanded\n        });\n        if (children.length > 0 && isExpanded) {\n          this.populateViewData(children, level + 1);\n        }\n      });\n    }\n    resetViewData() {\n      this.idxCounter = 0;\n      this.viewData = new Set();\n    }\n    loadChildren(item) {\n      return this.originalItems.filter(i => {\n        return isPresent(i.parentId) && i.parentId === item.id;\n      });\n    }\n    onSelect(selectedIdx) {\n      this.selectedIndices = [selectedIdx];\n      const drawer = this.owner;\n      if (drawer.autoCollapse && !drawer.minimized) {\n        drawer.toggle(false);\n      }\n    }\n    setSelection(item) {\n      if (this.selectedIndices.length === 0 && item.selected) {\n        this.selectedIndices.push(this.idxCounter);\n      }\n    }\n    resetSelection() {\n      this.selectedIndices = [];\n    }\n  }\n  _class36 = DrawerService;\n  _defineProperty(DrawerService, \"\\u0275fac\", function _class36_Factory(t) {\n    return new (t || _class36)();\n  });\n  _defineProperty(DrawerService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class36,\n    factory: _class36.ɵfac\n  }));\n  return DrawerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction miniExpandPush(duration, width, miniWidth) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: `${miniWidth}px`\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\nfunction miniCollapsePush(duration, width, miniWidth) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${miniWidth}px`\n  }))];\n}\n/**\n * @hidden\n *\n */\nfunction miniExpandOverlay(duration, width, miniWidth) {\n  return [style({\n    width: `${miniWidth}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    width: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\nfunction expandPush(duration, width) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: '0px'\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\nfunction collapsePush(duration, width) {\n  return [style({\n    flexBasis: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    flexBasis: `0px`\n  }))];\n}\n/**\n * @hidden\n */\nfunction expandRTLOverlay(duration) {\n  return [style({\n    transform: `translateX(100%)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(0)`\n  }))];\n}\n/**\n * @hidden\n */\nfunction expandOverlay(duration, position) {\n  const translateDir = position !== 'end' ? `-100%` : `100%`;\n  return [style({\n    transform: `translateX(${translateDir})`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(0)`\n  }))];\n}\n/**\n * @hidden\n */\nfunction miniCollapseOverlay(duration, width, miniWidth) {\n  return [style({\n    width: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    width: `${miniWidth}px`\n  }))];\n}\n/**\n * @hidden\n */\nfunction collapseOverlay(duration, position) {\n  const translateDir = position !== 'end' ? '-100%' : '100%';\n  return [style({\n    transform: `translateX(0)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(${translateDir})`\n  }))];\n}\n/**\n * @hidden\n */\nfunction collapseRTLOverlay(duration) {\n  return [style({\n    transform: `translateX(0)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(100%)`\n  }))];\n}\n/**\n * @hidden\n */\nfunction expandAnimation(settings) {\n  const duration = settings.animation.duration;\n  const width = settings.width;\n  const miniWidth = settings.miniWidth;\n  const mode = settings.mode;\n  const mini = settings.mini;\n  const rtl = settings.rtl;\n  const position = settings.position;\n  if (mini && mode === 'push') {\n    return miniExpandPush(duration, width, miniWidth);\n  }\n  if (!mini && mode === 'push') {\n    return expandPush(duration, width);\n  }\n  if (!mini && mode === 'overlay') {\n    return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);\n  }\n  if (mini && mode === 'overlay') {\n    return miniExpandOverlay(duration, width, miniWidth);\n  }\n}\n/**\n * @hidden\n */\nfunction collapseAnimation(settings) {\n  const duration = settings.animation.duration;\n  const width = settings.width;\n  const miniWidth = settings.miniWidth;\n  const mode = settings.mode;\n  const mini = settings.mini;\n  const rtl = settings.rtl;\n  const position = settings.position;\n  if (mini && mode === 'push') {\n    return miniCollapsePush(duration, width, miniWidth);\n  }\n  if (!mini && mode === 'push') {\n    return collapsePush(duration, width);\n  }\n  if (!mini && mode === 'overlay') {\n    return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);\n  }\n  if (mini && mode === 'overlay') {\n    return miniCollapseOverlay(duration, width, miniWidth);\n  }\n}\n\n/**\n * @hidden\n */\nconst DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';\n\n/**\n * @hidden\n */\nconst DRAWER_LINK_SELECTOR = '.k-drawer-link';\n/**\n * @hidden\n */\nconst ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-disabled) .k-drawer-link';\n/**\n * @hidden\n */\nconst nestedLink = (element, selector) => element.querySelector(selector);\n\n/**\n * @hidden\n */\nclass DrawerListSelectEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The index of the selected item in the `items` collection.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     * The selected Drawer item.\n     */\n    _defineProperty(this, \"item\", void 0);\n    /**\n     * The DOM event that triggered the selection.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @hidden\n */\nlet DrawerItemComponent = /*#__PURE__*/(() => {\n  var _class38;\n  class DrawerItemComponent {\n    get disabledClass() {\n      return this.item.disabled;\n    }\n    get selectedClass() {\n      return this.drawerService.selectedIndices.indexOf(this.index) >= 0;\n    }\n    get label() {\n      return this.item.text ? this.item.text : null;\n    }\n    constructor(drawerService, element, renderer) {\n      _defineProperty(this, \"drawerService\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"viewItem\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"mini\", void 0);\n      _defineProperty(this, \"expanded\", void 0);\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"cssClass\", void 0);\n      _defineProperty(this, \"cssStyle\", void 0);\n      _defineProperty(this, \"arrowUpIcon\", chevronUpIcon);\n      _defineProperty(this, \"arrowDownIcon\", chevronDownIcon);\n      this.drawerService = drawerService;\n      this.element = element;\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      const elem = this.element.nativeElement;\n      const link = nestedLink(elem, DRAWER_LINK_SELECTOR);\n      if (link) {\n        this.renderer.removeAttribute(link, 'tabindex');\n      }\n    }\n    get iconClasses() {\n      if (this.item.icon) {\n        const stripIcon = this.item.icon.replace('k-i-', '');\n        return `${stripIcon}`;\n      }\n    }\n    get innerCssClasses() {\n      if (this.item.iconClass && this.item.icon) {\n        return `${this.item.iconClass}`;\n      }\n    }\n    get customIconClasses() {\n      if (!this.item.icon && this.item.iconClass) {\n        return this.item.iconClass;\n      }\n    }\n    get item() {\n      return this.viewItem.item;\n    }\n  }\n  _class38 = DrawerItemComponent;\n  _defineProperty(DrawerItemComponent, \"\\u0275fac\", function _class38_Factory(t) {\n    return new (t || _class38)(i0.ɵɵdirectiveInject(DrawerService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(DrawerItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class38,\n    selectors: [[\"\", \"kendoDrawerItem\", \"\"]],\n    hostVars: 7,\n    hostBindings: function _class38_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"aria-current\", ctx.selectedClass)(\"aria-label\", ctx.label);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabledClass)(\"k-selected\", ctx.selectedClass);\n      }\n    },\n    inputs: {\n      viewItem: \"viewItem\",\n      index: \"index\",\n      itemTemplate: \"itemTemplate\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      disabled: \"disabled\",\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c26,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\", \"ngIfElse\"], [\"defaultTemplate\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngIf\"], [3, \"name\", \"customFontClass\", \"svgIcon\", \"innerCssClass\", 4, \"ngIf\"], [1, \"k-item-text\"], [\"class\", \"k-spacer\", 4, \"ngIf\"], [\"innerCssClass\", \"k-drawer-toggle\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [3, \"name\", \"customFontClass\", \"svgIcon\", \"innerCssClass\"], [1, \"k-spacer\"], [\"innerCssClass\", \"k-drawer-toggle\", 3, \"name\", \"svgIcon\"]],\n    template: function _class38_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class38_0_Template, 1, 7, null, 0);\n        i0.ɵɵtemplate(1, _class38_ng_template_1_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.itemTemplate)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return DrawerItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DrawerListComponent = /*#__PURE__*/(() => {\n  var _class39;\n  class DrawerListComponent {\n    constructor(drawerService, renderer, ngZone, element) {\n      _defineProperty(this, \"drawerService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"mini\", void 0);\n      _defineProperty(this, \"expanded\", void 0);\n      _defineProperty(this, \"view\", []);\n      _defineProperty(this, \"select\", new EventEmitter());\n      _defineProperty(this, \"items\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.drawerService = drawerService;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.element = element;\n    }\n    ngOnInit() {\n      this.initDomEvents();\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    identifyItem(_index, viewItem) {\n      return viewItem.item.id ?? viewItem.index;\n    }\n    initDomEvents() {\n      if (!this.element) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        const nativeElement = this.element.nativeElement;\n        this.subscriptions.add(this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this)));\n        this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', e => {\n          const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n          const isArrowUpOrDown = e.keyCode === Keys.ArrowUp || e.keyCode === Keys.ArrowDown;\n          if (isEnterOrSpace) {\n            this.onEnterOrSpaceKeyDown(e);\n          } else if (isArrowUpOrDown) {\n            if (e.target.classList.contains('k-drawer-item')) {\n              e.preventDefault();\n              const keyName = e.keyCode === Keys.ArrowUp ? 'arrowUp' : 'arrowDown';\n              this.drawerService.changeFocusedItem(this.items, keyName, this.renderer);\n            }\n          }\n        }));\n      });\n    }\n    clickHandler(e) {\n      const viewItemIdx = this.getDrawerItemIndex(e.target);\n      const viewItem = this.view[viewItemIdx];\n      const filterItems = this.view.filter(items => !items.item.separator);\n      const selectedItemIndex = filterItems.findIndex(item => item.index === viewItemIdx);\n      if (!viewItem) {\n        return;\n      }\n      if (viewItem.item.disabled) {\n        e.preventDefault();\n        return;\n      }\n      const args = {\n        index: viewItem.index,\n        item: viewItem.item,\n        originalEvent: e\n      };\n      this.ngZone.run(() => {\n        const event = new DrawerListSelectEvent(args);\n        this.select.emit(event);\n        if (!event.isDefaultPrevented()) {\n          this.drawerService.focusIndex = selectedItemIndex;\n          this.drawerService.onSelect(viewItemIdx);\n          this.drawerService.init();\n          this.view = this.drawerService.view;\n        }\n      });\n    }\n    onEnterOrSpaceKeyDown(e) {\n      this.clickHandler(e);\n      const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);\n      if (link) {\n        link.click();\n      }\n      return false;\n    }\n    getDrawerItemIndex(target) {\n      const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);\n      if (item) {\n        return itemIndex(item, DRAWER_ITEM_INDEX);\n      }\n    }\n  }\n  _class39 = DrawerListComponent;\n  _defineProperty(DrawerListComponent, \"\\u0275fac\", function _class39_Factory(t) {\n    return new (t || _class39)(i0.ɵɵdirectiveInject(DrawerService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(DrawerListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class39,\n    selectors: [[\"\", \"kendoDrawerList\", \"\"]],\n    viewQuery: function _class39_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DrawerItemComponent, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    inputs: {\n      itemTemplate: \"itemTemplate\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      view: \"view\"\n    },\n    outputs: {\n      select: \"select\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c28,\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"kendoDrawerItem\", \"\", \"role\", \"menuitem\", 3, \"class\", \"viewItem\", \"index\", \"mini\", \"expanded\", \"itemTemplate\", \"ngClass\", \"ngStyle\", \"tabindex\", 4, \"ngIf\"], [\"role\", \"separator\", \"class\", \"k-drawer-item k-drawer-separator\", 3, \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoDrawerItem\", \"\", \"role\", \"menuitem\", 3, \"viewItem\", \"index\", \"mini\", \"expanded\", \"itemTemplate\", \"ngClass\", \"ngStyle\", \"tabindex\"], [\"role\", \"separator\", 1, \"k-drawer-item\", \"k-drawer-separator\", 3, \"ngClass\", \"ngStyle\"]],\n    template: function _class39_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class39_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.view)(\"ngForTrackBy\", ctx.identifyItem);\n      }\n    },\n    dependencies: [NgFor, NgIf, DrawerItemComponent, NgClass, NgStyle],\n    encapsulation: 2\n  }));\n  return DrawerListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst DEFAULT_ANIMATION = {\n  type: 'slide',\n  duration: 200\n};\n/**\n * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-drawer-container>\n *             <kendo-drawer #drawer\n *                  [items]=\"items\"\n *                  mode=\"overlay\"\n *                  [(expanded)]=\"expanded\">\n *              </kendo-drawer>\n *              <kendo-drawer-content>\n *                  <button class=\"k-button\" (click)=\"drawer.toggle()\">Open the Drawer</button>\n *              </kendo-drawer-content>\n *        </kendo-drawer-container>\n *    `\n * })\n * class AppComponent {\n *    public expanded = false;\n *\n *    public items: any[] = [\n *      { text: 'Inbox', icon: 'k-i-inbox' },\n *      { text: 'Notifications', icon: 'k-i-bell' },\n *      { text: 'Date', icon: 'k-i-calendar' }\n *    ];\n * }\n * ```\n */\nlet DrawerComponent = /*#__PURE__*/(() => {\n  var _class40;\n  class DrawerComponent {\n    get startPositionClass() {\n      return this.position === 'start';\n    }\n    get endPositionClass() {\n      return this.position === 'end';\n    }\n    get overlayTransofrmStyles() {\n      if (this.mode === 'push') {\n        return;\n      }\n      if (this.expanded || this.minimized) {\n        return `translateX(0px)`;\n      }\n      return `translateX(-100%)`;\n    }\n    get flexStyles() {\n      if (this.mode === 'overlay') {\n        return;\n      }\n      if (!this.expanded && !this.minimized) {\n        return 0;\n      }\n      return this.drawerWidth;\n    }\n    /**\n     * Specifies the mode in which the Drawer will be displayed.\n     *\n     * The possible values are:\n     * * (Default) `overlay`\n     * * `push`\n     */\n\n    /**\n     * Defines a callback function which determines if an item should be expanded.\n     */\n    set isItemExpanded(fn) {\n      if (isDevMode && isPresent(fn) && typeof fn !== 'function') {\n        throw new Error(`isItemExpanded must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this.drawerService.isItemExpanded = fn;\n    }\n    get isItemExpanded() {\n      return this.drawerService.isItemExpanded;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(element, builder, localizationService, drawerService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"builder\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"drawerService\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"mode\", 'overlay');\n      /**\n       * Specifies the position of the Drawer\n       * ([see example]({% slug positioning_drawer %})).\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n      _defineProperty(this, \"position\", 'start');\n      /**\n       * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed\n       * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).\n       */\n      _defineProperty(this, \"mini\", false);\n      /**\n       * Specifies the state of the Drawer.\n       */\n      _defineProperty(this, \"expanded\", false);\n      /**\n       * Defines the width of the Drawer when it is expanded.\n       * Defaults to `240`.\n       */\n      _defineProperty(this, \"width\", 240);\n      /**\n       * Defines the width of the Drawer when the mini view is enabled\n       * and the component is collapsed. Defaults to `60`.\n       */\n      _defineProperty(this, \"miniWidth\", 50);\n      /**\n       * Specifies if the Drawer will be automatically collapsed when an item\n       * or the overlay is clicked. Defaults to `true`.\n       */\n      _defineProperty(this, \"autoCollapse\", true);\n      /**\n       * The collection of items that will be rendered in the Drawer.\n       */\n      _defineProperty(this, \"items\", []);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Specifies the animation settings of the Drawer.\n       * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true`\n       *    * `false`\n       * * `DrawerAnimation`\n       *    * (Default) `type?: 'slide'`\n       *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.\n       */\n      _defineProperty(this, \"animation\", DEFAULT_ANIMATION);\n      /**\n       * Fires when the Drawer is expanded and its animation is complete.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the Drawer is collapsed and its animation is complete.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Fires when a Drawer item is selected. This event is preventable.\n       */\n      _defineProperty(this, \"select\", new EventEmitter());\n      /**\n       * Fires when the `expanded` property of the component was updated.\n       * Used to provide a two-way binding for the `expanded` property.\n       */\n      _defineProperty(this, \"expandedChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"drawerTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"footerTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"itemTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"viewItems\", void 0);\n      _defineProperty(this, \"animationEnd\", new EventEmitter());\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      this.element = element;\n      this.builder = builder;\n      this.localizationService = localizationService;\n      this.drawerService = drawerService;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n      this.drawerService.owner = this;\n    }\n    ngOnChanges(changes) {\n      if (changes && changes['items']) {\n        this.drawerService.resetSelection();\n        this.drawerService.init();\n        this.viewItems = this.drawerService.view;\n      }\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get minimized() {\n      return this.mini && !this.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get drawerWidth() {\n      return this.minimized ? this.miniWidth : this.width;\n    }\n    /**\n     * Toggles the visibility of the Drawer.\n     *\n     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.\n     */\n    toggle(expanded) {\n      const previous = this.expanded;\n      const current = isPresent(expanded) ? expanded : !previous;\n      if (current === previous) {\n        return;\n      }\n      if (current === true) {\n        this.setExpanded(true);\n      } else if (current === false && !this.animation) {\n        this.setExpanded(false);\n      }\n      if (this.animation) {\n        this.animationEnd.pipe(take(1)).subscribe(() => {\n          this.onAnimationEnd(current);\n        });\n        this.animate(current);\n      } else {\n        this[current ? 'expand' : 'collapse'].emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onSelect(e) {\n      this.select.emit(Object.assign(e, {\n        sender: this\n      }));\n    }\n    onAnimationEnd(currentExpanded) {\n      if (currentExpanded) {\n        this.expand.emit();\n      } else {\n        this.setExpanded(false);\n        this.collapse.emit();\n      }\n    }\n    setExpanded(value) {\n      this.expanded = value;\n      this.expandedChange.emit(value);\n    }\n    animate(expanded) {\n      const settings = {\n        mode: this.mode,\n        mini: this.mini,\n        miniWidth: this.miniWidth,\n        width: this.width,\n        rtl: this.rtl,\n        position: this.position,\n        animation: typeof this.animation !== 'boolean' ? this.animation : DEFAULT_ANIMATION\n      };\n      const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);\n      const player = this.createPlayer(animation, this.element.nativeElement);\n      player.play();\n    }\n    createPlayer(animation, animatedElement) {\n      const factory = this.builder.build(animation);\n      let player = factory.create(animatedElement);\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n      return player;\n    }\n  }\n  _class40 = DrawerComponent;\n  _defineProperty(DrawerComponent, \"\\u0275fac\", function _class40_Factory(t) {\n    return new (t || _class40)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$2.AnimationBuilder), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(DrawerService));\n  });\n  _defineProperty(DrawerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class40,\n    selectors: [[\"kendo-drawer\"]],\n    contentQueries: function _class40_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerFooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerHeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class40_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"transform\", ctx.overlayTransofrmStyles)(\"flex-basis\", ctx.flexStyles, \"px\");\n        i0.ɵɵclassProp(\"k-drawer\", ctx.hostClasses)(\"k-drawer-start\", ctx.startPositionClass)(\"k-drawer-end\", ctx.endPositionClass);\n      }\n    },\n    inputs: {\n      mode: \"mode\",\n      position: \"position\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      width: \"width\",\n      miniWidth: \"miniWidth\",\n      autoCollapse: \"autoCollapse\",\n      items: \"items\",\n      isItemExpanded: \"isItemExpanded\",\n      animation: \"animation\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\",\n      select: \"select\",\n      expandedChange: \"expandedChange\"\n    },\n    exportAs: [\"kendoDrawer\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, DrawerService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.drawer'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"k-drawer-wrapper\", 3, \"width\", 4, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [1, \"k-drawer-wrapper\"], [4, \"ngIf\"], [\"kendoDrawerList\", \"\", \"role\", \"menubar\", \"orientation\", \"vertical\", 1, \"k-drawer-items\", 3, \"mini\", \"expanded\", \"view\", \"itemTemplate\", \"select\"], [3, \"ngTemplateOutlet\"], [\"kendoWatermarkOverlay\", \"\"]],\n    template: function _class40_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class40_div_0_Template, 3, 4, \"div\", 0);\n        i0.ɵɵtemplate(1, _class40_div_1_Template, 1, 0, \"div\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.expanded || ctx.mini);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, DrawerListComponent, WatermarkOverlayComponent],\n    encapsulation: 2\n  }));\n  return DrawerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Serves as a container for the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}) and its content.\n */\nlet DrawerContainerComponent = /*#__PURE__*/(() => {\n  var _class41;\n  class DrawerContainerComponent {\n    get hostClass() {\n      return true;\n    }\n    get overlayClass() {\n      return this.drawer.mode === 'overlay';\n    }\n    get miniClass() {\n      return this.drawer.mini && !this.drawer.expanded;\n    }\n    get pushClass() {\n      return this.drawer.mode === 'push';\n    }\n    get isExpandedClass() {\n      return this.drawer.expanded;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(localizationService) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"drawer\", void 0);\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      this.localizationService = localizationService;\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get overlay() {\n      return isPresent(this.drawer) && this.drawer.expanded && this.drawer.mode === 'overlay';\n    }\n    /**\n     * @hidden\n     */\n    closeDrawer() {\n      if (this.overlay && this.drawer.autoCollapse) {\n        this.drawer.toggle(false);\n      }\n    }\n  }\n  _class41 = DrawerContainerComponent;\n  _defineProperty(DrawerContainerComponent, \"\\u0275fac\", function _class41_Factory(t) {\n    return new (t || _class41)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(DrawerContainerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class41,\n    selectors: [[\"kendo-drawer-container\"]],\n    contentQueries: function _class41_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DrawerComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawer = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class41_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-drawer-container\", ctx.hostClass)(\"k-drawer-overlay\", ctx.overlayClass)(\"k-drawer-mini\", ctx.miniClass)(\"k-drawer-push\", ctx.pushClass)(\"k-drawer-expanded\", ctx.isExpandedClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.drawer.container'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"k-overlay\", 3, \"click\", 4, \"ngIf\"], [1, \"k-overlay\", 3, \"click\"]],\n    template: function _class41_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class41_div_0_Template, 1, 0, \"div\", 0);\n        i0.ɵɵprojection(1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.overlay);\n      }\n    },\n    dependencies: [NgIf],\n    encapsulation: 2\n  }));\n  return DrawerContainerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the content of the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).\n */\nlet DrawerContentComponent = /*#__PURE__*/(() => {\n  var _class42;\n  class DrawerContentComponent {\n    constructor() {\n      _defineProperty(this, \"hostClasses\", true);\n    }\n  }\n  _class42 = DrawerContentComponent;\n  _defineProperty(DrawerContentComponent, \"\\u0275fac\", function _class42_Factory(t) {\n    return new (t || _class42)();\n  });\n  _defineProperty(DrawerContentComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class42,\n    selectors: [[\"kendo-drawer-content\"]],\n    hostVars: 2,\n    hostBindings: function _class42_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-drawer-content\", ctx.hostClasses);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class42_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return DrawerContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `select` event of the Drawer.\n */\nclass DrawerSelectEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The index of the selected item in the `items` collection.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     * The selected Drawer item.\n     */\n    _defineProperty(this, \"item\", void 0);\n    /**\n     * The DOM event that triggered the selection.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    /**\n     * The Drawer that triggered the event.\n     */\n    _defineProperty(this, \"sender\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Represents a template that defines the content of the whole Step.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.\n */\nlet StepperStepTemplateDirective = /*#__PURE__*/(() => {\n  var _class44;\n  class StepperStepTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class44 = StepperStepTemplateDirective;\n  _defineProperty(StepperStepTemplateDirective, \"\\u0275fac\", function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(StepperStepTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class44,\n    selectors: [[\"\", \"kendoStepperStepTemplate\", \"\"]],\n    standalone: true\n  }));\n  return StepperStepTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the content of the Step label.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.\n */\nlet StepperLabelTemplateDirective = /*#__PURE__*/(() => {\n  var _class45;\n  class StepperLabelTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class45 = StepperLabelTemplateDirective;\n  _defineProperty(StepperLabelTemplateDirective, \"\\u0275fac\", function _class45_Factory(t) {\n    return new (t || _class45)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(StepperLabelTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class45,\n    selectors: [[\"\", \"kendoStepperLabelTemplate\", \"\"]],\n    standalone: true\n  }));\n  return StepperLabelTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the content of the Step indicator.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.\n */\nlet StepperIndicatorTemplateDirective = /*#__PURE__*/(() => {\n  var _class46;\n  class StepperIndicatorTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class46 = StepperIndicatorTemplateDirective;\n  _defineProperty(StepperIndicatorTemplateDirective, \"\\u0275fac\", function _class46_Factory(t) {\n    return new (t || _class46)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(StepperIndicatorTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class46,\n    selectors: [[\"\", \"kendoStepperIndicatorTemplate\", \"\"]],\n    standalone: true\n  }));\n  return StepperIndicatorTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_CURRENT_STEP = 0;\nconst handlers = {};\nhandlers[Keys.ArrowLeft] = 'left';\nhandlers[Keys.ArrowRight] = 'right';\nhandlers[Keys.ArrowUp] = 'up';\nhandlers[Keys.ArrowDown] = 'down';\nhandlers[Keys.Home] = 'home';\nhandlers[Keys.End] = 'end';\nhandlers[Keys.Enter] = 'enter';\nhandlers[Keys.Space] = 'enter';\nconst handlersRTL = Object.assign({}, handlers);\nhandlersRTL[Keys.ArrowLeft] = 'right';\nhandlersRTL[Keys.ArrowRight] = 'left';\n// error NG3003: One or more import cycles would need to be created to compile this component,\n// which is not supported by the current compiler configuration\n/**\n * @hidden\n */\nlet StepperActivateEvent$1 = class StepperActivateEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The index of the activated step in the `steps` collection.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     * The activated step.\n     */\n    _defineProperty(this, \"step\", void 0);\n    /**\n     * The DOM event that triggered the step activation.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    /**\n     * The Stepper that triggered the event.\n     */\n    _defineProperty(this, \"sender\", void 0);\n    Object.assign(this, args);\n  }\n};\n/**\n * @hidden\n */\nlet StepperService = /*#__PURE__*/(() => {\n  var _class48;\n  class StepperService {\n    get handlers() {\n      return this.localization.rtl ? handlersRTL : handlers;\n    }\n    constructor(localization, ngZone, changeDetector) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"owner\", void 0);\n      _defineProperty(this, \"currentStep\", DEFAULT_CURRENT_STEP);\n      _defineProperty(this, \"focusedStep\", void 0);\n      _defineProperty(this, \"triggerValidation\", new EventEmitter());\n      _defineProperty(this, \"focusedStepChange\", new EventEmitter());\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n    }\n    emit(event, eventArgs) {\n      const stepper = this.owner;\n      if (hasObservers(stepper[event])) {\n        stepper[event].emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    onActivate(currentIdx, originalEvent) {\n      const eventArgs = new StepperActivateEvent$1({\n        index: currentIdx,\n        step: this.owner.steps[currentIdx],\n        originalEvent: originalEvent,\n        sender: this.owner\n      });\n      this.ngZone.run(() => {\n        if (!this.emit('activate', eventArgs)) {\n          this.currentStep = currentIdx;\n          this.owner['currentStepChange'].emit(currentIdx);\n          this.changeDetector.detectChanges();\n        }\n      });\n    }\n    validateSteps() {\n      this.triggerValidation.emit();\n    }\n    keydown(e) {\n      const current = this.focusedStep || this.currentStep;\n      const handler = this.handlers[e.keyCode];\n      if (!isPresent(current)) {\n        return;\n      }\n      if (handler) {\n        e.preventDefault();\n        this[handler](e);\n      }\n    }\n    left() {\n      if (!this.isHorizontal) {\n        return;\n      }\n      this.focusPrevStep();\n    }\n    right() {\n      if (!this.isHorizontal) {\n        return;\n      }\n      this.focusNextStep();\n    }\n    up() {\n      if (this.isHorizontal) {\n        return;\n      }\n      this.focusPrevStep();\n    }\n    down() {\n      if (this.isHorizontal) {\n        return;\n      }\n      this.focusNextStep();\n    }\n    home() {\n      this.focusedStep = 0;\n      this.focusedStepChange.emit();\n    }\n    end() {\n      this.focusedStep = this.owner.steps.length - 1;\n      this.focusedStepChange.emit();\n    }\n    enter(event) {\n      if (this.focusedStep === this.currentStep) {\n        return;\n      }\n      if (this.isStepDisabled(this.focusedStep)) {\n        return;\n      }\n      if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {\n        return;\n      }\n      this.onActivate(this.focusedStep, event);\n    }\n    focus(focusedIdx) {\n      this.focusedStep = focusedIdx;\n    }\n    focusNextStep() {\n      if (this.focusedStep < this.owner.steps.length) {\n        this.focusedStep += 1;\n        this.focusedStepChange.emit();\n      }\n    }\n    focusPrevStep() {\n      if (this.focusedStep > 0) {\n        this.focusedStep -= 1;\n        this.focusedStepChange.emit();\n      }\n    }\n    isStepDisabled(index) {\n      return this.owner.steps[index].disabled;\n    }\n    isPrevOrNextStep(index) {\n      return index === this.currentStep + 1 || index === this.currentStep - 1;\n    }\n    get isHorizontal() {\n      return this.owner.orientation === 'horizontal';\n    }\n  }\n  _class48 = StepperService;\n  _defineProperty(StepperService, \"\\u0275fac\", function _class48_Factory(t) {\n    return new (t || _class48)(i0.ɵɵinject(i1.LocalizationService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(StepperService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class48,\n    factory: _class48.ɵfac\n  }));\n  return StepperService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst STEPPER_STEP_INDEX = 'data-kendo-stepper-index';\n\n/**\n * @hidden\n */\nlet StepperStepComponent = /*#__PURE__*/(() => {\n  var _class49;\n  class StepperStepComponent {\n    constructor(service, localization, ngZone) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"step\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"current\", void 0);\n      _defineProperty(this, \"type\", void 0);\n      _defineProperty(this, \"successIcon\", void 0);\n      _defineProperty(this, \"successSVGIcon\", void 0);\n      _defineProperty(this, \"errorIcon\", void 0);\n      _defineProperty(this, \"errorSVGIcon\", void 0);\n      _defineProperty(this, \"svgIcon\", void 0);\n      _defineProperty(this, \"indicatorTemplate\", void 0);\n      _defineProperty(this, \"labelTemplate\", void 0);\n      _defineProperty(this, \"stepTemplate\", void 0);\n      _defineProperty(this, \"stepLink\", void 0);\n      _defineProperty(this, \"isStepValid\", undefined);\n      _defineProperty(this, \"shouldCheckValidity\", undefined);\n      _defineProperty(this, \"checkCircleIcon\", checkCircleIcon);\n      _defineProperty(this, \"exclamationCircleIcon\", exclamationCircleIcon);\n      _defineProperty(this, \"subs\", void 0);\n      this.service = service;\n      this.localization = localization;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n      this.subs = this.service.focusedStepChange.subscribe(() => {\n        this.onFocusedStepChange();\n      });\n      this.subs.add(this.service.triggerValidation.subscribe(() => {\n        this.handleValidityChecks();\n      }));\n    }\n    get errorStepClass() {\n      if (isPresent(this.isStepValid)) {\n        return !this.isStepValid;\n      }\n      return false;\n    }\n    get successStepClass() {\n      if (isPresent(this.isStepValid)) {\n        return this.isStepValid;\n      }\n      return false;\n    }\n    ngOnInit() {\n      this.handleValidityChecks();\n    }\n    ngOnChanges(changes) {\n      if (changes['current'] && !changes['current'].firstChange) {\n        this.handleValidityChecks();\n      }\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n    onFocusedStepChange() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.index === this.service.focusedStep) {\n          this.stepLink.nativeElement.focus();\n        }\n      });\n    }\n    onFocus() {\n      this.service.focus(this.index);\n    }\n    get tabIndexAttr() {\n      const active = this.service.focusedStep || this.service.currentStep;\n      return this.index === active ? 0 : -1;\n    }\n    get indicatorIconClass() {\n      if (this.step.icon && !this.step.iconClass) {\n        return `${this.step.icon}`;\n      }\n      if (!this.step.icon && !this.step.iconClass && this.shouldCheckValidity) {\n        return this.validationIconClasses;\n      }\n    }\n    get customIndicatorIconClass() {\n      if (this.step.iconClass) {\n        return `${this.step.iconClass}`;\n      }\n      const renderCustomValidationIcon = !this.step.icon && !this.step.iconClass && this.shouldCheckValidity;\n      if (renderCustomValidationIcon) {\n        return this.customValidationIconClasses;\n      }\n    }\n    get SVGIndicatorIcon() {\n      if (this.step.svgIcon) {\n        return this.step.svgIcon;\n      }\n      if (!this.step.svgIcon && this.shouldCheckValidity) {\n        return this.validationSVGIcon;\n      }\n    }\n    get validationIconClasses() {\n      if (this.isStepValid) {\n        return !this.successIcon ? 'check-circle' : '';\n      }\n      return !this.errorIcon ? 'exclamation-circle' : '';\n    }\n    get customValidationIconClasses() {\n      if (this.isStepValid) {\n        return this.successIcon ? this.successIcon : '';\n      }\n      return this.errorIcon ? this.errorIcon : '';\n    }\n    get validationSVGIcon() {\n      if (this.isStepValid) {\n        return this.successSVGIcon ? this.successSVGIcon : this.checkCircleIcon;\n      }\n      return this.errorSVGIcon ? this.errorSVGIcon : this.exclamationCircleIcon;\n    }\n    get showIndicatorIcon() {\n      if (this.shouldCheckValidity) {\n        return true;\n      }\n      if (this.step.icon || this.step.iconClass || this.step.svgIcon) {\n        return true;\n      }\n      return false;\n    }\n    get showLabelIcon() {\n      if (this.shouldCheckValidity) {\n        if (this.type === 'label') {\n          return true;\n        }\n        if (this.step.icon || this.step.iconClass) {\n          return true;\n        }\n      }\n      return false;\n    }\n    get showLabelText() {\n      return this.type === 'label' || this.type === 'full';\n    }\n    get indicatorText() {\n      const text = this.step.text;\n      return text ? text : this.index + 1;\n    }\n    updateStepValidity() {\n      if (typeof this.step.isValid === 'boolean') {\n        return this.step.isValid;\n      }\n      if (typeof this.step.isValid === 'function') {\n        return this.step.isValid(this.index);\n      }\n      return undefined;\n    }\n    get showIndicator() {\n      return this.type === 'indicator' || this.type === 'full';\n    }\n    get showLabel() {\n      if (this.type === 'label' || this.type === 'full') {\n        return true;\n      }\n      return this.step.optional;\n    }\n    get optionalText() {\n      return this.localization.get('optional');\n    }\n    get transitionDuration() {\n      return this.service.owner.animationDuration;\n    }\n    _shouldCheckValidity() {\n      if (isPresent(this.step.validate)) {\n        if (typeof this.step.validate === 'boolean') {\n          return this.step.validate;\n        }\n        if (typeof this.step.validate === 'function') {\n          return this.step.validate(this.index);\n        }\n      }\n      return isPresent(this.step.isValid) && this.index < this.current;\n    }\n    handleValidityChecks() {\n      this.isStepValid = undefined;\n      this.shouldCheckValidity = this._shouldCheckValidity();\n      if (this.shouldCheckValidity) {\n        this.isStepValid = this.updateStepValidity();\n      }\n    }\n  }\n  _class49 = StepperStepComponent;\n  _defineProperty(StepperStepComponent, \"\\u0275fac\", function _class49_Factory(t) {\n    return new (t || _class49)(i0.ɵɵdirectiveInject(StepperService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(StepperStepComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class49,\n    selectors: [[\"\", \"kendoStepperStep\", \"\"]],\n    viewQuery: function _class49_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c29, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.stepLink = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class49_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-step-error\", ctx.errorStepClass)(\"k-step-success\", ctx.successStepClass);\n      }\n    },\n    inputs: {\n      step: \"step\",\n      index: \"index\",\n      current: \"current\",\n      type: \"type\",\n      successIcon: \"successIcon\",\n      successSVGIcon: \"successSVGIcon\",\n      errorIcon: \"errorIcon\",\n      errorSVGIcon: \"errorSVGIcon\",\n      svgIcon: \"svgIcon\",\n      indicatorTemplate: \"indicatorTemplate\",\n      labelTemplate: \"labelTemplate\",\n      stepTemplate: \"stepTemplate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c30,\n    decls: 4,\n    vars: 6,\n    consts: [[\"href\", \"#\", 1, \"k-step-link\", 3, \"focus\"], [\"stepLink\", \"\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-step-indicator\", \"aria-hidden\", \"true\", 3, \"transition-duration\", 4, \"ngIf\"], [\"class\", \"k-step-label\", 4, \"ngIf\"], [\"aria-hidden\", \"true\", 1, \"k-step-indicator\"], [\"innerCssClass\", \"k-step-indicator-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-step-indicator-text\", 4, \"ngIf\"], [\"innerCssClass\", \"k-step-indicator-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-step-indicator-text\"], [1, \"k-step-label\"], [\"class\", \"k-step-text\", 4, \"ngIf\"], [\"aria-hidden\", \"true\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-step-label-optional\", 4, \"ngIf\"], [1, \"k-step-text\"], [\"aria-hidden\", \"true\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-step-label-optional\"]],\n    template: function _class49_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"focus\", function _class49_Template_a_focus_0_listener() {\n          return ctx.onFocus();\n        });\n        i0.ɵɵtemplate(2, _class49_2_Template, 1, 5, null, 2);\n        i0.ɵɵtemplate(3, _class49_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndexAttr)(\"title\", ctx.step.label)(\"aria-disabled\", ctx.step.disabled)(\"aria-current\", ctx.index === ctx.current ? \"step\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.stepTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.stepTemplate);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return StepperStepComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet StepperListComponent = /*#__PURE__*/(() => {\n  var _class50;\n  class StepperListComponent {\n    constructor(renderer, ngZone, service, element) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"linear\", void 0);\n      _defineProperty(this, \"stepType\", void 0);\n      _defineProperty(this, \"orientation\", void 0);\n      _defineProperty(this, \"currentStep\", void 0);\n      _defineProperty(this, \"steps\", void 0);\n      _defineProperty(this, \"successIcon\", void 0);\n      _defineProperty(this, \"successSVGIcon\", void 0);\n      _defineProperty(this, \"errorIcon\", void 0);\n      _defineProperty(this, \"errorSVGIcon\", void 0);\n      _defineProperty(this, \"svgIcon\", void 0);\n      _defineProperty(this, \"indicatorTemplate\", void 0);\n      _defineProperty(this, \"labelTemplate\", void 0);\n      _defineProperty(this, \"stepTemplate\", void 0);\n      _defineProperty(this, \"listKeydown\", new EventEmitter());\n      _defineProperty(this, \"listClick\", new EventEmitter());\n      _defineProperty(this, \"domSubs\", void 0);\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.service = service;\n      this.element = element;\n    }\n    ngOnInit() {\n      this.initDomEvents();\n    }\n    ngOnDestroy() {\n      if (this.domSubs) {\n        this.domSubs();\n      }\n    }\n    get maxStepWidth() {\n      return this.maxStepDimension('width');\n    }\n    get maxStepHeight() {\n      return this.maxStepDimension('height');\n    }\n    get focusedStep() {\n      return this.service.focusedStep;\n    }\n    isPresent(arg) {\n      return isPresent$1(arg);\n    }\n    maxStepDimension(dimension) {\n      if (dimension === 'width' && this.orientation === 'vertical') {\n        return null;\n      }\n      if (dimension === 'height' && this.orientation === 'horizontal') {\n        return null;\n      }\n      return 100 / this.steps.length;\n    }\n    initDomEvents() {\n      if (!this.element) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        const nativeElement = this.element.nativeElement;\n        const clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));\n        const keydownSubscription = this.renderer.listen(nativeElement, 'keydown', e => {\n          if (hasClass(e.target, 'k-step-link')) {\n            this.listKeydown.emit(e);\n          }\n        });\n        this.domSubs = () => {\n          clickSubscription();\n          keydownSubscription();\n        };\n      });\n    }\n    clickHandler(e) {\n      e.preventDefault();\n      const stepIdx = this.getStepIndex(e.target);\n      const step = this.steps[stepIdx];\n      if (!step || step.disabled) {\n        return;\n      }\n      const eventArgs = {\n        stepIdx,\n        currentStep: this.currentStep,\n        linear: this.linear,\n        originalEvent: e\n      };\n      this.listClick.emit(eventArgs);\n    }\n    getStepIndex(target) {\n      const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);\n      if (step) {\n        return itemIndex(step, STEPPER_STEP_INDEX);\n      }\n    }\n  }\n  _class50 = StepperListComponent;\n  _defineProperty(StepperListComponent, \"\\u0275fac\", function _class50_Factory(t) {\n    return new (t || _class50)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(StepperService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(StepperListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class50,\n    selectors: [[\"\", \"kendoStepperList\", \"\"]],\n    inputs: {\n      linear: \"linear\",\n      stepType: \"stepType\",\n      orientation: \"orientation\",\n      currentStep: \"currentStep\",\n      steps: \"steps\",\n      successIcon: \"successIcon\",\n      successSVGIcon: \"successSVGIcon\",\n      errorIcon: \"errorIcon\",\n      errorSVGIcon: \"errorSVGIcon\",\n      svgIcon: \"svgIcon\",\n      indicatorTemplate: \"indicatorTemplate\",\n      labelTemplate: \"labelTemplate\",\n      stepTemplate: \"stepTemplate\"\n    },\n    outputs: {\n      listKeydown: \"listKeydown\",\n      listClick: \"listClick\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c32,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoStepperStep\", \"\", 1, \"k-step\", 3, \"type\", \"step\", \"index\", \"current\", \"successIcon\", \"successSVGIcon\", \"errorIcon\", \"errorSVGIcon\", \"svgIcon\", \"indicatorTemplate\", \"labelTemplate\", \"stepTemplate\", \"ngClass\", \"ngStyle\"]],\n    template: function _class50_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class50_ng_container_0_Template, 2, 33, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.steps);\n      }\n    },\n    dependencies: [NgFor, StepperStepComponent, NgClass, NgStyle],\n    encapsulation: 2\n  }));\n  return StepperListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet StepperMessages = /*#__PURE__*/(() => {\n  var _class51;\n  class StepperMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The optional text.\n       */\n      _defineProperty(this, \"optional\", void 0);\n    }\n  }\n  _class51 = StepperMessages;\n  _defineProperty(StepperMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class51_BaseFactory;\n    return function _class51_Factory(t) {\n      return (ɵ_class51_BaseFactory || (ɵ_class51_BaseFactory = i0.ɵɵgetInheritedFactory(_class51)))(t || _class51);\n    };\n  }());\n  _defineProperty(StepperMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class51,\n    selectors: [[\"kendo-stepper-messages-base\"]],\n    inputs: {\n      optional: \"optional\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return StepperMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedStepperMessagesDirective = /*#__PURE__*/(() => {\n  var _class52;\n  class LocalizedStepperMessagesDirective extends StepperMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class52 = LocalizedStepperMessagesDirective;\n  _defineProperty(LocalizedStepperMessagesDirective, \"\\u0275fac\", function _class52_Factory(t) {\n    return new (t || _class52)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedStepperMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class52,\n    selectors: [[\"\", \"kendoStepperLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: StepperMessages,\n      useExisting: forwardRef(() => _class52)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedStepperMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_ANIMATION_DURATION = 400;\n/**\n * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-stepper [steps]=\"steps\">\n *        </kendo-stepper>\n *    `\n * })\n * class AppComponent {\n *    public steps: Array<StepperStep> = [\n *      { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }\n *    ];\n * }\n * ```\n */\nlet StepperComponent = /*#__PURE__*/(() => {\n  var _class53;\n  class StepperComponent {\n    get linearClass() {\n      return this.linear;\n    }\n    /**\n     * The index of the current step.\n     */\n    set currentStep(value) {\n      this.stepperService.currentStep = value;\n    }\n    get currentStep() {\n      return this.stepperService.currentStep;\n    }\n    /**\n     * The collection of steps that will be rendered in the Stepper.\n     * ([see example]({% slug step_appearance_stepper %}))\n     */\n    set steps(steps) {\n      if (isPresent(steps) && steps.length > 0) {\n        this._steps = steps;\n      }\n    }\n    get steps() {\n      return this._steps;\n    }\n    /**\n     * Defines an SVG icon to be rendered inside the step indicator instead of the default numeric or text content.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    /**\n     * Defines an SVGIcon to be rendered for the success icon.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n\n    constructor(renderer, elem, localization, stepperService) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"stepperService\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"ariaRole\", 'navigation');\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"displayStyle\", 'grid');\n      /**\n       * Specifies the type of the steps in the Stepper.\n       *\n       * The possible values are:\n       * * (Default) `indicator`\n       * * `label`\n       * * `full`\n       */\n      _defineProperty(this, \"stepType\", 'indicator');\n      /**\n       * Specifies the linear flow of the Stepper.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"linear\", true);\n      /**\n       * Specifies the orientation of the Stepper\n       * ([see example]({% slug orientation_stepper %})).\n       *\n       * The possible values are:\n       * * (Default) `horizontal`\n       * * `vertical`\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"successSVGIcon\", void 0);\n      /**\n       * Defines an SVGIcon to be rendered for the error icon.\n       * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n       */\n      _defineProperty(this, \"errorSVGIcon\", void 0);\n      /**\n       * Specifies a custom icon that will be rendered inside the step\n       * for valid previous steps.\n       */\n      _defineProperty(this, \"successIcon\", void 0);\n      /**\n       * Specifies a custom icon that will be rendered inside the step\n       * for invalid previous steps.\n       */\n      _defineProperty(this, \"errorIcon\", void 0);\n      /**\n       * Specifies the duration of the progress indicator animation in milliseconds. Defaults to `400ms`.\n       *\n       * The possible values are:\n       *  * Boolean\n       *    * (Default) `true`\n       *    * false\n       *  * Number\n       */\n      _defineProperty(this, \"animation\", true);\n      /**\n       * Fires when a step is about to be activated. This event is preventable.\n       */\n      _defineProperty(this, \"activate\", new EventEmitter());\n      /**\n       * Fires when the `currentStep` property of the component was updated.\n       * Used to provide a two-way binding for the `currentStep` property.\n       */\n      _defineProperty(this, \"currentStepChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"stepTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"labelTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"indicatorTemplate\", void 0);\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"_steps\", []);\n      _defineProperty(this, \"_successSVGIcon\", void 0);\n      _defineProperty(this, \"_errorSVGIcon\", void 0);\n      _defineProperty(this, \"_svgIcon\", void 0);\n      this.renderer = renderer;\n      this.elem = elem;\n      this.localization = localization;\n      this.stepperService = stepperService;\n      this.dynamicRTLSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.stepperService.owner = this;\n    }\n    ngOnInit() {\n      this.applyHostStyling();\n    }\n    ngOnChanges(changes) {\n      if (changes['steps'] && !changes['steps'].firstChange) {\n        this.applyHostStyling();\n      }\n      if (changes['orientation']) {\n        this.resetHostStyling();\n        this.applyHostStyling();\n      }\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).\n     *\n     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.\n     */\n    validateSteps() {\n      this.stepperService.validateSteps();\n    }\n    applyHostStyling() {\n      const stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';\n      const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;\n      this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);\n    }\n    resetHostStyling() {\n      this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-columns');\n      this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-rows');\n    }\n    /**\n     * @hidden\n     */\n    get progressAnimation() {\n      return {\n        duration: this.animationDuration\n      };\n    }\n    /**\n     * @hidden\n     */\n    get animationDuration() {\n      if (typeof this.animation === 'number') {\n        return this.animation;\n      }\n      if (typeof this.animation === 'boolean' && this.animation) {\n        return DEFAULT_ANIMATION_DURATION;\n      }\n      return 0;\n    }\n    /**\n     * @hidden\n     */\n    get stepsListStyling() {\n      if (this.orientation === 'horizontal') {\n        return {\n          'grid-column-start': 1,\n          'grid-column-end': -1\n        };\n      }\n      return {\n        'grid-row-start': 1,\n        'grid-row-end': -1\n      };\n    }\n    /**\n     * @hidden\n     */\n    get progressBarStyling() {\n      if (this.orientation === 'horizontal') {\n        return {\n          'grid-column-start': 2,\n          'grid-column-end': this.steps.length * 2\n        };\n      }\n      return {\n        'grid-row-start': 2,\n        'grid-row-end': this.steps.length * 2\n      };\n    }\n    /**\n     * @hidden\n     */\n    onListKeydown(e) {\n      this.stepperService.keydown(e);\n    }\n    /**\n     * @hidden\n     */\n    onListClick(e) {\n      if (e.stepIdx === e.currentStep) {\n        this.stepperService.focus(e.stepIdx);\n        return;\n      }\n      if (e.linear && this.stepperService.isPrevOrNextStep(e.stepIdx) === false) {\n        return;\n      }\n      this.stepperService.onActivate(e.stepIdx, e.originalEvent);\n    }\n    /**\n     * @hidden\n     */\n    get isHorizontal() {\n      return this.orientation === 'horizontal';\n    }\n  }\n  _class53 = StepperComponent;\n  _defineProperty(StepperComponent, \"\\u0275fac\", function _class53_Factory(t) {\n    return new (t || _class53)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(StepperService));\n  });\n  _defineProperty(StepperComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class53,\n    selectors: [[\"kendo-stepper\"]],\n    contentQueries: function _class53_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, StepperStepTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, StepperLabelTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, StepperIndicatorTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.stepTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function _class53_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.ariaRole)(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n        i0.ɵɵclassProp(\"k-stepper\", ctx.hostClasses)(\"k-stepper-linear\", ctx.linearClass);\n      }\n    },\n    inputs: {\n      stepType: \"stepType\",\n      linear: \"linear\",\n      orientation: \"orientation\",\n      currentStep: \"currentStep\",\n      steps: \"steps\",\n      svgIcon: \"svgIcon\",\n      successSVGIcon: \"successSVGIcon\",\n      errorSVGIcon: \"errorSVGIcon\",\n      successIcon: \"successIcon\",\n      errorIcon: \"errorIcon\",\n      animation: \"animation\"\n    },\n    outputs: {\n      activate: \"activate\",\n      currentStepChange: \"currentStepChange\"\n    },\n    exportAs: [\"kendoStepper\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, StepperService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.stepper'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 19,\n    consts: function () {\n      let i18n_33;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the optional segment of the step label\n         * @meaning kendo.stepper.optional\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_34 = goog.getMsg(\"Optional\");\n        i18n_33 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_34;\n      } else {\n        i18n_33 = $localize`:kendo.stepper.optional|The text for the optional segment of the step label:Optional`;\n      }\n      return [[\"kendoStepperLocalizedMessages\", \"\", \"optional\", i18n_33], [\"kendoStepperList\", \"\", 1, \"k-step-list\", 3, \"stepType\", \"linear\", \"orientation\", \"steps\", \"currentStep\", \"successIcon\", \"successSVGIcon\", \"errorIcon\", \"errorSVGIcon\", \"svgIcon\", \"indicatorTemplate\", \"labelTemplate\", \"stepTemplate\", \"ngStyle\", \"listKeydown\", \"listClick\"], [3, \"animation\", \"max\", \"label\", \"orientation\", \"reverse\", \"value\", \"ngStyle\", 4, \"ngIf\"], [3, \"animation\", \"max\", \"label\", \"orientation\", \"reverse\", \"value\", \"ngStyle\"]];\n    },\n    template: function _class53_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"ol\", 1);\n        i0.ɵɵlistener(\"listKeydown\", function _class53_Template_ol_listKeydown_1_listener($event) {\n          return ctx.onListKeydown($event);\n        })(\"listClick\", function _class53_Template_ol_listClick_1_listener($event) {\n          return ctx.onListClick($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, _class53_kendo_progressbar_2_Template, 1, 9, \"kendo-progressbar\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-step-list-horizontal\", ctx.isHorizontal)(\"k-step-list-vertical\", !ctx.isHorizontal);\n        i0.ɵɵproperty(\"stepType\", ctx.stepType)(\"linear\", ctx.linear)(\"orientation\", ctx.orientation)(\"steps\", ctx.steps)(\"currentStep\", ctx.currentStep)(\"successIcon\", ctx.successIcon)(\"successSVGIcon\", ctx.successSVGIcon)(\"errorIcon\", ctx.errorIcon)(\"errorSVGIcon\", ctx.errorSVGIcon)(\"svgIcon\", ctx.svgIcon)(\"indicatorTemplate\", ctx.indicatorTemplate == null ? null : ctx.indicatorTemplate.templateRef)(\"labelTemplate\", ctx.labelTemplate == null ? null : ctx.labelTemplate.templateRef)(\"stepTemplate\", ctx.stepTemplate == null ? null : ctx.stepTemplate.templateRef)(\"ngStyle\", ctx.stepsListStyling);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.steps.length > 0);\n      }\n    },\n    dependencies: [LocalizedStepperMessagesDirective, StepperListComponent, NgStyle, NgIf, ProgressBarComponent],\n    encapsulation: 2\n  }));\n  return StepperComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `activate` event of the Stepper.\n */\nclass StepperActivateEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The index of the activated step in the `steps` collection.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     * The activated step.\n     */\n    _defineProperty(this, \"step\", void 0);\n    /**\n     * The DOM event that triggered the step activation.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    /**\n     * The Stepper that triggered the event.\n     */\n    _defineProperty(this, \"sender\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\nlet StepperCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class55;\n  class StepperCustomMessagesComponent extends StepperMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class55 = StepperCustomMessagesComponent;\n  _defineProperty(StepperCustomMessagesComponent, \"\\u0275fac\", function _class55_Factory(t) {\n    return new (t || _class55)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(StepperCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class55,\n    selectors: [[\"kendo-stepper-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: StepperMessages,\n      useExisting: forwardRef(() => _class55)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class55_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return StepperCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  var _class56;\n  class Messages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The alt attribute text of the image in the avatar.\n       */\n      _defineProperty(this, \"avatarAlt\", void 0);\n    }\n  }\n  _class56 = Messages;\n  _defineProperty(Messages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class56_BaseFactory;\n    return function _class56_Factory(t) {\n      return (ɵ_class56_BaseFactory || (ɵ_class56_BaseFactory = i0.ɵɵgetInheritedFactory(_class56)))(t || _class56);\n    };\n  }());\n  _defineProperty(Messages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class56,\n    selectors: [[\"kendoAvatarMessages\"]],\n    inputs: {\n      avatarAlt: \"avatarAlt\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-forward-ref\n/**\n * @hidden\n */\nlet LocalizedAvatarMessagesDirective = /*#__PURE__*/(() => {\n  var _class57;\n  class LocalizedAvatarMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class57 = LocalizedAvatarMessagesDirective;\n  _defineProperty(LocalizedAvatarMessagesDirective, \"\\u0275fac\", function _class57_Factory(t) {\n    return new (t || _class57)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedAvatarMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class57,\n    selectors: [[\"\", \"kendoAvatarLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class57)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedAvatarMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_ROUNDED = 'full';\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_THEME_COLOR = 'primary';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Displays images, icons or initials representing people or other entities.\n */\nlet AvatarComponent = /*#__PURE__*/(() => {\n  var _class58;\n  class AvatarComponent {\n    /**\n     * @hidden\n     */\n    get borderClass() {\n      return this.border;\n    }\n    /**\n     * @hidden\n     */\n    get flexBasis() {\n      return this.width;\n    }\n    /**\n     * Sets the shape for the avatar.\n     * @hidden\n     */\n    set shape(shape) {\n      this.rounded = mapShapeToRounded(shape);\n    }\n    /**\n     * Specifies the size of the avatar\n     * ([see example]({% slug appearance_avatar %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      if (size !== this._size) {\n        const newSize = size ? size : DEFAULT_SIZE;\n        this.handleClasses('size', newSize);\n        this._size = newSize;\n      }\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Specifies the rounded styling of the avatar\n     * ([see example](slug:appearance_avatar#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `full` (Default)\n     * * `none`\n     */\n    set rounded(rounded) {\n      if (rounded !== this._rounded) {\n        const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n        this.handleClasses('rounded', newRounded);\n        this._rounded = newRounded;\n      }\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Specifies the theme color of the avatar.\n     * The theme color will be applied as background and border color, while also amending the text color accordingly.\n     *\n     * The possible values are:\n     * * `base`&mdash; Applies the base coloring value.\n     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.\n     * * `secondary`&mdash;Applies coloring based on secondary theme color.\n     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.\n     * * `info`&mdash;Applies coloring based on info theme color.\n     * * `success`&mdash; Applies coloring based on success theme color.\n     * * `warning`&mdash; Applies coloring based on warning theme color.\n     * * `error`&mdash; Applies coloring based on error theme color.\n     * * `dark`&mdash; Applies coloring based on dark theme color.\n     * * `light`&mdash; Applies coloring based on light theme color.\n     * * `inverse`&mdash; Applies coloring based on inverted theme color.\n     * * `none`&mdash; Removes the styling associated with the theme color.\n     */\n    set themeColor(themeColor) {\n      if (themeColor !== this._themeColor) {\n        const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;\n        this._themeColor = newThemeColor;\n        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n      }\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Specifies the appearance fill style of the avatar.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      if (fillMode !== this.fillMode) {\n        const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n        this._fillMode = newFillMode;\n        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n      }\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Specifies the appearance fill style of the avatar.\n     * Deprecated, left for backward compatibility.\n     *\n     * @hidden\n     */\n    set fill(fillMode) {\n      this.fillMode = fillMode;\n    }\n    /**\n     * Sets a border to the avatar.\n     */\n\n    /**\n     * @hidden\n     */\n    get avatarWidth() {\n      return this.width;\n    }\n    /**\n     * Sets the height of the avatar.\n     */\n\n    /**\n     * @hidden\n     */\n    get avatarHeight() {\n      return this.height;\n    }\n    /**\n     * The CSS styles that will be rendered on the content element of the avatar.\n     * Supports the type of values that are supported by [ngStyle](link:site.data.urls.angular['ngstyleapi']).\n     */\n\n    /**\n     * Defines an SVGIcon to be rendered.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      if (isDevMode() && icon && this.icon && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    constructor(localization, renderer, element) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"border\", false);\n      /**\n       * Defines a CSS class — or multiple classes separated by spaces —\n       * which are applied to a span element inside the avatar.\n       * Allows the usage of custom icons.\n       */\n      _defineProperty(this, \"iconClass\", void 0);\n      /**\n       * Sets the width of the avatar.\n       */\n      _defineProperty(this, \"width\", void 0);\n      _defineProperty(this, \"height\", void 0);\n      _defineProperty(this, \"cssStyle\", void 0);\n      /**\n       * Sets `initials` to the avatar.\n       */\n      _defineProperty(this, \"initials\", void 0);\n      /**\n       * Sets the `icon` for the avatar.\n       * All [Kendo UI Icons](slug:icons#icons-list) are supported.\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * Sets the `image` source of the avatar.\n       */\n      _defineProperty(this, \"imageSrc\", void 0);\n      _defineProperty(this, \"_themeColor\", DEFAULT_THEME_COLOR);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE);\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED);\n      _defineProperty(this, \"_svgIcon\", void 0);\n      this.localization = localization;\n      this.renderer = renderer;\n      this.element = element;\n      validatePackage(packageMetadata);\n    }\n    ngOnInit() {\n      this.verifyProperties();\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(input, this[input]);\n      });\n      this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n    }\n    /**\n     * @hidden\n     */\n    get customAvatar() {\n      return !(this.imageSrc || this.initials || this.icon || this.iconClass);\n    }\n    verifyProperties() {\n      if (!isDevMode()) {\n        return;\n      }\n      const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];\n      const inputsLength = inputs.filter(value => value).length;\n      if (inputsLength > 1) {\n        throw new Error(`\n                Invalid property configuration given.\n                The kendo-avatar component can accept only one of:\n                icon, imageSrc or initials properties.\n            `);\n      }\n    }\n    handleClasses(styleType, value) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('avatar', styleType, this[styleType], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleFillModeAndThemeColorClasses(fill, themeColor) {\n      const wrapperElement = this.element.nativeElement;\n      // remove existing fill and theme color classes\n      const currentClasses = Array.from(wrapperElement.classList);\n      const classesToRemove = currentClasses.filter(cl => {\n        return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');\n      });\n      classesToRemove.forEach(cl => this.renderer.removeClass(wrapperElement, cl));\n      // add fill if needed\n      if (fill !== 'none') {\n        this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);\n      }\n      // add theme color class if fill and theme color\n      if (fill !== 'none' && themeColor !== 'none') {\n        this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);\n      }\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n      return this.localization.get(key);\n    }\n  }\n  _class58 = AvatarComponent;\n  _defineProperty(AvatarComponent, \"\\u0275fac\", function _class58_Factory(t) {\n    return new (t || _class58)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(AvatarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class58,\n    selectors: [[\"kendo-avatar\"]],\n    hostVars: 10,\n    hostBindings: function _class58_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"flex-basis\", ctx.flexBasis)(\"width\", ctx.avatarWidth)(\"height\", ctx.avatarHeight);\n        i0.ɵɵclassProp(\"k-avatar\", ctx.hostClass)(\"k-avatar-bordered\", ctx.borderClass);\n      }\n    },\n    inputs: {\n      shape: \"shape\",\n      size: \"size\",\n      rounded: \"rounded\",\n      themeColor: \"themeColor\",\n      fillMode: \"fillMode\",\n      fill: \"fill\",\n      border: \"border\",\n      iconClass: \"iconClass\",\n      width: \"width\",\n      height: \"height\",\n      cssStyle: \"cssStyle\",\n      initials: \"initials\",\n      icon: \"icon\",\n      imageSrc: \"imageSrc\",\n      svgIcon: \"svgIcon\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.avatar'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 5,\n    vars: 4,\n    consts: function () {\n      let i18n_36;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The alt attribute text of the image in the avatar.\n         * @meaning kendo.avatar.avatarAlt\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_37 = goog.getMsg(\"Avatar\");\n        i18n_36 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_37;\n      } else {\n        i18n_36 = $localize`:kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar.:Avatar`;\n      }\n      return [[\"kendoAvatarLocalizedMessages\", \"\", \"avatarAlt\", i18n_36], [4, \"ngIf\"], [1, \"k-avatar-image\"], [3, \"src\", \"alt\", \"ngStyle\"], [1, \"k-avatar-text\", 3, \"ngStyle\"], [1, \"k-avatar-icon\"], [3, \"ngStyle\", \"name\", \"customFontClass\", \"svgIcon\"]];\n    },\n    template: function _class58_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, _class58_ng_content_1_Template, 1, 0, \"ng-content\", 1);\n        i0.ɵɵtemplate(2, _class58_ng_container_2_Template, 3, 3, \"ng-container\", 1);\n        i0.ɵɵtemplate(3, _class58_ng_container_3_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(4, _class58_ng_container_4_Template, 3, 4, \"ng-container\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.customAvatar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageSrc);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.initials);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.iconClass || ctx.svgIcon);\n      }\n    },\n    dependencies: [NgIf, NgStyle, IconWrapperComponent, LocalizedAvatarMessagesDirective],\n    encapsulation: 2\n  }));\n  return AvatarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-forward-ref\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\nlet AvatarCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class59;\n  class AvatarCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class59 = AvatarCustomMessagesComponent;\n  _defineProperty(AvatarCustomMessagesComponent, \"\\u0275fac\", function _class59_Factory(t) {\n    return new (t || _class59)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(AvatarCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class59,\n    selectors: [[\"kendo-avatar-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class59)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class59_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return AvatarCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})\n */\nlet CardComponent = /*#__PURE__*/(() => {\n  var _class60;\n  class CardComponent {\n    get widthStyle() {\n      return this.width;\n    }\n    get vertical() {\n      return this.orientation === 'vertical';\n    }\n    get horizontal() {\n      return this.orientation === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(localizationService) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Specifies the layout of the Card content.\n       *\n       * The possible values are:\n       * * (Default) `vertical`\n       * * `horizontal`\n       *\n       */\n      _defineProperty(this, \"orientation\", 'vertical');\n      /**\n       * Defines the width of the Card.\n       * Defaults to `285px`.\n       */\n      _defineProperty(this, \"width\", '285px');\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      this.localizationService = localizationService;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n  }\n  _class60 = CardComponent;\n  _defineProperty(CardComponent, \"\\u0275fac\", function _class60_Factory(t) {\n    return new (t || _class60)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(CardComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class60,\n    selectors: [[\"kendo-card\"]],\n    hostVars: 9,\n    hostBindings: function _class60_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"width\", ctx.widthStyle);\n        i0.ɵɵclassProp(\"k-card\", ctx.hostClass)(\"k-card-vertical\", ctx.vertical)(\"k-card-horizontal\", ctx.horizontal);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      width: \"width\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.card.component'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class60_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return CardComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the content in the Card header.\n */\nlet CardHeaderComponent = /*#__PURE__*/(() => {\n  var _class61;\n  class CardHeaderComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class61 = CardHeaderComponent;\n  _defineProperty(CardHeaderComponent, \"\\u0275fac\", function _class61_Factory(t) {\n    return new (t || _class61)();\n  });\n  _defineProperty(CardHeaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class61,\n    selectors: [[\"kendo-card-header\"]],\n    hostVars: 2,\n    hostBindings: function _class61_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-header\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class61_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return CardHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the content in the Card body.\n */\nlet CardBodyComponent = /*#__PURE__*/(() => {\n  var _class62;\n  class CardBodyComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class62 = CardBodyComponent;\n  _defineProperty(CardBodyComponent, \"\\u0275fac\", function _class62_Factory(t) {\n    return new (t || _class62)();\n  });\n  _defineProperty(CardBodyComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class62,\n    selectors: [[\"kendo-card-body\"]],\n    hostVars: 2,\n    hostBindings: function _class62_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-body\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class62_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return CardBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the content in the Card footer.\n */\nlet CardFooterComponent = /*#__PURE__*/(() => {\n  var _class63;\n  class CardFooterComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class63 = CardFooterComponent;\n  _defineProperty(CardFooterComponent, \"\\u0275fac\", function _class63_Factory(t) {\n    return new (t || _class63)();\n  });\n  _defineProperty(CardFooterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class63,\n    selectors: [[\"kendo-card-footer\"]],\n    hostVars: 2,\n    hostBindings: function _class63_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-footer\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class63_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return CardFooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the action buttons of the Card.\n * * ([see example]({% slug actions_card %})).\n */\nlet CardActionsComponent = /*#__PURE__*/(() => {\n  var _class64;\n  class CardActionsComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * Specifies the layout of the Card action buttons.\n       *\n       * * The possible values are:\n       * * (Default) `horizontal`\n       * * `vertical`\n       *\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      /**\n       * Specifies the layout of the Card action buttons.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `center`\n       * * `end`\n       * * `stretched`\n       *\n       */\n      _defineProperty(this, \"layout\", 'start');\n      /**\n       * Fires when the user clicks an action button.\n       */\n      _defineProperty(this, \"action\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsArray\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsTemplate\", void 0);\n    }\n    get stretchedClass() {\n      return this.layout === 'stretched';\n    }\n    get startClass() {\n      return this.layout === 'start';\n    }\n    get endClass() {\n      return this.layout === 'end';\n    }\n    get centerClass() {\n      return this.layout === 'center';\n    }\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n    /**\n     * Allows the declarative specification of the Card actions.\n     */\n    set actions(value) {\n      if (Array.isArray(value)) {\n        this.actionsArray = value;\n      } else if (value instanceof TemplateRef) {\n        this.actionsTemplate = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n    onClick(action) {\n      this.action.emit(action);\n    }\n  }\n  _class64 = CardActionsComponent;\n  _defineProperty(CardActionsComponent, \"\\u0275fac\", function _class64_Factory(t) {\n    return new (t || _class64)();\n  });\n  _defineProperty(CardActionsComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class64,\n    selectors: [[\"kendo-card-actions\"]],\n    hostVars: 16,\n    hostBindings: function _class64_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-actions\", ctx.hostClass)(\"k-card-actions\", ctx.hostClass)(\"k-actions-stretched\", ctx.stretchedClass)(\"k-actions-start\", ctx.startClass)(\"k-actions-end\", ctx.endClass)(\"k-actions-center\", ctx.centerClass)(\"k-actions-vertical\", ctx.verticalClass)(\"k-actions-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      layout: \"layout\",\n      actions: \"actions\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"type\", \"button\", \"class\", \"k-button k-button-md k-rounded-md\", 3, \"k-button-solid\", \"k-button-flat\", \"k-button-solid-base\", \"k-button-solid-primary\", \"k-button-flat-base\", \"k-button-flat-primary\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", 3, \"click\"], [1, \"k-button-text\"], [3, \"ngTemplateOutlet\"]],\n    template: function _class64_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class64_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, _class64_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(2, _class64_2_Template, 1, 1, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.actionsArray && !ctx.actionsTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsArray);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsTemplate);\n      }\n    },\n    dependencies: [NgIf, NgFor, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return CardActionsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies a separator in the content of the Card.\n */\nlet CardSeparatorDirective = /*#__PURE__*/(() => {\n  var _class65;\n  class CardSeparatorDirective {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * Sets the color of the Card separator.\n       */\n      _defineProperty(this, \"color\", void 0);\n      /**\n       * Specifies the orientation of the Card separator.\n       *\n       * The possible values are:\n       * (Default) `horizontal`\n       * `vertical`\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n    }\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n  }\n  _class65 = CardSeparatorDirective;\n  _defineProperty(CardSeparatorDirective, \"\\u0275fac\", function _class65_Factory(t) {\n    return new (t || _class65)();\n  });\n  _defineProperty(CardSeparatorDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class65,\n    selectors: [[\"\", \"kendoCardSeparator\", \"\"]],\n    hostVars: 8,\n    hostBindings: function _class65_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"color\", ctx.color);\n        i0.ɵɵclassProp(\"k-card-separator\", ctx.hostClass)(\"k-separator-vertical\", ctx.verticalClass)(\"k-separator-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      orientation: \"orientation\"\n    },\n    standalone: true\n  }));\n  return CardSeparatorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the text and styles for the title of the Card.\n */\nlet CardTitleDirective = /*#__PURE__*/(() => {\n  var _class66;\n  class CardTitleDirective {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class66 = CardTitleDirective;\n  _defineProperty(CardTitleDirective, \"\\u0275fac\", function _class66_Factory(t) {\n    return new (t || _class66)();\n  });\n  _defineProperty(CardTitleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class66,\n    selectors: [[\"\", \"kendoCardTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class66_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-title\", ctx.hostClass);\n      }\n    },\n    standalone: true\n  }));\n  return CardTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the text and styles for the subtitle of the Card.\n */\nlet CardSubtitleDirective = /*#__PURE__*/(() => {\n  var _class67;\n  class CardSubtitleDirective {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class67 = CardSubtitleDirective;\n  _defineProperty(CardSubtitleDirective, \"\\u0275fac\", function _class67_Factory(t) {\n    return new (t || _class67)();\n  });\n  _defineProperty(CardSubtitleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class67,\n    selectors: [[\"\", \"kendoCardSubtitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class67_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-subtitle\", ctx.hostClass);\n      }\n    },\n    standalone: true\n  }));\n  return CardSubtitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies any media that will be displayed and aligned in the Card.\n */\nlet CardMediaDirective = /*#__PURE__*/(() => {\n  var _class68;\n  class CardMediaDirective {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class68 = CardMediaDirective;\n  _defineProperty(CardMediaDirective, \"\\u0275fac\", function _class68_Factory(t) {\n    return new (t || _class68)();\n  });\n  _defineProperty(CardMediaDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class68,\n    selectors: [[\"\", \"kendoCardMedia\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class68_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-media\", ctx.hostClass);\n      }\n    },\n    standalone: true\n  }));\n  return CardMediaDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The settings of the Card action buttons.\n */\nclass CardAction {\n  constructor() {\n    /**\n     * Determines if the action button is styled as a primary button.\n     */\n    _defineProperty(this, \"primary\", void 0);\n    /**\n     * Determines if the action button is styled as a flat button.\n     */\n    _defineProperty(this, \"flat\", void 0);\n    /**\n     * The text of the action button.\n     */\n    _defineProperty(this, \"text\", void 0);\n  }\n}\n\n/**\n * Represents a template that defines the content of the ExpansionPanel title.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoExpansionPanelTitleDirective` directive inside the `<kendo-expansionpanel>` tag.\n * ([see example]({% slug title_expansionpanel %}#toc-title-template)).\n */\nlet ExpansionPanelTitleDirective = /*#__PURE__*/(() => {\n  var _class70;\n  class ExpansionPanelTitleDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class70 = ExpansionPanelTitleDirective;\n  _defineProperty(ExpansionPanelTitleDirective, \"\\u0275fac\", function _class70_Factory(t) {\n    return new (t || _class70)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(ExpansionPanelTitleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class70,\n    selectors: [[\"\", \"kendoExpansionPanelTitleDirective\", \"\"]],\n    standalone: true\n  }));\n  return ExpansionPanelTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction expand(duration, height) {\n  return [style({\n    overflow: 'hidden',\n    display: 'block',\n    height: 0\n  }), animate(`${duration}ms ease-in`, style({\n    height: `${height}`\n  }))];\n}\n/**\n * @hidden\n */\nfunction collapse(duration, height) {\n  return [style({\n    overflow: 'hidden',\n    height: `${height}`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    height: 0\n  }))];\n}\n\n/**\n * Arguments for the `action` event of the ExpansionPanel.\n */\nclass ExpansionPanelActionEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    /**\n     * The action that will take place upon interaction with the ExpansionPanel.\n     */\n    _defineProperty(this, \"action\", void 0);\n    Object.assign(this, args);\n  }\n}\nconst DEFAULT_DURATION = 200;\nconst CONTENT_HIDDEN_CLASS = 'k-hidden';\n/**\n * Represents the [Kendo UI ExpansionPanel component for Angular]({% slug overview_expansionpanel %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-expansionpanel title=\"Chile\" subtitle=\"South America\">\n *              There are various theories about the origin of the word Chile.\n *        </kendo-expansionpanel>\n *    `\n * })\n * class AppComponent {}\n * ```\n */\nlet ExpansionPanelComponent = /*#__PURE__*/(() => {\n  var _class72;\n  class ExpansionPanelComponent {\n    /**\n     * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding.\n     * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).\n     *\n     * @default false\n     */\n    set expanded(value) {\n      if (value === this.expanded) {\n        return;\n      }\n      this._expanded = value;\n      if (this.expanded) {\n        this.removeContentHiddenClass();\n      } else {\n        this.addContentHiddenClass();\n      }\n    }\n    get expanded() {\n      return this._expanded;\n    }\n    /**\n     * Defines an SVGIcon for the expanded state of the component.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgExpandIcon(icon) {\n      if (isDevMode() && icon && this.expandIcon) {\n        throw new Error('Setting both expandIcon/svgExpandIcon options at the same time is not supported.');\n      }\n      this._svgExpandIcon = icon;\n    }\n    get svgExpandIcon() {\n      return this._svgExpandIcon;\n    }\n    /**\n     * Defines an SVGIcon for the collapsed state of the component.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgCollapseIcon(icon) {\n      if (isDevMode() && icon && this.collapseIcon) {\n        throw new Error('Setting both collapseIcon/svgCollapseIcon options at the same time is not supported.');\n      }\n      this._svgCollapseIcon = icon;\n    }\n    get svgCollapseIcon() {\n      return this._svgCollapseIcon;\n    }\n    /**\n     * Sets a custom icon via css class(es), for the collapsed state of the component\n     * ([see example]({% slug icons_expansionpanel %}#toc-icons)).\n     */\n\n    get expandedClass() {\n      return this.expanded && !this.disabled;\n    }\n    constructor(renderer, hostElement, ngZone, localizationService, builder) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"builder\", void 0);\n      /**\n       * Specifies the primary text in the header of the ExpansionPanel\n       * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).\n       */\n      _defineProperty(this, \"title\", '');\n      /**\n       * Specifies the secondary text in the header of the ExpansionPanel, which is rendered next to the collapse/expand icon\n       * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).\n       */\n      _defineProperty(this, \"subtitle\", '');\n      /**\n       * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed\n       * ([see example]({% slug disabled_expansionpanel %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"expandIcon\", void 0);\n      /**\n       * Sets a custom icon via css class(es), for the expanded state of the component\n       * ([see example]({% slug icons_expansionpanel %}#toc-icons)).\n       */\n      _defineProperty(this, \"collapseIcon\", void 0);\n      /**\n       * Specifies the animation settings of the ExpansionPanel\n       * ([see example]({% slug animations_expansionpanel %})).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true` Numeric values represent duration. Default duration is 200ms.\n       *    * false\n       * * Number\n       */\n      _defineProperty(this, \"animation\", true);\n      /**\n       * Fires when the `expanded` property of the component is updated.\n       * Used to provide a two-way binding for the `expanded` property\n       * ([see example](slug:events_expansionpanel)).\n       */\n      _defineProperty(this, \"expandedChange\", new EventEmitter());\n      /**\n       * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable\n       * ([see example](slug:events_expansionpanel)).\n       */\n      _defineProperty(this, \"action\", new EventEmitter());\n      /**\n       * Fires when the ExpansionPanel is expanded. If there is animation it will fire when the animation is complete\n       * ([see example](slug:events_expansionpanel)).\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the ExpansionPanel is collapsed. If there is animation it will fire when the animation is complete\n       * ([see example](slug:events_expansionpanel)).\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"titleTemplate\", void 0);\n      _defineProperty(this, \"content\", void 0);\n      _defineProperty(this, \"header\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focused\", false);\n      _defineProperty(this, \"animationEnd\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"_expanded\", false);\n      _defineProperty(this, \"_svgExpandIcon\", chevronDownIcon);\n      _defineProperty(this, \"_svgCollapseIcon\", chevronUpIcon);\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.ngZone = ngZone;\n      this.localizationService = localizationService;\n      this.builder = builder;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.hostElement.nativeElement, 'title');\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      const elem = this.hostElement.nativeElement;\n      const header = this.header.nativeElement;\n      this.subscriptions.add(this.renderer.listen(header, 'focus', () => this.focusExpansionPanel(elem)));\n      this.subscriptions.add(this.renderer.listen(header, 'blur', () => this.blurExpansionPanel(elem)));\n    }\n    ngAfterViewInit() {\n      this.initDomEvents();\n      if (!this.expanded) {\n        this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    initDomEvents() {\n      if (!this.hostElement) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        const elem = this.hostElement.nativeElement;\n        this.subscriptions.add(this.renderer.listen(elem, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(ev) {\n      const isEnterOrSpace = ev.keyCode === Keys.Enter || ev.keyCode === Keys.Space;\n      if (this.disabled || !isEnterOrSpace) {\n        return;\n      }\n      if (hasClass(ev.target, 'k-expander-header')) {\n        ev.preventDefault();\n        this.ngZone.run(() => {\n          this.onHeaderAction();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onHeaderClick(ev) {\n      const header = this.header.nativeElement;\n      if (!isFocusable(ev.target) || ev.target === header && !this.disabled) {\n        this.onHeaderAction();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onHeaderAction() {\n      const eventArgs = new ExpansionPanelActionEvent();\n      eventArgs.action = this.expanded ? 'collapse' : 'expand';\n      this.action.emit(eventArgs);\n      if (!eventArgs.isDefaultPrevented()) {\n        this.setExpanded(!this.expanded);\n        if (this.expanded) {\n          this.removeContentHiddenClass();\n        }\n        if (this.animation) {\n          this.animateContent();\n          return;\n        }\n        if (!this.expanded) {\n          this.addContentHiddenClass();\n        }\n        this.emitExpandCollapseEvent();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get expanderIndicatorClasses() {\n      if (this.expanded) {\n        return !this.collapseIcon ? `chevron-up` : '';\n      } else {\n        return !this.expandIcon ? `chevron-down` : '';\n      }\n    }\n    /**\n     * @hidden\n     */\n    get customExpanderIndicatorClasses() {\n      if (this.expanded) {\n        return this.collapseIcon ? this.collapseIcon : '';\n      } else {\n        return this.expandIcon ? this.expandIcon : '';\n      }\n    }\n    /**\n     * @hidden\n     */\n    get expanderSvgIcon() {\n      return this.expanded ? this.svgCollapseIcon : this.svgExpandIcon;\n    }\n    /**\n     * Toggles the visibility of the ExpansionPanel\n     * ([see example](slug:interaction_expansionpanel#toggling-between-states)).\n     *\n     * @param expanded? - Boolean. Specifies, whether the ExpansionPanel will be expanded or collapsed.\n     */\n    toggle(expanded) {\n      const previous = this.expanded;\n      const current = isPresent(expanded) ? expanded : !previous;\n      if (current === previous) {\n        return;\n      }\n      this.setExpanded(current);\n      if (this.expanded) {\n        this.removeContentHiddenClass();\n      }\n      if (this.animation) {\n        this.animateContent();\n        return;\n      }\n      if (!this.expanded) {\n        this.addContentHiddenClass();\n      }\n      this.emitExpandCollapseEvent();\n    }\n    focusExpansionPanel(el) {\n      if (!this.focused) {\n        this.focused = true;\n        this.renderer.addClass(el, 'k-focus');\n      }\n    }\n    blurExpansionPanel(el) {\n      if (this.focused) {\n        this.focused = false;\n        this.renderer.removeClass(el, 'k-focus');\n      }\n    }\n    setExpanded(value) {\n      this._expanded = value;\n      this.expandedChange.emit(value);\n    }\n    animateContent() {\n      const duration = typeof this.animation === 'boolean' ? DEFAULT_DURATION : this.animation;\n      const contentHeight = getComputedStyle(this.content.nativeElement).height;\n      const animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);\n      const player = this.createPlayer(animation, this.content.nativeElement);\n      this.animationEnd.pipe(take(1)).subscribe(() => {\n        if (!this.expanded) {\n          this.addContentHiddenClass();\n        }\n        this.emitExpandCollapseEvent();\n      });\n      player.play();\n    }\n    createPlayer(animation, animatedElement) {\n      const factory = this.builder.build(animation);\n      let player = factory.create(animatedElement);\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n      return player;\n    }\n    emitExpandCollapseEvent() {\n      this[this.expanded ? 'expand' : 'collapse'].emit();\n    }\n    addContentHiddenClass() {\n      this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n    }\n    removeContentHiddenClass() {\n      this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n    }\n  }\n  _class72 = ExpansionPanelComponent;\n  _defineProperty(ExpansionPanelComponent, \"\\u0275fac\", function _class72_Factory(t) {\n    return new (t || _class72)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i1$2.AnimationBuilder));\n  });\n  _defineProperty(ExpansionPanelComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class72,\n    selectors: [[\"kendo-expansionpanel\"]],\n    contentQueries: function _class72_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ExpansionPanelTitleDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class72_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c38, 7);\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function _class72_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-expander\", ctx.hostClass)(\"k-expanded\", ctx.expandedClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      subtitle: \"subtitle\",\n      disabled: \"disabled\",\n      expanded: \"expanded\",\n      svgExpandIcon: \"svgExpandIcon\",\n      svgCollapseIcon: \"svgCollapseIcon\",\n      expandIcon: \"expandIcon\",\n      collapseIcon: \"collapseIcon\",\n      animation: \"animation\"\n    },\n    outputs: {\n      expandedChange: \"expandedChange\",\n      action: \"action\",\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    exportAs: [\"kendoExpansionPanel\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.expansionpanel'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 10,\n    vars: 14,\n    consts: [[\"role\", \"button\", \"tabindex\", \"0\", 3, \"click\"], [\"header\", \"\"], [4, \"ngIf\"], [1, \"k-expander-indicator\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-expander-content-wrapper\", 3, \"id\"], [\"content\", \"\"], [1, \"k-expander-content\"], [\"class\", \"k-expander-title\", 4, \"ngIf\"], [1, \"k-spacer\"], [\"class\", \"k-expander-sub-title\", 4, \"ngIf\"], [1, \"k-expander-title\"], [1, \"k-expander-sub-title\"], [3, \"ngTemplateOutlet\"]],\n    template: function _class72_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class72_Template_div_click_0_listener($event) {\n          return ctx.onHeaderClick($event);\n        });\n        i0.ɵɵtemplate(2, _class72_ng_container_2_Template, 4, 2, \"ng-container\", 2);\n        i0.ɵɵtemplate(3, _class72_3_Template, 1, 1, null, 2);\n        i0.ɵɵelementStart(4, \"span\", 3);\n        i0.ɵɵelement(5, \"kendo-icon-wrapper\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"div\", 5, 6)(8, \"div\", 7);\n        i0.ɵɵprojection(9);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-expander-header\", true)(\"k-disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.expanded && !ctx.disabled)(\"aria-controls\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.titleTemplate);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"name\", ctx.expanderIndicatorClasses)(\"customFontClass\", ctx.customExpanderIndicatorClasses)(\"svgIcon\", ctx.expanderSvgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-hidden\", !ctx.expanded);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ExpansionPanelComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet idx = 0;\n/**\n * @hidden\n */\nconst getId = prefix => {\n  return `${prefix}-${++idx}`;\n};\n/**\n * @hidden\n */\nconst normalizeValue = value => {\n  return value ? +value : undefined;\n};\n/**\n * @hidden\n */\nconst isRowItemPresent = items => {\n  return items.some(item => isPresent(item.row));\n};\n/**\n * @hidden\n */\nconst propsChanged = (initialProps, newProps) => {\n  for (let i = 0; i < initialProps.length; i++) {\n    if (initialProps[i] !== newProps[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * @hidden\n *\n * Extracts the event target from the viewport coords. Required for touch devices\n * where the `event.target` of a `pointermove` event is always the initially dragged item.\n */\nconst getDropTarget = event => {\n  if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {\n    return [event.target];\n  }\n  return document.elementsFromPoint(event.clientX, event.clientY).filter(item => item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')));\n};\n/**\n * @hidden\n */\nconst setElementStyles = (renderer, elem, styles) => {\n  const props = Object.keys(styles);\n  props.forEach(p => {\n    renderer.setStyle(elem, p, styles[p]);\n  });\n};\n/**\n * @hidden\n */\nconst calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {\n  const tileLayoutRect = tileLayoutElement.getBoundingClientRect();\n  const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);\n  const distanceFromTop = coordinates.y - tileLayoutRect.y;\n  const distanceFromLeft = coordinates.x - tileLayoutRect.x;\n  const distanceFromRight = tileLayoutRect.right - coordinates.x;\n  const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));\n  const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);\n  const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));\n  const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);\n  const col = Math.max(cappedColumnPosition, 0);\n  const row = Math.max(cappedRowPosition, 0);\n  return {\n    row,\n    col\n  };\n};\n/**\n * @hidden\n */\nconst calculateOrderFromCell = (row, col, items, draggedItem, tileLayoutElement, gap, cellSize, columns) => {\n  let order = 0;\n  items.forEach(item => {\n    const rect = item.elem.nativeElement.getBoundingClientRect();\n    const start = calculateCellFromPosition({\n      x: rect.x,\n      y: rect.y\n    }, tileLayoutElement, gap, cellSize, columns);\n    if (item !== draggedItem && (start.row === row && start.col < col || start.row < row)) {\n      order++;\n    }\n  });\n  return order;\n};\n/**\n * @hidden\n */\nconst shouldResize = (keyCode, col, selectedTile, settings) => {\n  const resizeRight = keyCode === Keys.ArrowRight && col + selectedTile.colSpan <= settings.columns;\n  const resizeLeft = keyCode === Keys.ArrowLeft && selectedTile.colSpan > 1;\n  const resizeDown = keyCode === Keys.ArrowDown;\n  const resizeUp = keyCode === Keys.ArrowUp && selectedTile.rowSpan > 1;\n  return {\n    resizeRight,\n    resizeLeft,\n    resizeDown,\n    resizeUp\n  };\n};\n/**\n * @hidden\n */\nconst shouldReorder = (keyCode, col, selectedTile, settings) => {\n  let reorderRight;\n  let reorderLeft;\n  if (selectedTile.col) {\n    reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + col <= settings.columns;\n    reorderLeft = keyCode === Keys.ArrowLeft && col > 1;\n  } else {\n    reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + selectedTile.order < settings.items.length;\n    reorderLeft = keyCode === Keys.ArrowLeft && selectedTile.order > 0;\n  }\n  return {\n    reorderLeft,\n    reorderRight\n  };\n};\n/**\n * @hidden\n */\nconst getCurrentCol = (selectedTile, settings, rtl) => {\n  const rects = selectedTile.elem.nativeElement.getBoundingClientRect();\n  const targetSize = {\n    rowSpan: selectedTile.rowSpan,\n    colSpan: selectedTile.colSpan\n  };\n  const width = (rects.width - (targetSize.colSpan - 1) * settings.gap.columns) / targetSize.colSpan;\n  const height = (rects.height - (targetSize.rowSpan - 1) * settings.gap.rows) / targetSize.rowSpan;\n  const {\n    col\n  } = calculateCellFromPosition({\n    x: rects.x,\n    y: rects.y\n  }, settings.tileLayoutElement, settings.gap, {\n    width: width,\n    height: height\n  }, settings.columns, rtl);\n  return col;\n};\n\n/**\n * @hidden\n */\nconst RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;\n/**\n * @hidden\n */\nconst RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;\n/**\n * @hidden\n */\nconst RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;\n/**\n * @hidden\n */\nconst RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;\n/**\n * @hidden\n */\nconst DRAGGED_ZINDEX = 10;\n/**\n * @hidden\n */\nconst RESIZE_DIRECTIONS = ['ew', 'ns', 'nwse'];\n/**\n * @hidden\n */\nconst RTL_RESIZE_DIRECTIONS = ['ew', 'ns', 'nesw'];\n/**\n * @hidden\n */\nconst RESIZE_HANDLE_DIMENSIONS = {\n  // numeric values represent pixels\n  ew: {\n    width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP\n  },\n  ns: {\n    height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,\n    overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP\n  },\n  nwse: {\n    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,\n    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP\n  },\n  nesw: {\n    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,\n    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP\n  }\n};\n/**\n * @hidden\n */\nconst OVERLAP_THRESHOLD = 0.3;\n/**\n * @hidden\n */\nconst REVERSE_OVERLAP_THRESHOLD = -0.7;\n/**\n * @hidden\n */\nconst HINT_BORDERS_HEIGHT = 2;\n\n/**\n * Arguments for the `reorder` event. The event fires when the order or starting\n * positions of the items is changed via the UI. If you prevent the event, the change is canceled ([see example]({% slug reordering_tilelayout %}#toc-handling-the-reorder-event)).\n */\nclass TileLayoutReorderEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `reorder` event.\n   * @param item - The TileLayoutItem being reordered.\n   * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.\n   * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.\n   * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.\n   * @param newCol - The new start column of the reordered item.\n   * @param oldCol - The initial start column of the reordered item.\n   * @param newRow - The new start row of the reordered item.\n   * @param oldRow - The initial start row of the reordered item.\n   * @hidden\n   */\n  constructor(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {\n    super();\n    _defineProperty(this, \"item\", void 0);\n    _defineProperty(this, \"items\", void 0);\n    _defineProperty(this, \"newIndex\", void 0);\n    _defineProperty(this, \"oldIndex\", void 0);\n    _defineProperty(this, \"newCol\", void 0);\n    _defineProperty(this, \"oldCol\", void 0);\n    _defineProperty(this, \"newRow\", void 0);\n    _defineProperty(this, \"oldRow\", void 0);\n    this.item = item;\n    this.items = items;\n    this.newIndex = newIndex;\n    this.oldIndex = oldIndex;\n    this.newCol = newCol;\n    this.oldCol = oldCol;\n    this.newRow = newRow;\n    this.oldRow = oldRow;\n  }\n}\n\n/**\n * Arguments for the `resize` event. The `resize` event fires when any item size\n * is changed from the UI. If you cancel the event, the change is prevented ([see example]({% slug resizing_tilelayout %}#toc-handling-the-resize-event)).\n */\nclass TileLayoutResizeEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `resize` event.\n   * @param item - The TileLayoutItem being resized\n   * @param items - The TileLayoutItem collection\n   * @param newRowSpan - The new rowSpan of the resized item\n   * @param oldRowSpan - The initial rowSpan of the resized item\n   * @param newColSpan - The new colSpan of the resized item\n   * @param oldColSpan - The initial colSpan of the resized item\n   * @hidden\n   */\n  constructor(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {\n    super();\n    _defineProperty(this, \"item\", void 0);\n    _defineProperty(this, \"items\", void 0);\n    _defineProperty(this, \"newRowSpan\", void 0);\n    _defineProperty(this, \"oldRowSpan\", void 0);\n    _defineProperty(this, \"newColSpan\", void 0);\n    _defineProperty(this, \"oldColSpan\", void 0);\n    this.item = item;\n    this.items = items;\n    this.newRowSpan = newRowSpan;\n    this.oldRowSpan = oldRowSpan;\n    this.newColSpan = newColSpan;\n    this.oldColSpan = oldColSpan;\n  }\n}\n\n/**\n * @hidden\n */\nlet TileLayoutDraggingService = /*#__PURE__*/(() => {\n  var _class75;\n  class TileLayoutDraggingService {\n    get colStart() {\n      return this.currentColStart;\n    }\n    get rowStart() {\n      return this.currentRowStart;\n    }\n    get itemWrapper() {\n      return this.draggedItemWrapper;\n    }\n    get order() {\n      return this.targetOrder;\n    }\n    constructor(zone, renderer, cdr, localization) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"reorderable\", new BehaviorSubject(null));\n      _defineProperty(this, \"resizable\", new BehaviorSubject(null));\n      _defineProperty(this, \"reorder\", new Subject());\n      _defineProperty(this, \"resize\", new Subject());\n      _defineProperty(this, \"tileLayoutSettings\", void 0);\n      _defineProperty(this, \"draggedItem\", void 0);\n      _defineProperty(this, \"draggedItemWrapper\", void 0);\n      _defineProperty(this, \"reordering\", void 0);\n      _defineProperty(this, \"resizing\", void 0);\n      _defineProperty(this, \"offset\", void 0);\n      _defineProperty(this, \"targetSize\", void 0);\n      _defineProperty(this, \"cellSize\", void 0);\n      _defineProperty(this, \"targetOrder\", void 0);\n      _defineProperty(this, \"currentColStart\", void 0);\n      _defineProperty(this, \"currentRowStart\", void 0);\n      _defineProperty(this, \"startingPoint\", void 0);\n      _defineProperty(this, \"currentResizingColSpan\", void 0);\n      _defineProperty(this, \"currentResizingRowSpan\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"lastDragCursorOffset\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"localizationSubscription\", void 0);\n      _defineProperty(this, \"rtl\", void 0);\n      this.zone = zone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.localizationSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl);\n    }\n    ngOnDestroy() {\n      this.localizationSubscription.unsubscribe();\n    }\n    handlePress(originalEvent) {\n      const resizing = !!originalEvent.target.classList.contains('k-resize-handle');\n      const closestTile = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item'), this.tileLayoutSettings.tileLayoutElement);\n      const closestHeader = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item-header'), this.tileLayoutSettings.tileLayoutElement);\n      if (!closestTile) {\n        return;\n      }\n      this.zone.run(() => {\n        this.draggedItemWrapper = closestTile;\n        this.draggedItem = this.tileLayoutSettings.items.find(item => item.order === +closestTile.style.order);\n      });\n      const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;\n      const focusableTarget = isFocusable(originalEvent.target);\n      if (!(reordering || resizing) || focusableTarget) {\n        return;\n      } else {\n        originalEvent.preventDefault();\n      }\n      this.zone.run(() => {\n        this.reordering = reordering;\n        this.resizing = resizing;\n      });\n      const tileRect = this.draggedItemWrapper.getBoundingClientRect();\n      this.zone.run(() => {\n        this.offset = {\n          top: originalEvent.clientY - tileRect.top,\n          left: originalEvent.clientX - tileRect.left,\n          x: tileRect.x,\n          y: tileRect.y,\n          width: tileRect.width,\n          height: tileRect.height\n        };\n        this.targetSize = {\n          rowSpan: this.draggedItem.rowSpan,\n          colSpan: this.draggedItem.colSpan\n        };\n        this.cellSize = {\n          width: (tileRect.width - (this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns) / this.targetSize.colSpan,\n          height: (tileRect.height - (this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows) / this.targetSize.rowSpan\n        };\n        this.lastDragCursorOffset = {\n          x: originalEvent.clientX,\n          y: originalEvent.clientY\n        };\n      });\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        left: tileRect.left + window.pageXOffset - window.scrollX + 'px',\n        top: tileRect.top + window.pageYOffset - window.scrollY + 'px',\n        width: tileRect.width + 'px',\n        height: tileRect.height + 'px',\n        zIndex: DRAGGED_ZINDEX\n      });\n      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n        display: 'flex',\n        height: tileRect.height - HINT_BORDERS_HEIGHT + 'px'\n      });\n      this.zone.run(() => this.targetOrder = this.draggedItem.order);\n      this.cdr.markForCheck();\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        position: 'fixed'\n      });\n      if (this.reorderable.getValue() && !resizing) {\n        this.zone.run(() => {\n          this.currentColStart = this.draggedItem.colStart;\n          this.currentRowStart = this.draggedItem.rowStart;\n        });\n        this.cdr.markForCheck();\n      } else if (this.resizable && resizing) {\n        this.zone.run(() => {\n          this.startingPoint = {\n            top: originalEvent.clientY,\n            left: originalEvent.clientX\n          };\n          this.currentResizingColSpan = this.draggedItem.colSpan;\n          this.currentResizingRowSpan = this.draggedItem.rowSpan;\n          if (this.draggedItem.col) {\n            this.currentColStart = this.draggedItem.col.toString();\n          }\n          if (this.draggedItem.row) {\n            this.currentRowStart = this.draggedItem.row.toString();\n          }\n          this.direction = originalEvent.target.classList[1];\n        });\n      }\n    }\n    handleDrag(originalEvent) {\n      if (this.draggedItemWrapper) {\n        if (this.reordering) {\n          this.reorderItems(originalEvent);\n        } else if (this.resizing) {\n          this.resizeItem(originalEvent);\n        }\n        this.lastDragCursorOffset = {\n          x: originalEvent.clientX,\n          y: originalEvent.clientY\n        };\n      }\n    }\n    handleRelease(originalEvent) {\n      originalEvent.preventDefault();\n      if (this.reordering) {\n        const initialOrder = this.draggedItem.order;\n        const initialCol = this.draggedItem.col;\n        const initialRow = this.draggedItem.row;\n        const targetCol = normalizeValue(this.currentColStart);\n        const targetRow = normalizeValue(this.currentRowStart);\n        if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {\n          const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, normalizeValue(this.currentColStart), initialCol, targetRow, initialRow);\n          this.reorder.next(reorderEvent);\n          if (!reorderEvent.isDefaultPrevented()) {\n            if (this.targetOrder > initialOrder) {\n              this.zone.run(() => {\n                for (let i = initialOrder + 1; i <= this.targetOrder; i++) {\n                  this.tileLayoutSettings.items.find(item => item.order === i).order = i - 1;\n                }\n              });\n            } else {\n              this.zone.run(() => {\n                for (let i = initialOrder - 1; i >= this.targetOrder; i--) {\n                  this.tileLayoutSettings.items.find(item => item.order === i).order = i + 1;\n                }\n              });\n            }\n            this.draggedItem.order = this.targetOrder;\n            if (this.draggedItem.col) {\n              this.draggedItem.col = +this.currentColStart;\n            }\n            if (this.draggedItem.row) {\n              this.draggedItem.row = +this.currentRowStart;\n            }\n          }\n        }\n        this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);\n        this.cdr.markForCheck();\n        this.zone.run(() => this.cleanUp());\n      } else if (!this.reordering && this.resizing) {\n        const initialRowSpan = this.draggedItem.rowSpan;\n        const initialColSpan = this.draggedItem.colSpan;\n        const {\n          targetColSpan,\n          targetRowSpan\n        } = isRowItemPresent(this.tileLayoutSettings.items) ? this.targetSpan() : {\n          targetColSpan: this.currentResizingColSpan,\n          targetRowSpan: this.currentResizingRowSpan\n        };\n        if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {\n          const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);\n          this.resize.next(resizeEvent);\n          if (!resizeEvent.isDefaultPrevented()) {\n            this.draggedItem.colSpan = this.currentResizingColSpan;\n            this.draggedItem.rowSpan = this.currentResizingRowSpan;\n          }\n        }\n        this.zone.run(() => this.cleanUp());\n      }\n    }\n    reorderItems(event) {\n      const targets = getDropTarget(event);\n      const closestTile = targets.find(t => t !== this.draggedItemWrapper);\n      const tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;\n      if (this.tileLayoutSettings.autoFlow !== 'none') {\n        const deltaX = event.clientX - this.lastDragCursorOffset.x;\n        const deltaY = event.clientY - this.lastDragCursorOffset.y;\n        const directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;\n        const directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;\n        const rect = this.draggedItemWrapper.getBoundingClientRect();\n        const horizontalGap = this.tileLayoutSettings.gap.columns;\n        const verticalGap = this.tileLayoutSettings.gap.rows;\n        if (directionX && this.draggedItem.col) {\n          const {\n            col\n          } = calculateCellFromPosition({\n            x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,\n            y: event.clientY\n          }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n          const targetStartCol = this.getTargetCol(col, directionX);\n          this.currentColStart = targetStartCol.toString();\n        }\n        if (directionY && this.draggedItem.row) {\n          const {\n            row\n          } = calculateCellFromPosition({\n            x: event.clientX,\n            y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap\n          }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n          const targetStartRow = this.getTargetRow(row, directionY);\n          this.currentRowStart = targetStartRow.toString();\n        }\n      }\n      const hintBefore = tileOrder < this.targetOrder;\n      const hintAfter = tileOrder > this.targetOrder;\n      this.zone.run(() => this.targetOrder = tileOrder);\n      if (hintBefore) {\n        this.tileLayoutSettings.tileLayoutElement.insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);\n      } else if (hintAfter) {\n        this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);\n      }\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        top: event.pageY - this.offset.top - window.scrollY + 'px',\n        left: event.pageX - this.offset.left - window.scrollX + 'px'\n      });\n      this.cdr.markForCheck();\n    }\n    resizeItem(event) {\n      setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {\n        cursor: this.direction.split('k-cursor-')[1]\n      });\n      const currentWidth = this.rtl ? this.offset.width + (this.offset.x - event.clientX) : this.offset.width + (event.clientX - this.startingPoint.left);\n      const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);\n      const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();\n      const hintWidth = hintRect.width;\n      const hintHeight = hintRect.height;\n      const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;\n      const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;\n      const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({\n        x: this.rtl ? hintRect.right : hintRect.x,\n        y: hintRect.y\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;\n      const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;\n      const resizeHorizontally = () => {\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + 'px'\n        });\n        if (this.rtl && currentWidth > this.cellSize.width) {\n          const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);\n          const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;\n          setElementStyles(this.renderer, this.draggedItemWrapper, {\n            left: Math.max(event.clientX, leftBoundary) + 'px'\n          });\n        }\n        const deltaX = currentWidth - hintWidth;\n        const {\n          x,\n          y,\n          right\n        } = this.draggedItem.elem.nativeElement.getBoundingClientRect();\n        const {\n          col\n        } = calculateCellFromPosition({\n          x: this.rtl ? right : x,\n          y: y\n        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n        const resizedColSpan = col + this.currentResizingColSpan;\n        const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;\n        const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;\n        if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width && expandingCondition && resizedColSpan <= this.tileLayoutSettings.columns) {\n          this.currentResizingColSpan++;\n        } else if (this.currentResizingColSpan > 1 && shrinkingCondition && deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {\n          this.currentResizingColSpan--;\n        }\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          gridColumnEnd: `span ${this.currentResizingColSpan}`\n        });\n      };\n      const resizeVertically = () => {\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          height: Math.max(currentHeight, this.cellSize.height) + 'px'\n        });\n        const deltaY = currentHeight - hintHeight;\n        if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {\n          this.currentResizingRowSpan++;\n        } else if (this.currentResizingRowSpan > 1 && verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {\n          this.currentResizingRowSpan--;\n        }\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          gridRowEnd: `span ${this.currentResizingRowSpan}`\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          height: `${this.calculateHintHeight()}px`\n        });\n      };\n      if (this.direction.indexOf('ew') > -1) {\n        resizeHorizontally();\n      } else if (this.direction.indexOf('ns') > -1) {\n        resizeVertically();\n      } else {\n        resizeHorizontally();\n        resizeVertically();\n      }\n    }\n    cleanUp() {\n      this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;\n      this.resizing = this.reordering = false;\n      this.direction = null;\n      if (this.draggedItemWrapper) {\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          top: '',\n          left: '',\n          display: '',\n          width: '',\n          height: '',\n          zIndex: '',\n          position: ''\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          display: 'none',\n          height: 'auto'\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {\n          cursor: 'default'\n        });\n        this.draggedItemWrapper = this.offset = this.draggedItem = this.resizing = this.reordering = this.currentResizingColSpan = this.currentResizingRowSpan = this.startingPoint = undefined;\n        this.lastDragCursorOffset = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n    targetSpan() {\n      const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();\n      const startingCell = calculateCellFromPosition({\n        x: this.rtl ? itemRect.right : itemRect.x,\n        y: itemRect.y\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n      const targetEndCell = calculateCellFromPosition({\n        x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,\n        y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n      return {\n        targetColSpan: targetEndCell.col - startingCell.col + 1,\n        targetRowSpan: targetEndCell.row - startingCell.row + 1\n      };\n    }\n    getTargetCol(col, direction) {\n      if (this.rtl) {\n        return direction === 'left' ? col - this.draggedItem.colSpan + 1 : col;\n      }\n      return direction === 'right' ? col - this.draggedItem.colSpan + 1 : col;\n    }\n    getTargetRow(row, direction) {\n      return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;\n    }\n    calculateHintHeight() {\n      const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;\n      const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;\n      const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;\n      return hintHeight;\n    }\n  }\n  _class75 = TileLayoutDraggingService;\n  _defineProperty(TileLayoutDraggingService, \"\\u0275fac\", function _class75_Factory(t) {\n    return new (t || _class75)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i0.ChangeDetectorRef), i0.ɵɵinject(i1.LocalizationService));\n  });\n  _defineProperty(TileLayoutDraggingService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class75,\n    factory: _class75.ɵfac\n  }));\n  return TileLayoutDraggingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable no-unused-expressions */\n/**\n * @hidden\n */\nlet TileLayoutKeyboardNavigationService = /*#__PURE__*/(() => {\n  var _class76;\n  class TileLayoutKeyboardNavigationService {\n    constructor(zone, renderer, localization) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"navigable\", new BehaviorSubject(false));\n      _defineProperty(this, \"owner\", void 0);\n      _defineProperty(this, \"mousedown\", void 0);\n      _defineProperty(this, \"localizationSubscription\", void 0);\n      _defineProperty(this, \"rtl\", void 0);\n      _defineProperty(this, \"lastFocused\", void 0);\n      this.zone = zone;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.localizationSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl);\n    }\n    ngOnDestroy() {\n      this.localizationSubscription.unsubscribe();\n    }\n    onKeyDown(event, elem, focusableItems, settings) {\n      const keyCode = event.keyCode;\n      const isTileFocused = document.activeElement === elem;\n      const focusedTile = settings.items.find(item => item.elem.nativeElement === elem);\n      const col = getCurrentCol(focusedTile, settings, this.rtl);\n      const isArrow = [Keys.ArrowLeft, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowUp].some(key => key === event.keyCode);\n      this.lastFocused = focusedTile;\n      if (keyCode === Keys.Enter && isTileFocused && focusableItems.length > 0) {\n        this.changeTabIndex('0', elem, focusableItems);\n        focusableItems[0].focus();\n      } else if (keyCode === Keys.Escape) {\n        this.changeTabIndex('-1', elem, focusableItems);\n        elem.focus();\n      } else if (isArrow && (event.ctrlKey || event.metaKey) && isTileFocused && focusedTile.isResizable) {\n        event.preventDefault();\n        this.zone.run(() => {\n          this.resizeItem(keyCode, focusedTile, settings, col);\n        });\n      } else if (isArrow && event.shiftKey && isTileFocused && focusedTile.isReorderable) {\n        this.zone.run(() => {\n          this.reorderItem(keyCode, focusedTile, settings, col);\n        });\n      } else if (keyCode === Keys.Tab) {\n        if (!isTileFocused) {\n          this.keepFocusWithinComponent(event, elem);\n        } else {\n          const dir = event.shiftKey ? -1 : 1;\n          const nextFocusableTileOrder = focusedTile.order + dir;\n          if (nextFocusableTileOrder < 0 || nextFocusableTileOrder >= settings.items.length) {\n            const first = settings.items[0];\n            const last = settings.items[settings.items.length - 1];\n            if (dir > 0) {\n              last.focus();\n            } else {\n              first.focus();\n            }\n            return;\n          }\n          event.preventDefault();\n          this.lastFocused = settings.items.find(item => item.order === nextFocusableTileOrder);\n          this.lastFocused?.focus();\n        }\n      }\n    }\n    onFocusOut(event, elem, focusableItems) {\n      const isTargetFocusable = focusableItems.includes(event.target);\n      const isRelatedTargetFocusable = focusableItems.includes(event.relatedTarget);\n      if (isTargetFocusable && !isRelatedTargetFocusable) {\n        this.changeTabIndex('-1', elem, focusableItems);\n        event.relatedTarget?.focus();\n      }\n    }\n    onMousedown(event, elem, focusableItems, tile) {\n      this.mousedown = true;\n      const isTargetFocusable = focusableItems.includes(event.target);\n      this.lastFocused = tile;\n      if (isTargetFocusable) {\n        this.changeTabIndex('0', elem, focusableItems);\n        event.target.focus();\n      }\n    }\n    changeTabIndex(tabIndex, elem, focusableItems) {\n      this.renderer.setAttribute(elem, 'tabindex', tabIndex === '0' ? '-1' : '0');\n      focusableItems.forEach(focusItem => {\n        this.renderer.setAttribute(focusItem, 'tabindex', tabIndex);\n      });\n    }\n    getAllFocusableChildren(parent) {\n      return Array.from(parent.querySelectorAll(focusableSelector)).filter(element => element.offsetParent !== null);\n    }\n    returnFocus() {\n      this.lastFocused ? this.lastFocused.focus() : this.owner.items.find(item => item.order === 0).focus();\n    }\n    resizeItem(keyCode, focusedTile, settings, col) {\n      const {\n        resizeRight,\n        resizeLeft,\n        resizeDown,\n        resizeUp\n      } = shouldResize(keyCode, col, focusedTile, settings);\n      const resizeHorizontal = resizeLeft || resizeRight;\n      const resizeVertical = resizeDown || resizeUp;\n      const resizeDir = resizeLeft || resizeUp ? -1 : 1;\n      if (!(resizeHorizontal || resizeVertical)) {\n        return;\n      }\n      const resizeEvent = new TileLayoutResizeEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.rowSpan + resizeDir, focusedTile.rowSpan, focusedTile.colSpan + resizeDir, focusedTile.colSpan);\n      this.owner.resize.emit(resizeEvent);\n      if (!resizeEvent.isDefaultPrevented()) {\n        if (resizeHorizontal) {\n          focusedTile.colSpan += resizeDir;\n        } else if (resizeVertical) {\n          focusedTile.rowSpan += resizeDir;\n        }\n      }\n    }\n    reorderItem(keyCode, focusedTile, settings, col) {\n      const {\n        reorderLeft,\n        reorderRight\n      } = shouldReorder(keyCode, col, focusedTile, settings);\n      if (!(reorderLeft || reorderRight)) {\n        return;\n      }\n      const reorder = dir => {\n        const relatedTile = this.targetTile(focusedTile, settings.items, dir);\n        if (relatedTile) {\n          relatedTile.order -= dir;\n          if (relatedTile.col) {\n            relatedTile.col -= dir;\n          }\n          focusedTile.order += dir;\n          if (focusedTile.col) {\n            focusedTile.col += dir;\n          }\n        }\n      };\n      const reorderDir = reorderRight ? 1 : -1;\n      const reorderEvent = new TileLayoutReorderEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.order + reorderDir, focusedTile.order, focusedTile.col ? focusedTile.col + reorderDir : undefined, focusedTile.col, focusedTile.row, focusedTile.row);\n      this.owner.reorder.next(reorderEvent);\n      if (!reorderEvent.isDefaultPrevented()) {\n        reorder(reorderDir);\n      }\n    }\n    keepFocusWithinComponent(event, wrapper) {\n      const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);\n      const tabAfterLastFocusable = !event.shiftKey && event.target === lastFocusable;\n      const shiftTabAfterFirstFocusable = event.shiftKey && event.target === firstFocusable;\n      if (tabAfterLastFocusable) {\n        event.preventDefault();\n        firstFocusable.focus();\n        wrapper.blur();\n      }\n      if (shiftTabAfterFirstFocusable) {\n        event.preventDefault();\n        lastFocusable.focus();\n      }\n    }\n    getFirstAndLastFocusable(parent) {\n      const all = this.getAllFocusableChildren(parent);\n      const firstFocusable = all.length > 0 ? all[0] : parent;\n      const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;\n      return [firstFocusable, lastFocusable];\n    }\n    targetTile(focusedTile, items, offset) {\n      return items.find(item => item.order === focusedTile.order + offset);\n    }\n  }\n  _class76 = TileLayoutKeyboardNavigationService;\n  _defineProperty(TileLayoutKeyboardNavigationService, \"\\u0275fac\", function _class76_Factory(t) {\n    return new (t || _class76)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i1.LocalizationService));\n  });\n  _defineProperty(TileLayoutKeyboardNavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class76,\n    factory: _class76.ɵfac\n  }));\n  return TileLayoutKeyboardNavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Holds the content of the header section of the TileLayoutItem component.\n * This is the area which can be dragged to reorder the items if reordering is enabled for this item.\n */\nlet TileLayoutItemHeaderComponent = /*#__PURE__*/(() => {\n  var _class77;\n  class TileLayoutItemHeaderComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n    }\n  }\n  _class77 = TileLayoutItemHeaderComponent;\n  _defineProperty(TileLayoutItemHeaderComponent, \"\\u0275fac\", function _class77_Factory(t) {\n    return new (t || _class77)();\n  });\n  _defineProperty(TileLayoutItemHeaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class77,\n    selectors: [[\"kendo-tilelayout-item-header\"]],\n    hostVars: 4,\n    hostBindings: function _class77_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-tilelayout-item-header\", ctx.hostClass)(\"k-card-header\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class77_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return TileLayoutItemHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TileLayoutResizeHandleDirective = /*#__PURE__*/(() => {\n  var _class78;\n  class TileLayoutResizeHandleDirective {\n    constructor(el, renderer) {\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"resizeDirection\", void 0);\n      _defineProperty(this, \"rtl\", void 0);\n      this.el = el;\n      this.renderer = renderer;\n    }\n    ngOnInit() {\n      this.sizeHandle();\n    }\n    setHorizontalPosition(element) {\n      this.renderer.setStyle(element, this.rtl ? 'left' : 'right', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + 'px');\n    }\n    setBottom(element) {\n      this.renderer.setStyle(element, 'bottom', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + 'px');\n    }\n    sizeHandle() {\n      const element = this.el.nativeElement;\n      const handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width}px` : '100%';\n      const handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height}px` : '100%';\n      this.renderer.setStyle(element, 'width', handleWidth);\n      this.renderer.setStyle(element, 'height', handleHeight);\n      if (this.resizeDirection === 'ew') {\n        this.setHorizontalPosition(element);\n      } else if (this.resizeDirection === 'ns') {\n        this.setBottom(element);\n      } else {\n        this.setHorizontalPosition(element);\n        this.setBottom(element);\n      }\n    }\n  }\n  _class78 = TileLayoutResizeHandleDirective;\n  _defineProperty(TileLayoutResizeHandleDirective, \"\\u0275fac\", function _class78_Factory(t) {\n    return new (t || _class78)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TileLayoutResizeHandleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class78,\n    selectors: [[\"\", \"kendoTileLayoutResizeHandle\", \"\"]],\n    inputs: {\n      resizeDirection: \"resizeDirection\",\n      rtl: \"rtl\"\n    },\n    standalone: true\n  }));\n  return TileLayoutResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a tile item within the TileLayoutComponent.\n */\nlet TileLayoutItemComponent = /*#__PURE__*/(() => {\n  var _class79;\n  class TileLayoutItemComponent {\n    /**\n     * Determines the order of the tile items within the TileLayout.\n     * If not set, the items will receive increasing sequential order in accordance with\n     * their position in the DOM when initially rendered.\n     */\n    set order(value) {\n      this._order = value;\n      this.renderer.setStyle(this.elem.nativeElement, 'order', `${this._order}`);\n    }\n    get order() {\n      return this._order;\n    }\n    /**\n     * Sets the starting column of the item ([see example](slug:tiles_tilelayout#size-and-position)).\n     */\n\n    get hostDropEffect() {\n      return this.isResizable || this.isReorderable ? 'execute' : undefined;\n    }\n    get hostTabindex() {\n      return this.isNavigable ? '0' : undefined;\n    }\n    get ariaKeyShortcuts() {\n      return this.isNavigable ? 'Enter' : undefined;\n    }\n    get hostGrabbed() {\n      return this.isResizable || this.isReorderable;\n    }\n    get hostLabelledBy() {\n      return this.title ? this.titleId : undefined;\n    }\n    get colEnd() {\n      return `span ${this.colSpan}`;\n    }\n    get rowEnd() {\n      return `span ${this.rowSpan}`;\n    }\n    get colStart() {\n      return isPresent(this.col) ? this.col.toString() : undefined;\n    }\n    get rowStart() {\n      return isPresent(this.row) ? this.row.toString() : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get isReorderable() {\n      return this.reorderable && this.draggingService.reorderable.getValue();\n    }\n    /**\n     * @hidden\n     */\n    get isNavigable() {\n      return this.keyboardNavigationService.navigable.getValue();\n    }\n    /**\n     * @hidden\n     */\n    get isResizable() {\n      return this.resizable && this.draggingService.resizable.getValue();\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(elem, zone, renderer, localization, draggingService, keyboardNavigationService) {\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"draggingService\", void 0);\n      _defineProperty(this, \"keyboardNavigationService\", void 0);\n      /**\n       * The title that will be rendered in the item header ([see example]({% slug tiles_tilelayout %}#toc-tiles-configuration)).\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Determines how many rows will the tile item span ([see example](slug:resizing_tilelayout#programmatic-resizing)).\n       * @default 1\n       */\n      _defineProperty(this, \"rowSpan\", 1);\n      /**\n       * Determines how many columns will the tile item span ([see example](slug:resizing_tilelayout#programmatic-resizing)).\n       * @default 1\n       */\n      _defineProperty(this, \"colSpan\", 1);\n      _defineProperty(this, \"col\", void 0);\n      /**\n       * Sets the starting row of the item ([see example](slug:tiles_tilelayout#size-and-position)).\n       */\n      _defineProperty(this, \"row\", void 0);\n      /**\n       * Determines whether the item can be reordered. By default all items are reorderable when the [reorderable]({% slug api_layout_tilelayoutcomponent %}#toc-reorderable) property of the TileLayoutComponent is set to `true` ([see example]({% slug reordering_tilelayout %}#toc-disabling-reordering)).\n       *\n       * @default true\n       */\n      _defineProperty(this, \"reorderable\", true);\n      /**\n       * Determines whether the item can be resized. By default all items are resizable when the [resizable]({% slug api_layout_tilelayoutcomponent %}#resizable) property of the TileLayoutComponent is set to `true` ([see example](slug:resizing_tilelayout#toc-disabling-resizing)).\n       * @default true\n       */\n      _defineProperty(this, \"resizable\", true);\n      _defineProperty(this, \"itemClass\", true);\n      _defineProperty(this, \"hostRole\", 'listitem');\n      _defineProperty(this, \"resizeDirections\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"rtl\", void 0);\n      _defineProperty(this, \"headers\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"titleId\", '');\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"keyboardNavigationSubs\", void 0);\n      _defineProperty(this, \"focusableItems\", void 0);\n      _defineProperty(this, \"_order\", void 0);\n      this.elem = elem;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.draggingService = draggingService;\n      this.keyboardNavigationService = keyboardNavigationService;\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n      }));\n      this.subs.add(this.draggingService.resizable.subscribe(resizable => {\n        this.resizeDirections = resizable && this.resizable ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;\n      }));\n      this.titleId = getId('k-tilelayout-title');\n    }\n    ngAfterViewInit() {\n      const elem = this.elem.nativeElement;\n      const keyboardNavigation = this.keyboardNavigationService;\n      this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {\n        this.toggleCursorClass(reorderable && this.reorderable);\n      }));\n      this.subs.add(keyboardNavigation.navigable.subscribe(isNavigable => {\n        if (isNavigable) {\n          this.keyboardNavigationSubs = new Subscription();\n          this.focusableItems = keyboardNavigation.getAllFocusableChildren(elem);\n          this.zone.runOutsideAngular(() => {\n            keyboardNavigation.changeTabIndex('-1', elem, this.focusableItems);\n            this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'keydown', event => keyboardNavigation.onKeyDown(event, elem, this.focusableItems, this.draggingService.tileLayoutSettings)));\n            this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'mousedown', event => keyboardNavigation.onMousedown(event, elem, this.focusableItems, this)));\n            this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'focusout', event => keyboardNavigation.onFocusOut(event, elem, this.focusableItems)));\n          });\n        } else if (this.focusableItems) {\n          this.focusableItems.forEach(focusItem => {\n            this.renderer.setAttribute(focusItem, 'tabindex', '0');\n          });\n          this.keyboardNavigationSubs.unsubscribe();\n        }\n      }));\n    }\n    ngOnChanges(changes) {\n      if (changes['reorderable'] && !changes['reorderable'].firstChange) {\n        this.toggleCursorClass(changes['reorderable'].currentValue && this.draggingService.reorderable.getValue());\n      }\n      if (changes['resizable']) {\n        this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n      if (this.keyboardNavigationSubs) {\n        this.keyboardNavigationSubs.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    focus() {\n      this.elem.nativeElement.focus();\n    }\n    toggleCursorClass(isReorderable) {\n      const headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');\n      if (!headerEl) {\n        return;\n      }\n      if (isReorderable) {\n        this.renderer.addClass(headerEl, 'k-cursor-move');\n      } else {\n        this.renderer.removeClass(headerEl, 'k-cursor-move');\n      }\n    }\n  }\n  _class79 = TileLayoutItemComponent;\n  _defineProperty(TileLayoutItemComponent, \"\\u0275fac\", function _class79_Factory(t) {\n    return new (t || _class79)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(TileLayoutDraggingService), i0.ɵɵdirectiveInject(TileLayoutKeyboardNavigationService));\n  });\n  _defineProperty(TileLayoutItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class79,\n    selectors: [[\"kendo-tilelayout-item\"]],\n    contentQueries: function _class79_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TileLayoutItemHeaderComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headers = _t);\n      }\n    },\n    hostVars: 18,\n    hostBindings: function _class79_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole)(\"aria-dropeffect\", ctx.hostDropEffect)(\"tabindex\", ctx.hostTabindex)(\"aria-keyshortcuts\", ctx.ariaKeyShortcuts)(\"aria-grabbed\", ctx.hostGrabbed)(\"aria-labelledby\", ctx.hostLabelledBy);\n        i0.ɵɵstyleProp(\"grid-column-end\", ctx.colEnd)(\"grid-row-end\", ctx.rowEnd)(\"grid-column-start\", ctx.colStart)(\"grid-row-start\", ctx.rowStart);\n        i0.ɵɵclassProp(\"k-tilelayout-item\", ctx.itemClass)(\"k-card\", ctx.itemClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      rowSpan: \"rowSpan\",\n      colSpan: \"colSpan\",\n      order: \"order\",\n      col: \"col\",\n      row: \"row\",\n      reorderable: \"reorderable\",\n      resizable: \"resizable\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [1, \"k-card-title\", 3, \"id\"], [\"kendoTileLayoutResizeHandle\", \"\", 3, \"class\", \"rtl\", \"resizeDirection\", 4, \"ngFor\", \"ngForOf\"], [\"kendoTileLayoutResizeHandle\", \"\", 3, \"rtl\", \"resizeDirection\"]],\n    template: function _class79_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class79_kendo_tilelayout_item_header_0_Template, 3, 2, \"kendo-tilelayout-item-header\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵtemplate(2, _class79_ng_container_2_Template, 2, 1, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.resizable);\n      }\n    },\n    dependencies: [NgIf, TileLayoutItemHeaderComponent, NgFor, TileLayoutResizeHandleDirective],\n    encapsulation: 2\n  }));\n  return TileLayoutItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst autoFlowClasses = {\n  column: 'k-grid-flow-col',\n  row: 'k-grid-flow-row',\n  'column-dense': 'k-grid-flow-col-dense',\n  'row-dense': 'k-grid-flow-row-dense'\n};\n/**\n * Represents the [Kendo UI TileLayout component for Angular]({% slug overview_tilelayout %})\n */\nlet TileLayoutComponent = /*#__PURE__*/(() => {\n  var _class80;\n  class TileLayoutComponent {\n    /**\n     * The numeric values which determine the spacing in pixels between the layout items horizontally and vertically.\n     * Properties:\n     * * rows - the vertical spacing. Numeric values are treated as pixels. Defaults to `16`.\n     * * columns - the horizontal spacing. Numeric values are treated as pixels. Defaults to `16`.\n     *\n     * When bound to a single numeric value, it will be set to both `rows` and `columns` properties.\n     */\n    set gap(value) {\n      this._gap = typeof value === 'number' ? {\n        rows: value,\n        columns: value\n      } : Object.assign(this._gap, value);\n    }\n    get gap() {\n      return this._gap;\n    }\n    /**\n     * Determines whether the reordering functionality will be enabled ([see example]({% slug reordering_tilelayout %})).\n     * @default false\n     */\n\n    get gapStyle() {\n      return `${this.gap.rows}px ${this.gap.columns}px`;\n    }\n    get currentColStart() {\n      return this.draggingService.colStart;\n    }\n    get currentRowStart() {\n      return this.draggingService.rowStart;\n    }\n    get draggedItemWrapper() {\n      return this.draggingService.itemWrapper;\n    }\n    get targetOrder() {\n      return this.draggingService.order;\n    }\n    /**\n     * A query list of all declared [TileLayoutItemComponent]({% slug api_layout_tilelayoutitemcomponent %}) items.\n     */\n\n    constructor(zone, elem, renderer, localization, draggingService, navigationService) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"draggingService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      /**\n       * Defines the number of columns ([see example](slug:tiles_tilelayout#size-and-position)).\n       * @default 1\n       */\n      _defineProperty(this, \"columns\", 1);\n      /**\n       * Determines the width of the columns. Numeric values are treated as pixels ([see example](slug:tiles_tilelayout#size-and-position)).\n       * @default '1fr'\n       */\n      _defineProperty(this, \"columnWidth\", '1fr');\n      _defineProperty(this, \"reorderable\", false);\n      /**\n       * Determines whether the resizing functionality will be enabled ([see example]({% slug resizing_tilelayout %})).\n       * @default false\n       */\n      _defineProperty(this, \"resizable\", false);\n      /**\n       * Determines the height of the rows. Numeric values are treated as pixels ([see example](slug:tiles_tilelayout#size-and-position)).\n       * @default '1fr'\n       */\n      _defineProperty(this, \"rowHeight\", '1fr');\n      /**\n       * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).\n       * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).\n       *\n       * The possible values are:\n       * * (Default) `column`\n       * * `row`\n       * * `row dense`\n       * * `column dense`\n       * * `none`\n       *\n       */\n      _defineProperty(this, \"autoFlow\", 'column');\n      /**\n       * If set to true, the user can use dedicated shortcuts to interact with the TileLayout.\n       * By default, navigation is disabled and focusable TileLayout content is a part of the natural tab sequence of the page.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"navigable\", false);\n      /**\n       * Fires when the user completes the reordering of the item ([see example]({% slug reordering_tilelayout %})).\n       * This event is preventable. If you cancel it, the item will not be reordered.\n       */\n      _defineProperty(this, \"reorder\", new EventEmitter());\n      /**\n       * Fires when the user completes the resizing of the item ([see example]({% slug resizing_tilelayout %})).\n       * This event is preventable. If you cancel it, the item will not be resized.\n       */\n      _defineProperty(this, \"resize\", new EventEmitter());\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"hostRole\", 'list');\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"items\", void 0);\n      _defineProperty(this, \"hint\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"_gap\", {\n        rows: 16,\n        columns: 16\n      });\n      _defineProperty(this, \"onFocusIn\", e => {\n        if (!this.navigable || this.navigationService.mousedown || !e.relatedTarget) {\n          this.navigationService.mousedown = false;\n          return;\n        }\n        if (!(this.elem.nativeElement.compareDocumentPosition(e.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {\n          this.navigationService.returnFocus();\n        }\n      });\n      this.zone = zone;\n      this.elem = elem;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.draggingService = draggingService;\n      this.navigationService = navigationService;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n    }\n    ngOnInit() {\n      this.applyColStyling();\n      this.applyRowStyling();\n      this.draggingService.reorderable.next(this.reorderable);\n      this.draggingService.resizable.next(this.resizable);\n      this.navigationService.owner = this;\n      this.navigationService.navigable.next(this.navigable);\n      if (hasObservers(this.reorder)) {\n        this.subs.add(this.draggingService.reorder.subscribe(e => this.reorder.emit(e)));\n      }\n      if (hasObservers(this.resize)) {\n        this.subs.add(this.draggingService.resize.subscribe(e => this.resize.emit(e)));\n      }\n      this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {\n        if (reorderable && !this.draggable) {\n          this.initializeDraggable();\n        }\n      }));\n      this.subs.add(this.draggingService.resizable.subscribe(resizable => {\n        if (resizable && !this.draggable) {\n          this.initializeDraggable();\n        }\n      }));\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      }));\n    }\n    ngAfterViewInit() {\n      this.draggingService.tileLayoutSettings = this.draggingServiceConfig();\n      this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);\n      this.items.changes.subscribe(() => {\n        this.setItemsOrder();\n        this.draggingService.tileLayoutSettings.items = this.items.toArray();\n      });\n      this.zone.runOutsideAngular(() => {\n        this.elem.nativeElement.addEventListener('focusin', this.onFocusIn);\n      });\n    }\n    ngAfterContentInit() {\n      this.setItemsOrder();\n    }\n    ngOnChanges(changes) {\n      if (changes['columns'] || changes['columnWidth']) {\n        this.applyColStyling();\n      }\n      if (changes['rowHeight']) {\n        this.applyRowStyling();\n      }\n      if (isChanged('reorderable', changes)) {\n        this.draggingService.reorderable.next(changes['reorderable'].currentValue);\n      }\n      if (isChanged('resizable', changes)) {\n        this.draggingService.resizable.next(changes['resizable'].currentValue);\n      }\n      if (changes['gap'] || changes['autoFlow'] || changes['columns']) {\n        this.draggingService.tileLayoutSettings = this.draggingServiceConfig();\n        if (changes['autoFlow']) {\n          this.applyAutoFlow(autoFlowClasses[changes['autoFlow'].previousValue] || '', autoFlowClasses[changes['autoFlow'].currentValue]);\n        }\n      }\n      if (isChanged('navigable', changes)) {\n        this.navigationService.navigable.next(changes['navigable'].currentValue);\n      }\n    }\n    ngOnDestroy() {\n      if (this.draggable) {\n        this.draggable.destroy();\n      }\n      this.subs.unsubscribe();\n      this.elem.nativeElement.removeEventListener('focusin', this.onFocusIn);\n    }\n    handlePress({\n      originalEvent\n    }) {\n      this.draggingService.handlePress(originalEvent);\n    }\n    handleDrag({\n      originalEvent\n    }) {\n      this.draggingService.handleDrag(originalEvent);\n    }\n    handleRelease({\n      originalEvent\n    }) {\n      this.draggingService.handleRelease(originalEvent);\n    }\n    applyColStyling() {\n      const colWidth = typeof this.columnWidth === 'number' ? `${this.columnWidth}px` : this.columnWidth;\n      const gridTemplateColumnsStyle = `repeat(${this.columns}, ${colWidth})`;\n      this.renderer.setStyle(this.elem.nativeElement, 'grid-template-columns', gridTemplateColumnsStyle);\n    }\n    applyRowStyling() {\n      const rowHeight = typeof this.rowHeight === 'number' ? `${this.rowHeight}px` : this.rowHeight;\n      const gridAutoRowsStyle = `${rowHeight}`;\n      this.renderer.setStyle(this.elem.nativeElement, 'grid-auto-rows', gridAutoRowsStyle);\n    }\n    draggingServiceConfig() {\n      return {\n        tileLayoutElement: this.elem ? this.elem.nativeElement : undefined,\n        hintElement: this.hint ? this.hint.nativeElement : undefined,\n        gap: this.gap,\n        columns: this.columns,\n        autoFlow: this.autoFlow,\n        items: this.items ? this.items.toArray() : []\n      };\n    }\n    initializeDraggable() {\n      this.draggable = new Draggable({\n        press: this.handlePress.bind(this),\n        drag: this.handleDrag.bind(this),\n        release: this.handleRelease.bind(this)\n      });\n      this.zone.runOutsideAngular(() => this.draggable.bindTo(this.elem.nativeElement));\n    }\n    applyAutoFlow(classToRemove, classToAdd) {\n      const element = this.elem.nativeElement;\n      if (classToRemove) {\n        this.renderer.removeClass(element, classToRemove);\n      }\n      if (this.autoFlow !== 'none' && isPresent(classToAdd)) {\n        this.renderer.addClass(element, classToAdd);\n      }\n    }\n    setItemsOrder() {\n      this.items.forEach((item, index) => {\n        if (!isPresent(item.order)) {\n          item.order = index;\n        }\n      });\n    }\n  }\n  _class80 = TileLayoutComponent;\n  _defineProperty(TileLayoutComponent, \"\\u0275fac\", function _class80_Factory(t) {\n    return new (t || _class80)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(TileLayoutDraggingService), i0.ɵɵdirectiveInject(TileLayoutKeyboardNavigationService));\n  });\n  _defineProperty(TileLayoutComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class80,\n    selectors: [[\"kendo-tilelayout\"]],\n    contentQueries: function _class80_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TileLayoutItemComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    viewQuery: function _class80_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c39, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hint = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function _class80_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole)(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"gap\", ctx.gapStyle)(\"padding\", ctx.gapStyle);\n        i0.ɵɵclassProp(\"k-tilelayout\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      columnWidth: \"columnWidth\",\n      gap: \"gap\",\n      reorderable: \"reorderable\",\n      resizable: \"resizable\",\n      rowHeight: \"rowHeight\",\n      autoFlow: \"autoFlow\",\n      navigable: \"navigable\"\n    },\n    outputs: {\n      reorder: \"reorder\",\n      resize: \"resize\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, TileLayoutDraggingService, TileLayoutKeyboardNavigationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.tilelayout.component'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 4,\n    vars: 15,\n    consts: [[1, \"k-layout-item-hint\"], [\"hint\", \"\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\"]],\n    template: function _class80_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelement(1, \"div\", 0, 1);\n        i0.ɵɵtemplate(3, _class80_div_3_Template, 1, 0, \"div\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"display\", \"none\")(\"order\", ctx.targetOrder)(\"grid-column-end\", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridColumnEnd)(\"grid-row-end\", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridRowEnd)(\"grid-column-start\", ctx.currentColStart)(\"grid-row-start\", ctx.currentRowStart)(\"z-index\", \"1\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [NgIf, WatermarkOverlayComponent],\n    encapsulation: 2\n  }));\n  return TileLayoutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Holds the main content of the TileLayoutItem component.\n */\nlet TileLayoutItemBodyComponent = /*#__PURE__*/(() => {\n  var _class81;\n  class TileLayoutItemBodyComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"minHeight\", 0);\n    }\n  }\n  _class81 = TileLayoutItemBodyComponent;\n  _defineProperty(TileLayoutItemBodyComponent, \"\\u0275fac\", function _class81_Factory(t) {\n    return new (t || _class81)();\n  });\n  _defineProperty(TileLayoutItemBodyComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class81,\n    selectors: [[\"kendo-tilelayout-item-body\"]],\n    hostVars: 6,\n    hostBindings: function _class81_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"min-height\", ctx.minHeight);\n        i0.ɵɵclassProp(\"k-tilelayout-item-body\", ctx.hostClass)(\"k-card-body\", ctx.hostClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class81_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return TileLayoutItemBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst VERTICAL_SUFFIX = {\n  top: 'start',\n  middle: 'center',\n  bottom: 'end',\n  stretch: 'stretch'\n};\n/**\n * @hidden\n */\nconst JUSTIFY_PREFIX = `k-justify-content`;\n/**\n * @hidden\n */\nconst GRID_JUSTIFY_PREFIX = `k-justify-items`;\n/**\n * @hidden\n */\nconst ALIGN_PREFIX = `k-align-items`;\n/**\n * @hidden\n */\nconst normalizeGap = gap => {\n  if (typeof gap === 'number' || typeof gap === 'string') {\n    return {\n      cols: gap,\n      rows: gap\n    };\n  } else {\n    const parsedGap = {};\n    parsedGap.rows = gap.rows ? gap.rows : 0;\n    parsedGap.cols = gap.cols ? gap.cols : 0;\n    return parsedGap;\n  }\n};\n/**\n * @hidden\n */\nconst generateGapStyle = gap => {\n  if (gap.rows === gap.cols) {\n    return typeof gap.rows === 'number' ? `${gap.rows}px` : gap.rows;\n  } else {\n    const rowStyle = `${typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows}`;\n    const colStyle = `${typeof gap.cols === 'number' ? gap.cols + 'px' : gap.cols}`;\n    return `${rowStyle} ${colStyle}`;\n  }\n};\n/**\n * @hidden\n */\nconst generateGridStyle = (items, itemType) => {\n  const styling = [];\n  items.forEach(item => {\n    if (typeof item === 'number') {\n      styling.push(`${item}px`);\n    } else if (typeof item === 'string') {\n      styling.push(item);\n    } else {\n      if (itemType === 'rows') {\n        const rowHeight = item.height;\n        if (rowHeight) {\n          styling.push(typeof rowHeight === 'number' ? `${rowHeight}px` : rowHeight);\n        } else {\n          styling.push('0px');\n        }\n      } else {\n        const colWidth = item.width;\n        if (colWidth) {\n          styling.push(typeof colWidth === 'number' ? `${colWidth}px` : colWidth);\n        } else {\n          styling.push('0px');\n        }\n      }\n    }\n  });\n  return styling;\n};\n/**\n * @hidden\n */\nconst validateGridLayoutRowsCols = arr => {\n  for (const el of arr) {\n    const isNum = typeof el === 'number';\n    const isStr = typeof el === 'string';\n    const isObject = typeof el === 'object' && el !== null;\n    if (!isNum && !isStr && !isObject) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Represents the [Kendo UI GridLayout component for Angular]({% slug overview_gridlayout %}).\n */\nlet GridLayoutComponent = /*#__PURE__*/(() => {\n  var _class82;\n  class GridLayoutComponent {\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * Specifies the number of rows and their height\n     * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).\n     *\n     * Accepts an array, which serves two purposes:\n     *\n     * The number of elements in the array defines the number of rows.\n     * Each array element defines the size of the corresponding row. The possible array values are:\n     * * `number` - Defines the size in pixels.\n     * * `string` - Enables the usage of arbitrary units e.g. `20%` or `auto`.\n     * * [GridLayoutRowSize]({% slug api_layout_gridlayoutrowsize %}) - Configuration object, which accepts a `height` key.\n     */\n\n    /**\n     * Specifies the horizontal and vertical alignment of the inner GridLayout elements\n     * ([see example]({% slug layout_gridlayout %}#toc-alignment)).\n     */\n    set align(align) {\n      this._align = Object.assign({}, this._align, align);\n      this.handleAlignClasses();\n    }\n    get align() {\n      return this._align;\n    }\n    constructor(renderer, element, localization) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"rows\", void 0);\n      /**\n       * Specifies the number of columns and their widths\n       * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).\n       *\n       * Accepts an array, which serves two purposes:\n       *\n       * The number of elements in the array defines the number of columns.\n       * Each array element defines the size of the corresponding column. The possible array values are:\n       * * `number` - Defines the size in pixels.\n       * * `string` - Enables the usage of arbitrary units e.g. `20%` or `auto`.\n       * * [GridLayoutColSize]({% slug api_layout_gridlayoutcolsize %}) - Configuration object, which accepts a `width` key.\n       */\n      _defineProperty(this, \"cols\", void 0);\n      /**\n       * Specifies the gaps between the elements. The default value is `0`\n       * ([see example](slug:layout_gridlayout#toc-gap)).\n       */\n      _defineProperty(this, \"gap\", 0);\n      _defineProperty(this, \"_align\", {\n        horizontal: 'stretch',\n        vertical: 'stretch'\n      });\n      _defineProperty(this, \"justifyClass\", void 0);\n      _defineProperty(this, \"alignClass\", void 0);\n      this.renderer = renderer;\n      this.element = element;\n      this.localization = localization;\n      validatePackage(packageMetadata);\n    }\n    ngAfterViewInit() {\n      this.handleAlignClasses();\n      this.handleGridTemplateStyling('rows');\n      this.handleGridTemplateStyling('cols');\n      this.setGap();\n    }\n    ngOnChanges(changes) {\n      if (isChanged('gap', changes)) {\n        this.setGap();\n      }\n      if (isChanged('rows', changes)) {\n        this.handleGridTemplateStyling('rows');\n      }\n      if (isChanged('cols', changes)) {\n        this.handleGridTemplateStyling('cols');\n      }\n    }\n    handleAlignClasses() {\n      const elem = this.element.nativeElement;\n      if (isPresent(this.justifyClass)) {\n        this.renderer.removeClass(elem, this.justifyClass);\n      }\n      if (isPresent(this.alignClass)) {\n        this.renderer.removeClass(elem, this.alignClass);\n      }\n      this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;\n      this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n      this.renderer.addClass(elem, this.justifyClass);\n      this.renderer.addClass(elem, this.alignClass);\n    }\n    setGap() {\n      const parsedGap = normalizeGap(this.gap);\n      const gapStyle = generateGapStyle(parsedGap);\n      this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);\n    }\n    handleGridTemplateStyling(type) {\n      if (!isPresent(this[type])) {\n        return;\n      }\n      const isValid = validateGridLayoutRowsCols(this[type]);\n      if (!isValid && isDevMode()) {\n        const valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';\n        throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);\n      }\n      const gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';\n      const gridStyle = generateGridStyle(this[type], type);\n      this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));\n    }\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n  }\n  _class82 = GridLayoutComponent;\n  _defineProperty(GridLayoutComponent, \"\\u0275fac\", function _class82_Factory(t) {\n    return new (t || _class82)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(GridLayoutComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class82,\n    selectors: [[\"kendo-gridlayout\"]],\n    hostVars: 3,\n    hostBindings: function _class82_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-grid-layout\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      rows: \"rows\",\n      cols: \"cols\",\n      gap: \"gap\",\n      align: \"align\"\n    },\n    exportAs: [\"kendoGridLayout\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.gridlayout'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class82_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return GridLayoutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GridLayoutItemComponent = /*#__PURE__*/(() => {\n  var _class83;\n  class GridLayoutItemComponent {\n    constructor(renderer, element) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      /**\n       * Sets the row of the item in the GridLayout\n       * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).\n       */\n      _defineProperty(this, \"row\", void 0);\n      /**\n       * Sets the column of the item in the GridLayout\n       * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).\n       */\n      _defineProperty(this, \"col\", void 0);\n      /**\n       * Determines how many rows will the item span. The default size is one row\n       * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).\n       */\n      _defineProperty(this, \"rowSpan\", void 0);\n      /**\n       * Determines how many columns will the item span. The default size is one column\n       * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).\n       */\n      _defineProperty(this, \"colSpan\", void 0);\n      this.renderer = renderer;\n      this.element = element;\n    }\n    ngOnInit() {\n      this.setItemStyle();\n    }\n    ngOnChanges() {\n      this.setItemStyle();\n    }\n    setItemStyle() {\n      const row = this.row || 'auto';\n      const col = this.col || 'auto';\n      const rowSpan = this.rowSpan ? `span ${this.rowSpan}` : 'auto';\n      const colSpan = this.colSpan ? `span ${this.colSpan}` : 'auto';\n      const gridAreaStyle = `${row} / ${col} / ${rowSpan} / ${colSpan}`;\n      this.renderer.setStyle(this.element.nativeElement, 'grid-area', gridAreaStyle);\n    }\n  }\n  _class83 = GridLayoutItemComponent;\n  _defineProperty(GridLayoutItemComponent, \"\\u0275fac\", function _class83_Factory(t) {\n    return new (t || _class83)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(GridLayoutItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class83,\n    selectors: [[\"kendo-gridlayout-item\"]],\n    inputs: {\n      row: \"row\",\n      col: \"col\",\n      rowSpan: \"rowSpan\",\n      colSpan: \"colSpan\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class83_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return GridLayoutItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI StackLayout component for Angular]({% slug overview_stacklayout %}).\n */\nlet StackLayoutComponent = /*#__PURE__*/(() => {\n  var _class84;\n  class StackLayoutComponent {\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * Specifies the horizontal and vertical alignment of the inner StackLayout elements\n     * ([see example]({% slug layout_stacklayout %}#toc-alignment)).\n     */\n    set align(align) {\n      this._align = Object.assign({}, this._align, align);\n      this.handleAlignClasses();\n    }\n    get align() {\n      return this._align;\n    }\n    /**\n     * Specifies the gap between the inner StackLayout elements. The default value is `0`\n     * ([see example](slug:layout_stacklayout#toc-gap)).\n     */\n\n    constructor(renderer, element, localization) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"gap\", 0);\n      /**\n       * Specifies the orientation of the StackLayout\n       * ([see example]({% slug layout_stacklayout %}#toc-orientation)).\n       *\n       * The possible values are:\n       * (Default) `horizontal`\n       * `vertical`\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"_align\", {\n        horizontal: 'stretch',\n        vertical: 'stretch'\n      });\n      _defineProperty(this, \"justifyClass\", void 0);\n      _defineProperty(this, \"alignClass\", void 0);\n      this.renderer = renderer;\n      this.element = element;\n      this.localization = localization;\n      validatePackage(packageMetadata);\n    }\n    ngAfterViewInit() {\n      this.handleAlignClasses();\n      this.setGap();\n    }\n    ngOnChanges(changes) {\n      if (isChanged('gap', changes)) {\n        this.setGap();\n      }\n      if (isChanged('orientation', changes)) {\n        this.handleAlignClasses();\n      }\n    }\n    handleAlignClasses() {\n      const elem = this.element.nativeElement;\n      if (isPresent(this.justifyClass)) {\n        this.renderer.removeClass(elem, this.justifyClass);\n      }\n      if (isPresent(this.alignClass)) {\n        this.renderer.removeClass(elem, this.alignClass);\n      }\n      if (this.orientation === 'horizontal') {\n        this.justifyClass = `${JUSTIFY_PREFIX}-${this.align.horizontal}`;\n        this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n      } else {\n        this.justifyClass = `${JUSTIFY_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n        this.alignClass = `${ALIGN_PREFIX}-${this.align.horizontal}`;\n      }\n      this.renderer.addClass(elem, this.justifyClass);\n      this.renderer.addClass(elem, this.alignClass);\n    }\n    setGap() {\n      const parsedGap = isNumber(this.gap) ? `${this.gap}px` : this.gap;\n      this.renderer.setStyle(this.element.nativeElement, 'gap', parsedGap);\n    }\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n  }\n  _class84 = StackLayoutComponent;\n  _defineProperty(StackLayoutComponent, \"\\u0275fac\", function _class84_Factory(t) {\n    return new (t || _class84)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(StackLayoutComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class84,\n    selectors: [[\"kendo-stacklayout\"]],\n    hostVars: 7,\n    hostBindings: function _class84_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-stack-layout\", ctx.hostClass)(\"k-hstack\", ctx.horizontalClass)(\"k-vstack\", ctx.verticalClass);\n      }\n    },\n    inputs: {\n      align: \"align\",\n      gap: \"gap\",\n      orientation: \"orientation\"\n    },\n    exportAs: [\"kendoStackLayout\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.stacklayout'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function _class84_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return StackLayoutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TimelineMessages = /*#__PURE__*/(() => {\n  var _class85;\n  class TimelineMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the previous button in horizontal orientation.\n       */\n      _defineProperty(this, \"previous\", void 0);\n      /**\n       * The title of the next button in horizontal orientation.\n       */\n      _defineProperty(this, \"next\", void 0);\n    }\n  }\n  _class85 = TimelineMessages;\n  _defineProperty(TimelineMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class85_BaseFactory;\n    return function _class85_Factory(t) {\n      return (ɵ_class85_BaseFactory || (ɵ_class85_BaseFactory = i0.ɵɵgetInheritedFactory(_class85)))(t || _class85);\n    };\n  }());\n  _defineProperty(TimelineMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class85,\n    selectors: [[\"kendo-timeline-messages-base\"]],\n    inputs: {\n      previous: \"previous\",\n      next: \"next\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return TimelineMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet TimelineCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class86;\n  class TimelineCustomMessagesComponent extends TimelineMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class86 = TimelineCustomMessagesComponent;\n  _defineProperty(TimelineCustomMessagesComponent, \"\\u0275fac\", function _class86_Factory(t) {\n    return new (t || _class86)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TimelineCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class86,\n    selectors: [[\"kendo-timeline-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimelineMessages,\n      useExisting: forwardRef(() => _class86)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class86_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return TimelineCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the actions of each timeline card. To define an actions template, nest an `<ng-template>` tag\n * with the `kendoTimelineCardActionsTemplate` directive inside the `<kendo-timeline>` tag.\n *\n * The following values are available as context variables:\n * - `let-event=\"event\"` (`TimelineEvent`) - The current card's event. Also available as implicit context variable.\n * - `let-index=\"index\"` (`number`) - The current event index.\n */\nlet TimelineCardActionsTemplateDirective = /*#__PURE__*/(() => {\n  var _class87;\n  class TimelineCardActionsTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class87 = TimelineCardActionsTemplateDirective;\n  _defineProperty(TimelineCardActionsTemplateDirective, \"\\u0275fac\", function _class87_Factory(t) {\n    return new (t || _class87)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(TimelineCardActionsTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class87,\n    selectors: [[\"\", \"kendoTimelineCardActionsTemplate\", \"\"]],\n    standalone: true\n  }));\n  return TimelineCardActionsTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the body of each timeline card. To define a body template, nest an `<ng-template>` tag\n * with the `kendoTimelineCardBodyTemplate` directive inside the `<kendo-timeline>` tag.\n *\n * The following values are available as context variables:\n * - `let-event=\"event\"` (`TimelineEvent`) - The current card's event. Also available as implicit context variable.\n * - `let-index=\"index\"` (`number`) - The current event index.\n */\nlet TimelineCardBodyTemplateDirective = /*#__PURE__*/(() => {\n  var _class88;\n  class TimelineCardBodyTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class88 = TimelineCardBodyTemplateDirective;\n  _defineProperty(TimelineCardBodyTemplateDirective, \"\\u0275fac\", function _class88_Factory(t) {\n    return new (t || _class88)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(TimelineCardBodyTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class88,\n    selectors: [[\"\", \"kendoTimelineCardBodyTemplate\", \"\"]],\n    standalone: true\n  }));\n  return TimelineCardBodyTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the header of each timeline card. To define a header template, nest an `<ng-template>` tag\n * with the `kendoTimelineCardHeaderTemplate` directive inside the `<kendo-timeline>` tag.\n *\n * The following values are available as context variables:\n * - `let-event=\"event\"` (`TimelineEvent`) - The current card's event. Also available as implicit context variable.\n * - `let-index=\"index\"` (`number`) - The current event index.\n */\nlet TimelineCardHeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class89;\n  class TimelineCardHeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class89 = TimelineCardHeaderTemplateDirective;\n  _defineProperty(TimelineCardHeaderTemplateDirective, \"\\u0275fac\", function _class89_Factory(t) {\n    return new (t || _class89)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(TimelineCardHeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class89,\n    selectors: [[\"\", \"kendoTimelineCardHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return TimelineCardHeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst defaultModelFields = {\n  title: 'title',\n  subtitle: 'subtitle',\n  description: 'description',\n  date: 'date',\n  expanded: 'expanded',\n  images: 'images',\n  actions: 'actions'\n};\n\n/**\n * @hidden\n */\nconst processItems = (items, fields) => {\n  return items.map(item => parseItem(item, fields));\n};\n/**\n * @hidden\n */\nconst parseItem = (item, fields) => ({\n  title: item[fields.title] || item.title,\n  date: item[fields.date] || item.date,\n  subtitle: item[fields.subtitle] || item.subtitle,\n  description: item[fields.description] || item.description,\n  expanded: item[fields.expanded] || item.expanded,\n  images: item[fields.images] || item.images,\n  actions: item[fields.actions] || item.actions\n});\n/**\n * @hidden\n */\nconst MAX_VISIBLE_EVENTS = 3;\n\n/**\n * @hidden\n */\nlet TimelineService = /*#__PURE__*/(() => {\n  var _class90;\n  class TimelineService {\n    constructor() {\n      _defineProperty(this, \"timeline\", void 0);\n    }\n    onToggle(event) {\n      if (this.timeline) {\n        this.timeline['onToggle']?.emit(event);\n      }\n    }\n    onActionClick(event) {\n      if (this.timeline) {\n        this.timeline['onActionClick']?.emit(event);\n      }\n    }\n    onNavigate(event) {\n      if (this.timeline) {\n        this.timeline['onNavigate']?.emit(event);\n      }\n    }\n  }\n  _class90 = TimelineService;\n  _defineProperty(TimelineService, \"\\u0275fac\", function _class90_Factory(t) {\n    return new (t || _class90)();\n  });\n  _defineProperty(TimelineService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class90,\n    factory: _class90.ɵfac\n  }));\n  return TimelineService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TimelineCardComponent = /*#__PURE__*/(() => {\n  var _class91;\n  class TimelineCardComponent {\n    set calloutStyle(value) {\n      // applies only to horizontal orientation where the callout points upwards\n      if (!this.calloutElementRef || !this.calloutElementRef.nativeElement.classList.contains('k-callout-n')) {\n        return;\n      }\n      this.calloutElementRef.nativeElement.style.left = value?.left;\n    }\n    get collapsedClass() {\n      return !this.expanded && !this.animationInProgress && this.animationState === 'collapsed';\n    }\n    onComponentKeyDown(event) {\n      if (!this.navigable) {\n        return;\n      }\n      if (event.keyCode === Keys.Space || event.keyCode === Keys.Enter) {\n        event.preventDefault();\n        if (this.collapsible && this.orientation === 'vertical') {\n          this.expanded = !this.expanded;\n        }\n      }\n    }\n    get role() {\n      return this.orientation === 'vertical' ? 'button' : 'tabpanel';\n    }\n    get ariaLive() {\n      return this.orientation === 'vertical' ? 'polite' : null;\n    }\n    get ariaExpanded() {\n      return this.orientation === 'vertical' ? this.expanded : null;\n    }\n    constructor(element, timelineService, renderer) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"timelineService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"event\", void 0);\n      _defineProperty(this, \"expanded\", false);\n      _defineProperty(this, \"collapsible\", true);\n      _defineProperty(this, \"reversed\", false);\n      _defineProperty(this, \"orientation\", void 0);\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"tabIndex\", void 0);\n      _defineProperty(this, \"animationDuration\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"eventWidth\", void 0);\n      _defineProperty(this, \"eventHeight\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"bodyTemplate\", void 0);\n      _defineProperty(this, \"actionsTemplate\", void 0);\n      _defineProperty(this, \"calloutElementRef\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"calloutSvgIcon\", chevronRightIcon);\n      _defineProperty(this, \"calloutFontIcon\", 'arrow-chevron-right');\n      _defineProperty(this, \"animationState\", this.expanded ? 'expanded' : 'collapsed');\n      _defineProperty(this, \"animationInProgress\", false);\n      this.element = element;\n      this.timelineService = timelineService;\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      this.makeOverflowVisible();\n    }\n    ngOnChanges(changes) {\n      if (isChanged('collapsible', changes, false)) {\n        if (!this.collapsible) {\n          this.expanded = true;\n        }\n      }\n    }\n    toggle() {\n      if (this.orientation === 'vertical') {\n        this.expanded = this.collapsible ? !this.expanded : true;\n        this.timelineService.onToggle(this.index);\n      }\n    }\n    expand() {\n      if (!this.expanded) {\n        this.expanded = true;\n        this.timelineService.onToggle(this.index);\n      }\n    }\n    collapse() {\n      if (!this.collapsible || !this.expanded) {\n        return;\n      }\n      this.expanded = false;\n      this.timelineService.onToggle(this.index);\n    }\n    onActionClick(event) {\n      event.stopPropagation();\n      this.timelineService.onActionClick(this.index);\n    }\n    animationStart() {\n      this.animationInProgress = true;\n    }\n    animationDone(event) {\n      this.animationInProgress = false;\n      if (event.toState === 'expanded' && event.fromState !== 'expanded') {\n        this.animationState = 'expanded';\n        this.makeOverflowVisible();\n      } else if (event.toState === 'collapsed' && event.fromState !== 'collapsed') {\n        this.animationState = 'collapsed';\n      }\n    }\n    makeOverflowVisible() {\n      if (this.orientation === 'vertical') {\n        return;\n      }\n      const cardBody = this.element?.nativeElement.querySelector('.k-card-body');\n      if (cardBody) {\n        this.renderer.setStyle(cardBody, 'overflow', 'auto');\n      }\n    }\n  }\n  _class91 = TimelineCardComponent;\n  _defineProperty(TimelineCardComponent, \"\\u0275fac\", function _class91_Factory(t) {\n    return new (t || _class91)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TimelineService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TimelineCardComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class91,\n    selectors: [[\"kendo-timeline-card\"]],\n    viewQuery: function _class91_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c40, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calloutElementRef = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class91_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function _class91_keydown_HostBindingHandler($event) {\n          return ctx.onComponentKeyDown($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-timeline-card\", ctx.hostClass)(\"k-collapsed\", ctx.collapsedClass);\n      }\n    },\n    inputs: {\n      event: \"event\",\n      expanded: \"expanded\",\n      collapsible: \"collapsible\",\n      reversed: \"reversed\",\n      orientation: \"orientation\",\n      navigable: \"navigable\",\n      tabIndex: \"tabIndex\",\n      animationDuration: \"animationDuration\",\n      index: \"index\",\n      eventWidth: \"eventWidth\",\n      eventHeight: \"eventHeight\",\n      headerTemplate: \"headerTemplate\",\n      bodyTemplate: \"bodyTemplate\",\n      actionsTemplate: \"actionsTemplate\",\n      calloutStyle: \"calloutStyle\"\n    },\n    exportAs: [\"kendoTimelineCard\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 4,\n    vars: 14,\n    consts: [[1, \"k-card-with-callout\", \"k-card-vertical\", 3, \"ngStyle\", \"width\", \"click\"], [1, \"k-timeline-card-callout\", \"k-card-callout\", 3, \"ngClass\"], [\"callout\", \"\"], [\"class\", \"k-card-inner\", 4, \"ngIf\"], [1, \"k-card-inner\"], [4, \"ngIf\"], [\"kendoCardTitle\", \"\", 4, \"ngIf\"], [\"kendoCardSubtitle\", \"\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"kendoCardTitle\", \"\"], [1, \"k-event-title\"], [\"kendoButton\", \"\", \"class\", \"k-event-collapse\", \"fillMode\", \"flat\", \"tabindex\", \"-1\", \"type\", \"button\", 3, \"icon\", \"svgIcon\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"fillMode\", \"flat\", \"tabindex\", \"-1\", \"type\", \"button\", 1, \"k-event-collapse\", 3, \"icon\", \"svgIcon\"], [\"kendoCardSubtitle\", \"\"], [\"class\", \"k-card-description\", 4, \"ngIf\"], [1, \"k-card-description\"], [4, \"ngFor\", \"ngForOf\"], [\"kendoCardMedia\", \"\", 3, \"src\", \"alt\", 4, \"ngIf\"], [\"kendoCardMedia\", \"\", 3, \"src\", 4, \"ngIf\"], [\"kendoCardMedia\", \"\", 3, \"src\", \"alt\"], [\"kendoCardMedia\", \"\", 3, \"src\"], [\"class\", \"k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary\", \"role\", \"button\", 3, \"href\", \"target\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-primary\", 3, \"href\", \"target\", \"click\"]],\n    template: function _class91_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-card\", 0);\n        i0.ɵɵlistener(\"click\", function _class91_Template_kendo_card_click_0_listener() {\n          return ctx.toggle();\n        });\n        i0.ɵɵelement(1, \"span\", 1, 2);\n        i0.ɵɵtemplate(3, _class91_div_3_Template, 7, 5, \"div\", 3);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(8, _c43, ctx.orientation === \"horizontal\" ? ctx.eventHeight + \"px\" : null))(\"width\", ctx.orientation === \"horizontal\" ? \"auto\" : ctx.eventWidth + \"px\");\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-live\", ctx.ariaLive)(\"aria-expanded\", ctx.ariaExpanded)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction3(10, _c44, ctx.orientation === \"horizontal\", ctx.orientation === \"vertical\" && !ctx.reversed, ctx.orientation === \"vertical\" && ctx.reversed));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.event);\n      }\n    },\n    dependencies: [CardComponent, NgStyle, NgClass, NgIf, CardHeaderComponent, NgTemplateOutlet, CardTitleDirective, ButtonComponent, CardSubtitleDirective, CardBodyComponent, NgFor, CardMediaDirective, CardActionsComponent],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [state('collapsed', style({\n        height: '0',\n        'overflow-y': 'hidden',\n        display: 'none'\n      })), state('expanded', style({\n        height: '*',\n        'overflow-y': 'hidden',\n        display: 'block'\n      })), transition('collapsed <=> expanded', [animate('{{animationDuration}}ms')], {\n        params: {\n          animationDuration: '400'\n        }\n      })])]\n    }\n  }));\n  return TimelineCardComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_TAB_WIDTH = 200;\nconst SPACE_BETWEEN_TABS = 25;\nconst TRANSITION_EVENTS_COUNT = 3;\n/**\n * @hidden\n */\nlet TimelineHorizontalComponent = /*#__PURE__*/(() => {\n  var _class92;\n  class TimelineHorizontalComponent {\n    get selectedEvent() {\n      return this._selectedEvent;\n    }\n    set selectedEvent(value) {\n      if (this._selectedEvent === value) {\n        return;\n      }\n      const newSelectedIndex = this.events.findIndex(event => event === value);\n      if (newSelectedIndex === -1 && value !== null) {\n        return;\n      }\n      this._selectedEvent = value;\n      this.selectedEventIndex = newSelectedIndex;\n      this.calloutStyle = this.calloutOffset;\n    }\n    constructor(cdr, _zone, renderer, timelineService, localization) {\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"timelineService\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"events\", []);\n      _defineProperty(this, \"alterMode\", void 0);\n      _defineProperty(this, \"collapsibleEvents\", void 0);\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"showDateLabels\", void 0);\n      _defineProperty(this, \"animationDuration\", void 0);\n      _defineProperty(this, \"eventHeight\", void 0);\n      _defineProperty(this, \"dateFormat\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"bodyTemplate\", void 0);\n      _defineProperty(this, \"actionsTemplate\", void 0);\n      _defineProperty(this, \"cardElementRefs\", void 0);\n      _defineProperty(this, \"circleElementRefs\", void 0);\n      _defineProperty(this, \"flagElementRefs\", void 0);\n      _defineProperty(this, \"trackElementRef\", void 0);\n      _defineProperty(this, \"scrollableTrackElementRef\", void 0);\n      _defineProperty(this, \"cardComponents\", void 0);\n      _defineProperty(this, \"trackWrapWidth\", void 0);\n      _defineProperty(this, \"scrollableTrackWidth\", void 0);\n      _defineProperty(this, \"cardWidth\", void 0);\n      _defineProperty(this, \"svgLeftIcon\", caretAltLeftIcon);\n      _defineProperty(this, \"svgRightIcon\", caretAltRightIcon);\n      _defineProperty(this, \"calloutStyle\", void 0);\n      _defineProperty(this, \"animationState\", 'center');\n      _defineProperty(this, \"translateValue\", 0);\n      _defineProperty(this, \"eventsInInterval\", [0, 1, 2]);\n      _defineProperty(this, \"selectedCardIndex\", 0);\n      _defineProperty(this, \"selectedEventIndex\", void 0);\n      _defineProperty(this, \"tabFlex\", void 0);\n      _defineProperty(this, \"tabWidth\", DEFAULT_TAB_WIDTH);\n      _defineProperty(this, \"visibleTabsCount\", void 0);\n      _defineProperty(this, \"firstCircleInView\", 0);\n      _defineProperty(this, \"visibleEvents\", []);\n      _defineProperty(this, \"trackItems\", []);\n      _defineProperty(this, \"previousTitle\", 'previous');\n      _defineProperty(this, \"nextTitle\", 'next');\n      _defineProperty(this, \"_selectedEvent\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.cdr = cdr;\n      this._zone = _zone;\n      this.renderer = renderer;\n      this.timelineService = timelineService;\n      this.localization = localization;\n    }\n    ngOnInit() {\n      this.l10nChange();\n      this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));\n      if (this.events.length > 0) {\n        this.selectedEvent = this.events[0];\n      }\n      this.events.forEach(event => {\n        if (event.flag) {\n          this.trackItems.push({\n            isFlag: event.flag\n          });\n        }\n        this.trackItems.push(event);\n      });\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subscriptions.add(this.renderer.listen(this.trackElementRef.nativeElement, 'keydown', this.onKeyDown.bind(this)));\n      this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;\n      this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;\n      this._zone.runOutsideAngular(() => {\n        this.onCirclesChange();\n        this.subscriptions.add(this.circleElementRefs.changes.subscribe(this.onCirclesChange.bind(this)));\n        this.subscriptions.add(this.cardElementRefs.changes.subscribe(this.onCardsChange.bind(this)));\n      });\n      if (this.events.length === 0) {\n        return;\n      }\n      this.onCardsChange();\n      if (this.cardComponents.get(this.selectedCardIndex)) {\n        this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;\n        this.focusTrackItem(0);\n      }\n    }\n    ngOnChanges(changes) {\n      if (isChanged('events', changes)) {\n        if (!this.events || this.events.length === 0) {\n          this.selectedEvent = null;\n          this.trackItems = [];\n          this.visibleEvents = [];\n        } else {\n          this.trackItems = [];\n          this.events.forEach(event => {\n            if (event.flag) {\n              this.trackItems.push({\n                isFlag: event.flag\n              });\n            }\n            this.trackItems.push(event);\n          });\n          this.visibleEvents = this.trackItems.slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount).filter(event => !event.isFlag);\n          this.selectedEvent = this.events[0];\n          this.cdr.detectChanges();\n          this.calloutStyle = this.calloutOffset;\n          this.focusTrackItem(0);\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    onResize() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.trackWrapWidth === this.trackElementRef.nativeElement.getBoundingClientRect().width) {\n        return;\n      }\n      this.cardWidth = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.offsetWidth;\n      this.transformCards();\n      this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;\n      this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;\n      this.changeTabsCount();\n      this._zone.run(() => {\n        this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;\n      });\n    }\n    onTransitionEnd() {\n      this.cardElementRefs?.forEach(card => this.renderer.removeStyle(card.nativeElement, 'transition-duration'));\n      this.cardComponents.get(this.selectedCardIndex).event = this.selectedEvent;\n      this.calloutStyle = this.calloutOffset;\n    }\n    onTrackTransitionEnd() {\n      this.calloutStyle = this.calloutOffset;\n    }\n    onSlideDone() {\n      this.calloutStyle = this.calloutOffset;\n    }\n    previous() {\n      if (this.firstCircleInView === 0) {\n        return;\n      }\n      this.updateInterval(false);\n    }\n    previousClick() {\n      this.previous();\n      this.timelineService.onNavigate('previous');\n    }\n    next() {\n      if (!this.visibleTabsCount || this.firstCircleInView + this.visibleTabsCount > this.trackItems.length) {\n        return;\n      }\n      this.updateInterval(true);\n    }\n    nextClick() {\n      this.next();\n      this.timelineService.onNavigate('next');\n    }\n    open(index) {\n      if (index < 0 || index >= this.events.length) {\n        return;\n      }\n      if (this.visibleEvents.findIndex(event => event === this.events[index]) === -1) {\n        // determine the start and end of the interval that the event belongs to, regardless of its position in the interval\n        const trackItemIndex = this.trackItems.findIndex(event => event === this.events[index]);\n        const start = Math.floor(trackItemIndex / this.visibleTabsCount) * this.visibleTabsCount;\n        this.navigateToInterval(start, index);\n      }\n      this.selectedEvent = this.events[index];\n      this.selectedCardIndex = this.getOtherSelectedCardIndex(index > this.selectedEventIndex);\n      this.calloutStyle = this.calloutOffset;\n      this.focusTrackItem(this.selectedEventIndex);\n      this.animateCards();\n    }\n    navigateToEvent(index) {\n      const eventIndex = this.events.findIndex(event => event === this.trackItems[index]);\n      if (this.selectedEventIndex === eventIndex) {\n        return;\n      }\n      this.selectedEvent = this.events[eventIndex];\n      this.selectedCardIndex = this.getOtherSelectedCardIndex(index > eventIndex);\n      this.calloutStyle = this.calloutOffset;\n      this.animateCards();\n    }\n    getOtherSelectedCardIndex(forward) {\n      // change the selected card which changes all cards' transform styles\n      if (forward) {\n        return this.selectedCardIndex === 0 ? TRANSITION_EVENTS_COUNT - 1 : this.selectedCardIndex - 1;\n      }\n      return this.selectedCardIndex === TRANSITION_EVENTS_COUNT - 1 ? 0 : this.selectedCardIndex + 1;\n    }\n    tabStyle() {\n      if (!this.tabFlex) {\n        return {};\n      }\n      return {\n        'flex': `1 0 ${this.tabFlex}%`\n      };\n    }\n    getTransformation(width, position) {\n      if (position === this.selectedCardIndex - 1 || position === this.selectedCardIndex + 2) {\n        return `translate3d(${-width}px, 0, 0)`;\n      }\n      if (position === this.selectedCardIndex + 1 || position === this.selectedCardIndex - 2) {\n        return `translate3d(${width}px, 0, 0)`;\n      }\n      return `translate3d(0, 0, 0)`;\n    }\n    getState(position) {\n      if (position === this.selectedCardIndex) {\n        return 'center';\n      }\n      if (position === this.selectedCardIndex - 1 || position === this.selectedCardIndex + 2) {\n        return 'left';\n      }\n      return 'right';\n    }\n    get calloutOffset() {\n      if (!isDocumentAvailable() || !this.circleElementRefs?.first || !this.trackElementRef || !isPresent$1(this.selectedEventIndex)) {\n        return {};\n      }\n      const circleCenter = this.circleElementRefs.get(this.selectedEventIndex).nativeElement.getBoundingClientRect().left + this.circleElementRefs.get(this.selectedEventIndex).nativeElement.offsetWidth / 2;\n      const trackOffset = this.trackElementRef.nativeElement.getBoundingClientRect().left;\n      return {\n        left: `${circleCenter - trackOffset}px`\n      };\n    }\n    get isFirstRange() {\n      return this.firstCircleInView === 0;\n    }\n    get isLastRange() {\n      if (!this.circleElementRefs?.first && !this.flagElementRefs?.first) {\n        return false;\n      }\n      return this.trackItems.length === 0 || this.firstCircleInView + this.visibleTabsCount >= this.trackItems.length;\n    }\n    onCardsChange() {\n      if (this.cardElementRefs?.get(this.selectedCardIndex)) {\n        this.cardWidth = this.cardElementRefs.get(this.selectedCardIndex).nativeElement.offsetWidth;\n        this.transformCards();\n      }\n    }\n    onCirclesChange() {\n      if (!this.circleElementRefs?.first) {\n        return;\n      }\n      this.circleElementRefs.map(element => element.nativeElement).forEach((element, index) => {\n        this.subscriptions.add(this.renderer.listen(element, 'click', () => {\n          this.focusTrackItem(index);\n        }));\n      });\n      const width = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width;\n      if (width > DEFAULT_TAB_WIDTH) {\n        this.tabWidth = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width + SPACE_BETWEEN_TABS;\n      }\n      this.changeTabsCount();\n      this.visibleEvents = this.trackItems.slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount).filter(event => !event.isFlag);\n    }\n    onKeyDown(event) {\n      if (!this.navigable) {\n        return;\n      }\n      event.preventDefault();\n      if (event.keyCode === Keys.Home) {\n        this.onHomeKey();\n      } else if (event.keyCode === Keys.End) {\n        this.onEndKey();\n      } else if (event.keyCode === Keys.ArrowRight) {\n        this.onArrowRightKey();\n      } else if (event.keyCode === Keys.ArrowLeft) {\n        this.onArrowLeftKey();\n      }\n    }\n    focusTrackItem(index) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (!this.circleElementRefs || index < 0 || index >= this.circleElementRefs.length) {\n        return;\n      }\n      const selectedTrackItem = this.circleElementRefs.find(element => element.nativeElement.hasAttribute('aria-selected'));\n      if (selectedTrackItem) {\n        this.removeTrackItemAttributes(selectedTrackItem);\n        this.removeCardsAttributes();\n      }\n      const newTrackItem = this.circleElementRefs.get(index).nativeElement;\n      this.setTrackItemAttributes(newTrackItem, index);\n    }\n    setTrackItemAttributes(element, index) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const innerCard = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.querySelector('.k-card');\n      const selectedCircle = this.circleElementRefs.get(index).nativeElement;\n      this.renderer.addClass(element, 'k-focus');\n      this.renderer.setAttribute(element, 'aria-selected', 'true');\n      this.assignAriaLabel(innerCard, selectedCircle);\n      this.assignAriaDescribedBy(innerCard, selectedCircle);\n    }\n    removeTrackItemAttributes(element) {\n      this.renderer.removeClass(element.nativeElement, 'k-focus');\n      this.renderer.removeAttribute(element.nativeElement, 'aria-selected');\n      this.renderer.removeAttribute(element.nativeElement, 'id');\n      this.renderer.removeAttribute(element.nativeElement, 'aria-describedby');\n    }\n    removeCardsAttributes() {\n      this.cardElementRefs.forEach(card => {\n        this.renderer.removeAttribute(card.nativeElement.querySelector('.k-card'), 'id');\n        this.renderer.removeAttribute(card.nativeElement.querySelector('.k-card'), 'aria-label');\n      });\n    }\n    assignAriaLabel(cardElement, dateElement) {\n      const dateLabelId = `k-${guid()}`;\n      this.renderer.setAttribute(dateElement, 'id', dateLabelId);\n      this.renderer.setAttribute(cardElement, 'aria-label', dateLabelId);\n    }\n    assignAriaDescribedBy(cardElement, dateElement) {\n      const cardId = `k-${guid()}`;\n      this.renderer.setAttribute(cardElement, 'id', cardId);\n      this.renderer.setAttribute(dateElement, 'aria-describedby', cardId);\n    }\n    updateInterval(forward) {\n      let start = forward ? this.firstCircleInView + this.visibleTabsCount : this.firstCircleInView - this.visibleTabsCount;\n      if (start < 0 || start >= this.trackItems.length) {\n        start = 0;\n      }\n      this.navigateToInterval(start, 0, forward, !forward);\n    }\n    onHomeKey() {\n      if (this.selectedEvent === this.events[0]) {\n        return;\n      }\n      this.navigateToFirstInterval();\n    }\n    onEndKey() {\n      if (this.selectedEvent === this.events[this.events.length - 1]) {\n        return;\n      }\n      this.navigateToLastInterval();\n    }\n    onArrowRightKey() {\n      this.navigateToOtherEvent(true);\n    }\n    onArrowLeftKey() {\n      this.navigateToOtherEvent(false);\n    }\n    navigateToFirstInterval() {\n      this.navigateToInterval(0);\n    }\n    navigateToLastInterval() {\n      const start = Math.floor((this.trackItems.length - 1) / this.visibleTabsCount) * this.visibleTabsCount;\n      this.navigateToInterval(start, this.events.length - 1);\n    }\n    navigateToOtherEvent(direction) {\n      const offset = direction ? 1 : -1;\n      const newIndex = this.selectedEventIndex + offset;\n      if (newIndex < 0 || newIndex >= this.events.length) {\n        return;\n      }\n      if (this.visibleEvents.findIndex(event => event === this.events[newIndex]) === -1) {\n        this.updateInterval(direction);\n      } else {\n        this.selectedEvent = this.events[newIndex];\n        this.selectedCardIndex = this.getOtherSelectedCardIndex(direction);\n        this.focusTrackItem(this.selectedEventIndex);\n        this.animateCards();\n        this.cdr.markForCheck();\n      }\n    }\n    navigateToInterval(start, selectedIndex = 0, selectFirst = false, selectLast = false) {\n      const end = start + this.visibleTabsCount < this.trackItems.length ? start + this.visibleTabsCount : undefined;\n      const forward = this.firstCircleInView < start;\n      this.firstCircleInView = start;\n      const interval = Math.floor(start / this.visibleTabsCount);\n      this.translateValue = interval * -100;\n      this.animationState = forward ? 'right' : 'left';\n      this.visibleEvents = this.trackItems.slice(this.firstCircleInView, end).filter(event => !event.isFlag);\n      if (selectFirst) {\n        this.selectedEvent = this.visibleEvents[0];\n      } else if (selectLast) {\n        this.selectedEvent = this.visibleEvents[this.visibleEvents.length - 1];\n      } else {\n        this.selectedEvent = this.events[selectedIndex];\n      }\n      this.selectedCardIndex = this.getOtherSelectedCardIndex(forward);\n      this.cdr.detectChanges();\n      this.focusTrackItem(this.selectedEventIndex);\n      this.animateCards();\n      this.calloutStyle = this.calloutOffset;\n      this.cdr.markForCheck();\n    }\n    animateCards() {\n      if (this.animationDuration) {\n        this.cardComponents.get(this.selectedCardIndex).event = null;\n      }\n      this.cardElementRefs.forEach((card, index) => {\n        this.renderer.setStyle(card.nativeElement, 'transform', this.getTransformation(this.cardWidth, index));\n        this.renderer.setStyle(card.nativeElement, 'transition-duration', `${this.animationDuration || 0}ms`);\n      });\n    }\n    transformCards() {\n      this.cardElementRefs.forEach((card, index) => this.renderer.setStyle(card.nativeElement, 'transform', this.getTransformation(this.cardWidth, index)));\n    }\n    changeTabsCount() {\n      this.visibleTabsCount = Math.round(this.scrollableTrackWidth / this.tabWidth);\n      if (this.tabFlex !== 100 / this.visibleTabsCount) {\n        this.tabFlex = 100 / this.visibleTabsCount;\n        this.circleElementRefs.forEach(item => this.renderer.setStyle(item.nativeElement, 'flex', `1 0 ${this.tabFlex}%`));\n        this.flagElementRefs.forEach(item => this.renderer.setStyle(item.nativeElement, 'flex', `1 0 ${this.tabFlex}%`));\n        this.cdr.detectChanges();\n        this.visibleEvents = this.trackItems.slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount).filter(event => !event.isFlag);\n        if (!this.visibleEvents.find(event => event === this.selectedEvent)) {\n          const trackItemIndex = this.trackItems.findIndex(event => event === this.selectedEvent);\n          this.navigateToInterval(trackItemIndex, this.selectedEventIndex);\n        }\n      }\n    }\n    l10nChange() {\n      if (this.localization.get('previous')) {\n        this.previousTitle = this.localization.get('previous');\n      }\n      if (this.localization.get('next')) {\n        this.nextTitle = this.localization.get('next');\n      }\n      this.cdr.markForCheck();\n    }\n  }\n  _class92 = TimelineHorizontalComponent;\n  _defineProperty(TimelineHorizontalComponent, \"\\u0275fac\", function _class92_Factory(t) {\n    return new (t || _class92)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TimelineService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TimelineHorizontalComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class92,\n    selectors: [[\"kendo-timeline-horizontal\"]],\n    viewQuery: function _class92_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c45, 5);\n        i0.ɵɵviewQuery(_c46, 5);\n        i0.ɵɵviewQuery(_c47, 5, ElementRef);\n        i0.ɵɵviewQuery(_c48, 5);\n        i0.ɵɵviewQuery(_c49, 5);\n        i0.ɵɵviewQuery(TimelineCardComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.trackElementRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollableTrackElementRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cardElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.circleElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.flagElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cardComponents = _t);\n      }\n    },\n    inputs: {\n      events: \"events\",\n      alterMode: \"alterMode\",\n      collapsibleEvents: \"collapsibleEvents\",\n      navigable: \"navigable\",\n      showDateLabels: \"showDateLabels\",\n      animationDuration: \"animationDuration\",\n      eventHeight: \"eventHeight\",\n      dateFormat: \"dateFormat\",\n      headerTemplate: \"headerTemplate\",\n      bodyTemplate: \"bodyTemplate\",\n      actionsTemplate: \"actionsTemplate\"\n    },\n    exportAs: [\"kendoTimelineHorizontal\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 11,\n    vars: 17,\n    consts: [[1, \"k-timeline-track-wrap\"], [\"track\", \"\"], [\"kendoButton\", \"\", \"icon\", \"caret-alt-left\", \"rounded\", \"full\", \"tabindex\", \"-1\", \"type\", \"button\", 1, \"k-timeline-arrow\", \"k-timeline-arrow-left\", 3, \"svgIcon\", \"title\", \"disabled\", \"click\"], [\"kendoButton\", \"\", \"icon\", \"caret-alt-right\", \"rounded\", \"full\", \"tabindex\", \"-1\", \"type\", \"button\", 1, \"k-timeline-arrow\", \"k-timeline-arrow-right\", 3, \"svgIcon\", \"title\", \"disabled\", \"click\"], [1, \"k-timeline-track\"], [1, \"k-timeline-scrollable-wrap\", 3, \"transitionend\"], [\"scrollableTrack\", \"\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-timeline-events-list\"], [\"class\", \"k-timeline-scrollable-wrap\", 3, \"ngStyle\", 4, \"ngIf\"], [3, \"rateLimit\", \"resize\"], [\"class\", \"k-timeline-flag-wrap k-timeline-track-item\", 3, \"ngStyle\", 4, \"ngIf\"], [\"class\", \"k-timeline-track-item\", 3, \"ngStyle\", \"click\", 4, \"ngIf\"], [1, \"k-timeline-flag-wrap\", \"k-timeline-track-item\", 3, \"ngStyle\"], [\"trackFlag\", \"\"], [1, \"k-timeline-flag\"], [1, \"k-timeline-track-item\", 3, \"ngStyle\", \"click\"], [\"trackCircle\", \"\"], [1, \"k-timeline-date-wrap\"], [\"class\", \"k-timeline-date\", 4, \"ngIf\"], [1, \"k-timeline-circle\"], [1, \"k-timeline-date\"], [1, \"k-timeline-scrollable-wrap\", 3, \"ngStyle\"], [\"class\", \"k-timeline-event\", 3, \"transitionend\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-timeline-event\", 3, \"transitionend\"], [\"card\", \"\"], [\"orientation\", \"horizontal\", 3, \"event\", \"expanded\", \"collapsible\", \"calloutStyle\", \"ngStyle\", \"tabIndex\", \"navigable\", \"index\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\", \"eventHeight\"]],\n    template: function _class92_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"button\", 2);\n        i0.ɵɵlistener(\"click\", function _class92_Template_button_click_2_listener() {\n          return ctx.previousClick();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"button\", 3);\n        i0.ɵɵlistener(\"click\", function _class92_Template_button_click_3_listener() {\n          return ctx.nextClick();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\", 4)(5, \"ul\", 5, 6);\n        i0.ɵɵlistener(\"@trackSlide.done\", function _class92_Template_ul_animation_trackSlide_done_5_listener() {\n          return ctx.onSlideDone();\n        })(\"transitionend\", function _class92_Template_ul_transitionend_5_listener() {\n          return ctx.onTrackTransitionEnd();\n        });\n        i0.ɵɵtemplate(7, _class92_ng_container_7_Template, 3, 2, \"ng-container\", 7);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(8, \"div\", 8);\n        i0.ɵɵtemplate(9, _class92_ul_9_Template, 2, 9, \"ul\", 9);\n        i0.ɵɵelementStart(10, \"kendo-resize-sensor\", 10);\n        i0.ɵɵlistener(\"resize\", function _class92_Template_kendo_resize_sensor_resize_10_listener() {\n          return ctx.onResize();\n        });\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"svgIcon\", ctx.svgLeftIcon)(\"title\", ctx.previousTitle)(\"disabled\", ctx.isFirstRange);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"svgIcon\", ctx.svgRightIcon)(\"title\", ctx.nextTitle)(\"disabled\", ctx.isLastRange);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"@trackSlide\", i0.ɵɵpureFunction2(14, _c42, ctx.animationState, i0.ɵɵpureFunction1(12, _c53, ctx.translateValue)));\n        i0.ɵɵattribute(\"role\", \"tablist\")(\"tabindex\", \"0\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.trackItems);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.selectedEvent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"rateLimit\", 10);\n      }\n    },\n    dependencies: [ButtonComponent, NgFor, NgIf, NgStyle, TimelineCardComponent, DatePipe, ResizeSensorComponent],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('trackSlide', [state('left', style({\n        transform: `translateX({{transformValue}}%)`\n      }), {\n        params: {\n          transformValue: '0'\n        }\n      }), state('right', style({\n        transform: `translateX({{transformValue}}%)`\n      }), {\n        params: {\n          transformValue: '0'\n        }\n      }), state('center', style({\n        transform: `translateX(0)`\n      }))]), trigger('eventsSlide', [transition('* => right', [animate('{{animationDuration}}ms', style({\n        transform: `translateX(-100%)`\n      }))], {\n        params: {\n          animationDuration: '400'\n        }\n      }), transition('* => left', [animate('{{animationDuration}}ms', style({\n        transform: `translateX(100%)`\n      }))], {\n        params: {\n          animationDuration: '400'\n        }\n      })])]\n    }\n  }));\n  return TimelineHorizontalComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TimelineVerticalComponent = /*#__PURE__*/(() => {\n  var _class93;\n  class TimelineVerticalComponent {\n    constructor(renderer) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"events\", []);\n      _defineProperty(this, \"alterMode\", void 0);\n      _defineProperty(this, \"collapsibleEvents\", void 0);\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"showDateLabels\", void 0);\n      _defineProperty(this, \"animationDuration\", void 0);\n      _defineProperty(this, \"eventWidth\", void 0);\n      _defineProperty(this, \"dateFormat\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"bodyTemplate\", void 0);\n      _defineProperty(this, \"actionsTemplate\", void 0);\n      _defineProperty(this, \"cards\", void 0);\n      _defineProperty(this, \"dateElementRefs\", void 0);\n      _defineProperty(this, \"innerDateElementRefs\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      this.ariaDescribedByAllEvents();\n      this.subscriptions.add(this.innerDateElementRefs.changes.subscribe(() => {\n        if (this.innerDateElementRefs?.length > 0) {\n          this.ariaDescribedByAllEvents();\n        } else {\n          this.removeAriaDescribedBy();\n        }\n      }));\n    }\n    expand(index) {\n      if (index < 0 || index >= this.cards.length) {\n        return;\n      }\n      this.cards.get(index).expand();\n    }\n    collapse(index) {\n      if (index < 0 || index >= this.cards.length) {\n        return;\n      }\n      this.cards.get(index).collapse();\n    }\n    ariaDescribedByAllEvents() {\n      this.cards?.forEach((card, index) => {\n        const innerCard = card.element.nativeElement.querySelector('.k-card');\n        const innerDate = this.dateElementRefs.get(index).nativeElement.querySelector('.k-timeline-date');\n        if (innerDate) {\n          this.assignAriaDescribedBy(innerCard, innerDate);\n        }\n      });\n    }\n    removeAriaDescribedBy() {\n      this.cards?.forEach(card => {\n        const innerCard = card.element.nativeElement.querySelector('.k-card');\n        this.renderer.removeAttribute(innerCard, 'aria-describedby');\n      });\n    }\n    assignAriaDescribedBy(cardElement, dateElement) {\n      const dateLabelId = `k-${guid()}`;\n      this.renderer.setAttribute(dateElement, 'id', dateLabelId);\n      this.renderer.setAttribute(cardElement, 'aria-describedby', dateLabelId);\n    }\n  }\n  _class93 = TimelineVerticalComponent;\n  _defineProperty(TimelineVerticalComponent, \"\\u0275fac\", function _class93_Factory(t) {\n    return new (t || _class93)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TimelineVerticalComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class93,\n    selectors: [[\"kendo-timeline-vertical\"]],\n    viewQuery: function _class93_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c47, 5);\n        i0.ɵɵviewQuery(_c54, 5);\n        i0.ɵɵviewQuery(_c55, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cards = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.innerDateElementRefs = _t);\n      }\n    },\n    inputs: {\n      events: \"events\",\n      alterMode: \"alterMode\",\n      collapsibleEvents: \"collapsibleEvents\",\n      navigable: \"navigable\",\n      showDateLabels: \"showDateLabels\",\n      animationDuration: \"animationDuration\",\n      eventWidth: \"eventWidth\",\n      dateFormat: \"dateFormat\",\n      headerTemplate: \"headerTemplate\",\n      bodyTemplate: \"bodyTemplate\",\n      actionsTemplate: \"actionsTemplate\"\n    },\n    exportAs: [\"kendoTimelineVertical\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([]), i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-timeline-flag-wrap\", 4, \"ngIf\"], [1, \"k-timeline-event\", 3, \"ngClass\"], [1, \"k-timeline-date-wrap\"], [\"dateWrap\", \"\"], [\"class\", \"k-timeline-date\", 4, \"ngIf\"], [1, \"k-timeline-circle\"], [\"orientation\", \"vertical\", 3, \"event\", \"expanded\", \"collapsible\", \"reversed\", \"tabIndex\", \"navigable\", \"animationDuration\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\", \"index\", \"eventWidth\"], [\"card\", \"\"], [1, \"k-timeline-flag-wrap\"], [1, \"k-timeline-flag\"], [1, \"k-timeline-date\"], [\"innerDate\", \"\"]],\n    template: function _class93_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class93_ul_0_Template, 2, 1, \"ul\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.events && ctx.events.length > 0);\n      }\n    },\n    dependencies: [NgIf, NgFor, NgClass, TimelineCardComponent, DatePipe],\n    encapsulation: 2\n  }));\n  return TimelineVerticalComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedTimelineMessagesDirective = /*#__PURE__*/(() => {\n  var _class94;\n  class LocalizedTimelineMessagesDirective extends TimelineMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class94 = LocalizedTimelineMessagesDirective;\n  _defineProperty(LocalizedTimelineMessagesDirective, \"\\u0275fac\", function _class94_Factory(t) {\n    return new (t || _class94)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedTimelineMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class94,\n    selectors: [[\"\", \"kendoTimelineLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimelineMessages,\n      useExisting: forwardRef(() => _class94)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedTimelineMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_HORIZONTAL_ANIMATION_DURATION = 400;\nconst DEFAULT_VERTICAL_ANIMATION_DURATION = 300;\nconst DEFAULT_EVENT_WIDTH = 400;\nconst DEFAULT_EVENT_HEIGHT = 600;\nconst DEFAULT_DATE_FORMAT = 'MMMM dd, yyyy';\n/**\n * Represents the [Kendo UI Timeline component for Angular]({% slug overview_timeline %}).\n */\nlet TimelineComponent = /*#__PURE__*/(() => {\n  var _class95;\n  class TimelineComponent {\n    /**\n     * An array of event instances which will be shown by the Timeline.\n     */\n    set events(events) {\n      if (!isPresent$1(events)) {\n        return;\n      }\n      this.originalData = events;\n      this._events = processItems(this.originalData, this.modelFields);\n      this._events.sort((a, b) => {\n        return a.date.getTime() - b.date.getTime();\n      });\n      if (this._events.length > 0) {\n        let flag = this._events[0].date.getFullYear() - 1;\n        this._events.forEach(event => {\n          if (event.date.getFullYear() !== flag) {\n            flag = event.date.getFullYear();\n            event.flag = flag;\n          }\n        });\n      }\n    }\n    get events() {\n      return this._events;\n    }\n    /**\n     * The names of the model fields from which the Timeline will read its data.\n     */\n    set modelFields(value) {\n      this._modelFields = {\n        ...defaultModelFields,\n        ...value\n      };\n      if (this.originalData) {\n        this.events = this.originalData;\n      }\n    }\n    get modelFields() {\n      return this._modelFields;\n    }\n    /**\n     * Specifies the orientation of the axis.\n     *\n     * @default 'vertical'\n     */\n\n    /**\n     * Sets a specific width for the event.\n     * This setting is supported only in `vertical` mode.\n     *\n     * @default 400\n     */\n    get eventWidth() {\n      return this._eventWidth;\n    }\n    set eventWidth(value) {\n      if (value) {\n        this._eventWidth = value;\n      } else {\n        this._eventWidth = DEFAULT_EVENT_WIDTH;\n      }\n    }\n    /**\n     * Sets a specific height for the event.\n     * This setting is supported only in `horizontal` mode.\n     *\n     * @default 600\n     */\n    get eventHeight() {\n      return this._eventHeight;\n    }\n    set eventHeight(value) {\n      if (value) {\n        this._eventHeight = value;\n      } else {\n        this._eventHeight = DEFAULT_EVENT_HEIGHT;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get animationDuration() {\n      if (typeof this.animation === 'number') {\n        return this.animation;\n      }\n      if (typeof this.animation === 'boolean' && this.animation || !isPresent$1(this.animation)) {\n        return this.orientation === 'horizontal' ? DEFAULT_HORIZONTAL_ANIMATION_DURATION : DEFAULT_VERTICAL_ANIMATION_DURATION;\n      }\n      return 0;\n    }\n    /**\n     * Specifies the date format for displaying the event date.\n     *\n     * @default 'MMMM dd, yyyy'\n     */\n    set dateFormat(value) {\n      if (isPresent$1(value) && value !== '') {\n        this._dateFormat = value;\n      } else {\n        this._dateFormat = DEFAULT_DATE_FORMAT;\n      }\n    }\n    get dateFormat() {\n      return this._dateFormat;\n    }\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n    get alternatingClass() {\n      return this.alterMode === true && this.orientation === 'vertical';\n    }\n    get collapsibleClass() {\n      return this.collapsibleEvents === true && this.orientation === 'vertical';\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(timelineService) {\n      _defineProperty(this, \"timelineService\", void 0);\n      _defineProperty(this, \"orientation\", 'vertical');\n      /**\n       * Specifies whether to render events alternatingly on both sides of the axis.\n       * Applicable when `orientation` is set to `vertical`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"alterMode\", false);\n      /**\n       * Specifies whether the event cards can be collapsed.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"collapsibleEvents\", true);\n      /**\n       * Specifies whether the user can use dedicated shortcuts to interact with the Timeline.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"navigable\", true);\n      /**\n       * Specifies whether an event's date label will be visible.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"showDateLabels\", true);\n      /**\n       * Specifies the time for sliding to the next event in `horizontal` mode and the time for collapsing the event in `vertical` mode.\n       * The default animation duration values are `300ms` for `horizontal` mode and `400ms` for `vertical` mode.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"animation\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"timelineHorizontal\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"timelineVertical\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"cardHeaderTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"cardBodyTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"cardActionsTemplate\", void 0);\n      /**\n       * Fires when a card is toggled.\n       * This event is supported only in `vertical` mode.\n       */\n      _defineProperty(this, \"onToggle\", new EventEmitter());\n      /**\n       * Fires when a card's action is clicked.\n       */\n      _defineProperty(this, \"onActionClick\", new EventEmitter());\n      /**\n       * Fires when the left or right arrow is clicked.\n       * This event is supported only in `horizontal` mode.\n       */\n      _defineProperty(this, \"onNavigate\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"bodyTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsTemplate\", void 0);\n      _defineProperty(this, \"_events\", []);\n      _defineProperty(this, \"_modelFields\", defaultModelFields);\n      _defineProperty(this, \"_eventWidth\", DEFAULT_EVENT_WIDTH);\n      _defineProperty(this, \"_eventHeight\", DEFAULT_EVENT_HEIGHT);\n      _defineProperty(this, \"_dateFormat\", DEFAULT_DATE_FORMAT);\n      _defineProperty(this, \"originalData\", []);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.timelineService = timelineService;\n      this.timelineService.timeline = this;\n    }\n    ngAfterContentInit() {\n      this.initTemplates();\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * Switches to the previous portion of events.\n     * This method is supported only in `horizontal` mode.\n     */\n    previous() {\n      this.timelineHorizontal?.previous();\n    }\n    /**\n     * Switches to the next portion of events.\n     * This method is supported only in `horizontal` mode.\n     */\n    next() {\n      this.timelineHorizontal?.next();\n    }\n    /**\n     * Open event details.\n     * This method is supported only in `horizontal` mode.\n     */\n    open(index) {\n      this.timelineHorizontal?.open(index);\n    }\n    /**\n     * Expands an event.\n     * This method is supported only in `vertical` mode.\n     */\n    expand(index) {\n      this.timelineVertical?.expand(index);\n    }\n    /**\n     * Collapses an event.\n     * This method is supported only in `vertical` mode.\n     */\n    collapse(index) {\n      this.timelineVertical?.collapse(index);\n    }\n    initTemplates() {\n      this.headerTemplate = this.cardHeaderTemplate?.first;\n      this.bodyTemplate = this.cardBodyTemplate?.first;\n      this.actionsTemplate = this.cardActionsTemplate?.first;\n      this.subscriptions.add(this.cardHeaderTemplate?.changes.subscribe(() => {\n        this.headerTemplate = this.cardHeaderTemplate?.first || null;\n      }));\n      this.subscriptions.add(this.cardBodyTemplate?.changes.subscribe(() => {\n        this.bodyTemplate = this.cardBodyTemplate?.first || null;\n      }));\n      this.subscriptions.add(this.cardActionsTemplate?.changes.subscribe(() => {\n        this.actionsTemplate = this.cardActionsTemplate?.first || null;\n      }));\n    }\n  }\n  _class95 = TimelineComponent;\n  _defineProperty(TimelineComponent, \"\\u0275fac\", function _class95_Factory(t) {\n    return new (t || _class95)(i0.ɵɵdirectiveInject(TimelineService));\n  });\n  _defineProperty(TimelineComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class95,\n    selectors: [[\"kendo-timeline\"]],\n    contentQueries: function _class95_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TimelineCardHeaderTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TimelineCardBodyTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TimelineCardActionsTemplateDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cardHeaderTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cardBodyTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cardActionsTemplate = _t);\n      }\n    },\n    viewQuery: function _class95_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TimelineHorizontalComponent, 5);\n        i0.ɵɵviewQuery(TimelineVerticalComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timelineHorizontal = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timelineVertical = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function _class95_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-timeline\", ctx.hostClass)(\"k-timeline-vertical\", ctx.verticalClass)(\"k-timeline-horizontal\", ctx.horizontalClass)(\"k-timeline-alternating\", ctx.alternatingClass)(\"k-timeline-collapsible\", ctx.collapsibleClass);\n      }\n    },\n    inputs: {\n      events: \"events\",\n      modelFields: \"modelFields\",\n      orientation: \"orientation\",\n      alterMode: \"alterMode\",\n      collapsibleEvents: \"collapsibleEvents\",\n      navigable: \"navigable\",\n      showDateLabels: \"showDateLabels\",\n      animation: \"animation\",\n      eventWidth: \"eventWidth\",\n      eventHeight: \"eventHeight\",\n      dateFormat: \"dateFormat\"\n    },\n    outputs: {\n      onToggle: \"onToggle\",\n      onActionClick: \"onActionClick\",\n      onNavigate: \"onNavigate\"\n    },\n    exportAs: [\"kendoTimeline\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([TimelineService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.timeline'\n    }]), i0.ɵɵStandaloneFeature],\n    decls: 4,\n    vars: 2,\n    consts: function () {\n      let i18n_57;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the previous button in horizontal orientation.\n         * @meaning kendo.timeline.previous\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_58 = goog.getMsg(\"previous\");\n        i18n_57 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_58;\n      } else {\n        i18n_57 = $localize`:kendo.timeline.previous|The title of the previous button in horizontal orientation.:previous`;\n      }\n      let i18n_59;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the next button in horizontal orientation.\n         * @meaning kendo.timeline.next\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_60 = goog.getMsg(\"next\");\n        i18n_59 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_60;\n      } else {\n        i18n_59 = $localize`:kendo.timeline.next|The title of the next button in horizontal orientation.:next`;\n      }\n      return [[\"kendoTimelineLocalizedMessages\", \"\", \"previous\", i18n_57], [\"kendoTimelineLocalizedMessages\", \"\", \"next\", i18n_59], [3, \"events\", \"alterMode\", \"collapsibleEvents\", \"navigable\", \"showDateLabels\", \"animationDuration\", \"eventWidth\", \"dateFormat\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\", 4, \"ngIf\"], [3, \"events\", \"collapsibleEvents\", \"navigable\", \"showDateLabels\", \"animationDuration\", \"eventHeight\", \"dateFormat\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\", 4, \"ngIf\"], [3, \"events\", \"alterMode\", \"collapsibleEvents\", \"navigable\", \"showDateLabels\", \"animationDuration\", \"eventWidth\", \"dateFormat\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\"], [3, \"events\", \"collapsibleEvents\", \"navigable\", \"showDateLabels\", \"animationDuration\", \"eventHeight\", \"dateFormat\", \"headerTemplate\", \"bodyTemplate\", \"actionsTemplate\"]];\n    },\n    template: function _class95_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0)(1, 1);\n        i0.ɵɵtemplate(2, _class95_kendo_timeline_vertical_2_Template, 1, 11, \"kendo-timeline-vertical\", 2);\n        i0.ɵɵtemplate(3, _class95_kendo_timeline_horizontal_3_Template, 1, 10, \"kendo-timeline-horizontal\", 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.orientation === \"vertical\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.orientation === \"horizontal\");\n      }\n    },\n    dependencies: [LocalizedTimelineMessagesDirective, NgIf, TimelineVerticalComponent, TimelineHorizontalComponent],\n    encapsulation: 2\n  }));\n  return TimelineComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `Avatar` related components and directives.\n */\nconst KENDO_AVATAR = [AvatarComponent, AvatarCustomMessagesComponent];\n/**\n * Utility array that contains all `Card` related components and directives.\n */\nconst KENDO_CARD = [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective];\n/**\n * Utility array that contains all `Drawer` related components and directives.\n */\nconst KENDO_DRAWER = [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective];\n/**\n * Utility array that contains all `ExpansionPanel` related components and directives.\n */\nconst KENDO_EXPANSIONPANEL = [ExpansionPanelComponent, ExpansionPanelTitleDirective];\n/**\n * Utility array that contains all `GridLayout` related components and directives.\n */\nconst KENDO_GRIDLAYOUT = [GridLayoutComponent, GridLayoutItemComponent];\n/**\n * Utility array that contains all `PanelBar` related components and directives.\n */\nconst KENDO_PANELBAR = [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective];\n/**\n * Utility array that contains all `Splitter` related components and directives.\n */\nconst KENDO_SPLITTER = [SplitterComponent, SplitterPaneComponent];\n/**\n * Utility array that contains all `StackLayout` related components and directives.\n */\nconst KENDO_STACKLAYOUT = [StackLayoutComponent];\n/**\n * Utility array that contains all `Stepper` related components and directives.\n */\nconst KENDO_STEPPER = [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective];\n/**\n * Utility array that contains all `TabStrip` related components and directives.\n */\nconst KENDO_TABSTRIP = [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent];\n/**\n * Utility array that contains all `TileLayout` related components and directives.\n */\nconst KENDO_TILELAYOUT = [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent];\n/**\n * Utility array that contains all `Timeline` related components and directives\n */\nconst KENDO_TIMELINE = [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective];\n/**\n * Utility array that contains all `@progress/kendo-angular-layout` related components and directives.\n */\nconst KENDO_LAYOUT = [...KENDO_AVATAR, ...KENDO_CARD, ...KENDO_DRAWER, ...KENDO_EXPANSIONPANEL, ...KENDO_GRIDLAYOUT, ...KENDO_PANELBAR, ...KENDO_SPLITTER, ...KENDO_STACKLAYOUT, ...KENDO_STEPPER, ...KENDO_TABSTRIP, ...KENDO_TILELAYOUT, ...KENDO_TIMELINE];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Avatar component.\n */\nlet AvatarModule = /*#__PURE__*/(() => {\n  var _class96;\n  class AvatarModule {}\n  _class96 = AvatarModule;\n  _defineProperty(AvatarModule, \"\\u0275fac\", function _class96_Factory(t) {\n    return new (t || _class96)();\n  });\n  _defineProperty(AvatarModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class96\n  }));\n  _defineProperty(AvatarModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [AvatarComponent]\n  }));\n  return AvatarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Card component.\n */\nlet CardModule = /*#__PURE__*/(() => {\n  var _class97;\n  class CardModule {}\n  _class97 = CardModule;\n  _defineProperty(CardModule, \"\\u0275fac\", function _class97_Factory(t) {\n    return new (t || _class97)();\n  });\n  _defineProperty(CardModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class97\n  }));\n  _defineProperty(CardModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return CardModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Drawer component.\n */\nlet DrawerModule = /*#__PURE__*/(() => {\n  var _class98;\n  class DrawerModule {}\n  _class98 = DrawerModule;\n  _defineProperty(DrawerModule, \"\\u0275fac\", function _class98_Factory(t) {\n    return new (t || _class98)();\n  });\n  _defineProperty(DrawerModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class98\n  }));\n  _defineProperty(DrawerModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [DrawerComponent]\n  }));\n  return DrawerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Layout components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Layout module\n * import { LayoutModule } from '@progress/kendo-angular-layout';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, LayoutModule], // import Layout module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet LayoutModule = /*#__PURE__*/(() => {\n  var _class99;\n  class LayoutModule {}\n  _class99 = LayoutModule;\n  _defineProperty(LayoutModule, \"\\u0275fac\", function _class99_Factory(t) {\n    return new (t || _class99)();\n  });\n  _defineProperty(LayoutModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class99\n  }));\n  _defineProperty(LayoutModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [AvatarComponent, DrawerComponent, ExpansionPanelComponent, PanelBarComponent, PanelBarItemComponent, SplitterComponent, StepperComponent, TabStripComponent, TileLayoutComponent, TimelineComponent]\n  }));\n  return LayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the PanelBar component.\n *\n * The module registers:\n * - `PanelBarComponent`&mdash;The `PanelBar` component class.\n * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.\n * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.\n * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.\n * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.\n */\nlet PanelBarModule = /*#__PURE__*/(() => {\n  var _class100;\n  class PanelBarModule {}\n  _class100 = PanelBarModule;\n  _defineProperty(PanelBarModule, \"\\u0275fac\", function _class100_Factory(t) {\n    return new (t || _class100)();\n  });\n  _defineProperty(PanelBarModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class100\n  }));\n  _defineProperty(PanelBarModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [PanelBarComponent, PanelBarItemComponent]\n  }));\n  return PanelBarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Splitter component.\n *\n * The module registers:\n * - `SplitterComponent`&mdash;The `Splitter` component class.\n * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.\n */\nlet SplitterModule = /*#__PURE__*/(() => {\n  var _class101;\n  class SplitterModule {}\n  _class101 = SplitterModule;\n  _defineProperty(SplitterModule, \"\\u0275fac\", function _class101_Factory(t) {\n    return new (t || _class101)();\n  });\n  _defineProperty(SplitterModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class101\n  }));\n  _defineProperty(SplitterModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [SplitterComponent]\n  }));\n  return SplitterModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Stepper component.\n */\nlet StepperModule = /*#__PURE__*/(() => {\n  var _class102;\n  class StepperModule {}\n  _class102 = StepperModule;\n  _defineProperty(StepperModule, \"\\u0275fac\", function _class102_Factory(t) {\n    return new (t || _class102)();\n  });\n  _defineProperty(StepperModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class102\n  }));\n  _defineProperty(StepperModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [StepperComponent]\n  }));\n  return StepperModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the TabStrip component.\n *\n * The module registers:\n * - `TabStripComponent`&mdash;The `TabStrip` component class.\n * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.\n * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.\n * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.\n */\nlet TabStripModule = /*#__PURE__*/(() => {\n  var _class103;\n  class TabStripModule {}\n  _class103 = TabStripModule;\n  _defineProperty(TabStripModule, \"\\u0275fac\", function _class103_Factory(t) {\n    return new (t || _class103)();\n  });\n  _defineProperty(TabStripModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class103\n  }));\n  _defineProperty(TabStripModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TabStripComponent]\n  }));\n  return TabStripModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the ExpansionPanel component.\n */\nlet ExpansionPanelModule = /*#__PURE__*/(() => {\n  var _class104;\n  class ExpansionPanelModule {}\n  _class104 = ExpansionPanelModule;\n  _defineProperty(ExpansionPanelModule, \"\\u0275fac\", function _class104_Factory(t) {\n    return new (t || _class104)();\n  });\n  _defineProperty(ExpansionPanelModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class104\n  }));\n  _defineProperty(ExpansionPanelModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [ExpansionPanelComponent]\n  }));\n  return ExpansionPanelModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the TileLayout component.\n *\n * The module registers:\n * - `TileLayoutComponent`&mdash;The `TileLayoutComponent` component class.\n * - `TileLayoutItemComponent`&mdash;The `TileLayoutItemComponent` component class.\n * - `TileLayoutItemHeaderComponent`&mdash;The `TileLayoutItemHeaderComponent` component class.\n * - `TileLayoutItemBodyComponent`&mdash;The `TileLayoutItemBodyComponent` component class.\n */\nlet TileLayoutModule = /*#__PURE__*/(() => {\n  var _class105;\n  class TileLayoutModule {}\n  _class105 = TileLayoutModule;\n  _defineProperty(TileLayoutModule, \"\\u0275fac\", function _class105_Factory(t) {\n    return new (t || _class105)();\n  });\n  _defineProperty(TileLayoutModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class105\n  }));\n  _defineProperty(TileLayoutModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TileLayoutComponent]\n  }));\n  return TileLayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the StackLayout component.\n */\nlet StackLayoutModule = /*#__PURE__*/(() => {\n  var _class106;\n  class StackLayoutModule {}\n  _class106 = StackLayoutModule;\n  _defineProperty(StackLayoutModule, \"\\u0275fac\", function _class106_Factory(t) {\n    return new (t || _class106)();\n  });\n  _defineProperty(StackLayoutModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class106\n  }));\n  _defineProperty(StackLayoutModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return StackLayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the GridLayout component.\n */\nlet GridLayoutModule = /*#__PURE__*/(() => {\n  var _class107;\n  class GridLayoutModule {}\n  _class107 = GridLayoutModule;\n  _defineProperty(GridLayoutModule, \"\\u0275fac\", function _class107_Factory(t) {\n    return new (t || _class107)();\n  });\n  _defineProperty(GridLayoutModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class107\n  }));\n  _defineProperty(GridLayoutModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return GridLayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Timeline component.\n *\n * The module registers:\n * - `TimelineComponent`&mdash;The `TimelineComponent` component class.\n */\nlet TimelineModule = /*#__PURE__*/(() => {\n  var _class108;\n  class TimelineModule {}\n  _class108 = TimelineModule;\n  _defineProperty(TimelineModule, \"\\u0275fac\", function _class108_Factory(t) {\n    return new (t || _class108)();\n  });\n  _defineProperty(TimelineModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class108\n  }));\n  _defineProperty(TimelineModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TimelineComponent]\n  }));\n  return TimelineModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AvatarComponent, AvatarCustomMessagesComponent, AvatarModule, CardAction, CardActionsComponent, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardModule, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, DrawerModule, DrawerSelectEvent, DrawerTemplateDirective, ExpansionPanelActionEvent, ExpansionPanelComponent, ExpansionPanelModule, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, GridLayoutModule, KENDO_AVATAR, KENDO_CARD, KENDO_DRAWER, KENDO_EXPANSIONPANEL, KENDO_GRIDLAYOUT, KENDO_LAYOUT, KENDO_PANELBAR, KENDO_SPLITTER, KENDO_STACKLAYOUT, KENDO_STEPPER, KENDO_TABSTRIP, KENDO_TILELAYOUT, KENDO_TIMELINE, LayoutModule, LocalizedAvatarMessagesDirective, LocalizedStepperMessagesDirective, LocalizedTabStripMessagesDirective, PanelBarCollapseEvent, PanelBarComponent, PanelBarContentDirective, PanelBarExpandEvent, PanelBarExpandMode, PanelBarItemClickEvent, PanelBarItemComponent, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarModule, PanelBarSelectEvent, PanelBarStateChangeEvent, SelectEvent, SplitterComponent, SplitterModule, SplitterPaneComponent, StackLayoutComponent, StackLayoutModule, StepperActivateEvent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperModule, StepperStepTemplateDirective, TabCloseEvent, TabComponent, TabContentDirective, TabStripComponent, TabStripCustomMessagesComponent, TabStripModule, TabStripTabComponent, TabTemplateDirective, TabTitleDirective, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutModule, TileLayoutReorderEvent, TileLayoutResizeEvent, TileLayoutResizeHandleDirective, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective, TimelineComponent, TimelineCustomMessagesComponent, TimelineModule };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}