{"ast":null,"code":"import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\nconst X = \"x\";\nconst Y = \"y\";\nexport function pointsToCurve(pointsIn, closed) {\n  const points = pointsIn.slice(0);\n  const segments = [];\n  let length = points.length;\n  if (length > 2) {\n    removeDuplicates(0, points);\n    length = points.length;\n  }\n  if (length < 2 || length === 2 && points[0].equals(points[1])) {\n    return segments;\n  }\n  let p0 = points[0];\n  let p1 = points[1];\n  let p2 = points[2];\n  segments.push(new Segment(p0));\n  while (p0.equals(points[length - 1])) {\n    closed = true;\n    points.pop();\n    length--;\n  }\n  if (length === 2) {\n    const tangent = getTangent(p0, p1, X, Y);\n    last(segments).controlOut(firstControlPoint(tangent, p0, p1, X, Y));\n    segments.push(new Segment(p1, secondControlPoint(tangent, p0, p1, X, Y)));\n    return segments;\n  }\n  let initialControlPoint, lastControlPoint;\n  if (closed) {\n    p0 = points[length - 1];\n    p1 = points[0];\n    p2 = points[1];\n    const controlPoints = getControlPoints(p0, p1, p2);\n    initialControlPoint = controlPoints[1];\n    lastControlPoint = controlPoints[0];\n  } else {\n    const tangent = getTangent(p0, p1, X, Y);\n    initialControlPoint = firstControlPoint(tangent, p0, p1, X, Y);\n  }\n  let cp0 = initialControlPoint;\n  for (let idx = 0; idx <= length - 3; idx++) {\n    removeDuplicates(idx, points);\n    length = points.length;\n    if (idx + 3 <= length) {\n      p0 = points[idx];\n      p1 = points[idx + 1];\n      p2 = points[idx + 2];\n      const controlPoints = getControlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      cp0 = controlPoints[1];\n      const cp1 = controlPoints[0];\n      segments.push(new Segment(p1, cp1));\n    }\n  }\n  if (closed) {\n    p0 = points[length - 2];\n    p1 = points[length - 1];\n    p2 = points[0];\n    const controlPoints = getControlPoints(p0, p1, p2);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p1, controlPoints[0]));\n    last(segments).controlOut(controlPoints[1]);\n    segments.push(new Segment(p2, lastControlPoint));\n  } else {\n    const tangent = getTangent(p1, p2, X, Y);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p2, secondControlPoint(tangent, p1, p2, X, Y)));\n  }\n  return segments;\n}\nexport function pointsToClosedCurve(pointsIn) {\n  return pointsToCurve(pointsIn, true);\n}\nexport function removeDuplicates(idx, points) {\n  while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n    points.splice(idx + 1, 1);\n  }\n}\nexport function invertAxis(p0, p1, p2) {\n  let invertAxis = false;\n  if (p0.x === p1.x) {\n    invertAxis = true;\n  } else if (p1.x === p2.x) {\n    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n      invertAxis = true;\n    }\n  } else {\n    const fn = lineFunction(p0, p1);\n    const y2 = calculateFunction(fn, p2.x);\n    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n      invertAxis = true;\n    }\n  }\n  return invertAxis;\n}\nexport function isLine(p0, p1, p2) {\n  const fn = lineFunction(p0, p1);\n  const y2 = calculateFunction(fn, p2.x);\n  return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n}\nexport function lineFunction(p1, p2) {\n  const a = (p2.y - p1.y) / (p2.x - p1.x);\n  const b = p1.y - a * p1.x;\n  return [b, a];\n}\nexport function getControlPoints(p0, p1, p2) {\n  let xField = X;\n  let yField = Y;\n  let restrict = false;\n  let switchOrientation = false;\n  let tangent;\n  if (isLine(p0, p1, p2)) {\n    tangent = getTangent(p0, p1, X, Y);\n  } else {\n    const monotonic = {\n      x: isMonotonicByField(p0, p1, p2, X),\n      y: isMonotonicByField(p0, p1, p2, Y)\n    };\n    if (monotonic.x && monotonic.y) {\n      tangent = getTangent(p0, p2, X, Y);\n      restrict = true;\n    } else {\n      if (invertAxis(p0, p1, p2)) {\n        xField = Y;\n        yField = X;\n      }\n      if (monotonic[xField]) {\n        tangent = 0;\n      } else {\n        let sign;\n        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n          sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n        } else {\n          sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n        }\n        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n        switchOrientation = true;\n      }\n    }\n  }\n  const secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n  if (switchOrientation) {\n    const oldXField = xField;\n    xField = yField;\n    yField = oldXField;\n  }\n  const firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n  if (restrict) {\n    restrictControlPoint(p0, p1, secondCP, tangent);\n    restrictControlPoint(p1, p2, firstCP, tangent);\n  }\n  return [secondCP, firstCP];\n}\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n  if (p1.y < p2.y) {\n    if (p2.y < cp.y) {\n      cp.x = p1.x + (p2.y - p1.y) / tangent;\n      cp.y = p2.y;\n    } else if (cp.y < p1.y) {\n      cp.x = p2.x - (p2.y - p1.y) / tangent;\n      cp.y = p1.y;\n    }\n  } else {\n    if (cp.y < p2.y) {\n      cp.x = p1.x - (p1.y - p2.y) / tangent;\n      cp.y = p2.y;\n    } else if (p1.y < cp.y) {\n      cp.x = p2.x + (p1.y - p2.y) / tangent;\n      cp.y = p1.y;\n    }\n  }\n}\nexport function getTangent(p0, p1, xField, yField) {\n  const x = p1[xField] - p0[xField];\n  const y = p1[yField] - p0[yField];\n  let tangent;\n  if (x === 0) {\n    tangent = 0;\n  } else {\n    tangent = y / x;\n  }\n  return tangent;\n}\nexport function isMonotonicByField(p0, p1, p2, field) {\n  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n}\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n  const t1 = p0[xField];\n  const t2 = p3[xField];\n  const distance = (t2 - t1) * WEIGHT;\n  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n  const t1 = p0[xField];\n  const t2 = p3[xField];\n  const distance = (t2 - t1) * WEIGHT;\n  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\nexport function point(xValue, yValue, xField, yField) {\n  const controlPoint = new Point();\n  controlPoint[xField] = xValue;\n  controlPoint[yField] = yValue;\n  return controlPoint;\n}\nexport function calculateFunction(fn, x) {\n  const length = fn.length;\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result += Math.pow(x, i) * fn[i];\n  }\n  return result;\n}\nexport function numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}