{"ast":null,"code":"import { exportImage, geometry, Group, MultiPath, Path, Image, Surface } from '@progress/kendo-drawing';\nimport { elementOffset, limitValue } from '../common';\nconst {\n  Point,\n  Rect,\n  transform\n} = geometry;\nconst noop = () => {};\nconst DECIMAL_DIGITS = 3;\nconst DEFAULT_COLOR = '#000';\nconst DEFAULT_BACKGROUND_COLOR = '#fff';\nconst DEFAULT_PRECISION = 1;\nconst DEFAULT_SAMPLING_RATE = 200; // Updates per second\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_WIDTH = 750;\nconst DEFAULT_HEIGHT = 250;\nconst DEFAULT_SCALE = 1;\n// Export images at maximized scale (3x) and 2x pixel density to cover HiDPI screens.\nconst DEFAULT_EXPORT_SCALE = 6;\nexport class SignaturePad {\n  constructor(element, options = {}) {\n    this.element = element;\n    this.lastMoveTime = 0;\n    this.resolveColors(options);\n    this.options = Object.assign({\n      scale: DEFAULT_SCALE,\n      precision: DEFAULT_PRECISION,\n      samplingRate: DEFAULT_SAMPLING_RATE,\n      smooth: options.smooth !== false,\n      color: DEFAULT_COLOR,\n      backgroundColor: DEFAULT_BACKGROUND_COLOR,\n      strokeWidth: DEFAULT_STROKE_WIDTH,\n      onChange: noop,\n      onDraw: noop,\n      onDrawEnd: noop\n    }, options, {\n      color: this.color,\n      backgroundColor: this.backgroundColor\n    });\n    this.pathOptions = {\n      stroke: {\n        color: this.options.color,\n        width: this.options.strokeWidth,\n        lineCap: 'round',\n        lineJoin: 'round'\n      }\n    };\n    this.initSurface();\n    this.attachEvents();\n  }\n  destroy() {\n    this.detachEvents();\n  }\n  clear() {\n    this.rootGroup.clear();\n    this.path = null;\n  }\n  readThemeColors() {\n    let themeColor;\n    let themeBackgroundColor;\n    if (typeof document !== 'undefined') {\n      const themeElement = this.element.closest(\".k-signature\") || this.element;\n      const computedStyle = themeElement.ownerDocument.defaultView.getComputedStyle(themeElement);\n      themeColor = computedStyle.color;\n      themeBackgroundColor = computedStyle.backgroundColor;\n    }\n    this.themeColor = themeColor || this.themeColor || DEFAULT_COLOR;\n    this.themeBackgroundColor = themeBackgroundColor || this.themeBackgroundColor || DEFAULT_BACKGROUND_COLOR;\n  }\n  resolveColors(options) {\n    this.readThemeColors();\n    this.color = options.color || (this.options || {}).color || this.themeColor;\n    this.backgroundColor = options.backgroundColor || (this.options || {}).backgroundColor || this.themeBackgroundColor;\n  }\n  get isDrawing() {\n    return Boolean(this.points);\n  }\n  get pathData() {\n    var _a;\n    return (_a = this.path) === null || _a === void 0 ? void 0 : _a.toString(DECIMAL_DIGITS);\n  }\n  set pathData(value) {\n    this.clear();\n    this.path = MultiPath.parse(value, this.pathOptions);\n    this.rootGroup.append(this.path);\n  }\n  loadImage(data, size = []) {\n    if (!data) {\n      this.clear();\n      return;\n    }\n    const [width, height] = this.size;\n    const contentWidth = width / this.options.scale;\n    const contentHeight = height / this.options.scale;\n    const importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;\n    const importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;\n    const scaleX = contentWidth / importWidth;\n    const scaleY = contentHeight / importHeight;\n    const scale = Math.min(scaleX, scaleY);\n    const img = new Image(data, new geometry.Rect([0, 0], [importWidth, importHeight]));\n    img.transform(transform().scale(scale, scale));\n    this.clear();\n    this.rootGroup.append(img);\n  }\n  exportImage(options) {\n    const [width, height] = this.size;\n    const contentWidth = width / this.options.scale;\n    const contentHeight = height / this.options.scale;\n    const exportWidth = (options === null || options === void 0 ? void 0 : options.width) || contentWidth * DEFAULT_EXPORT_SCALE;\n    const exportHeight = (options === null || options === void 0 ? void 0 : options.height) || contentHeight * DEFAULT_EXPORT_SCALE;\n    const scaleX = exportWidth / contentWidth;\n    const scaleY = exportHeight / contentHeight;\n    const scale = Math.min(scaleX, scaleY);\n    const exportRect = new Rect([0, 0], [exportWidth, exportHeight]);\n    const exportGroup = new Group({\n      clip: Path.fromRect(exportRect)\n    });\n    const contentGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    const frame = Path.fromRect(exportRect, {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    exportGroup.append(frame);\n    exportGroup.append(contentGroup);\n    contentGroup.children.push(...this.rootGroup.children);\n    return exportImage(exportGroup, Object.assign({\n      width: exportWidth,\n      height: exportHeight\n    }, options));\n  }\n  resize() {\n    this.surface.resize(true);\n  }\n  setOptions(options) {\n    this.resolveColors(options);\n    Object.assign(this.options, options, {\n      color: this.color,\n      backgroundColor: this.backgroundColor\n    });\n    this.pathOptions.stroke.color = this.options.color;\n    this.pathOptions.stroke.width = this.options.strokeWidth;\n    if (this.path) {\n      this.path.options.set('stroke.color', this.options.color);\n      this.path.options.set('stroke.width', this.options.strokeWidth);\n    }\n    this.background.options.set('fill.color', this.options.backgroundColor);\n  }\n  initSurface() {\n    this.surface = Surface.create(this.element, {\n      type: 'canvas'\n    });\n    this.element.style.touchAction = 'none';\n    const scale = this.options.scale;\n    this.rootGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    // The signature is not resizable, store initial dimensions.\n    const width = this.element.offsetWidth || DEFAULT_WIDTH;\n    const height = this.element.offsetHeight || DEFAULT_HEIGHT;\n    this.size = [width, height];\n    this.background = Path.fromRect(new Rect([0, 0], this.size), {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    this.surface.draw(this.background);\n    this.surface.draw(this.rootGroup);\n  }\n  attachEvents() {\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onDragStart = this.onDragStart.bind(this);\n    this.element.addEventListener('pointerdown', this.onPointerDown);\n    this.element.addEventListener('pointerup', this.onPointerUp);\n    this.element.addEventListener('dragstart', this.onDragStart);\n  }\n  detachEvents() {\n    this.element.removeEventListener('pointerdown', this.onPointerDown);\n    this.detachPointerMove();\n    this.element.removeEventListener('pointerup', this.onPointerUp);\n    this.element.removeEventListener('dragstart', this.onDragStart);\n  }\n  attachPointerMove() {\n    this.element.addEventListener('pointermove', this.onPointerMove);\n  }\n  detachPointerMove() {\n    this.element.removeEventListener('pointermove', this.onPointerMove);\n  }\n  touchPoint(e) {\n    const offset = elementOffset(this.element);\n    const pageX = e.pageX;\n    const pageY = e.pageY;\n    const scale = 1 / this.options.scale;\n    return new Point(pageX - offset.left, pageY - offset.top).scale(scale, scale);\n  }\n  onDragStart(e) {\n    // fixes a problem that is currently reproducible in Chrome on Windows only\n    // 1. Start selecting a text on the page and while holding, move inside the signature\n    // 2. Release.\n    // 3. Start drawing without releasing the mouse - the action is blocked (browser assumes dragstart event).\n    // 4. If you release, then you can continue drawing although you haven't pressed on the drawing surface.\n    e.preventDefault();\n  }\n  onPointerDown(e) {\n    if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {\n      return;\n    }\n    this.detachPointerMove();\n    this.attachPointerMove();\n    if (!this.path) {\n      this.path = new MultiPath(this.pathOptions);\n      this.rootGroup.append(this.path);\n    }\n    this.options.onDraw();\n    this.element.setPointerCapture(e.pointerId);\n    const point = this.touchPoint(e);\n    this.points = [point];\n    this.path.moveTo(point);\n  }\n  onPointerMove(e) {\n    if (!this.points || !this.path || !e.isPrimary) {\n      return;\n    }\n    const now = new Date().getTime();\n    const elapsed = now - this.lastMoveTime;\n    const minTimeDelta = 1000 / limitValue(this.options.samplingRate, 1, 10000);\n    if (elapsed < minTimeDelta) {\n      return;\n    } else {\n      this.lastMoveTime = now;\n    }\n    const point = this.touchPoint(e);\n    const lastPoint = this.points[this.points.length - 1];\n    const minDelta = 1 / limitValue(this.options.precision, 0.01, 100);\n    if (point.distanceTo(lastPoint) < minDelta) {\n      return;\n    }\n    this.points.push(point);\n    this.path.lineTo(point);\n  }\n  onPointerUp(e) {\n    if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {\n      return;\n    }\n    this.detachPointerMove();\n    if (this.options.smooth) {\n      const segments = Path.curveFromPoints(this.points);\n      this.path.paths.splice(this.path.paths.length - 1, 1, segments);\n    }\n    this.points = null;\n    this.options.onDrawEnd();\n    this.options.onChange(this.pathData);\n  }\n}\nfunction isMainButton(e) {\n  return typeof e.button !== 'number' || e.button === 0;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}