{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport * as i0 from '@angular/core';\nimport { isDevMode, Component, HostBinding, Input, Directive, forwardRef, EventEmitter, Output, ViewChild, ContentChild, NgModule } from '@angular/core';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { hasObservers, isDocumentAvailable, isChanged, ResizeSensorComponent, ResizeBatchService } from '@progress/kendo-angular-common';\nimport { NgStyle, NgClass, NgIf, NgFor, NgTemplateOutlet } from '@angular/common';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n/**\n * @hidden\n */\nconst _c0 = [\"progressStatus\"];\nconst _c1 = [\"progressStatusWrap\"];\nfunction _class4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.formattedLabelValue);\n  }\n}\nfunction _class4_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.formattedLabelValue);\n  }\n}\nfunction _class5_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"li\", 3);\n  }\n  if (rf & 2) {\n    const chunk_r1 = ctx.$implicit;\n    const i_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.orientationStyles.width)(\"height\", ctx_r0.orientationStyles.height);\n    i0.ɵɵclassProp(\"k-first\", i_r2 === 0)(\"k-last\", i_r2 === ctx_r0.chunkCount - 1)(\"k-selected\", chunk_r1);\n    i0.ɵɵproperty(\"ngClass\", chunk_r1 ? ctx_r0.progressCssClass : ctx_r0.emptyCssClass)(\"ngStyle\", chunk_r1 ? ctx_r0.progressCssStyle : ctx_r0.emptyCssStyle);\n  }\n}\nconst _c6 = [\"progress\"];\nconst _c7 = [\"scale\"];\nconst _c8 = [\"label\"];\nconst _c9 = [\"surface\"];\nfunction _class7_div_11_ng_template_2_Template(rf, ctx) {}\nfunction _class7_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵnamespaceHTML();\n    i0.ɵɵelementStart(0, \"div\", 10, 11);\n    i0.ɵɵtemplate(2, _class7_div_11_ng_template_2_Template, 0, 0, \"ng-template\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.centerTemplate.templateRef)(\"ngTemplateOutletContext\", ctx_r4.centerTemplateContext);\n  }\n}\nconst packageMetadata = {\n  name: '@progress/kendo-angular-progressbar',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163538,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nconst MIN_MAX_ERROR_MESSAGE = `The max value should be greater than the min.`;\n/**\n * @hidden\n */\nconst LABEL_DECIMALS = 3;\n/**\n * @hidden\n */\nconst MIN_RATIO = 0.0001;\n\n/**\n * @hidden\n */\nconst formatValue = (value, min, max, label) => {\n  const defaultFormattedValue = truncateNumber(value);\n  if (typeof label !== 'boolean') {\n    if (typeof label.format === 'string') {\n      switch (label.format) {\n        case 'value':\n          return defaultFormattedValue;\n        case 'percent':\n          return `${Math.floor(calculatePercentage(value, min, max))}%`;\n        default:\n          return defaultFormattedValue;\n      }\n    } else if (typeof label.format === 'function') {\n      return label.format(value);\n    } else {\n      return defaultFormattedValue;\n    }\n  }\n  return defaultFormattedValue;\n};\n/**\n * @hidden\n */\nconst validateRange = (min, max) => {\n  if (isDevMode && min > max) {\n    throw new Error(MIN_MAX_ERROR_MESSAGE);\n  }\n};\n/**\n * @hidden\n */\nconst adjustValueToRange = (min, max, value) => Math.max(Math.min(value, max), min);\n/**\n * @hidden\n */\nconst calculatePercentage = (value, min, max) => {\n  const decimalValue = Math.abs((value - min) / (max - min));\n  return decimalValue * 100;\n};\n/**\n * @hidden\n */\nconst truncateNumber = value => {\n  const numberParts = value.toString().split('.');\n  return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;\n};\n/**\n * @hidden\n */\nconst calculateRatio = (min, max, value) => Math.max((value - min) / (max - min), MIN_RATIO);\n/**\n * @hidden\n */\nconst extractValueFromChanges = (changes, type, value) => changes[type] && changes[type].currentValue !== undefined ? changes[type].currentValue : value;\n/**\n * @hidden\n */\nconst runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== 'undefined' && changes['value'] && previousValue !== displayValue;\n/**\n * @hidden\n */\nconst stopCurrentAnimation = changes => {\n  const isAnimationChanged = Boolean(changes['animation']);\n  const hasAnimation = isAnimationChanged && changes['animation'].currentValue;\n  return isAnimationChanged && !hasAnimation;\n};\n/**\n * @hidden\n */\nconst setProgressBarStyles = (props, renderer) => {\n  props.forEach(prop => {\n    renderer[prop.method](prop.el, prop.attr, `${prop.attrValue}`);\n  });\n};\n/**\n * @hidden\n */\nconst removeProgressBarStyles = (props, renderer) => {\n  props.forEach(prop => {\n    renderer[prop.method](prop.el, prop.attr);\n  });\n};\n/**\n * @hidden\n */\nconst hasElementSize = element => {\n  return !!(element.style.width && element.style.height);\n};\n\n/**\n * @hidden\n */\nlet ProgressBarBase = /*#__PURE__*/(() => {\n  var _class;\n  class ProgressBarBase {\n    get isHorizontal() {\n      return this.orientation === 'horizontal';\n    }\n    get isVertical() {\n      return this.orientation === 'vertical';\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get reverseClass() {\n      return this.reverse;\n    }\n    get indeterminateClass() {\n      return this.indeterminate;\n    }\n    get dirAttribute() {\n      return this.direction;\n    }\n    get ariaMinAttribute() {\n      return String(this.min);\n    }\n    get ariaMaxAttribute() {\n      return String(this.max);\n    }\n    get ariaValueAttribute() {\n      return this.indeterminate ? undefined : String(this.displayValue);\n    }\n    /**\n     * The maximum value of the ProgressBar.\n     * Defaults to `100`.\n     */\n\n    /**\n     * @hidden\n     */\n    get isCompleted() {\n      return this.value === this.max;\n    }\n    /**\n     * @hidden\n     */\n    get statusWidth() {\n      return this.orientation === 'horizontal' ? this._progressRatio * 100 : 100;\n    }\n    /**\n     * @hidden\n     */\n    get statusHeight() {\n      return this.orientation === 'vertical' ? this._progressRatio * 100 : 100;\n    }\n    /**\n     * @hidden\n     */\n    get statusWrapperWidth() {\n      return this.orientation === 'horizontal' ? 100 / this._progressRatio : 100;\n    }\n    /**\n     * @hidden\n     */\n    get statusWrapperHeight() {\n      return this.orientation === 'vertical' ? 100 / this._progressRatio : 100;\n    }\n    get _progressRatio() {\n      return calculateRatio(this.min, this.max, this.displayValue);\n    }\n    /**\n     * Defines the orientation of the ProgressBar\n     * ([see example]({% slug progressbar_orientation %})).\n     * Defaults to `horizontal`.\n     */\n\n    /**\n     * @hidden\n     */\n    constructor(elem, renderer, localization) {\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"roleAttribute\", 'progressbar');\n      _defineProperty(this, \"max\", 100);\n      /**\n       * The minimum value of the ProgressBar.\n       * Defaults to `0`.\n       */\n      _defineProperty(this, \"min\", 0);\n      /**\n       * The value of the ProgressBar.\n       * Has to be between `min` and `max`.\n       * By default, the value is equal to the `min` value.\n       */\n      /**\n       * The value of the ProgressBar.\n       * Has to be between `min` and `max`.\n       * Defaults to `0`.\n       */\n      _defineProperty(this, \"value\", 0);\n      _defineProperty(this, \"orientation\", 'horizontal');\n      /**\n       * If set to `true`, the ProgressBar will be disabled\n       * ([see example]({% slug progressbar_disabled %})).\n       * It will still allow you to change its value.\n       * Defaults to `false`.\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * If set to `true`, the ProgressBar will be reversed\n       * ([see example]({% slug progressbar_direction %})).\n       * Defaults to `false`.\n       */\n      _defineProperty(this, \"reverse\", false);\n      /**\n       * Sets the `indeterminate` state of the ProgressBar.\n       * Defaults to `false`.\n       */\n      _defineProperty(this, \"indeterminate\", false);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"localizationChangeSubscription\", void 0);\n      _defineProperty(this, \"displayValue\", 0);\n      _defineProperty(this, \"previousValue\", 0);\n      this.elem = elem;\n      this.renderer = renderer;\n      this.localization = localization;\n      validatePackage(packageMetadata);\n      this.localizationChangeSubscription = localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngAfterViewInit() {\n      const elem = this.elem.nativeElement;\n      const label = this.localization.get('progressBarLabel');\n      this.renderer.setAttribute(elem, 'aria-label', label);\n    }\n    ngOnChanges(changes) {\n      const min = extractValueFromChanges(changes, 'min', this.min);\n      const max = extractValueFromChanges(changes, 'max', this.max);\n      const value = extractValueFromChanges(changes, 'value', this.value);\n      if (changes['min'] || changes['max'] || changes['value']) {\n        if (changes['min'] || changes['max']) {\n          validateRange(min, max);\n        }\n        if (changes['value']) {\n          if (value == null || Number.isNaN(value)) {\n            this.value = min;\n          }\n          const previousValue = this.displayValue;\n          this.displayValue = adjustValueToRange(this.min, this.max, value);\n          this.previousValue = previousValue;\n        }\n        this.min = min;\n        this.max = max;\n        this.displayValue = adjustValueToRange(this.min, this.max, value);\n      }\n    }\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n    }\n  }\n  _class = ProgressBarBase;\n  _defineProperty(ProgressBarBase, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ProgressBarBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"ng-component\"]],\n    hostVars: 17,\n    hostBindings: function _class_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dirAttribute)(\"role\", ctx.roleAttribute)(\"aria-valuemin\", ctx.ariaMinAttribute)(\"aria-valuemax\", ctx.ariaMaxAttribute)(\"aria-valuenow\", ctx.ariaValueAttribute);\n        i0.ɵɵclassProp(\"k-progressbar\", ctx.hostClasses)(\"k-progressbar-horizontal\", ctx.isHorizontal)(\"k-progressbar-vertical\", ctx.isVertical)(\"k-disabled\", ctx.disabledClass)(\"k-progressbar-reverse\", ctx.reverseClass)(\"k-progressbar-indeterminate\", ctx.indeterminateClass);\n      }\n    },\n    inputs: {\n      max: \"max\",\n      min: \"min\",\n      value: \"value\",\n      orientation: \"orientation\",\n      disabled: \"disabled\",\n      reverse: \"reverse\",\n      indeterminate: \"indeterminate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ProgressBarBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ProgressBarMessages = /*#__PURE__*/(() => {\n  var _class2;\n  class ProgressBarMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The aria-label attribute for the ProgressBar component.\n       */\n      _defineProperty(this, \"progressBarLabel\", void 0);\n    }\n  }\n  _class2 = ProgressBarMessages;\n  _defineProperty(ProgressBarMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class2_BaseFactory;\n    return function _class2_Factory(t) {\n      return (ɵ_class2_BaseFactory || (ɵ_class2_BaseFactory = i0.ɵɵgetInheritedFactory(_class2)))(t || _class2);\n    };\n  }());\n  _defineProperty(ProgressBarMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class2,\n    inputs: {\n      progressBarLabel: \"progressBarLabel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return ProgressBarMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedProgressBarMessagesDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class LocalizedProgressBarMessagesDirective extends ProgressBarMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class3 = LocalizedProgressBarMessagesDirective;\n  _defineProperty(LocalizedProgressBarMessagesDirective, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedProgressBarMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"\", \"kendoProgressBarLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ProgressBarMessages,\n      useExisting: forwardRef(() => _class3)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedProgressBarMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ProgressBar component for Angular]({% slug overview_progressbar %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-progressbar [value]=\"value\">\n *        </kendo-progressbar>\n *    `\n * })\n * class AppComponent {\n *     public value = 50;\n * }\n * ```\n */\nlet ProgressBarComponent = /*#__PURE__*/(() => {\n  var _class4;\n  class ProgressBarComponent extends ProgressBarBase {\n    /**\n     * @hidden\n     */\n    get showLabel() {\n      if (typeof this.label === 'boolean') {\n        return this.label;\n      } else {\n        if (this.label && !this.label.hasOwnProperty('visible')) {\n          this.label.visible = true;\n        }\n        return this.label.visible;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get labelPosition() {\n      if (typeof this.label === 'boolean') {\n        return 'end';\n      } else {\n        if (this.label && !this.label.hasOwnProperty('position')) {\n          this.label.position = 'end';\n        }\n        return this.label.position;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get isPositionStart() {\n      return this.labelPosition === 'start';\n    }\n    /**\n     * @hidden\n     */\n    get isPositionCenter() {\n      return this.labelPosition === 'center';\n    }\n    /**\n     * @hidden\n     */\n    get isPositionEnd() {\n      return this.labelPosition === 'end';\n    }\n    /**\n     * @hidden\n     */\n    get formattedLabelValue() {\n      return formatValue(this.displayValue, this.min, this.max, this.label);\n    }\n    /**\n     * @hidden\n     */\n    constructor(localization, elem, renderer, zone) {\n      super(elem, renderer, localization);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      /**\n       * Determines whether the status label will be visible.\n       * Defaults to `true`&mdash;the label will be visible and displayed with the default\n       * `LabelSettings` having its position set to `end` and its format set to `value`.\n       */\n      _defineProperty(this, \"label\", true);\n      /**\n       * The CSS styles that will be rendered on the inner element which represents the full portion of the progress bar\n       * ([see example]({% slug progressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).\n       */\n      _defineProperty(this, \"progressCssStyle\", void 0);\n      /**\n       * The CSS classes that will be rendered on the inner element which represents the full portion of the progress bar\n       * ([see example]({% slug progressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      _defineProperty(this, \"progressCssClass\", void 0);\n      /**\n       * The CSS styles that will be rendered on the inner element which represents the empty portion of the progress bar\n       * ([see example]({% slug progressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).\n       */\n      _defineProperty(this, \"emptyCssStyle\", void 0);\n      /**\n       * The CSS classes that will be rendered on the inner element which represents the empty portion of the progress bar\n       * ([see example]({% slug progressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      _defineProperty(this, \"emptyCssClass\", void 0);\n      /**\n       * The animation configuration of the ProgressBar.\n       * Defaults to `false`.\n       */\n      _defineProperty(this, \"animation\", false);\n      /**\n       * Fires when the animation which indicates the latest value change is completed.\n       */\n      _defineProperty(this, \"animationEnd\", new EventEmitter());\n      _defineProperty(this, \"progressStatusElement\", void 0);\n      _defineProperty(this, \"progressStatusWrapperElement\", void 0);\n      _defineProperty(this, \"animationFrame\", void 0);\n      _defineProperty(this, \"cancelCurrentAnimation\", void 0);\n      _defineProperty(this, \"isAnimationInProgress\", void 0);\n      this.localization = localization;\n      this.elem = elem;\n      this.renderer = renderer;\n      this.zone = zone;\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      super.ngOnChanges(changes);\n      if (this.isAnimationInProgress && stopCurrentAnimation(changes)) {\n        this.cancelCurrentAnimation = true;\n      }\n      if (runAnimation(changes, this.animation, this.previousValue, this.displayValue) && !changes['value'].firstChange) {\n        this.startAnimation(this.previousValue);\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      if (this.animationFrame) {\n        cancelAnimationFrame(this.animationFrame);\n      }\n    }\n    /**\n     * @hidden\n     */\n    startAnimation(previousValue) {\n      this.isAnimationInProgress = true;\n      const element = this.progressStatusElement.nativeElement;\n      const wrapperElement = this.progressStatusWrapperElement.nativeElement;\n      const animationOptions = this.getAnimationOptions(previousValue);\n      this.zone.runOutsideAngular(() => {\n        if (this.animationFrame) {\n          cancelAnimationFrame(this.animationFrame);\n        }\n        const animate = () => {\n          const elapsed = new Date().getTime() - animationOptions.startTime;\n          const position = Math.min(elapsed / animationOptions.duration, 1);\n          const size = animationOptions.startSize + animationOptions.deltaSize * position;\n          const wrapperSize = 100 / size * 100;\n          this.renderValueChange(element, wrapperElement, animationOptions.property, size, wrapperSize);\n          if (position < 1) {\n            if (this.cancelCurrentAnimation) {\n              this.resetProgress(element, wrapperElement, animationOptions.property);\n              return;\n            }\n            this.animationFrame = requestAnimationFrame(animate);\n          } else {\n            this.stopAnimation(previousValue);\n          }\n        };\n        animate();\n      });\n    }\n    /**\n     * @hidden\n     */\n    get animationDuration() {\n      if (typeof this.animation === 'boolean') {\n        return 400;\n      } else {\n        if (this.animation && !this.animation.hasOwnProperty('duration')) {\n          this.animation.duration = 400;\n        }\n        return this.animation.duration;\n      }\n    }\n    stopAnimation(value) {\n      if (hasObservers(this.animationEnd)) {\n        this.zone.run(() => {\n          this.animationEnd.emit({\n            from: value,\n            to: this.displayValue\n          });\n        });\n      }\n      this.zone.run(() => {\n        this.isAnimationInProgress = false;\n      });\n    }\n    getAnimationOptions(value) {\n      const isHorizontal = this.orientation === 'horizontal';\n      const previousRatio = calculateRatio(this.min, this.max, value);\n      const previousStatusWidth = isHorizontal ? previousRatio * 100 : 100;\n      const previousStatusHeight = !isHorizontal ? previousRatio * 100 : 100;\n      const property = isHorizontal ? 'width' : 'height';\n      const startTime = new Date().getTime();\n      const startSize = isHorizontal ? previousStatusWidth : previousStatusHeight;\n      const deltaSize = isHorizontal ? this.statusWidth - previousStatusWidth : this.statusHeight - previousStatusHeight;\n      const duration = this.animationDuration * Math.abs(deltaSize / 100);\n      return {\n        property,\n        startTime,\n        startSize,\n        deltaSize,\n        duration\n      };\n    }\n    renderValueChange(element, wrapperElement, property, size, wrapperSize) {\n      this.renderer.setStyle(element, property, size + '%');\n      this.renderer.setStyle(wrapperElement, property, wrapperSize + '%');\n    }\n    resetProgress(element, wrapperElement, property) {\n      const size = calculateRatio(this.min, this.max, this.value);\n      const newSize = size * 100;\n      const newWrapperSize = 100 / size;\n      this.renderValueChange(element, wrapperElement, property, newSize, newWrapperSize);\n      this.zone.run(() => {\n        this.cancelCurrentAnimation = false;\n        this.isAnimationInProgress = false;\n      });\n    }\n  }\n  _class4 = ProgressBarComponent;\n  _defineProperty(ProgressBarComponent, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ProgressBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class4,\n    selectors: [[\"kendo-progressbar\"]],\n    viewQuery: function _class4_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.progressStatusElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.progressStatusWrapperElement = _t.first);\n      }\n    },\n    inputs: {\n      label: \"label\",\n      progressCssStyle: \"progressCssStyle\",\n      progressCssClass: \"progressCssClass\",\n      emptyCssStyle: \"emptyCssStyle\",\n      emptyCssClass: \"emptyCssClass\",\n      animation: \"animation\"\n    },\n    outputs: {\n      animationEnd: \"animationEnd\"\n    },\n    exportAs: [\"kendoProgressBar\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.progressbar'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 8,\n    vars: 28,\n    consts: function () {\n      let i18n_2;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label attribute for the ProgressBar component.\n         * @meaning kendo.progressbar.progressBarLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_3 = goog.getMsg(\"Progressbar\");\n        i18n_2 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_3;\n      } else {\n        i18n_2 = $localize`:kendo.progressbar.progressBarLabel|The aria-label attribute for the ProgressBar component.:Progressbar`;\n      }\n      return [[\"kendoProgressBarLocalizedMessages\", \"\", \"progressBarLabel\", i18n_2], [1, \"k-progress-status-wrap\", 3, \"ngStyle\", \"ngClass\"], [\"class\", \"k-progress-status\", 4, \"ngIf\"], [1, \"k-selected\", \"k-progressbar-value\", 3, \"ngStyle\", \"ngClass\"], [\"progressStatus\", \"\"], [1, \"k-progress-status-wrap\"], [\"progressStatusWrap\", \"\"], [1, \"k-progress-status\"]];\n    },\n    template: function _class4_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class4_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 3, 4)(5, \"span\", 5, 6);\n        i0.ɵɵtemplate(7, _class4_span_7_Template, 2, 1, \"span\", 2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-progress-start\", ctx.isPositionStart)(\"k-progress-center\", ctx.isPositionCenter)(\"k-progress-end\", ctx.isPositionEnd);\n        i0.ɵɵproperty(\"ngStyle\", ctx.emptyCssStyle)(\"ngClass\", ctx.emptyCssClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLabel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.statusWidth, \"%\")(\"height\", ctx.statusHeight, \"%\");\n        i0.ɵɵclassProp(\"k-complete\", ctx.isCompleted);\n        i0.ɵɵproperty(\"ngStyle\", ctx.progressCssStyle)(\"ngClass\", ctx.progressCssClass);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.statusWrapperWidth, \"%\")(\"height\", ctx.statusWrapperHeight, \"%\");\n        i0.ɵɵclassProp(\"k-progress-start\", ctx.isPositionStart)(\"k-progress-center\", ctx.isPositionCenter)(\"k-progress-end\", ctx.isPositionEnd);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLabel);\n      }\n    },\n    dependencies: [LocalizedProgressBarMessagesDirective, NgStyle, NgClass, NgIf],\n    encapsulation: 2\n  }));\n  return ProgressBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ChunkProgressBar component for Angular]({% slug overview_chunkprogressbar %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-chunkprogressbar [value]=\"value\">\n *        </kendo-chunkprogressbar>\n *    `\n * })\n * class AppComponent {\n *     public value = 40;\n * }\n * ```\n */\nlet ChunkProgressBarComponent = /*#__PURE__*/(() => {\n  var _class5;\n  class ChunkProgressBarComponent extends ProgressBarBase {\n    /**\n     * @hidden\n     */\n    get chunks() {\n      const count = this.chunkCount;\n      const chunks = Array(count).fill(false);\n      const completedChunks = Math.floor(this._progressRatio * count);\n      for (let i = 0; i < completedChunks; i++) {\n        chunks[i] = true;\n      }\n      return chunks;\n    }\n    /**\n     * The CSS styles that will be rendered on the full chunk elements ([see example]({% slug chunkprogressbar_appearance %})).\n     * Supports the type of values that are supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    /**\n     * @hidden\n     */\n    get chunkSizePercentage() {\n      return 100 / this.chunkCount;\n    }\n    /**\n     * @hidden\n     */\n    get orientationStyles() {\n      if (this.orientation === 'horizontal') {\n        this._orientationStyles.width = `${this.chunkSizePercentage}%`;\n        this._orientationStyles.height = null;\n      } else {\n        this._orientationStyles.height = `${this.chunkSizePercentage}%`;\n        this._orientationStyles.width = null;\n      }\n      return this._orientationStyles;\n    }\n    /**\n     * @hidden\n     */\n    constructor(localization, elem, renderer) {\n      super(elem, renderer, localization);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"elem\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"chunkClass\", true);\n      /**\n       * Sets the number of chunks into which the ChunkProgressBar will be split.\n       * Defaults to `5`.\n       */\n      _defineProperty(this, \"chunkCount\", 5);\n      _defineProperty(this, \"progressCssStyle\", void 0);\n      /**\n       * The CSS classes that will be rendered on the full chunk elements ([see example]({% slug chunkprogressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"progressCssClass\", void 0);\n      /**\n       * The CSS styles that will be rendered on the empty chunk elements ([see example]({% slug chunkprogressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).\n       */\n      _defineProperty(this, \"emptyCssStyle\", void 0);\n      /**\n       * The CSS classes that will be rendered on the empty chunk elements ([see example]({% slug chunkprogressbar_appearance %})).\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      _defineProperty(this, \"emptyCssClass\", void 0);\n      _defineProperty(this, \"_orientationStyles\", {\n        width: `${this.chunkSizePercentage}%`,\n        height: null\n      });\n      this.localization = localization;\n      this.elem = elem;\n      this.renderer = renderer;\n    }\n  }\n  _class5 = ChunkProgressBarComponent;\n  _defineProperty(ChunkProgressBarComponent, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(ChunkProgressBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class5,\n    selectors: [[\"kendo-chunkprogressbar\"]],\n    hostVars: 2,\n    hostBindings: function _class5_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-chunk-progressbar\", ctx.chunkClass);\n      }\n    },\n    inputs: {\n      chunkCount: \"chunkCount\",\n      progressCssStyle: \"progressCssStyle\",\n      progressCssClass: \"progressCssClass\",\n      emptyCssStyle: \"emptyCssStyle\",\n      emptyCssClass: \"emptyCssClass\"\n    },\n    exportAs: [\"kendoChunkProgressBar\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chunkprogressbar'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 1,\n    consts: function () {\n      let i18n_4;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label attribute for the ChunkProgressBar component.\n         * @meaning kendo.chunkprogressbar.progressBarLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_5 = goog.getMsg(\"Chunk progressbar\");\n        i18n_4 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_5;\n      } else {\n        i18n_4 = $localize`:kendo.chunkprogressbar.progressBarLabel|The aria-label attribute for the ChunkProgressBar component.:Chunk progressbar`;\n      }\n      return [[\"kendoProgressBarLocalizedMessages\", \"\", \"progressBarLabel\", i18n_4], [1, \"k-reset\", \"k-progressbar-chunks\"], [\"class\", \"k-progressbar-chunk\", 3, \"k-first\", \"k-last\", \"k-selected\", \"ngClass\", \"ngStyle\", \"width\", \"height\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-progressbar-chunk\", 3, \"ngClass\", \"ngStyle\"]];\n    },\n    template: function _class5_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"ul\", 1);\n        i0.ɵɵtemplate(2, _class5_li_2_Template, 1, 12, \"li\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.chunks);\n      }\n    },\n    dependencies: [LocalizedProgressBarMessagesDirective, NgFor, NgClass, NgStyle],\n    encapsulation: 2\n  }));\n  return ChunkProgressBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive that selects a template within the `<kendo-circularprogessbar>` component which will be used for the center template.\n * ([see example]({% slug center_template_circularprogressbar %})).\n */\nlet CircularProgressbarCenterTemplateDirective = /*#__PURE__*/(() => {\n  var _class6;\n  class CircularProgressbarCenterTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class6 = CircularProgressbarCenterTemplateDirective;\n  _defineProperty(CircularProgressbarCenterTemplateDirective, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(CircularProgressbarCenterTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class6,\n    selectors: [[\"\", \"kendoCircularProgressbarCenterTemplate\", \"\"]],\n    standalone: true\n  }));\n  return CircularProgressbarCenterTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SURFACE_SIZE = 200;\n/**\n * Represents the [Kendo UI Circular ProgressBar component for Angular]({% slug overview_circularprogressbar %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-circularprogressbar [value]=\"value\"></kendo-circularprogressbar>\n *    `\n * })\n * class AppComponent {\n *     public value: number = 50;\n * }\n * ```\n */\nlet CircularProgressBarComponent = /*#__PURE__*/(() => {\n  var _class7;\n  class CircularProgressBarComponent {\n    get ariaMinAttribute() {\n      return String(this.min);\n    }\n    get ariaMaxAttribute() {\n      return String(this.max);\n    }\n    get ariaValueAttribute() {\n      return this.indeterminate ? undefined : String(this.value);\n    }\n    /**\n     * Sets the default value of the Circular Progressbar between `min` and `max`.\n     *\n     * @default 0\n     */\n    set value(value) {\n      if (value > this.max) {\n        this.handleErrors('value > max');\n      }\n      if (value < this.min) {\n        this.handleErrors('value < min');\n      }\n      this.previousValue = this.value;\n      this._value = value;\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * The maximum value which the Circular Progressbar can accept.\n     *\n     * @default 100\n     */\n    set max(max) {\n      if (max < this.min) {\n        this.handleErrors('max < min');\n      }\n      this._max = max;\n    }\n    get max() {\n      return this._max;\n    }\n    /**\n     * The minimum value which the Circular Progressbar can accept.\n     *\n     * @default 0\n     */\n    set min(min) {\n      if (min > this.max) {\n        this.handleErrors('max < min');\n      }\n      this._min = min;\n    }\n    get min() {\n      return this._min;\n    }\n    /**\n     * Indicates whether an animation will be played on value changes.\n     *\n     * @default false\n     */\n\n    /**\n     * Puts the Circular ProgressBar in indeterminate state.\n     * @default false\n     */\n    set indeterminate(indeterminate) {\n      this._indeterminate = indeterminate;\n    }\n    get indeterminate() {\n      return this._indeterminate;\n    }\n    /**\n     * Configures the pointer color. Could be set to a single color string or customized per progress stages.\n     */\n\n    constructor(renderer, cdr, localization, element, zone) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"roleAttribute\", 'progressbar');\n      _defineProperty(this, \"animation\", false);\n      /**\n       * The opacity of the value arc.\n       * @default 1\n       */\n      _defineProperty(this, \"opacity\", 1);\n      _defineProperty(this, \"progressColor\", void 0);\n      /**\n       * Fires when the animation which indicates the latest value change is completed.\n       */\n      _defineProperty(this, \"animationEnd\", new EventEmitter());\n      _defineProperty(this, \"progress\", void 0);\n      _defineProperty(this, \"scale\", void 0);\n      _defineProperty(this, \"labelElement\", void 0);\n      _defineProperty(this, \"surface\", void 0);\n      _defineProperty(this, \"centerTemplate\", void 0);\n      _defineProperty(this, \"centerTemplateContext\", {});\n      _defineProperty(this, \"_indeterminate\", false);\n      _defineProperty(this, \"_max\", 100);\n      _defineProperty(this, \"_min\", 0);\n      _defineProperty(this, \"_value\", 0);\n      _defineProperty(this, \"previousValue\", 0);\n      _defineProperty(this, \"internalValue\", 0);\n      _defineProperty(this, \"rtl\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.element = element;\n      this.zone = zone;\n      validatePackage(packageMetadata);\n      this.subscriptions.add(this.localization.changes.subscribe(this.rtlChange.bind(this)));\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const elem = this.element.nativeElement;\n      const ariaLabel = this.localization.get('progressBarLabel');\n      this.renderer.setAttribute(elem, 'aria-label', ariaLabel);\n      this.initProgressArc();\n    }\n    ngOnChanges(changes) {\n      const skipFirstChange = true;\n      if (isChanged('value', changes, skipFirstChange) && this.progress) {\n        if (this.animation) {\n          this.progressbarAnimation();\n        } else {\n          const value = this.value - this.min;\n          this.internalValue = changes['value'].currentValue;\n          this.calculateProgress(value);\n        }\n      }\n      if (changes['opacity'] && this.progress) {\n        setProgressBarStyles([{\n          method: 'setAttribute',\n          el: this.progress.nativeElement,\n          attr: 'opacity',\n          attrValue: this.opacity.toString()\n        }], this.renderer);\n      }\n      if (changes['indeterminate'] && !changes['indeterminate'].firstChange) {\n        this.indeterminateState();\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      this.setStyles();\n      const value = this.animation ? this.internalValue : this.value;\n      this.calculateProgress(value);\n      this.updateCenterTemplate(value);\n    }\n    initProgressArc() {\n      this.setStyles();\n      if (this.indeterminate) {\n        this.indeterminateState();\n      } else {\n        if (!this.animation) {\n          const value = this.value - this.min;\n          this.calculateProgress(value);\n        } else {\n          this.progressbarAnimation();\n        }\n      }\n    }\n    calculateProgress(value) {\n      if (this.progressColor) {\n        this.updateProgressColor(value);\n      }\n      // needed when we have *ngIf inside the template to render different content depending on some condition\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        this.updateCenterTemplate(value + this.min);\n      });\n      const progressArc = this.progress.nativeElement;\n      const radius = this.progress.nativeElement.r.baseVal.value;\n      const circumference = Math.PI * (radius * 2);\n      const dir = this.rtl ? circumference * -1 : circumference;\n      const strokeDashOffest = circumference - dir * (value / (this.max - this.min));\n      const progressCalculations = [{\n        method: 'setStyle',\n        el: progressArc,\n        attr: 'strokeDasharray',\n        attrValue: circumference.toString()\n      }, {\n        method: 'setStyle',\n        el: progressArc,\n        attr: 'strokeDashoffset',\n        attrValue: strokeDashOffest.toString()\n      }];\n      setProgressBarStyles(progressCalculations, this.renderer);\n    }\n    progressbarAnimation() {\n      const forwardProgress = {\n        isOngoing: this.internalValue > this.value - this.min,\n        isPositive: this.value >= this.previousValue\n      };\n      const backwardProgress = {\n        isOngoing: this.internalValue < this.value - this.min,\n        isNegative: this.value <= this.previousValue\n      };\n      if (forwardProgress.isOngoing && forwardProgress.isPositive || backwardProgress.isOngoing && backwardProgress.isNegative) {\n        return;\n      }\n      this.calculateProgress(this.internalValue);\n      const from = this.internalValue;\n      if (hasObservers(this.animationEnd)) {\n        this.animationEnd.emit({\n          from: from,\n          to: this.internalValue\n        });\n      }\n      // eslint-disable-next-line no-unused-expressions\n      forwardProgress.isPositive ? this.internalValue += 1 : this.internalValue -= 1;\n      requestAnimationFrame(this.progressbarAnimation.bind(this));\n    }\n    setStyles() {\n      const progressArc = this.progress.nativeElement;\n      const scale = this.scale.nativeElement;\n      const surface = this.surface.nativeElement;\n      const element = this.element.nativeElement;\n      let elWidth = element.getBoundingClientRect().width;\n      if (!hasElementSize(element)) {\n        const surfaceSize = [{\n          method: 'setStyle',\n          el: surface,\n          attr: 'width',\n          attrValue: `${DEFAULT_SURFACE_SIZE}px`\n        }, {\n          method: 'setStyle',\n          el: surface,\n          attr: 'height',\n          attrValue: `${DEFAULT_SURFACE_SIZE}px`\n        }];\n        elWidth = DEFAULT_SURFACE_SIZE;\n        setProgressBarStyles(surfaceSize, this.renderer);\n      }\n      const attributesArray = [{\n        method: 'setAttribute',\n        el: progressArc,\n        attr: 'r',\n        attrValue: String(elWidth / 2 - 10)\n      }, {\n        method: 'setAttribute',\n        el: progressArc,\n        attr: 'cx',\n        attrValue: String(elWidth / 2)\n      }, {\n        method: 'setAttribute',\n        el: progressArc,\n        attr: 'cy',\n        attrValue: String(elWidth / 2)\n      }, {\n        method: 'setAttribute',\n        el: progressArc,\n        attr: 'opacity',\n        attrValue: String(this.opacity)\n      }, {\n        method: 'setAttribute',\n        el: scale,\n        attr: 'r',\n        attrValue: String(elWidth / 2 - 10)\n      }, {\n        method: 'setAttribute',\n        el: scale,\n        attr: 'cx',\n        attrValue: String(elWidth / 2)\n      }, {\n        method: 'setAttribute',\n        el: scale,\n        attr: 'cy',\n        attrValue: String(elWidth / 2)\n      }];\n      setProgressBarStyles(attributesArray, this.renderer);\n    }\n    indeterminateState() {\n      const progressArc = this.progress.nativeElement;\n      if (this.indeterminate) {\n        // the indeterminate state wont work as the `k-circular-progressbar-arc` has a transform: rotate(-90deg) which is\n        // interfering with the svg animation as the animateTransform brings its own transform: rotate()\n        // This will be like this until the themes release a new version, bringing a new class `k-circular-progressbar-indeterminate-arc`\n        // containing only the necassery CSS styles and we will switch between them when the state of the progressbar is switched.\n        this.calculateProgress(this.value - this.min);\n        const rotate = this.rtl ? {\n          from: 360,\n          to: 0\n        } : {\n          from: 0,\n          to: 360\n        };\n        let color;\n        if (!this.progressColor) {\n          color = getComputedStyle(progressArc).stroke;\n        }\n        const indeterminateStyles = [{\n          method: 'setStyle',\n          el: progressArc,\n          attr: 'transform-origin',\n          attrValue: 'center'\n        }, {\n          method: 'setStyle',\n          el: progressArc,\n          attr: 'fill',\n          attrValue: 'none'\n        }, {\n          method: 'setStyle',\n          el: progressArc,\n          attr: 'stroke-linecap',\n          attrValue: 'round'\n        }, {\n          method: 'setStyle',\n          el: progressArc,\n          attr: 'stroke',\n          attrValue: color ? color : this.currentColor\n        }];\n        setProgressBarStyles(indeterminateStyles, this.renderer);\n        this.renderer.removeClass(progressArc, 'k-circular-progressbar-arc');\n        progressArc.innerHTML = `<animateTransform attributeName=\"transform\" type=\"rotate\" from=\"${rotate.from} 0 0\" to=\"${rotate.to} 0 0\" dur=\"1s\" repeatCount=\"indefinite\" />`;\n      } else {\n        this.renderer.addClass(progressArc, 'k-circular-progressbar-arc');\n        const removeIndeterminateStyles = [{\n          method: 'removeStyle',\n          el: progressArc,\n          attr: 'transform-origin'\n        }, {\n          method: 'removeStyle',\n          el: progressArc,\n          attr: 'fill'\n        }, {\n          method: 'removeStyle',\n          el: progressArc,\n          attr: 'stroke-linecap'\n        }];\n        removeProgressBarStyles(removeIndeterminateStyles, this.renderer);\n        progressArc.innerHTML = '';\n        if (this.animation) {\n          this.progressbarAnimation();\n        }\n      }\n    }\n    updateCenterTemplate(value) {\n      if (!this.centerTemplate) {\n        return;\n      }\n      this.centerTemplateContext.value = value;\n      this.centerTemplateContext.color = this.currentColor;\n      this.cdr.detectChanges();\n      this.positionLabel();\n    }\n    positionLabel() {\n      const labelEl = this.labelElement.nativeElement;\n      const element = this.element.nativeElement;\n      const surface = this.surface.nativeElement;\n      let elWidth;\n      let elHeight;\n      if (!hasElementSize(element)) {\n        const surfaceSize = surface.getBoundingClientRect();\n        elWidth = surfaceSize.width;\n        elHeight = surfaceSize.height;\n      } else {\n        const elementSize = element.getBoundingClientRect();\n        elWidth = elementSize.width;\n        elHeight = elementSize.height;\n      }\n      const left = elWidth / 2 - labelEl.offsetWidth / 2;\n      const top = elHeight / 2 - labelEl.offsetHeight / 2;\n      const labelCalculations = [{\n        method: 'setStyle',\n        el: labelEl,\n        attr: 'left',\n        attrValue: `${left}px`\n      }, {\n        method: 'setStyle',\n        el: labelEl,\n        attr: 'top',\n        attrValue: `${top}px`\n      }];\n      setProgressBarStyles(labelCalculations, this.renderer);\n    }\n    get currentColor() {\n      const currentColor = this.progress.nativeElement.style.stroke;\n      return currentColor;\n    }\n    updateProgressColor(value) {\n      const progressArc = this.progress.nativeElement;\n      if (typeof this.progressColor === 'string') {\n        this.renderer.setStyle(progressArc, 'stroke', this.progressColor);\n      } else {\n        for (let i = 0; i < this.progressColor.length; i++) {\n          const from = this.progressColor[i].from;\n          const to = this.progressColor[i].to;\n          if (value >= from && value <= to || !from && value <= to) {\n            this.renderer.setStyle(progressArc, 'stroke', this.progressColor[i].color);\n            break;\n          }\n          if (!to && value >= from) {\n            this.renderer.setStyle(progressArc, 'stroke', this.progressColor[i].color);\n          }\n        }\n      }\n    }\n    handleErrors(type) {\n      if (isDevMode()) {\n        switch (type) {\n          case 'value > max':\n            throw new Error('The value of the CircularProgressbar cannot exceed the max value');\n          case 'value < min':\n            throw new Error('The value of the CircularProgressbar cannot be lower than the min value');\n          case 'max < min':\n            throw new Error('The min value cannot be higher than the max value');\n          default:\n        }\n      }\n    }\n    setDirection() {\n      this.rtl = this.localization.rtl;\n      if (this.element) {\n        this.renderer.setAttribute(this.element.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');\n      }\n      if (this.labelElement) {\n        this.renderer.setAttribute(this.labelElement.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');\n      }\n    }\n    rtlChange() {\n      if (this.element && this.rtl !== this.localization.rtl) {\n        this.setDirection();\n      }\n    }\n  }\n  _class7 = CircularProgressBarComponent;\n  _defineProperty(CircularProgressBarComponent, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(CircularProgressBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class7,\n    selectors: [[\"kendo-circularprogressbar\"]],\n    contentQueries: function _class7_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CircularProgressbarCenterTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.centerTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class7_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 5);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 5);\n        i0.ɵɵviewQuery(_c9, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.progress = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scale = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.surface = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function _class7_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.ariaMinAttribute)(\"aria-valuemax\", ctx.ariaMaxAttribute)(\"aria-valuenow\", ctx.ariaValueAttribute)(\"role\", ctx.roleAttribute);\n        i0.ɵɵclassProp(\"k-circular-progressbar\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      max: \"max\",\n      min: \"min\",\n      animation: \"animation\",\n      opacity: \"opacity\",\n      indeterminate: \"indeterminate\",\n      progressColor: \"progressColor\"\n    },\n    outputs: {\n      animationEnd: \"animationEnd\"\n    },\n    exportAs: [\"kendoCircularProgressBar\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.circularprogressbar'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 13,\n    vars: 1,\n    consts: function () {\n      let i18n_10;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label attribute for the Circular ProgressBar component.\n         * @meaning kendo.circularprogressbar.progressBarLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_11 = goog.getMsg(\"Circular progressbar\");\n        i18n_10 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_11;\n      } else {\n        i18n_10 = $localize`:kendo.circularprogressbar.progressBarLabel|The aria-label attribute for the Circular ProgressBar component.:Circular progressbar`;\n      }\n      return [[\"kendoProgressBarLocalizedMessages\", \"\", \"progressBarLabel\", i18n_10], [1, \"k-circular-progressbar-surface\"], [\"surface\", \"\"], [\"svg\", \"\"], [\"stroke-width\", \"9.5\", 1, \"k-circular-progressbar-scale\"], [\"scale\", \"\"], [\"stroke-width\", \"9.5\", 1, \"k-circular-progressbar-arc\"], [\"progress\", \"\"], [\"class\", \"k-circular-progressbar-label\", 4, \"ngIf\"], [3, \"resize\"], [1, \"k-circular-progressbar-label\"], [\"label\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]];\n    },\n    template: function _class7_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"div\");\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(4, \"svg\", null, 3)(6, \"g\");\n        i0.ɵɵelement(7, \"circle\", 4, 5)(9, \"circle\", 6, 7);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(11, _class7_div_11_Template, 3, 2, \"div\", 8);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(12, \"kendo-resize-sensor\", 9);\n        i0.ɵɵlistener(\"resize\", function _class7_Template_kendo_resize_sensor_resize_12_listener() {\n          return ctx.onResize();\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(11);\n        i0.ɵɵproperty(\"ngIf\", ctx.centerTemplate);\n      }\n    },\n    dependencies: [LocalizedProgressBarMessagesDirective, NgIf, NgTemplateOutlet, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return CircularProgressBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\nlet ProgressBarCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class8;\n  class ProgressBarCustomMessagesComponent extends ProgressBarMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class8 = ProgressBarCustomMessagesComponent;\n  _defineProperty(ProgressBarCustomMessagesComponent, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ProgressBarCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class8,\n    selectors: [[\"kendo-progressbar-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ProgressBarMessages,\n      useExisting: forwardRef(() => _class8)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class8_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ProgressBarCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `ChunkProgressBar` related components and directives\n */\nconst KENDO_CHUNKPROGRESSBAR = [ChunkProgressBarComponent, ProgressBarCustomMessagesComponent];\n/**\n * Utility array that contains all `CircularProgressBar` related components and directives\n */\nconst KENDO_CIRCULARPROGRESSBAR = [CircularProgressbarCenterTemplateDirective, CircularProgressBarComponent, ProgressBarCustomMessagesComponent];\n/**\n * Utility array that contains all `ProgressBar` related components and directives\n */\nconst KENDO_PROGRESSBAR = [ProgressBarComponent, ProgressBarCustomMessagesComponent];\n/**\n * Utility array that contains all `@progress/kendo-angular-progressbar` related components and directives\n */\nconst KENDO_PROGRESSBARS = [...KENDO_CHUNKPROGRESSBAR, ...KENDO_CIRCULARPROGRESSBAR, ...KENDO_PROGRESSBAR];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the ProgressBar components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the ProgressBar module\n * import { ProgressBarModule } from '@progress/kendo-angular-progressbar';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ProgressBarModule], // import ProgressBar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet ProgressBarModule = /*#__PURE__*/(() => {\n  var _class9;\n  class ProgressBarModule {}\n  _class9 = ProgressBarModule;\n  _defineProperty(ProgressBarModule, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)();\n  });\n  _defineProperty(ProgressBarModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class9\n  }));\n  _defineProperty(ProgressBarModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ResizeBatchService],\n    imports: [CircularProgressBarComponent]\n  }));\n  return ProgressBarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ChunkProgressBarComponent, CircularProgressBarComponent, CircularProgressbarCenterTemplateDirective, KENDO_CHUNKPROGRESSBAR, KENDO_CIRCULARPROGRESSBAR, KENDO_PROGRESSBAR, KENDO_PROGRESSBARS, LocalizedProgressBarMessagesDirective, ProgressBarComponent, ProgressBarCustomMessagesComponent, ProgressBarModule };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}