{"ast":null,"code":"import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\nconst formatDate = ({\n  utcDates\n}) => ({\n  field,\n  value,\n  ignoreCase,\n  operator\n}) => ({\n  value: (!utcDates ? toUTC(value) : value).toISOString(),\n  field,\n  ignoreCase,\n  operator\n});\nconst fnFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${operator}(${field},${value})`;\nconst singleOperatorFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${field} ${operator} ${value}`;\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\nconst appendEqual = str => `${str} eq -1`;\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\nconst filterOperators = (operator, settings) => ({\n  contains: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"contains\"\n  })),\n  doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"indexof\"\n  }))),\n  endswith: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"endswith\"\n  })),\n  eq: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"eq\"\n  })),\n  gt: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"gt\"\n  })),\n  gte: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"ge\"\n  })),\n  isempty: nonValueExpression(({\n    field\n  }) => `${field} eq ''`),\n  isnotempty: nonValueExpression(({\n    field\n  }) => `${field} ne ''`),\n  isnotnull: nonValueExpression(({\n    field\n  }) => `${field} ne null`),\n  isnull: nonValueExpression(({\n    field\n  }) => `${field} eq null`),\n  lt: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"lt\"\n  })),\n  lte: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"le\"\n  })),\n  neq: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"ne\"\n  })),\n  startswith: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"startswith\"\n  }))\n})[operator];\nconst join = x => ` ${x.logic} `;\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\nexport const serializeFilter = (filter, settings = {}) => {\n  if (filter.filters && filter.filters.length) {\n    return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n  }\n  return \"\";\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}