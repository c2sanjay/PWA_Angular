{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, inject, ElementRef, Directive, ViewChild, Input, Output, forwardRef, Component, HostBinding, ViewContainerRef, ContentChildren, HostListener, isDevMode, ViewChildren, NgModule } from '@angular/core';\nimport * as i2 from '@progress/kendo-angular-popup';\nimport { PopupService } from '@progress/kendo-angular-popup';\nimport { Keys, isDocumentAvailable, guid, ResizeSensorComponent, ResizeBatchService } from '@progress/kendo-angular-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { take, filter, takeUntil } from 'rxjs/operators';\nimport { Subject, Subscription, merge, fromEvent } from 'rxjs';\nimport { caretAltLeftIcon, caretAltRightIcon, moreHorizontalIcon, moreVerticalIcon, caretAltDownIcon } from '@progress/kendo-svg-icons';\nimport { ButtonComponent, ButtonGroupComponent, DropDownButtonComponent, SplitButtonComponent } from '@progress/kendo-angular-buttons';\nimport { NgTemplateOutlet, NgFor, NgIf, NgClass, NgStyle } from '@angular/common';\nimport { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\n\n/**\n * @hidden\n */\nconst _c0 = [\"toolbarTemplate\"];\nconst _c1 = [\"sectionTemplate\"];\nconst _c2 = [\"popupTemplate\"];\nconst _c3 = [\"kendoToolbarScrollableButton\", \"\"];\nconst _c4 = [\"overflowButton\"];\nconst _c5 = [\"popupSectionTemplate\"];\nconst _c6 = [\"scrollContainer\"];\nconst _c7 = [\"resizeSensor\"];\nconst _c8 = [\"container\"];\nconst _c9 = [\"prevScrollButton\"];\nconst _c10 = [\"nextScrollButton\"];\nconst _c11 = [\"startButtonGroup\"];\nconst _c12 = [\"endButtonGroup\"];\nconst _c13 = [\"scrollSeparator\"];\nconst _c20 = function (a0, a1, a2) {\n  return {\n    \"k-button-sm\": a0,\n    \"k-button-md\": a1,\n    \"k-button-lg\": a2\n  };\n};\nfunction _class12_ng_container_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 13, 14);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_1_span_1_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r17.scrollTools($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"prev\", true)(\"overflow\", ctx_r13.normalizedOverflow)(\"title\", ctx_r13.getScrollButtonTitle(\"prev\"))(\"ngClass\", i0.ɵɵpureFunction3(4, _c20, ctx_r13.size === \"small\", ctx_r13.size === \"medium\" || !ctx_r13.size, ctx_r13.size === \"large\"));\n  }\n}\nfunction _class12_ng_container_1_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15, 16)(2, \"span\", 13, 14);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_1_div_2_Template_span_onClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r22.scrollTools($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 17, 18);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_1_div_2_Template_span_onClick_4_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r24.scrollTools($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"prev\", true)(\"overflow\", ctx_r14.normalizedOverflow)(\"title\", ctx_r14.getScrollButtonTitle(\"prev\"))(\"ngClass\", i0.ɵɵpureFunction3(8, _c20, ctx_r14.size === \"small\", ctx_r14.size === \"medium\" || !ctx_r14.size, ctx_r14.size === \"large\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"prev\", false)(\"overflow\", ctx_r14.normalizedOverflow)(\"title\", ctx_r14.getScrollButtonTitle(\"next\"))(\"ngClass\", i0.ɵɵpureFunction3(12, _c20, ctx_r14.size === \"small\", ctx_r14.size === \"medium\" || !ctx_r14.size, ctx_r14.size === \"large\"));\n  }\n}\nfunction _class12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class12_ng_container_1_span_1_Template, 2, 8, \"span\", 9);\n    i0.ɵɵtemplate(2, _class12_ng_container_1_div_2_Template, 6, 16, \"div\", 10);\n    i0.ɵɵelement(3, \"div\", 11, 12);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.hasScrollButtons.position === \"split\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.hasScrollButtons.position === \"start\");\n  }\n}\nfunction _class12_div_2_ng_container_2_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵelementContainer(1, 25);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const tool_r27 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tool_r27.toolbarTemplate);\n  }\n}\nfunction _class12_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0, 22);\n    i0.ɵɵlistener(\"rendererClick\", function _class12_div_2_ng_container_2_Template_ng_container_rendererClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r32.onRendererClick($event));\n    });\n    i0.ɵɵtemplate(1, _class12_div_2_ng_container_2_ng_template_1_Template, 2, 1, \"ng-template\", null, 23, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const tool_r27 = ctx.$implicit;\n    const _r29 = i0.ɵɵreference(2);\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"tool\", tool_r27)(\"resizable\", ctx_r26.resizable)(\"ngTemplateOutlet\", tool_r27.isBuiltInTool ? tool_r27.toolbarTemplate : _r29);\n  }\n}\nfunction _class12_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 19, 20);\n    i0.ɵɵtemplate(2, _class12_div_2_ng_container_2_Template, 3, 3, \"ng-container\", 21);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.allTools);\n  }\n}\nfunction _class12_ng_template_3_ng_container_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵelementContainer(1, 25);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const tool_r35 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tool_r35.toolbarTemplate);\n  }\n}\nfunction _class12_ng_template_3_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0, 22);\n    i0.ɵɵlistener(\"rendererClick\", function _class12_ng_template_3_ng_container_0_Template_ng_container_rendererClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n      const ctx_r40 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r40.onRendererClick($event));\n    });\n    i0.ɵɵtemplate(1, _class12_ng_template_3_ng_container_0_ng_template_1_Template, 2, 1, \"ng-template\", null, 23, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const tool_r35 = ctx.$implicit;\n    const _r37 = i0.ɵɵreference(2);\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"tool\", tool_r35)(\"resizable\", ctx_r34.resizable)(\"ngTemplateOutlet\", tool_r35.isBuiltInTool ? tool_r35.toolbarTemplate : _r37);\n  }\n}\nfunction _class12_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class12_ng_template_3_ng_container_0_Template, 3, 3, \"ng-container\", 21);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.allTools);\n  }\n}\nfunction _class12_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 11);\n  }\n}\nfunction _class12_button_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 26, 27);\n    i0.ɵɵlistener(\"click\", function _class12_button_6_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r44);\n      const ctx_r43 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r43.showPopup());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"position\", \"relative\");\n    i0.ɵɵproperty(\"icon\", ctx_r5.overflowButtonIcon(\"font\"))(\"svgIcon\", ctx_r5.overflowButtonIcon(\"svg\"))(\"title\", ctx_r5.moreToolsTitle)(\"id\", ctx_r5.overflowBtnId)(\"ngClass\", ctx_r5.overflowClass);\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.moreToolsTitle)(\"aria-expanded\", ctx_r5.popupOpen)(\"aria-haspopup\", ctx_r5.normalizedOverflow.mode === \"section\" ? null : \"menu\");\n  }\n}\nfunction _class12_ng_container_7_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r50 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 17, 18);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_7_span_3_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r50);\n      const ctx_r49 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r49.scrollTools($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r46 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"prev\", false)(\"overflow\", ctx_r46.normalizedOverflow)(\"title\", ctx_r46.getScrollButtonTitle(\"next\"))(\"ngClass\", i0.ɵɵpureFunction3(4, _c20, ctx_r46.size === \"small\", ctx_r46.size === \"medium\" || !ctx_r46.size, ctx_r46.size === \"large\"));\n  }\n}\nfunction _class12_ng_container_7_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r55 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15, 29)(2, \"span\", 13, 14);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_7_div_4_Template_span_onClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r55);\n      const ctx_r54 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r54.scrollTools($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 17, 18);\n    i0.ɵɵlistener(\"onClick\", function _class12_ng_container_7_div_4_Template_span_onClick_4_listener($event) {\n      i0.ɵɵrestoreView(_r55);\n      const ctx_r56 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r56.scrollTools($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"prev\", true)(\"overflow\", ctx_r47.normalizedOverflow)(\"title\", ctx_r47.getScrollButtonTitle(\"prev\"))(\"ngClass\", i0.ɵɵpureFunction3(8, _c20, ctx_r47.size === \"small\", ctx_r47.size === \"medium\" || !ctx_r47.size, ctx_r47.size === \"large\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"prev\", false)(\"overflow\", ctx_r47.normalizedOverflow)(\"title\", ctx_r47.getScrollButtonTitle(\"next\"))(\"ngClass\", i0.ɵɵpureFunction3(12, _c20, ctx_r47.size === \"small\", ctx_r47.size === \"medium\" || !ctx_r47.size, ctx_r47.size === \"large\"));\n  }\n}\nfunction _class12_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"div\", 11, 12);\n    i0.ɵɵtemplate(3, _class12_ng_container_7_span_3_Template, 2, 8, \"span\", 28);\n    i0.ɵɵtemplate(4, _class12_ng_container_7_div_4_Template, 6, 16, \"div\", 10);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasScrollButtons.position === \"split\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasScrollButtons.position === \"end\");\n  }\n}\nfunction _class12_ng_template_8_ng_container_1_1_ng_template_0_Template(rf, ctx) {}\nfunction _class12_ng_template_8_ng_container_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r65 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class12_ng_template_8_ng_container_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 33);\n    i0.ɵɵlistener(\"rendererClick\", function _class12_ng_template_8_ng_container_1_1_Template_ng_template_rendererClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r65);\n      const ctx_r64 = i0.ɵɵnextContext(3);\n      return i0.ɵɵresetView(ctx_r64.onRendererClick($event));\n    });\n  }\n  if (rf & 2) {\n    const tool_r58 = i0.ɵɵnextContext().$implicit;\n    const _r61 = i0.ɵɵreference(3);\n    const ctx_r60 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"tool\", tool_r58)(\"resizable\", ctx_r60.resizable)(\"ngTemplateOutlet\", tool_r58.isBuiltInTool ? tool_r58.popupTemplate : _r61);\n  }\n}\nfunction _class12_ng_template_8_ng_container_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 34);\n    i0.ɵɵelementContainer(1, 25);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const tool_r58 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tool_r58.popupTemplate);\n  }\n}\nfunction _class12_ng_template_8_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class12_ng_template_8_ng_container_1_1_Template, 1, 3, null, 1);\n    i0.ɵɵtemplate(2, _class12_ng_template_8_ng_container_1_ng_template_2_Template, 2, 1, \"ng-template\", null, 32, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const tool_r58 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", tool_r58.popupTemplate);\n  }\n}\nfunction _class12_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 30);\n    i0.ɵɵtemplate(1, _class12_ng_template_8_ng_container_1_Template, 4, 1, \"ng-container\", 31);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r8.popupId);\n    i0.ɵɵattribute(\"dir\", ctx_r8.direction === \"rtl\" ? \"rtl\" : null)(\"aria-labelledby\", ctx_r8.overflowBtnId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r8.overflowTools);\n  }\n}\nfunction _class12_ng_template_10_ng_container_1_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 25);\n  }\n  if (rf & 2) {\n    const tool_r69 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tool_r69.sectionTemplate);\n  }\n}\nfunction _class12_ng_template_10_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r75 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0, 37);\n    i0.ɵɵlistener(\"rendererClick\", function _class12_ng_template_10_ng_container_1_Template_ng_container_rendererClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r75);\n      const ctx_r74 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r74.onRendererClick($event));\n    });\n    i0.ɵɵtemplate(1, _class12_ng_template_10_ng_container_1_ng_template_1_Template, 1, 1, \"ng-template\", null, 23, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const tool_r69 = ctx.$implicit;\n    const _r71 = i0.ɵɵreference(2);\n    const ctx_r68 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"tool\", tool_r69)(\"resizable\", ctx_r68.resizable)(\"ngTemplateOutlet\", tool_r69.isBuiltInTool ? tool_r69.sectionTemplate : _r71);\n  }\n}\nfunction _class12_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 35);\n    i0.ɵɵtemplate(1, _class12_ng_template_10_ng_container_1_Template, 3, 3, \"ng-container\", 36);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r10.sectionSizeClass)(\"id\", ctx_r10.popupId);\n    i0.ɵɵattribute(\"dir\", ctx_r10.direction === \"rtl\" ? \"rtl\" : null)(\"aria-labelledby\", ctx_r10.overflowBtnId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r10.overflowTools);\n  }\n}\nfunction _class12_kendo_resize_sensor_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\", null, 38);\n  }\n}\nconst _c21 = [\"toolbarButton\"];\nconst _c22 = [\"sectionButton\"];\nfunction _class13_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 3, 4);\n    i0.ɵɵlistener(\"click\", function _class13_ng_template_0_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.click.emit($event));\n    })(\"pointerdown\", function _class13_ng_template_0_Template_button_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.pointerdown.emit($event));\n    })(\"selectedChange\", function _class13_ng_template_0_Template_button_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.selectedChangeHandler($event));\n    })(\"blur\", function _class13_ng_template_0_Template_button_blur_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.onBlur());\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-toolbar-button\", !ctx_r1.toggleable)(\"k-toolbar-toggle-button\", ctx_r1.toggleable);\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.tabIndex)(\"ngStyle\", ctx_r1.style)(\"ngClass\", ctx_r1.className)(\"disabled\", ctx_r1.disabled)(\"toggleable\", ctx_r1.toggleable)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null)(\"selected\", ctx_r1.selected)(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"svgIcon\", ctx_r1.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", ctx_r1.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.toolbarOptions.text, \" \");\n  }\n}\nfunction _class13_ng_template_2_kendo_icon_wrapper_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r13.overflowOptions.icon)(\"customFontClass\", ctx_r13.overflowOptions.iconClass)(\"svgIcon\", ctx_r13.overflowOptions.svgIcon);\n  }\n}\nfunction _class13_ng_template_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r14.overflowOptions.text);\n  }\n}\nfunction _class13_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5, 6);\n    i0.ɵɵlistener(\"click\", function _class13_ng_template_2_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r15.handleClick($event));\n    });\n    i0.ɵɵelementStart(2, \"span\", 7);\n    i0.ɵɵtemplate(3, _class13_ng_template_2_kendo_icon_wrapper_3_Template, 1, 3, \"kendo-icon-wrapper\", 8);\n    i0.ɵɵtemplate(4, _class13_ng_template_2_span_4_Template, 2, 1, \"span\", 9);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r3.disabled);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.className)(\"ngStyle\", ctx_r3.style);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-selected\", ctx_r3.selected);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.icon || ctx_r3.overflowOptions.iconClass || ctx_r3.overflowOptions.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.text);\n  }\n}\nfunction _class13_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 3, 12);\n    i0.ɵɵlistener(\"click\", function _class13_ng_template_4_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.click.emit($event));\n    })(\"pointerdown\", function _class13_ng_template_4_Template_button_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r20.pointerdown.emit($event));\n    })(\"selectedChange\", function _class13_ng_template_4_Template_button_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r21.selectedChangeHandler($event));\n    })(\"blur\", function _class13_ng_template_4_Template_button_blur_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r22.onBlur());\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-toolbar-button\", !ctx_r5.toggleable)(\"k-toolbar-toggle-button\", ctx_r5.toggleable);\n    i0.ɵɵproperty(\"tabindex\", ctx_r5.tabIndex)(\"ngStyle\", ctx_r5.style)(\"ngClass\", ctx_r5.className)(\"disabled\", ctx_r5.disabled)(\"toggleable\", ctx_r5.toggleable)(\"fillMode\", ctx_r5.fillMode)(\"themeColor\", ctx_r5.fillMode ? ctx_r5.themeColor : null)(\"selected\", ctx_r5.selected)(\"icon\", ctx_r5.toolbarOptions.icon)(\"iconClass\", ctx_r5.toolbarOptions.iconClass)(\"svgIcon\", ctx_r5.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r5.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", ctx_r5.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.toolbarOptions.text, \" \");\n  }\n}\nconst _c23 = [\"toolbarButtonGroup\"];\nconst _c24 = [\"sectionButtonGroup\"];\nconst _c25 = [\"listItem\"];\nfunction _class14_ng_template_0_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function _class14_ng_template_0_button_2_Template_button_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r10);\n      const button_r8 = restoredCtx.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      button_r8.click.emit($event);\n      return i0.ɵɵresetView(ctx_r9.onButtonClick($event));\n    })(\"pointerdown\", function _class14_ng_template_0_button_2_Template_button_pointerdown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r10);\n      const button_r8 = restoredCtx.$implicit;\n      return i0.ɵɵresetView(button_r8.pointerdown.emit($event));\n    })(\"selectedChange\", function _class14_ng_template_0_button_2_Template_button_selectedChange_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r10);\n      const button_r8 = restoredCtx.$implicit;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.selectedChangeHandler($event, button_r8));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const button_r8 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", button_r8.style)(\"ngClass\", button_r8.className)(\"disabled\", button_r8.disabled)(\"togglable\", button_r8.togglable)(\"selected\", button_r8.selected)(\"fillMode\", button_r8.fillMode)(\"themeColor\", button_r8.fillMode ? button_r8.themeColor : null)(\"icon\", button_r8.toolbarOptions.icon)(\"iconClass\", button_r8.toolbarOptions.iconClass)(\"svgIcon\", button_r8.toolbarOptions.svgIcon)(\"imageUrl\", button_r8.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", button_r8.title)(\"aria-pressed\", button_r8.selected ? true : false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", button_r8.toolbarOptions.text, \" \");\n  }\n}\nfunction _class14_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-buttongroup\", 3, 4);\n    i0.ɵɵlistener(\"navigate\", function _class14_ng_template_0_Template_kendo_buttongroup_navigate_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.onNavigate($event));\n    })(\"focus\", function _class14_ng_template_0_Template_kendo_buttongroup_focus_0_listener() {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r15.onFocus());\n    });\n    i0.ɵɵtemplate(2, _class14_ng_template_0_button_2_Template, 2, 14, \"button\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"k-toolbar-button-group k-button-group-\", ctx_r1.fillMode, \"\");\n    i0.ɵɵproperty(\"tabIndex\", -1)(\"selection\", ctx_r1.selection)(\"disabled\", ctx_r1.disabled)(\"width\", ctx_r1.width);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.buttonComponents);\n  }\n}\nfunction _class14_ng_template_2_div_0_kendo_icon_wrapper_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 13);\n  }\n  if (rf & 2) {\n    const button_r17 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"name\", button_r17.overflowOptions.icon)(\"customFontClass\", button_r17.overflowOptions.iconClass)(\"svgIcon\", button_r17.overflowOptions.svgIcon);\n  }\n}\nfunction _class14_ng_template_2_div_0_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 14);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const button_r17 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(button_r17.overflowOptions.text);\n  }\n}\nfunction _class14_ng_template_2_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 8, 9);\n    i0.ɵɵlistener(\"click\", function _class14_ng_template_2_div_0_Template_div_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r24);\n      const button_r17 = restoredCtx.$implicit;\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r23.handleClick($event, button_r17));\n    });\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵtemplate(3, _class14_ng_template_2_div_0_kendo_icon_wrapper_3_Template, 1, 3, \"kendo-icon-wrapper\", 11);\n    i0.ɵɵtemplate(4, _class14_ng_template_2_div_0_span_4_Template, 2, 1, \"span\", 12);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const button_r17 = ctx.$implicit;\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r16.disabled || button_r17.disabled);\n    i0.ɵɵproperty(\"ngStyle\", button_r17.style)(\"ngClass\", button_r17.className);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-selected\", button_r17.selected);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", button_r17.overflowOptions.icon || button_r17.overflowOptions.iconClass || button_r17.overflowOptions.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", button_r17.overflowOptions.text);\n  }\n}\nfunction _class14_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class14_ng_template_2_div_0_Template, 5, 8, \"div\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.buttonComponents);\n  }\n}\nfunction _class14_ng_template_4_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function _class14_ng_template_4_button_2_Template_button_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r29);\n      const button_r27 = restoredCtx.$implicit;\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      button_r27.click.emit($event);\n      return i0.ɵɵresetView(ctx_r28.onButtonClick($event));\n    })(\"pointerdown\", function _class14_ng_template_4_button_2_Template_button_pointerdown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r29);\n      const button_r27 = restoredCtx.$implicit;\n      return i0.ɵɵresetView(button_r27.pointerdown.emit($event));\n    })(\"selectedChange\", function _class14_ng_template_4_button_2_Template_button_selectedChange_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r29);\n      const button_r27 = restoredCtx.$implicit;\n      const ctx_r31 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r31.selectedChangeHandler($event, button_r27));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const button_r27 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", button_r27.style)(\"ngClass\", button_r27.className)(\"disabled\", button_r27.disabled)(\"togglable\", button_r27.togglable)(\"selected\", button_r27.selected)(\"fillMode\", button_r27.fillMode)(\"themeColor\", button_r27.fillMode ? button_r27.themeColor : null)(\"icon\", button_r27.toolbarOptions.icon)(\"iconClass\", button_r27.toolbarOptions.iconClass)(\"svgIcon\", button_r27.toolbarOptions.svgIcon)(\"imageUrl\", button_r27.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", button_r27.title)(\"aria-pressed\", button_r27.selected ? true : false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", button_r27.toolbarOptions.text, \" \");\n  }\n}\nfunction _class14_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-buttongroup\", 3, 15);\n    i0.ɵɵlistener(\"navigate\", function _class14_ng_template_4_Template_kendo_buttongroup_navigate_0_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r32.onNavigate($event));\n    })(\"focus\", function _class14_ng_template_4_Template_kendo_buttongroup_focus_0_listener() {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r34.onFocus());\n    });\n    i0.ɵɵtemplate(2, _class14_ng_template_4_button_2_Template, 2, 14, \"button\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"k-toolbar-button-group k-button-group-\", ctx_r5.fillMode, \"\");\n    i0.ɵɵproperty(\"tabIndex\", -1)(\"selection\", ctx_r5.selection)(\"disabled\", ctx_r5.disabled)(\"width\", ctx_r5.width);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r5.buttonComponents);\n  }\n}\nconst _c26 = [\"dropdownButton\"];\nconst _c27 = [\"toolbarDropDownButton\"];\nconst _c28 = [\"sectionDropDownButton\"];\nconst _c29 = function (a0) {\n  return {\n    \"title\": a0\n  };\n};\nfunction _class15_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownbutton\", 3, 4);\n    i0.ɵɵlistener(\"open\", function _class15_ng_template_0_Template_kendo_dropdownbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.open.emit($event));\n    })(\"close\", function _class15_ng_template_0_Template_kendo_dropdownbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.close.emit($event));\n    })(\"itemClick\", function _class15_ng_template_0_Template_kendo_dropdownbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.itemClick.emit($event));\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"svgIcon\", ctx_r1.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl)(\"arrowIcon\", ctx_r1.arrowIcon)(\"buttonClass\", ctx_r1.buttonClass)(\"disabled\", ctx_r1.disabled)(\"tabIndex\", -1)(\"data\", ctx_r1.data)(\"buttonAttributes\", i0.ɵɵpureFunction1(15, _c29, ctx_r1.title))(\"textField\", ctx_r1.textField)(\"popupSettings\", ctx_r1.popupSettings)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.toolbarOptions.text, \" \");\n  }\n}\nfunction _class15_ng_template_2_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r11.overflowOptions.icon)(\"customFontClass\", ctx_r11.overflowOptions.iconClass)(\"svgIcon\", ctx_r11.overflowOptions.svgIcon);\n  }\n}\nfunction _class15_ng_template_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r12.overflowOptions.text);\n  }\n}\nfunction _class15_ng_template_2_ng_container_4_kendo_icon_wrapper_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 10);\n  }\n  if (rf & 2) {\n    const item_r14 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"name\", item_r14.icon)(\"customFontClass\", item_r14.iconClass)(\"svgIcon\", item_r14.svgIcon);\n  }\n}\nfunction _class15_ng_template_2_ng_container_4_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r14 = i0.ɵɵnextContext().$implicit;\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r18.getText(item_r14));\n  }\n}\nfunction _class15_ng_template_2_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 12, 13);\n    i0.ɵɵlistener(\"click\", function _class15_ng_template_2_ng_container_4_Template_div_click_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r22);\n      const item_r14 = restoredCtx.$implicit;\n      const i_r15 = restoredCtx.index;\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.handleClick($event, item_r14, i_r15));\n    });\n    i0.ɵɵelementStart(3, \"span\", 14);\n    i0.ɵɵtemplate(4, _class15_ng_template_2_ng_container_4_kendo_icon_wrapper_4_Template, 1, 3, \"kendo-icon-wrapper\", 7);\n    i0.ɵɵtemplate(5, _class15_ng_template_2_ng_container_4_span_5_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r14 = ctx.$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r13.disabled || item_r14.disabled);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", item_r14.cssClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r14.icon || item_r14.iconClass || item_r14.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.getText(item_r14));\n  }\n}\nconst _c30 = function () {\n  return {\n    \"k-link\": true,\n    \"k-menu-link\": true\n  };\n};\nfunction _class15_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5)(1, \"span\", 6);\n    i0.ɵɵtemplate(2, _class15_ng_template_2_kendo_icon_wrapper_2_Template, 1, 3, \"kendo-icon-wrapper\", 7);\n    i0.ɵɵtemplate(3, _class15_ng_template_2_span_3_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(4, _class15_ng_template_2_ng_container_4_Template, 6, 5, \"ng-container\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.buttonClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(5, _c30));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.icon || ctx_r3.overflowOptions.iconClass || ctx_r3.overflowOptions.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.data);\n  }\n}\nfunction _class15_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownbutton\", 3, 15);\n    i0.ɵɵlistener(\"open\", function _class15_ng_template_4_Template_kendo_dropdownbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r24.open.emit($event));\n    })(\"close\", function _class15_ng_template_4_Template_kendo_dropdownbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r26 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r26.close.emit($event));\n    })(\"itemClick\", function _class15_ng_template_4_Template_kendo_dropdownbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r27.itemClick.emit($event));\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r5.toolbarOptions.icon)(\"iconClass\", ctx_r5.toolbarOptions.iconClass)(\"svgIcon\", ctx_r5.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r5.toolbarOptions.imageUrl)(\"arrowIcon\", ctx_r5.arrowIcon)(\"buttonClass\", ctx_r5.buttonClass)(\"disabled\", ctx_r5.disabled)(\"tabIndex\", -1)(\"data\", ctx_r5.data)(\"buttonAttributes\", i0.ɵɵpureFunction1(15, _c29, ctx_r5.title))(\"textField\", ctx_r5.textField)(\"popupSettings\", ctx_r5.popupSettings)(\"fillMode\", ctx_r5.fillMode)(\"themeColor\", ctx_r5.fillMode ? ctx_r5.themeColor : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.toolbarOptions.text, \" \");\n  }\n}\nconst _c31 = [\"toolbarSplitButton\"];\nconst _c32 = [\"sectionSplitButton\"];\nconst _c33 = [\"overflowMainButton\"];\nfunction _class16_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-splitbutton\", 3, 4);\n    i0.ɵɵlistener(\"buttonClick\", function _class16_ng_template_0_Template_kendo_splitbutton_buttonClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.buttonClick.emit($event));\n    })(\"open\", function _class16_ng_template_0_Template_kendo_splitbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.open.emit($event));\n    })(\"close\", function _class16_ng_template_0_Template_kendo_splitbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.close.emit($event));\n    })(\"itemClick\", function _class16_ng_template_0_Template_kendo_splitbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.itemClick.emit($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r1.data)(\"text\", ctx_r1.toolbarOptions.text)(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"svgIcon\", ctx_r1.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl)(\"buttonClass\", ctx_r1.buttonClass)(\"arrowButtonClass\", ctx_r1.arrowButtonClass)(\"arrowButtonIcon\", ctx_r1.arrowButtonIcon)(\"arrowButtonSvgIcon\", ctx_r1.arrowButtonSvgIcon)(\"disabled\", ctx_r1.disabled)(\"tabIndex\", -1)(\"textField\", ctx_r1.textField)(\"popupSettings\", ctx_r1.popupSettings)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null);\n  }\n}\nfunction _class16_ng_template_2_kendo_icon_wrapper_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r13.overflowOptions.icon)(\"customFontClass\", ctx_r13.overflowOptions.iconClass)(\"svgIcon\", ctx_r13.overflowOptions.svgIcon);\n  }\n}\nfunction _class16_ng_template_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r14.overflowOptions.text);\n  }\n}\nfunction _class16_ng_template_2_ng_container_5_kendo_icon_wrapper_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 11);\n  }\n  if (rf & 2) {\n    const item_r16 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"name\", item_r16.icon)(\"customFontClass\", item_r16.iconClass)(\"svgIcon\", item_r16.svgIcon);\n  }\n}\nfunction _class16_ng_template_2_ng_container_5_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r16 = i0.ɵɵnextContext().$implicit;\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r20.getText(item_r16));\n  }\n}\nfunction _class16_ng_template_2_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 13, 14);\n    i0.ɵɵlistener(\"click\", function _class16_ng_template_2_ng_container_5_Template_div_click_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r24);\n      const item_r16 = restoredCtx.$implicit;\n      const i_r17 = restoredCtx.index;\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r23.handleClick($event, item_r16, i_r17));\n    });\n    i0.ɵɵelementStart(3, \"span\", 15);\n    i0.ɵɵtemplate(4, _class16_ng_template_2_ng_container_5_kendo_icon_wrapper_4_Template, 1, 3, \"kendo-icon-wrapper\", 8);\n    i0.ɵɵtemplate(5, _class16_ng_template_2_ng_container_5_span_5_Template, 2, 1, \"span\", 9);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r16 = ctx.$implicit;\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r15.disabled || item_r16.disabled);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", item_r16.icon || item_r16.iconClass || item_r16.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.getText(item_r16));\n  }\n}\nfunction _class16_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5, 6);\n    i0.ɵɵlistener(\"click\", function _class16_ng_template_2_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r25.onMainButtonClick($event));\n    });\n    i0.ɵɵelementStart(2, \"span\", 7);\n    i0.ɵɵtemplate(3, _class16_ng_template_2_kendo_icon_wrapper_3_Template, 1, 3, \"kendo-icon-wrapper\", 8);\n    i0.ɵɵtemplate(4, _class16_ng_template_2_span_4_Template, 2, 1, \"span\", 9);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(5, _class16_ng_template_2_ng_container_5_Template, 6, 4, \"ng-container\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r3.disabled);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.buttonClass);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(7, _c30));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.icon || ctx_r3.overflowOptions.iconClass || ctx_r3.overflowOptions.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.overflowOptions.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.data);\n  }\n}\nfunction _class16_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-splitbutton\", 3, 16);\n    i0.ɵɵlistener(\"buttonClick\", function _class16_ng_template_4_Template_kendo_splitbutton_buttonClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.buttonClick.emit($event));\n    })(\"open\", function _class16_ng_template_4_Template_kendo_splitbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r30 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r30.open.emit($event));\n    })(\"close\", function _class16_ng_template_4_Template_kendo_splitbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r31.close.emit($event));\n    })(\"itemClick\", function _class16_ng_template_4_Template_kendo_splitbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r32.itemClick.emit($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r5.data)(\"text\", ctx_r5.toolbarOptions.text)(\"icon\", ctx_r5.toolbarOptions.icon)(\"iconClass\", ctx_r5.toolbarOptions.iconClass)(\"svgIcon\", ctx_r5.toolbarOptions.svgIcon)(\"imageUrl\", ctx_r5.toolbarOptions.imageUrl)(\"buttonClass\", ctx_r5.buttonClass)(\"arrowButtonClass\", ctx_r5.arrowButtonClass)(\"arrowButtonIcon\", ctx_r5.arrowButtonIcon)(\"arrowButtonSvgIcon\", ctx_r5.arrowButtonSvgIcon)(\"disabled\", ctx_r5.disabled)(\"tabIndex\", -1)(\"textField\", ctx_r5.textField)(\"popupSettings\", ctx_r5.popupSettings)(\"fillMode\", ctx_r5.fillMode)(\"themeColor\", ctx_r5.fillMode ? ctx_r5.themeColor : null);\n  }\n}\nconst _c34 = [\"separator\"];\nfunction _class17_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n  }\n}\nfunction _class17_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n  }\n}\nfunction _class17_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵelement(1, \"div\", 5);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class18_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 1);\n  }\n}\nconst packageMetadata = {\n  name: '@progress/kendo-angular-toolbar',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163607,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nlet RefreshService = /*#__PURE__*/(() => {\n  var _class;\n  class RefreshService {\n    constructor() {\n      _defineProperty(this, \"onRefresh\", new EventEmitter());\n    }\n    refresh(tool) {\n      this.onRefresh.emit(tool);\n    }\n  }\n  _class = RefreshService;\n  _defineProperty(RefreshService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)();\n  });\n  _defineProperty(RefreshService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return RefreshService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\nfunction outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseFloat(style.marginLeft) || 0 + parseFloat(style.marginRight) || 0;\n  return width;\n}\n/**\n * @hidden\n */\nfunction innerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width -= parseFloat(style.paddingLeft) || 0 + parseFloat(style.borderLeftWidth) || 0;\n  width -= parseFloat(style.paddingRight) || 0 + parseFloat(style.borderRightWidth) || 0;\n  return width;\n}\n/**\n * @hidden\n */\nfunction outerHeight(element) {\n  let width = element.offsetHeight;\n  const style = getComputedStyle(element);\n  width += parseFloat(style.marginTop) || 0 + parseFloat(style.marginBottom) || 0;\n  return width;\n}\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n  return node;\n};\n/**\n * @hidden\n */\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0;\n  // Elements can have zero size due to styling, but they should still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n  node = node.firstChild;\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n      if (element) {\n        return element;\n      }\n    }\n    node = node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\nconst isFocusable = (element, checkVisibility = true) => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    let focusable = tabIndex !== null;\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled;\n    }\n    return focusable && (!checkVisibility || isVisible(element));\n  }\n  return false;\n};\n/**\n * @hidden\n */\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusable(node, checkVisibility));\n};\n/**\n * @hidden\n */\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusable(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\nconst findFocusableSibling = (element, checkVisibility = true, reverse) => {\n  let node = reverse ? element.prevSibling : element.nextSibling;\n  while (node) {\n    if (node.nodeType === 1) {\n      const result = findElement(node, el => isFocusable(el, checkVisibility));\n      if (result) {\n        return result;\n      }\n    }\n    node = reverse ? node.prevSibling : node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst makePeeker = collection => index => isPresent(collection[index]);\n/**\n * @hidden\n */\nconst getIndexOfFocused = (prevKeyCode, nextKeyCode, collection) => ev => {\n  switch (ev.type) {\n    case 'keydown':\n      if (ev.keyCode === prevKeyCode) {\n        return collection.length - 1;\n      }\n      if (ev.keyCode === nextKeyCode) {\n        return 0;\n      }\n      break;\n    case 'click':\n      return collection.findIndex(be => be === ev.target || be.contains(ev.target));\n    case 'focus':\n      return 0;\n    default:\n      return 0;\n  }\n};\n/**\n * @hidden\n */\nconst seekFocusedIndex = (prevKeyCode, nextKeyCode, seeker) => (startIndex, ev) => {\n  switch (ev.keyCode) {\n    case prevKeyCode:\n      return seeker(startIndex - 1) ? startIndex - 1 : startIndex;\n    case nextKeyCode:\n      return seeker(startIndex + 1) ? startIndex + 1 : startIndex;\n    default:\n      return startIndex;\n  }\n};\n/**\n * @hidden\n */\nconst areEqual = first => second => first === second;\n/**\n * @hidden\n */\nconst getNextKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowDown : rtl ? Keys.ArrowLeft : Keys.ArrowRight;\n/**\n * @hidden\n */\nconst getPrevKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowUp : rtl ? Keys.ArrowRight : Keys.ArrowLeft;\n/**\n * @hidden\n */\nconst getValueForLocation = (property, displayMode, overflows) => {\n  switch (displayMode) {\n    case 'toolbar':\n      return overflows ? undefined : property;\n    case 'overflow':\n      return overflows ? property : undefined;\n    default:\n      return property;\n  }\n};\n/**\n * @hidden\n */\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n    case 'fillMode':\n      return {\n        toRemove: `k-${componentType}-${previousValue}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''\n      };\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n *\n * Checks whether a Node is Text or Element node.\n * nodeType 1 is Element, nodeType 3 is Text\n */\nconst isElementOrTextNode = n => n.nodeType === 1 || n.nodeType === 3;\n/**\n * @hidden\n */\nconst normalizeOverflowSettings = overflow => {\n  const defaultOverflowSettings = {\n    mode: 'none',\n    scrollButtons: 'auto',\n    scrollButtonsPosition: 'split'\n  };\n  let normalizedSettings = {};\n  if (typeof overflow === 'object') {\n    normalizedSettings = Object.assign(defaultOverflowSettings, overflow);\n  } else if (typeof overflow === 'boolean') {\n    normalizedSettings = overflow ? Object.assign(defaultOverflowSettings, {\n      mode: 'menu'\n    }) : defaultOverflowSettings;\n  } else {\n    normalizedSettings = Object.assign(defaultOverflowSettings, {\n      mode: overflow\n    });\n  }\n  return normalizedSettings;\n};\n\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class2;\n  class NavigationService {\n    constructor(zone) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"overflowButton\", void 0);\n      _defineProperty(this, \"focused\", {\n        renderedTool: null,\n        index: -1\n      });\n      _defineProperty(this, \"renderedTools\", []);\n      _defineProperty(this, \"isPopupFocused\", false);\n      _defineProperty(this, \"isOverflowButtonFocused\", false);\n      this.zone = zone;\n    }\n    setRenderedTools(rts) {\n      this.renderedTools = rts;\n    }\n    click({\n      context,\n      event: ev\n    }) {\n      if (this.focused.renderedTool !== context && ev) {\n        this.focus(context, ev);\n      }\n    }\n    moveFocusToToolBar() {\n      this.isPopupFocused = false;\n      this.focusOverflowButton();\n    }\n    moveFocusToPopup() {\n      this.isPopupFocused = true;\n      this.resetNavigation();\n      this.focus();\n    }\n    focusNext(ev) {\n      if (this.isOverflowButtonFocused) {\n        const firstFocusableRT = this.getFocusableTools()[0];\n        this.focus(firstFocusableRT, ev);\n      } else if (!this.isOverflowButtonFocused && this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {\n        const nextRT = this.getFocusableTools().slice(this.focused.index + 1)[0];\n        if (nextRT) {\n          this.focus(nextRT, ev);\n        } else {\n          if (this.isOverflowButtonVisible() && !this.isPopupFocused) {\n            this.focusOverflowButton();\n          } else {\n            const firstRT = this.getFocusableTools()[0];\n            this.focus(firstRT, ev);\n          }\n        }\n      }\n    }\n    focusPrev(ev) {\n      if (this.isOverflowButtonFocused) {\n        const lastFocusableRT = this.getFocusableTools().reverse()[0];\n        this.focus(lastFocusableRT, ev);\n      } else if (!this.isOverflowButtonFocused && this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {\n        const prevRT = this.getFocusableTools().slice(0, this.focused.index).reverse()[0];\n        if (prevRT) {\n          this.focus(prevRT, ev);\n        } else {\n          if (this.isOverflowButtonVisible() && !this.isPopupFocused) {\n            this.focusOverflowButton();\n          } else {\n            const lastRT = this.getFocusableTools().reverse()[0];\n            this.focus(lastRT, ev);\n          }\n        }\n      }\n    }\n    resetNavigation() {\n      this.blurOverflowButton();\n      this.focused.renderedTool = null;\n      this.focused.index = -1;\n    }\n    focusFirst(ev) {\n      const firstTool = this.getFocusableTools()[0];\n      const overFlowButton = this.overflowButton;\n      if (firstTool) {\n        this.focused.renderedTool = firstTool;\n        this.focused.index = this.getFocusableTools().findIndex(rt => rt === firstTool);\n        this.focus(firstTool, ev);\n      } else if (overFlowButton) {\n        overFlowButton.nativeElement.focus();\n      }\n    }\n    focusLast(ev) {\n      const lastTool = this.getFocusableTools().reverse()[0];\n      const overFlowButton = this.overflowButton;\n      if (lastTool) {\n        this.focused.renderedTool = lastTool;\n        this.focused.index = this.getFocusableTools().findIndex(rt => rt === lastTool);\n        this.focus(lastTool, ev);\n      } else if (overFlowButton) {\n        overFlowButton.nativeElement.focus();\n      }\n    }\n    getFocusableTools() {\n      return this.renderedTools.filter(rt => rt.tool.overflows === this.isPopupFocused && rt.tool.canFocus());\n    }\n    focus(renderedTool, ev) {\n      // running the code below in onStable fixes issue #2939\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        if (!renderedTool) {\n          const focusableRTs = this.getFocusableTools();\n          const lastFocusedRT = focusableRTs.find(rt => rt === this.focused.renderedTool) || focusableRTs[0];\n          // guard against only disabled tools\n          if (lastFocusedRT) {\n            this.focused.renderedTool = lastFocusedRT;\n            this.focused.index = this.getFocusableTools().findIndex(rt => rt === lastFocusedRT);\n            // if event is undefined, then this means that the tool is the first one in the overflow popup\n            lastFocusedRT.tool.focus(ev);\n          }\n        } else if (renderedTool.tool.canFocus && renderedTool.tool.canFocus()) {\n          this.focused.renderedTool = renderedTool;\n          this.focused.index = this.getFocusableTools().findIndex(rt => rt === renderedTool);\n          renderedTool.tool.focus(ev);\n          this.blurOverflowButton();\n        }\n      });\n    }\n    blurOverflowButton() {\n      if (this.overflowButton) {\n        this.isOverflowButtonFocused = false;\n        this.overflowButton.nativeElement.tabIndex = -1;\n      }\n    }\n    focusOverflowButton() {\n      if (this.overflowButton) {\n        this.isOverflowButtonFocused = true;\n        this.overflowButton.nativeElement.tabIndex = 0;\n        this.overflowButton.nativeElement.focus();\n      }\n    }\n    isOverflowButtonVisible() {\n      return isPresent(this.overflowButton) && window.getComputedStyle(this.overflowButton.nativeElement).getPropertyValue('visibility') === 'visible';\n    }\n  }\n  _class2 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the Base ToolBar Tool component for Angular.\n * Extend this class to create custom tools.\n */\nlet ToolBarToolComponent = /*#__PURE__*/(() => {\n  var _class3;\n  class ToolBarToolComponent {\n    constructor() {\n      _defineProperty(this, \"toolbarTemplate\", void 0);\n      _defineProperty(this, \"sectionTemplate\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"tabIndex\", -1);\n      //Focus movement inside the toolbar is managed using roving tabindex.\n      _defineProperty(this, \"overflows\", true);\n      _defineProperty(this, \"visibility\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"isBuiltInTool\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"location\", void 0);\n      // this should be replaced with showTool: DisplayMode = 'both';\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsive\", true);\n      this.element = inject(ElementRef);\n    }\n    get toolbarDisplay() {\n      return this.overflows ? 'none' : 'inline-flex';\n    }\n    get overflowDisplay() {\n      return this.overflows ? 'block' : 'none';\n    }\n    /**\n     * Determines if the tool can be focused.\n     * If the returned value is `false`, the tool will not be part of the keyboard navigation.\n     * @returns `true` if the tool should take part in keyboard navigation.\n     */\n    canFocus() {\n      return false;\n    }\n    /**\n     * Called when the tool is focused.\n     * The method accepts as argument the original browser event, which can be a `KeyboardEvent`, `MouseEvent` or `FocusEvent`.\n     * @param {Event} _ev - This is the event that caused the tool to be focused.\n     */\n    focus(_ev) {\n      /* noop */\n    }\n    /**\n     * Called when the tool is focused and one of the arrow keys is pressed.\n     * The returned boolean value determines whether the `ToolBarComponent` will move the focus to the next/previous `ToolBarToolComponent`\n     * ([see example]({% slug customcontroltypes_toolbar %}#toc-adding-keyboard-navigation)).\n     * @param {KeyboardEvent} _ev - The last pressed arrow key\n     * @returns a boolean value determines whether the focus will move to the next/previous component.\n     */\n    handleKey(_ev) {\n      return false;\n    }\n  }\n  _class3 = ToolBarToolComponent;\n  _defineProperty(ToolBarToolComponent, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)();\n  });\n  _defineProperty(ToolBarToolComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    viewQuery: function _class3_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sectionTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      }\n    },\n    inputs: {\n      responsive: \"responsive\"\n    },\n    standalone: true\n  }));\n  return ToolBarToolComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * @hidden\n */\nlet RendererService = /*#__PURE__*/(() => {\n  var _class5;\n  class RendererService {\n    constructor() {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n    }\n    getElement() {\n      return this.element.nativeElement;\n    }\n    querySelector(selector) {\n      return this.element.nativeElement.querySelector(selector);\n    }\n    querySelectorAll(selector) {\n      return this.element.nativeElement.querySelectorAll(selector);\n    }\n    findFocusable() {\n      return findFocusable(this.element.nativeElement, false);\n    }\n    findFocusableChild(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n      return findFocusableChild(element, false);\n    }\n    findNextFocusableSibling(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n      return findFocusableSibling(element, false);\n    }\n    findPrevFocusableSibling(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n      return findFocusableSibling(element, false, true);\n    }\n    setAttribute(element, attr, value) {\n      this.renderer.setAttribute(element, attr, value);\n    }\n  }\n  _class5 = RendererService;\n  _defineProperty(RendererService, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)();\n  });\n  _defineProperty(RendererService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac\n  }));\n  return RendererService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ToolbarToolsService = /*#__PURE__*/(() => {\n  var _class6;\n  class ToolbarToolsService {\n    constructor() {\n      _defineProperty(this, \"renderedToolsChange\", new Subject());\n      _defineProperty(this, \"overflowToolsChange\", new Subject());\n      _defineProperty(this, \"renderedTools\", []);\n      _defineProperty(this, \"overflowTools\", []);\n      _defineProperty(this, \"allTools\", []);\n    }\n    reset() {\n      this.renderedTools = this.overflowTools = this.allTools = [];\n    }\n  }\n  _class6 = ToolbarToolsService;\n  _defineProperty(ToolbarToolsService, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)();\n  });\n  _defineProperty(ToolbarToolsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  }));\n  return ToolbarToolsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MIN_SPACER_WIDTH = 18;\n/**\n * @hidden\n */\nlet ToolBarRendererComponent = /*#__PURE__*/(() => {\n  var _class7;\n  class ToolBarRendererComponent {\n    get isSpacer() {\n      return this.tool && this.tool.__isSpacer;\n    }\n    constructor(renderer, rendererService, refreshService, toolsService, viewContainer) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"rendererService\", void 0);\n      _defineProperty(this, \"refreshService\", void 0);\n      _defineProperty(this, \"toolsService\", void 0);\n      _defineProperty(this, \"viewContainer\", void 0);\n      _defineProperty(this, \"tool\", void 0);\n      _defineProperty(this, \"location\", void 0);\n      _defineProperty(this, \"resizable\", void 0);\n      _defineProperty(this, \"rendererClick\", new EventEmitter());\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"refreshSubscription\", void 0);\n      _defineProperty(this, \"internalComponentRef\", void 0);\n      _defineProperty(this, \"onClick\", ev => {\n        this.rendererClick.emit({\n          context: this,\n          event: ev\n        });\n      });\n      this.renderer = renderer;\n      this.rendererService = rendererService;\n      this.refreshService = refreshService;\n      this.toolsService = toolsService;\n      this.viewContainer = viewContainer;\n    }\n    ngOnInit() {\n      const viewContainerRootNodes = this.viewContainer.get(0)?.rootNodes?.filter(isElementOrTextNode);\n      if (!viewContainerRootNodes || viewContainerRootNodes.length === 0) {\n        return;\n      }\n      this.tool.location = this.location;\n      this.internalComponentRef = viewContainerRootNodes[0];\n      this.element = this.tool.element;\n      this.internalComponentRef.addEventListener('click', this.onClick);\n      this.rendererService.element = this.element;\n      this.rendererService.renderer = this;\n      this.refreshSubscription = this.refreshService.onRefresh.subscribe(tool => {\n        if (this.tool === tool) {\n          this.refresh();\n        }\n      });\n      if (this.resizable) {\n        if (this.location === 'toolbar') {\n          this.template = this.tool.toolbarTemplate;\n          this.renderer.setStyle(this.internalComponentRef, 'visibility', 'hidden');\n          this.renderer.setStyle(this.internalComponentRef, 'display', 'none');\n        } else if (this.location === 'section') {\n          this.template = this.tool.toolbarTemplate;\n          this.renderer.setStyle(this.internalComponentRef, 'visibility', 'visible');\n          this.renderer.setStyle(this.internalComponentRef, 'display', 'inline-flex');\n        } else {\n          this.template = this.tool.popupTemplate;\n          this.renderer.setStyle(this.internalComponentRef, 'display', 'none');\n        }\n      } else {\n        this.tool.overflows = false;\n        this.template = this.tool.toolbarTemplate;\n        this.renderer.setStyle(this.internalComponentRef, 'visibility', 'visible');\n        this.renderer.setStyle(this.internalComponentRef, 'display', 'inline-flex');\n      }\n    }\n    ngOnDestroy() {\n      this.refreshSubscription && this.refreshSubscription.unsubscribe();\n      this.internalComponentRef && this.internalComponentRef.removeEventListener('click', this.onClick);\n    }\n    ngAfterViewInit() {\n      if (this.resizable) {\n        this.refresh();\n      }\n      this.updateTools();\n    }\n    /**\n     * @hidden\n     */\n    get width() {\n      if (this.isSpacer) {\n        return MIN_SPACER_WIDTH;\n      }\n      return this.tool.overflows ? 0 : outerWidth(this.internalComponentRef);\n    }\n    isDisplayed() {\n      return this.internalComponentRef?.style?.display !== 'none';\n    }\n    refresh() {\n      this.tool.location = this.location;\n      if (this.resizable && this.internalComponentRef) {\n        if (this.location === 'toolbar') {\n          this.renderer.setStyle(this.internalComponentRef, 'visibility', this.tool.visibility);\n          this.renderer.setStyle(this.internalComponentRef, 'display', this.tool.toolbarDisplay);\n        } else {\n          this.renderer.setStyle(this.internalComponentRef, 'display', this.tool.overflowDisplay);\n        }\n        this.updateTools();\n      }\n    }\n    setAttribute(element, attr, value) {\n      this.renderer.setAttribute(element, attr, value);\n    }\n    updateTools() {\n      this.tool.location = this.location;\n      const isInToolbar = this.toolsService.renderedTools.some(t => t.tool === this.tool);\n      const isInPopup = this.toolsService.overflowTools.some(t => t.tool === this.tool);\n      if (this.location === 'toolbar') {\n        isInPopup && (this.toolsService.overflowTools = this.toolsService.overflowTools.filter(t => t.tool !== this.tool));\n        !isInToolbar && this.toolsService.renderedTools.push(this);\n      } else {\n        if (!isInPopup) {\n          this.toolsService.overflowTools.push(this);\n          this.toolsService.overflowTools.sort((t1, t2) => {\n            // ensures correct navigation order in Popup\n            return this.toolsService.allTools.indexOf(t1.tool) - this.toolsService.allTools.indexOf(t2.tool);\n          });\n        }\n      }\n    }\n  }\n  _class7 = ToolBarRendererComponent;\n  _defineProperty(ToolBarRendererComponent, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(RendererService), i0.ɵɵdirectiveInject(RefreshService), i0.ɵɵdirectiveInject(ToolbarToolsService), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  });\n  _defineProperty(ToolBarRendererComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class7,\n    selectors: [[\"\", \"kendoToolbarRenderer\", \"\"]],\n    inputs: {\n      tool: \"tool\",\n      location: \"location\",\n      resizable: \"resizable\"\n    },\n    outputs: {\n      rendererClick: \"rendererClick\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([RendererService])]\n  }));\n  return ToolBarRendererComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ToolbarMessages = /*#__PURE__*/(() => {\n  var _class8;\n  class ToolbarMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the **More Tools** button in a responsive ToolBar\n       */\n      _defineProperty(this, \"moreToolsTitle\", void 0);\n      /**\n       * The title for the **Previous Tool** button when the Toolbar is scrollable.\n       */\n      _defineProperty(this, \"previousToolButton\", void 0);\n      /**\n       * The title for the **Next Tool** button when the Toolbar is scrollable.\n       */\n      _defineProperty(this, \"nextToolButton\", void 0);\n    }\n  }\n  _class8 = ToolbarMessages;\n  _defineProperty(ToolbarMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class8_BaseFactory;\n    return function _class8_Factory(t) {\n      return (ɵ_class8_BaseFactory || (ɵ_class8_BaseFactory = i0.ɵɵgetInheritedFactory(_class8)))(t || _class8);\n    };\n  }());\n  _defineProperty(ToolbarMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class8,\n    selectors: [[\"kendo-toolbar-messages-base\"]],\n    inputs: {\n      moreToolsTitle: \"moreToolsTitle\",\n      previousToolButton: \"previousToolButton\",\n      nextToolButton: \"nextToolButton\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return ToolbarMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedToolbarMessagesDirective = /*#__PURE__*/(() => {\n  var _class9;\n  class LocalizedToolbarMessagesDirective extends ToolbarMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class9 = LocalizedToolbarMessagesDirective;\n  _defineProperty(LocalizedToolbarMessagesDirective, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedToolbarMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class9,\n    selectors: [[\"\", \"kendoToolbarLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolbarMessages,\n      useExisting: forwardRef(() => _class9)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedToolbarMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SCROLL_BEHAVIOR = 'smooth';\nconst DEFAULT_SCROLL_SPEED = 100;\n/**\n * @hidden\n */\nlet ScrollService = /*#__PURE__*/(() => {\n  var _class10;\n  class ScrollService {\n    get scrollElement() {\n      return this.owner.scrollContainer?.nativeElement;\n    }\n    get scrollContainerOverflowSize() {\n      if (!isDocumentAvailable()) {\n        return 0;\n      }\n      if (!this.scrollElement) {\n        return 0;\n      }\n      const overflowSize = Math.floor(this.scrollElement.scrollWidth - this.scrollElement.getBoundingClientRect().width);\n      return overflowSize < 0 ? 0 : overflowSize;\n    }\n    get toolsOverflow() {\n      return this.scrollContainerOverflowSize > 0;\n    }\n    constructor(ngZone, localization) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"owner\", void 0);\n      _defineProperty(this, \"position\", 0);\n      _defineProperty(this, \"scrollButtonActiveStateChange\", new Subject());\n      _defineProperty(this, \"isDisabled\", buttonType => this.owner[`${buttonType}ScrollButton`]?.nativeElement.classList.contains('k-disabled'));\n      this.ngZone = ngZone;\n      this.localization = localization;\n    }\n    toggleScrollButtonsState() {\n      const toolbar = this.owner;\n      if (!toolbar.hasScrollButtons) {\n        return;\n      }\n      const currentPrevButtonActive = !this.isDisabled('prev');\n      const currentNextButtonActive = !this.isDisabled('next');\n      const defaultOffset = 1;\n      const rtlDelta = this.localization.rtl ? -1 : 1;\n      const calculatedPrevButtonActive = this.position * rtlDelta > 0 && this.scrollContainerOverflowSize > 0;\n      const calculatedNextButtonActive = this.position * rtlDelta < this.scrollContainerOverflowSize - defaultOffset && this.scrollContainerOverflowSize > 0;\n      if (calculatedPrevButtonActive !== currentPrevButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));\n      }\n      if (calculatedNextButtonActive !== currentNextButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));\n      }\n    }\n    onScroll(e) {\n      this.position = e.target.scrollLeft;\n      this.toggleScrollButtonsState();\n    }\n    scrollTools(direction) {\n      this.calculateListPosition(direction, DEFAULT_SCROLL_SPEED);\n      if (this.scrollElement) {\n        this.scrollElement.scrollTo({\n          left: this.position,\n          behavior: DEFAULT_SCROLL_BEHAVIOR\n        });\n      }\n      this.toggleScrollButtonsState();\n    }\n    updateScrollPosition(element) {\n      this.position = element.scrollLeft;\n    }\n    calculateListPosition(direction, scrollSpeed) {\n      if (direction === 'prev') {\n        if (!this.localization.rtl) {\n          this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;\n        } else {\n          this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;\n        }\n      } else if (direction === 'next' && this.position < this.scrollContainerOverflowSize) {\n        if (this.position + scrollSpeed > this.scrollContainerOverflowSize) {\n          if (this.localization.rtl) {\n            this.position = -this.scrollContainerOverflowSize;\n          } else {\n            this.position = this.scrollContainerOverflowSize;\n          }\n          return;\n        }\n        if (this.localization.rtl) {\n          this.position -= scrollSpeed;\n        } else {\n          this.position += scrollSpeed;\n        }\n      }\n    }\n    toggleButtonActiveState(buttonType, active) {\n      this.scrollButtonActiveStateChange.next({\n        buttonType,\n        active\n      });\n    }\n  }\n  _class10 = ScrollService;\n  _defineProperty(ScrollService, \"\\u0275fac\", function _class10_Factory(t) {\n    return new (t || _class10)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.LocalizationService));\n  });\n  _defineProperty(ScrollService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class10,\n    factory: _class10.ɵfac\n  }));\n  return ScrollService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DIRECTION_CLASSES = {\n  left: 'caret-alt-left',\n  right: 'caret-alt-right'\n};\n/**\n * @hidden\n */\nlet ToolbarScrollableButtonComponent = /*#__PURE__*/(() => {\n  var _class11;\n  class ToolbarScrollableButtonComponent {\n    get prevClass() {\n      return this.prev;\n    }\n    get nextClass() {\n      return !this.prev;\n    }\n    get iconClass() {\n      return this.scrollButtonIconClass;\n    }\n    get customIconClass() {\n      return this.customScrollButtonIconClass;\n    }\n    get svgIcon() {\n      return this.scrollButtonSVGIcon;\n    }\n    constructor(host, renderer, ngZone, localization) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"role\", 'button');\n      _defineProperty(this, \"prev\", false);\n      _defineProperty(this, \"overflow\", void 0);\n      _defineProperty(this, \"onClick\", new EventEmitter());\n      _defineProperty(this, \"caretAltLeftIcon\", caretAltLeftIcon);\n      _defineProperty(this, \"caretAltRightIcon\", caretAltRightIcon);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"clickHandler\", () => {\n        const buttonType = this.prev ? 'prev' : 'next';\n        this.onClick.emit(buttonType);\n      });\n      this.host = host;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.localization = localization;\n    }\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));\n      });\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    get scrollButtonIconClass() {\n      const defaultPrevIcon = !this.localization.rtl ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.right;\n      const defaultNextIcon = !this.localization.rtl ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.left;\n      if (typeof this.overflow === 'object') {\n        const prevIcon = typeof this.overflow.prevButtonIcon === 'undefined' ? defaultPrevIcon : '';\n        const nextIcon = typeof this.overflow.nextButtonIcon === 'undefined' ? defaultNextIcon : '';\n        if (prevIcon && this.prev) {\n          return prevIcon;\n        } else if (nextIcon && !this.prev) {\n          return nextIcon;\n        }\n      }\n    }\n    get customScrollButtonIconClass() {\n      if (typeof this.overflow === 'object') {\n        const prevIcon = this.overflow.prevButtonIcon;\n        const nextIcon = this.overflow.nextButtonIcon;\n        if (prevIcon && this.prev) {\n          return `k-icon ${prevIcon}`;\n        }\n        if (nextIcon && !this.prev) {\n          return `k-icon ${nextIcon}`;\n        }\n      }\n    }\n    get scrollButtonSVGIcon() {\n      const defaultPrevSVGIcon = !this.localization.rtl ? this.caretAltLeftIcon : this.caretAltRightIcon;\n      const defaultNextSVGIcon = !this.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon;\n      if (typeof this.overflow === 'object') {\n        const prevIcon = this.overflow.prevSVGButtonIcon !== undefined ? this.overflow.prevSVGButtonIcon : defaultPrevSVGIcon;\n        const nextIcon = this.overflow.nextSVGButtonIcon !== undefined ? this.overflow.nextSVGButtonIcon : defaultNextSVGIcon;\n        if (prevIcon || nextIcon) {\n          return this.prev ? prevIcon : nextIcon;\n        }\n      }\n    }\n  }\n  _class11 = ToolbarScrollableButtonComponent;\n  _defineProperty(ToolbarScrollableButtonComponent, \"\\u0275fac\", function _class11_Factory(t) {\n    return new (t || _class11)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ToolbarScrollableButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class11,\n    selectors: [[\"\", \"kendoToolbarScrollableButton\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class11_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-toolbar-prev\", ctx.prevClass)(\"k-toolbar-next\", ctx.nextClass);\n      }\n    },\n    inputs: {\n      prev: \"prev\",\n      overflow: \"overflow\"\n    },\n    outputs: {\n      onClick: \"onClick\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c3,\n    decls: 1,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"]],\n    template: function _class11_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-icon-wrapper\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"name\", ctx.iconClass)(\"customFontClass\", ctx.customIconClass)(\"svgIcon\", ctx.svgIcon);\n      }\n    },\n    dependencies: [IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ToolbarScrollableButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable no-case-declarations */\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\nconst immediateResizeThreshold = 300;\nconst getInitialPopupSettings = isRtl => ({\n  animate: true,\n  anchorAlign: {\n    horizontal: isRtl ? 'left' : 'right',\n    vertical: 'bottom'\n  },\n  popupAlign: {\n    horizontal: isRtl ? 'left' : 'right',\n    vertical: 'top'\n  }\n});\n/**\n * Represents the [Kendo UI ToolBar component for Angular]({% slug overview_toolbar %}).\n */\nlet ToolBarComponent = /*#__PURE__*/(() => {\n  var _class12;\n  class ToolBarComponent {\n    get overflowClass() {\n      return `k-button-${SIZES[this.size]}`;\n    }\n    /**\n     * Configures the overflow mode. Used to specify how tools will be rendered when the total size of all tools is greater than the size of the Toolbar container.\n     * @default false\n     */\n    set overflow(overflow) {\n      if (this.isScrollMode) {\n        this.removeSubscriptions(['scrollButtonStateChangeSub', 'scrollContainerScrollSub']);\n      }\n      this._overflow = overflow;\n      if (this.isScrollMode) {\n        this.handleScrollModeUpdates();\n      }\n      this.setScrollableOverlayClasses();\n      this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());\n    }\n    get overflow() {\n      return this._overflow;\n    }\n    get showScrollButtons() {\n      const buttonsVisibility = this.normalizedOverflow.scrollButtons;\n      const showAuto = buttonsVisibility === 'auto' && this.showAutoButtons;\n      const showAlways = buttonsVisibility === 'visible';\n      return this.isScrollMode && (showAuto || showAlways);\n    }\n    /**\n     * @hidden\n     */\n    set resizable(value) {\n      this.overflow = value;\n    }\n    get resizable() {\n      return this.showMenu;\n    }\n    /**\n     * @hidden\n     */\n    get hasScrollButtons() {\n      const visible = this.normalizedOverflow.mode === 'scroll' && this.normalizedOverflow.scrollButtons !== 'hidden';\n      const position = this.normalizedOverflow.scrollButtonsPosition;\n      return {\n        visible,\n        position\n      };\n    }\n    /**\n     * @hidden\n     */\n    get isScrollMode() {\n      return this.normalizedOverflow.mode === 'scroll';\n    }\n    /**\n     * @hidden\n     */\n    get showMenu() {\n      return this.normalizedOverflow.mode === 'menu' || this.normalizedOverflow.mode === 'section';\n    }\n    /**\n     * @hidden\n     */\n    get overflowEnabled() {\n      return this.normalizedOverflow.mode !== 'none';\n    }\n    /**\n     * Configures the popup of the ToolBar overflow button ([see example](slug:responsive_toolbar#customizing-the-popup)).\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, getInitialPopupSettings(this.localization.rtl), settings);\n    }\n    get popupSettings() {\n      return this._popupSettings || getInitialPopupSettings(this.localization.rtl);\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Toolbar\n     * ([see example](slug:appearance_toolbar#toc-fill-mode)).\n     *\n     * @default 'solid'\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the ToolBar.\n     */\n\n    /**\n     * Specifies the padding of all Toolbar elements.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Fires when the overflow popup of the ToolBar is opened.\n     */\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    set popupOpen(open) {\n      if (this.popupOpen === open) {\n        return;\n      }\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      }\n      this.toggle(open);\n    }\n    get popupOpen() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n\n    get scrollableClass() {\n      return this.isScrollMode;\n    }\n    get sectionClass() {\n      return this.normalizedOverflow.mode === 'section';\n    }\n    /**\n     * @hidden\n     */\n    get normalizedOverflow() {\n      return normalizeOverflowSettings(this.overflow);\n    }\n    /**\n     * @hidden\n     */\n    onFocus(ev) {\n      if (this.focusedByPointer) {\n        this.focusedByPointer = false;\n        return;\n      }\n      this.navigationService.resetNavigation();\n      this.navigationService.focusFirst(ev);\n      // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n      this.element.nativeElement.setAttribute('tabindex', '-1');\n    }\n    /**\n     * @hidden\n     */\n    onFocusOut(event) {\n      // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n      if (closest(event.relatedTarget, el => el === this.element.nativeElement)) {\n        this.element.nativeElement.setAttribute('tabindex', '-1');\n        return;\n      }\n      this.element.nativeElement.setAttribute('tabindex', this.tabindex.toString());\n    }\n    get getDir() {\n      return this.direction;\n    }\n    get resizableClass() {\n      return this.resizable;\n    }\n    constructor(localization, popupService, refreshService, navigationService,\n    // Needs to be public as it is being accessed in the Editor component\n    element, zone, renderer, _cdr, toolsService, scrollService) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"refreshService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"_cdr\", void 0);\n      _defineProperty(this, \"toolsService\", void 0);\n      _defineProperty(this, \"scrollService\", void 0);\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires when the overflow popup of the ToolBar is closed.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"allTools\", void 0);\n      _defineProperty(this, \"overflowButton\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"popupSectionTemplate\", void 0);\n      _defineProperty(this, \"scrollContainer\", void 0);\n      _defineProperty(this, \"resizeSensor\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"prevScrollButton\", void 0);\n      _defineProperty(this, \"nextScrollButton\", void 0);\n      _defineProperty(this, \"startButtonGroup\", void 0);\n      _defineProperty(this, \"endButtonGroup\", void 0);\n      _defineProperty(this, \"scrollSeparator\", void 0);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"prevButtonIcon\", caretAltLeftIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"nextButtonIcon\", caretAltRightIcon);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"_overflow\", false);\n      _defineProperty(this, \"_popupSettings\", void 0);\n      _defineProperty(this, \"cachedOverflowAnchorWidth\", void 0);\n      _defineProperty(this, \"_open\", void 0);\n      _defineProperty(this, \"toolbarKeydownListener\", void 0);\n      _defineProperty(this, \"overflowKeydownListener\", void 0);\n      _defineProperty(this, \"sectionKeydownListener\", void 0);\n      _defineProperty(this, \"cancelRenderedToolsSubscription$\", new Subject());\n      _defineProperty(this, \"cachedGap\", void 0);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE);\n      _defineProperty(this, \"overflowButtonClickedTime\", null);\n      _defineProperty(this, \"showAutoButtons\", false);\n      _defineProperty(this, \"scrollButtonStateChangeSub\", void 0);\n      _defineProperty(this, \"scrollContainerScrollSub\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"popupSubs\", new Subscription());\n      _defineProperty(this, \"focusedByPointer\", false);\n      _defineProperty(this, \"role\", 'toolbar');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showOverflowSeparator\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"overflowBtnId\", guid());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"popupId\", guid());\n      this.localization = localization;\n      this.popupService = popupService;\n      this.refreshService = refreshService;\n      this.navigationService = navigationService;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this._cdr = _cdr;\n      this.toolsService = toolsService;\n      this.scrollService = scrollService;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.scrollService.owner = this;\n    }\n    ngAfterContentInit() {\n      this.toolsService.allTools = this.allTools.toArray();\n      this.subscriptions.add(this.allTools.changes.subscribe(() => {\n        this.toolsService.reset();\n        this.toolsService.allTools = this.allTools.toArray();\n        this.allTools.forEach(tool => {\n          this.refreshService.refresh(tool);\n        });\n        this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());\n      }));\n    }\n    ngAfterViewInit() {\n      this.toolsService.renderedToolsChange.next(this.toolsService.renderedTools);\n      this.toolsService.overflowToolsChange.next(this.toolsService.overflowTools);\n      const element = this.element.nativeElement;\n      if (!element.getAttribute('tabindex')) {\n        this.element.nativeElement.setAttribute('tabindex', '0');\n      }\n      this.zone.runOutsideAngular(() => {\n        this.toolbarKeydownListener = this.renderer.listen(this.element.nativeElement, 'keydown', ev => {\n          switch (ev.keyCode) {\n            case Keys.ArrowLeft:\n              this.zone.run(() => {\n                ev.preventDefault();\n                if (this.direction === 'ltr') {\n                  this.navigationService.focusPrev(ev);\n                } else {\n                  this.navigationService.focusNext(ev);\n                }\n                // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n                this.element.nativeElement.setAttribute('tabindex', '-1');\n              });\n              break;\n            case Keys.ArrowRight:\n              this.zone.run(() => {\n                ev.preventDefault();\n                if (this.direction === 'ltr') {\n                  this.navigationService.focusNext(ev);\n                } else {\n                  this.navigationService.focusPrev(ev);\n                }\n                // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n                this.element.nativeElement.setAttribute('tabindex', '-1');\n              });\n              break;\n            case Keys.Tab:\n              this.zone.run(() => this.navigationService.resetNavigation());\n              break;\n            case Keys.Escape:\n              this.zone.run(() => this.toggle(false));\n              break;\n            case Keys.Home:\n              this.zone.run(() => this.navigationService.focusFirst(ev));\n              break;\n            case Keys.End:\n              this.zone.run(() => this.navigationService.focusLast(ev));\n              break;\n            default:\n              break;\n          }\n        });\n      });\n      if (this.overflowEnabled) {\n        this.subscriptions.add(merge(this.resizeSensor.resize, this.toolsService.renderedToolsChange).subscribe(() => this.onResize()));\n        if (this.showMenu) {\n          this.navigationService.overflowButton = this.overflowButton;\n        }\n        // because of https://github.com/telerik/kendo-angular-buttons/pull/276\n        // button icons are not rendered until onResize() is called\n        this.zone.runOutsideAngular(() => {\n          setTimeout(() => {\n            this.zone.run(() => {\n              this.onResize();\n            });\n          });\n        });\n      }\n      if (this.isScrollMode) {\n        this.handleScrollModeUpdates();\n      }\n      this.subscriptions.add(this.renderer.listen(this.element.nativeElement, 'pointerdown', ev => {\n        if (!ev.target.closest('.k-toolbar-items')) {\n          this.focusedByPointer = true;\n        }\n      }));\n      this.navigationService.setRenderedTools(this.toolsService.renderedTools);\n      const stylingOptions = ['size', 'fillMode'];\n      stylingOptions.forEach(option => {\n        this.handleClasses(this[option], option);\n      });\n    }\n    ngOnInit() {\n      this.subscriptions.add(this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());\n      if (isDocumentAvailable()) {\n        this.zone.runOutsideAngular(() => this.subscriptions.add(fromEvent(document, 'click').pipe(filter(() => !!this.popupRef), filter(ev => !this.popupRef.popup.instance.container.nativeElement.contains(ev.target)), filter(ev => !this.overflowButton.nativeElement.contains(ev.target))).subscribe(() => {\n          this.zone.run(() => {\n            this.popupOpen = false;\n          });\n        })));\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes['tabindex']) {\n        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n        this.element.nativeElement.setAttribute('tabindex', changes['tabindex'].currentValue.toString());\n      }\n    }\n    ngOnDestroy() {\n      this.destroyPopup();\n      if (this.toolbarKeydownListener) {\n        this.toolbarKeydownListener();\n      }\n      this.cancelRenderedToolsSubscription$.next();\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    get moreToolsTitle() {\n      return this.localization.get('moreToolsTitle');\n    }\n    /**\n     * @hidden\n     */\n    get cdr() {\n      return this._cdr;\n    }\n    /**\n     * @hidden\n     */\n    get sectionSizeClass() {\n      return this.size === 'none' ? '' : `k-toolbar-items-list-${SIZES[this.size]}`;\n    }\n    /**\n     * @hidden\n     */\n    getScrollButtonTitle(buttonType) {\n      let currentButton;\n      if (this.localization.rtl) {\n        currentButton = buttonType === 'prev' ? 'nextToolButton' : 'previousToolButton';\n      } else {\n        currentButton = buttonType === 'prev' ? 'previousToolButton' : 'nextToolButton';\n      }\n      return this.localization.get(currentButton);\n    }\n    /**\n     * @hidden\n     */\n    scrollTools(dir) {\n      this.scrollService.scrollTools(dir);\n    }\n    /**\n     * @hidden\n     */\n    onRendererClick(data) {\n      this.navigationService.click(data);\n      this.element.nativeElement.setAttribute('tabindex', '-1');\n    }\n    /**\n     * @hidden\n     */\n    overflowButtonIcon(iconType) {\n      if (iconType === 'svg') {\n        return this.normalizedOverflow.mode === 'section' ? moreHorizontalIcon : moreVerticalIcon;\n      } else {\n        return this.normalizedOverflow.mode === 'section' ? 'more-horizontal' : 'more-vertical';\n      }\n    }\n    /**\n     * @hidden\n     */\n    showPopup() {\n      this.popupOpen = !this.popupOpen;\n      this.navigationService.click({\n        context: undefined,\n        event: undefined\n      });\n      this.overflowButtonClickedTime = Date.now();\n    }\n    /**\n     * Toggles the visibility of the overflow popup.\n     */\n    toggle(popupOpen) {\n      this._open = popupOpen !== undefined ? popupOpen : !this.popupOpen;\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n      if (this.popupOpen) {\n        let settings;\n        const isSection = this.normalizedOverflow.mode === 'section';\n        if (isSection) {\n          settings = {\n            anchor: this.element.nativeElement,\n            content: this.popupSectionTemplate,\n            popupClass: this.normalizePopupClasses(),\n            positionMode: 'absolute'\n          };\n        } else {\n          settings = {\n            anchor: this.overflowButton,\n            anchorAlign: this.popupSettings.anchorAlign,\n            popupAlign: this.popupSettings.popupAlign,\n            content: this.popupTemplate,\n            appendTo: this.appendTo,\n            animate: this.popupSettings.animate,\n            popupClass: this.normalizePopupClasses(this.popupSettings.popupClass),\n            positionMode: 'absolute'\n          };\n        }\n        this.popupRef = this.popupService.open(settings);\n        this.setPopupContentDimensions(isSection);\n        this.popupSubs.add(this.popupRef.popupOpen.subscribe(this.onPopupOpen.bind(this)));\n        this.popupSubs.add(this.popupRef.popupClose.subscribe(this.onPopupClose.bind(this)));\n      }\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      if (isDocumentAvailable()) {\n        if (this.showMenu) {\n          const containerWidth = innerWidth(this.element.nativeElement) - this.overflowAnchorWidth;\n          this.shrink(containerWidth, this.childrenWidth);\n          this.stretch(containerWidth, this.childrenWidth);\n          this.displayAnchor();\n          const isImmediateResize = Date.now() - this.overflowButtonClickedTime < immediateResizeThreshold;\n          if (this.popupOpen && !isImmediateResize) {\n            this.toggle();\n          }\n        } else if (this.isScrollMode) {\n          if (this.normalizedOverflow.scrollButtons === 'auto') {\n            const containerWidth = innerWidth(this.element.nativeElement);\n            let scrollButtonsWidth = 0;\n            if (this.showAutoButtons) {\n              const separatorWidth = this.scrollSeparator.nativeElement.getBoundingClientRect().width + 2 * this.gap;\n              if (this.hasScrollButtons.position === 'split') {\n                scrollButtonsWidth = innerWidth(this.prevScrollButton.nativeElement) + innerWidth(this.nextScrollButton.nativeElement) + 2 * separatorWidth;\n              } else if (this.hasScrollButtons.position === 'end') {\n                scrollButtonsWidth = innerWidth(this.endButtonGroup.nativeElement) + separatorWidth;\n              } else {\n                scrollButtonsWidth = innerWidth(this.startButtonGroup.nativeElement) + separatorWidth;\n              }\n            }\n            const shouldShowButtons = this.childrenWidth + scrollButtonsWidth > containerWidth;\n            if (shouldShowButtons !== this.showAutoButtons) {\n              this.showAutoButtons = shouldShowButtons;\n              this.cdr.detectChanges();\n            }\n            this.scrollService.toggleScrollButtonsState();\n          } else if (!this.hasScrollButtons.visible) {\n            this.setScrollableOverlayClasses();\n          } else if (!this.scrollService.toolsOverflow) {\n            this.renderer.addClass(this.nextScrollButton.nativeElement, 'k-disabled');\n            this.renderer.addClass(this.prevScrollButton.nativeElement, 'k-disabled');\n          } else {\n            this.scrollService.toggleScrollButtonsState();\n          }\n        }\n        this.resizeSensor?.acceptSize();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onPopupOpen() {\n      this.zone.runOutsideAngular(() => {\n        if (this.normalizedOverflow.mode === 'section') {\n          this.sectionKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', ev => {\n            switch (ev.keyCode) {\n              case Keys.ArrowLeft:\n                this.zone.run(() => {\n                  ev.preventDefault();\n                  if (this.direction === 'ltr') {\n                    this.navigationService.focusPrev(ev);\n                  } else {\n                    this.navigationService.focusNext(ev);\n                  }\n                  // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n                  this.element.nativeElement.setAttribute('tabindex', '-1');\n                });\n                break;\n              case Keys.ArrowRight:\n                this.zone.run(() => {\n                  ev.preventDefault();\n                  if (this.direction === 'ltr') {\n                    this.navigationService.focusNext(ev);\n                  } else {\n                    this.navigationService.focusPrev(ev);\n                  }\n                  // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n                  this.element.nativeElement.setAttribute('tabindex', '-1');\n                });\n                break;\n              case Keys.Escape:\n                {\n                  this.zone.run(() => this.toggle(false));\n                  const eventArgs = new PreventableEvent();\n                  this.close.emit(eventArgs);\n                  break;\n                }\n              case Keys.Tab:\n                this.zone.run(() => {\n                  this.toggle(false);\n                  this.navigationService.resetNavigation();\n                });\n                break;\n              default:\n                break;\n            }\n          });\n        } else {\n          this.overflowKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', ev => {\n            switch (ev.keyCode) {\n              case Keys.ArrowUp:\n                this.zone.run(() => {\n                  ev.preventDefault();\n                  this.navigationService.focusPrev(ev);\n                });\n                break;\n              case Keys.ArrowDown:\n                this.zone.run(() => {\n                  ev.preventDefault();\n                  this.navigationService.focusNext(ev);\n                });\n                break;\n              case Keys.Escape:\n                {\n                  this.zone.run(() => this.toggle(false));\n                  const eventArgs = new PreventableEvent();\n                  this.close.emit(eventArgs);\n                  break;\n                }\n              case Keys.Tab:\n                this.zone.run(() => {\n                  this.toggle(false);\n                  this.navigationService.resetNavigation();\n                });\n                break;\n              case Keys.Enter:\n              case Keys.Space:\n                this.zone.run(() => {\n                  if (ev.target.closest('.k-menu-item')) {\n                    ev.preventDefault();\n                    ev.target.click();\n                    ev.target.focus();\n                  }\n                });\n                break;\n              default:\n                break;\n            }\n          });\n        }\n      });\n      this.cancelRenderedToolsSubscription$.next();\n      this.navigationService.setRenderedTools(this.toolsService.overflowTools);\n      this.navigationService.moveFocusToPopup();\n      this.toolsService.overflowToolsChange.pipe(takeUntil(this.cancelRenderedToolsSubscription$)).subscribe(rts => this.navigationService.setRenderedTools(rts));\n      this.renderer.setAttribute(this.overflowButton.nativeElement, 'aria-controls', this.popupId);\n    }\n    /**\n     * @hidden\n     */\n    onPopupClose() {\n      this.cancelRenderedToolsSubscription$.next();\n      this.navigationService.setRenderedTools(this.toolsService.renderedTools);\n      this.toolsService.renderedToolsChange.pipe(takeUntil(this.cancelRenderedToolsSubscription$)).subscribe(rts => this.navigationService.setRenderedTools(rts));\n      this.navigationService.moveFocusToToolBar();\n      if (this.overflowKeydownListener) {\n        this.overflowKeydownListener();\n      }\n      if (this.sectionKeydownListener) {\n        this.sectionKeydownListener();\n      }\n      this.renderer.removeAttribute(this.overflowButton.nativeElement, 'aria-controls');\n    }\n    displayAnchor() {\n      const visibility = this.allTools.filter(t => t.overflows && t.responsive).length > 0 ? 'visible' : 'hidden';\n      this.overflowButton && this.renderer.setStyle(this.overflowButton.nativeElement, 'visibility', visibility);\n      const isVisible = visibility === 'visible';\n      if (isVisible !== this.showOverflowSeparator) {\n        this.showOverflowSeparator = isVisible;\n        this.cdr.detectChanges();\n      }\n    }\n    get popupWidth() {\n      if (!this.popupSettings || !this.popupSettings.width) {\n        return 'auto';\n      }\n      return isNaN(this.popupSettings.width) ? this.popupSettings.width : `${this.popupSettings.width}px`;\n    }\n    get popupHeight() {\n      if (!this.popupSettings || !this.popupSettings.height) {\n        return;\n      }\n      return isNaN(this.popupSettings.height) ? this.popupSettings.height : `${this.popupSettings.height}px`;\n    }\n    get overflowAnchorWidth() {\n      if (!this.showMenu) {\n        return 0;\n      }\n      if (!this.cachedOverflowAnchorWidth) {\n        this.cachedOverflowAnchorWidth = this.overflowButton.nativeElement.offsetWidth;\n      }\n      return this.cachedOverflowAnchorWidth;\n    }\n    get gap() {\n      if (isPresent(this.cachedGap)) {\n        return this.cachedGap;\n      }\n      const computedGap = getComputedStyle(this.element.nativeElement).gap;\n      this.cachedGap = isPresent(computedGap) ? parseInt(computedGap, 10) : 0;\n      return this.cachedGap;\n    }\n    get childrenWidth() {\n      const width = this.toolsService.renderedTools.reduce((totalWidth, tool) => tool.width + totalWidth + (tool.isDisplayed() ? this.gap : 0), 0);\n      return Math.ceil(width);\n    }\n    get visibleTools() {\n      return this.allTools.filter(tool => {\n        return tool.overflows === false;\n      });\n    }\n    get overflowTools() {\n      return this.allTools.filter(tool => {\n        return tool.overflows === true;\n      });\n    }\n    shrink(containerWidth, childrenWidth) {\n      let width;\n      if (containerWidth < childrenWidth) {\n        for (let i = this.visibleTools.length - 1; i >= 0; i--) {\n          if (containerWidth > childrenWidth) {\n            break;\n          } else {\n            width = this.hideLastVisibleTool();\n            childrenWidth -= width;\n          }\n        }\n      }\n    }\n    stretch(containerWidth, childrenWidth) {\n      let width;\n      if (containerWidth > childrenWidth) {\n        for (let i = this.overflowTools.length - 1; i >= 0; i--) {\n          width = this.showFirstHiddenTool(containerWidth, childrenWidth);\n          if (width) {\n            childrenWidth += width + this.gap;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    hideLastVisibleTool() {\n      const tool = this.visibleTools[this.visibleTools.length - 1];\n      if (!tool) {\n        return null;\n      }\n      const renderedElement = this.toolsService.renderedTools.find(r => {\n        return r.tool === tool;\n      });\n      const width = renderedElement.width;\n      tool.overflows = this.showMenu;\n      this.refreshService.refresh(tool);\n      return width;\n    }\n    showFirstHiddenTool(containerWidth, childrenWidth) {\n      const tool = this.overflowTools[0];\n      if (!tool) {\n        return null;\n      }\n      const renderedElement = this.toolsService.renderedTools.find(r => r.tool === tool);\n      tool.overflows = false;\n      tool.visibility = 'hidden';\n      this.refreshService.refresh(tool);\n      if (containerWidth > childrenWidth + renderedElement.width) {\n        tool.visibility = 'visible';\n      } else {\n        tool.overflows = true;\n      }\n      this.refreshService.refresh(tool);\n      return renderedElement.width; // returns 0 if `overflows` is true\n    }\n\n    setPopupContentDimensions(isSection) {\n      const popupContentContainer = this.popupRef.popup.instance.contentContainer.nativeElement;\n      if (isSection) {\n        const toolbarWidth = this.element.nativeElement.getBoundingClientRect().width;\n        popupContentContainer.style.width = `${toolbarWidth}px`;\n      } else {\n        popupContentContainer.style.width = this.popupWidth;\n        popupContentContainer.style.height = this.popupHeight;\n        popupContentContainer.style.overflow = 'auto';\n      }\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupSubs.unsubscribe();\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('toolbar', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    normalizePopupClasses(classList) {\n      let classes = ['k-toolbar-popup'];\n      if (this.normalizedOverflow.mode === 'menu') {\n        classes.push('k-menu-popup');\n      }\n      if (!classList) {\n        return classes;\n      }\n      if (typeof classList === 'string') {\n        classes.push(...classList.split(' '));\n      } else if (Array.isArray(classList)) {\n        classes = [...classes, ...classList];\n      } else {\n        for (const cl in classList) {\n          classes.push(classList[cl]);\n        }\n      }\n      return classes;\n    }\n    setScrollableOverlayClasses() {\n      const wrapper = this.element.nativeElement;\n      const container = this.scrollContainer?.nativeElement;\n      if (!container) {\n        return;\n      }\n      const scrollOffset = container.scrollLeft;\n      const defaultOffset = 1;\n      if (this.scrollService.toolsOverflow && !this.hasScrollButtons.visible) {\n        this.renderer.addClass(wrapper, 'k-toolbar-scrollable-overlay');\n        if (scrollOffset === 0) {\n          this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');\n          this.renderer.addClass(wrapper, 'k-toolbar-scrollable-start');\n        } else if (scrollOffset > 0 && scrollOffset < this.scrollService.scrollContainerOverflowSize - defaultOffset || scrollOffset < 0 && Math.abs(scrollOffset) < this.scrollService.scrollContainerOverflowSize - defaultOffset) {\n          this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');\n          this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');\n        } else {\n          this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');\n          this.renderer.addClass(wrapper, 'k-toolbar-scrollable-end');\n        }\n      } else {\n        this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-overlay');\n        this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');\n        this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');\n      }\n    }\n    handleScrollModeUpdates() {\n      if (isPresent(this.scrollContainer)) {\n        this.scrollService.updateScrollPosition(this.scrollContainer.nativeElement);\n        this.zone.runOutsideAngular(() => {\n          this.scrollContainerScrollSub = this.renderer.listen(this.scrollContainer.nativeElement, 'scroll', e => {\n            if (!this.hasScrollButtons.visible) {\n              this.setScrollableOverlayClasses();\n            } else {\n              this.scrollService.onScroll(e);\n            }\n          });\n          this.subscriptions.add(this.scrollContainerScrollSub);\n        });\n      }\n      if (this.showScrollButtons && this.nextScrollButton && this.prevScrollButton) {\n        if (this.normalizedOverflow.scrollButtons === 'visible' && !this.scrollService.toolsOverflow) {\n          this.renderer.addClass(this.nextScrollButton.nativeElement, 'k-disabled');\n          this.renderer.addClass(this.prevScrollButton.nativeElement, 'k-disabled');\n        } else {\n          const buttonToDisable = this.direction === 'rtl' ? this.nextScrollButton : this.prevScrollButton;\n          this.renderer.addClass(buttonToDisable.nativeElement, 'k-disabled');\n        }\n      }\n      if (this.hasScrollButtons.visible) {\n        this.scrollButtonStateChangeSub = this.scrollService.scrollButtonActiveStateChange.subscribe(activeButtonSettings => {\n          if (this.showScrollButtons) {\n            const action = activeButtonSettings.active ? 'remove' : 'add';\n            const scrollButton = this[`${activeButtonSettings.buttonType}ScrollButton`]?.nativeElement;\n            scrollButton && this.renderer[`${action}Class`](scrollButton, 'k-disabled');\n          }\n        });\n        this.subscriptions.add(this.scrollButtonStateChangeSub);\n        this.scrollService.toggleScrollButtonsState();\n      }\n    }\n    removeSubscriptions(subsToRemove) {\n      subsToRemove.forEach(sub => {\n        if (this[sub]) {\n          this.subscriptions.remove(this[sub]);\n          this[sub] = null;\n        }\n      });\n    }\n  }\n  _class12 = ToolBarComponent;\n  _defineProperty(ToolBarComponent, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(RefreshService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ToolbarToolsService), i0.ɵɵdirectiveInject(ScrollService));\n  });\n  _defineProperty(ToolBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class12,\n    selectors: [[\"kendo-toolbar\"]],\n    contentQueries: function _class12_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ToolBarToolComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.allTools = _t);\n      }\n    },\n    viewQuery: function _class12_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c4, 5, ElementRef);\n        i0.ɵɵviewQuery(_c2, 7);\n        i0.ɵɵviewQuery(_c5, 7);\n        i0.ɵɵviewQuery(_c6, 5, ElementRef);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c9, 5, ElementRef);\n        i0.ɵɵviewQuery(_c10, 5, ElementRef);\n        i0.ɵɵviewQuery(_c11, 5, ElementRef);\n        i0.ɵɵviewQuery(_c12, 5, ElementRef);\n        i0.ɵɵviewQuery(_c13, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupSectionTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.startButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.endButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollSeparator = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function _class12_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function _class12_focus_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        })(\"focusout\", function _class12_focusout_HostBindingHandler($event) {\n          return ctx.onFocusOut($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"dir\", ctx.getDir);\n        i0.ɵɵclassProp(\"k-toolbar\", ctx.hostClass)(\"k-toolbar-scrollable\", ctx.scrollableClass)(\"k-toolbar-section\", ctx.sectionClass)(\"k-toolbar-resizable\", ctx.resizableClass);\n      }\n    },\n    inputs: {\n      overflow: \"overflow\",\n      resizable: \"resizable\",\n      popupSettings: \"popupSettings\",\n      fillMode: \"fillMode\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBar\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([RefreshService, NavigationService, LocalizationService, ToolbarToolsService, ScrollService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.toolbar'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 15,\n    vars: 7,\n    consts: function () {\n      let i18n_14;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **more tools** button in a responsive ToolBar\n         * @meaning kendo.toolbar.moreToolsTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_15 = goog.getMsg(\"More tools\");\n        i18n_14 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_15;\n      } else {\n        i18n_14 = $localize`:kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar:More tools`;\n      }\n      let i18n_16;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Previous Tool** button when the Toolbar is scrollable.\n         * @meaning kendo.toolbar.previousToolButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_17 = goog.getMsg(\"Scroll left\");\n        i18n_16 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_17;\n      } else {\n        i18n_16 = $localize`:kendo.toolbar.previousToolButton|The title for the **Previous Tool** button when the Toolbar is scrollable.:Scroll left`;\n      }\n      let i18n_18;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Next Tool** button when the Toolbar is scrollable.\n         * @meaning kendo.toolbar.nextToolButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_19 = goog.getMsg(\"Scroll right\");\n        i18n_18 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLBAR_MJS_19;\n      } else {\n        i18n_18 = $localize`:kendo.toolbar.nextToolButton|The title for the **Next Tool** button when the Toolbar is scrollable.:Scroll right`;\n      }\n      return [[\"kendoToolbarLocalizedMessages\", \"\", \"moreToolsTitle\", i18n_14, \"previousToolButton\", i18n_16, \"nextToolButton\", i18n_18], [4, \"ngIf\"], [\"class\", \"k-toolbar-items k-toolbar-items-scroll\", \"tabindex\", \"-1\", 4, \"ngIf\", \"ngIfElse\"], [\"noScroll\", \"\"], [\"class\", \"k-toolbar-separator k-toolbar-button-separator k-separator\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"fillMode\", \"flat\", \"type\", \"button\", \"tabindex\", \"-1\", \"class\", \"k-toolbar-overflow-button\", 3, \"icon\", \"svgIcon\", \"title\", \"id\", \"visibility\", \"position\", \"ngClass\", \"click\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"popupSectionTemplate\", \"\"], [\"container\", \"\"], [\"kendoToolbarScrollableButton\", \"\", \"class\", \"k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md\", 3, \"prev\", \"overflow\", \"title\", \"ngClass\", \"onClick\", 4, \"ngIf\"], [\"class\", \"k-button-group k-button-group-solid\", 4, \"ngIf\"], [1, \"k-toolbar-separator\", \"k-toolbar-button-separator\", \"k-separator\"], [\"scrollSeparator\", \"\"], [\"kendoToolbarScrollableButton\", \"\", 1, \"k-toolbar-prev\", \"k-icon-button\", \"k-button\", \"k-button-solid\", \"k-button-solid-base\", \"k-rounded-md\", 3, \"prev\", \"overflow\", \"title\", \"ngClass\", \"onClick\"], [\"prevScrollButton\", \"\"], [1, \"k-button-group\", \"k-button-group-solid\"], [\"startButtonGroup\", \"\"], [\"kendoToolbarScrollableButton\", \"\", 1, \"k-toolbar-next\", \"k-icon-button\", \"k-button\", \"k-button-solid\", \"k-button-solid-base\", \"k-rounded-md\", 3, \"prev\", \"overflow\", \"title\", \"ngClass\", \"onClick\"], [\"nextScrollButton\", \"\"], [\"tabindex\", \"-1\", 1, \"k-toolbar-items\", \"k-toolbar-items-scroll\"], [\"scrollContainer\", \"\"], [\"kendoToolbarRenderer\", \"\", \"location\", \"toolbar\", 3, \"tool\", \"resizable\", \"ngTemplateOutlet\", \"rendererClick\", 4, \"ngFor\", \"ngForOf\"], [\"kendoToolbarRenderer\", \"\", \"location\", \"toolbar\", 3, \"tool\", \"resizable\", \"ngTemplateOutlet\", \"rendererClick\"], [\"wrapper\", \"\"], [1, \"k-toolbar-item\"], [3, \"ngTemplateOutlet\"], [\"kendoButton\", \"\", \"fillMode\", \"flat\", \"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-toolbar-overflow-button\", 3, \"icon\", \"svgIcon\", \"title\", \"id\", \"ngClass\", \"click\"], [\"overflowButton\", \"\"], [\"kendoToolbarScrollableButton\", \"\", \"class\", \"k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md\", 3, \"prev\", \"overflow\", \"title\", \"ngClass\", \"onClick\", 4, \"ngIf\"], [\"endButtonGroup\", \"\"], [\"role\", \"menu\", 1, \"k-menu-group\", \"k-menu-group-md\", 3, \"id\"], [4, \"ngFor\", \"ngForOf\"], [\"popupWrapper\", \"\"], [\"kendoToolbarRenderer\", \"\", \"location\", \"overflow\", 3, \"tool\", \"resizable\", \"ngTemplateOutlet\", \"rendererClick\"], [\"role\", \"menuitem\", \"tabindex\", \"-1\", 1, \"k-item\", \"k-menu-item\"], [\"role\", \"toolbar\", 1, \"k-toolbar-items-list\", \"k-toolbar-items-list-solid\", 3, \"ngClass\", \"id\"], [\"kendoToolbarRenderer\", \"\", \"location\", \"section\", 3, \"tool\", \"resizable\", \"ngTemplateOutlet\", \"rendererClick\", 4, \"ngFor\", \"ngForOf\"], [\"kendoToolbarRenderer\", \"\", \"location\", \"section\", 3, \"tool\", \"resizable\", \"ngTemplateOutlet\", \"rendererClick\"], [\"resizeSensor\", \"\"]];\n    },\n    template: function _class12_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, _class12_ng_container_1_Template, 5, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, _class12_div_2_Template, 3, 1, \"div\", 2);\n        i0.ɵɵtemplate(3, _class12_ng_template_3_Template, 1, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, _class12_div_5_Template, 1, 0, \"div\", 4);\n        i0.ɵɵtemplate(6, _class12_button_6_Template, 2, 12, \"button\", 5);\n        i0.ɵɵtemplate(7, _class12_ng_container_7_Template, 5, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(8, _class12_ng_template_8_Template, 2, 4, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, _class12_ng_template_10_Template, 2, 5, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(12, null, 8);\n        i0.ɵɵtemplate(14, _class12_kendo_resize_sensor_14_Template, 2, 0, \"kendo-resize-sensor\", 1);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(4);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showScrollButtons && (ctx.hasScrollButtons.position === \"split\" || ctx.hasScrollButtons.position === \"start\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isScrollMode)(\"ngIfElse\", _r2);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.showOverflowSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMenu);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showScrollButtons && (ctx.hasScrollButtons.position === \"split\" || ctx.hasScrollButtons.position === \"end\"));\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngIf\", ctx.overflowEnabled);\n      }\n    },\n    dependencies: [NgTemplateOutlet, LocalizedToolbarMessagesDirective, NgFor, ToolBarRendererComponent, NgIf, ButtonComponent, NgClass, ResizeSensorComponent, ToolbarScrollableButtonComponent],\n    encapsulation: 2\n  }));\n  return ToolBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ToolBar Button tool for Angular]({% slug controltypes_toolbar %}#toc-buttons).\n */\nlet ToolBarButtonComponent = /*#__PURE__*/(() => {\n  var _class13;\n  class ToolBarButtonComponent extends ToolBarToolComponent {\n    // showText and showIcon showIcon should be declared first\n    /**\n     * Specifies where button text should be displayed\n     */\n    set showText(value) {\n      this._showText = value;\n      this.setTextDisplayMode();\n    }\n    get showText() {\n      return this._showText;\n    }\n    /**\n     * Specifies where button icon should be displayed\n     */\n\n    /**\n     * Specifies the text of the Button ([see example]({% slug controltypes_toolbar %}#toc-buttons)).\n     */\n    set text(text) {\n      this._text = text;\n      this.setTextDisplayMode();\n    }\n    get text() {\n      return this._text;\n    }\n    /**\n     * Specifies custom inline CSS styles of the Button.\n     */\n\n    /**\n     * @hidden\n     */\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get togglable() {\n      return this.toggleable;\n    }\n    set togglable(value) {\n      this.toggleable = value;\n    }\n    /**\n     * Sets the selected state of the Button.\n     */\n\n    /**\n     * Defines the name for an existing icon in a Kendo UI theme\n     * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).\n     * The icon is rendered inside the Button by a `span.k-icon` element.\n     */\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;\n     * which are applied to a `span` element inside the Button. Allows the usage of custom icons.\n     */\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines an SVGIcon to be rendered within the button.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;\n      const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;\n      if (isDevMode() && icon && isIconSet && isIconClassSet) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines a URL which is used for an `img` element inside the Button.\n     * The URL can be relative or absolute. If relative, it is evaluated with relation to the web page URL.\n     */\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n    /**\n     * Fires each time the Button is clicked.\n     */\n\n    constructor(element, zone) {\n      super();\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"showIcon\", 'both');\n      _defineProperty(this, \"style\", void 0);\n      /**\n       * Specifies custom CSS class names that will be added to the Button.\n       */\n      _defineProperty(this, \"className\", void 0);\n      /**\n       * Specifies the title of the Button.\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * If `disabled` is set to `true`, the Button is disabled\n       * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      /**\n       * Provides visual styling that indicates if the Button is active\n       * ([see example]({% slug controltypes_toolbar %}#toc-toggle-buttons)).\n       * By default, `toggleable` is set to `false`.\n       */\n      _defineProperty(this, \"toggleable\", false);\n      _defineProperty(this, \"selected\", false);\n      /**\n       * The fillMode property specifies the background and border styles of the Button.\n       *\n       * The available values are:\n       * * `solid` (default)\n       * * `flat`\n       * * `outline`\n       * * `link`\n       * * `null`\n       */\n      _defineProperty(this, \"fillMode\", 'solid');\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n      _defineProperty(this, \"themeColor\", 'base');\n      _defineProperty(this, \"click\", new EventEmitter());\n      /**\n       * Fires when the Button [pointerdown](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerdown_event) event is triggered.\n       */\n      _defineProperty(this, \"pointerdown\", new EventEmitter());\n      /**\n       * Fires each time the selected state of a Toggle Button is changed.\n       * The event argument is the new selected state (Boolean).\n       */\n      _defineProperty(this, \"selectedChange\", new EventEmitter());\n      _defineProperty(this, \"toolbarOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"overflowOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"toolbarButtonElement\", void 0);\n      _defineProperty(this, \"sectionButtonElement\", void 0);\n      _defineProperty(this, \"overflowButtonElement\", void 0);\n      _defineProperty(this, \"_showText\", 'both');\n      _defineProperty(this, \"_text\", void 0);\n      this.element = element;\n      this.zone = zone;\n      this.isBuiltInTool = true;\n    }\n    ngOnInit() {\n      this.setTextDisplayMode();\n    }\n    /**\n     * @hidden\n     */\n    onBlur() {\n      this.getButton().tabIndex = -1;\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    focus(ev) {\n      // guard against focusing twice on mousedown.\n      if (!ev || ev.type === 'focus' || ev.type === 'keydown') {\n        this.getButton().focus();\n      }\n      this.getButton().tabIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n    handleKey() {\n      this.getButton().tabIndex = -1;\n      return false;\n    }\n    /**\n     * @hidden\n     */\n    handleClick(ev) {\n      this.click.emit(ev);\n      if (this.toggleable) {\n        this.selected = !this.selected;\n        this.selectedChange.emit(this.selected);\n      }\n    }\n    /**\n     * @hidden\n     */\n    selectedChangeHandler(state) {\n      this.selected = state;\n      this.selectedChange.emit(state);\n    }\n    getButton() {\n      return this[`${this.location}ButtonElement`]?.nativeElement;\n    }\n    setTextDisplayMode() {\n      this.toolbarOptions.text = this.showText === 'overflow' ? undefined : this.text;\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        this.overflowOptions.text = this.showText === 'toolbar' ? undefined : this.text;\n      });\n    }\n  }\n  _class13 = ToolBarButtonComponent;\n  _defineProperty(ToolBarButtonComponent, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ToolBarButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class13,\n    selectors: [[\"kendo-toolbar-button\"]],\n    viewQuery: function _class13_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c21, 5, ElementRef);\n        i0.ɵɵviewQuery(_c22, 5, ElementRef);\n        i0.ɵɵviewQuery(_c4, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarButtonElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sectionButtonElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowButtonElement = _t.first);\n      }\n    },\n    inputs: {\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      style: \"style\",\n      className: \"className\",\n      title: \"title\",\n      disabled: \"disabled\",\n      toggleable: \"toggleable\",\n      look: \"look\",\n      togglable: \"togglable\",\n      selected: \"selected\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      svgIcon: \"svgIcon\",\n      imageUrl: \"imageUrl\"\n    },\n    outputs: {\n      click: \"click\",\n      pointerdown: \"pointerdown\",\n      selectedChange: \"selectedChange\"\n    },\n    exportAs: [\"kendoToolBarButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class13)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [\"sectionTemplate\", \"\"], [\"type\", \"button\", \"kendoButton\", \"\", 3, \"tabindex\", \"ngStyle\", \"ngClass\", \"disabled\", \"toggleable\", \"fillMode\", \"themeColor\", \"selected\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\", \"blur\"], [\"toolbarButton\", \"\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"ngClass\", \"ngStyle\", \"click\"], [\"overflowButton\", \"\"], [1, \"k-link\", \"k-menu-link\"], [3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-menu-link-text\"], [\"sectionButton\", \"\"]],\n    template: function _class13_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class13_ng_template_0_Template, 3, 18, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, _class13_ng_template_2_Template, 5, 8, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, _class13_ng_template_4_Template, 3, 18, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    dependencies: [ButtonComponent, NgStyle, NgClass, NgIf, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ToolBarButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the Kendo UI Toolbar ButtonGroup for Angular.\n */\nlet ToolBarButtonGroupComponent = /*#__PURE__*/(() => {\n  var _class14;\n  class ToolBarButtonGroupComponent extends ToolBarToolComponent {\n    /**\n     * @hidden\n     */\n    set look(look) {\n      if (look) {\n        this.buttonComponents.forEach(b => b.fillMode = look === 'default' ? 'solid' : look);\n      }\n    }\n    get buttonElements() {\n      if (this.overflows && this.location === 'overflow') {\n        return [...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))].map(el => el.nativeElement);\n      } else if (this.overflows && this.location === 'section') {\n        return this.sectionButtonGroup.buttons.filter(b => !b.isDisabled).map(b => b.element);\n      } else {\n        return this.toolbarButtonGroup.buttons.filter(b => !b.isDisabled).map(b => b.element);\n      }\n    }\n    constructor(localization) {\n      super();\n      _defineProperty(this, \"localization\", void 0);\n      /**\n       * By default, the ButtonGroup is enabled. To disable the whole group of buttons, set its `disabled`\n       * attribute to `true`. To disable a specific button, set the `disabled` attribute of the button to\n       * `true` and leave the `disabled` attribute of the ButtonGroup undefined. If you define the `disabled`\n       * attribute of the ButtonGroup, it will take precedence over the `disabled` attributes of the underlying\n       * buttons and they will be ignored.\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      /**\n       * @hidden\n       *\n       * Used to set different fillmode in Spreadsheet and Toolbar to comply with referent rendering.\n       */\n      _defineProperty(this, \"fillMode\", 'solid');\n      /**\n       * By default, the selection mode of the ButtonGroup is set to `multiple`.\n       */\n      _defineProperty(this, \"selection\", 'multiple');\n      /**\n       * Sets the width of the ButtonGroup.\n       *\n       * If the width of the ButtonGroup is set:\n       * - The buttons resize automatically to fill the full width of the group wrapper.\n       * - The buttons acquire the same width.\n       */\n      _defineProperty(this, \"width\", void 0);\n      _defineProperty(this, \"toolbarButtonGroup\", void 0);\n      _defineProperty(this, \"sectionButtonGroup\", void 0);\n      _defineProperty(this, \"overflowListItems\", void 0);\n      _defineProperty(this, \"buttonComponents\", void 0);\n      _defineProperty(this, \"focusedIndex\", -1);\n      _defineProperty(this, \"getNextKey\", void 0);\n      _defineProperty(this, \"getPrevKey\", void 0);\n      this.localization = localization;\n      this.getNextKey = getNextKey(this.localization.rtl);\n      this.getPrevKey = getPrevKey(this.localization.rtl);\n      this.isBuiltInTool = true;\n    }\n    /**\n     * @hidden\n     */\n    onFocus() {\n      // triggered on tabin\n      this.focusedIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n    onNavigate(ev) {\n      ev.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    selectedChangeHandler(state, button) {\n      button.selected = state;\n      button.selectedChange.emit(state);\n    }\n    /**\n     * @hidden\n     */\n    overflowSelectedChangeHandler(button) {\n      if (this.selection === 'multiple') {\n        button.selected = !button.selected;\n      } else {\n        const filteredButtons = this.buttonComponents.filter(b => b !== button);\n        filteredButtons.forEach(b => b.selected = false);\n        button.selected = !button.selected;\n      }\n      button.selectedChange.emit(button.selected);\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick(ev) {\n      this.focusedIndex = this.buttonElements.findIndex(be => be === ev.target || be.contains(ev.target));\n      this.focusButton(this.focusedIndex, ev);\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return !(this.disabled || this.buttonElements.length === 0);\n    }\n    /**\n     * @hidden\n     */\n    focus(ev = {}) {\n      const nextKey = this.getNextKey(this.overflows && this.location === 'overflow');\n      const prevKey = this.getPrevKey(this.overflows && this.location === 'overflow');\n      this.focusedIndex = getIndexOfFocused(prevKey, nextKey, this.buttonElements)(ev);\n      this.focusButton(this.focusedIndex, ev);\n    }\n    /**\n     * @hidden\n     */\n    handleKey(ev) {\n      const nextKey = this.getNextKey(this.overflows && this.location === 'overflow');\n      const prevKey = this.getPrevKey(this.overflows && this.location === 'overflow');\n      const peekAtIndex = makePeeker(this.buttonElements);\n      const isUnmodified = areEqual(this.focusedIndex);\n      this.focusedIndex = seekFocusedIndex(prevKey, nextKey, peekAtIndex)(this.focusedIndex, ev);\n      this.focusButton(this.focusedIndex, ev);\n      return !isUnmodified(this.focusedIndex);\n    }\n    /**\n     * @hidden\n     */\n    handleClick(ev, button) {\n      button.click.emit(ev);\n      this.onButtonClick(ev);\n      this.overflowSelectedChangeHandler(button);\n    }\n    /**\n     * @hidden\n     */\n    getIconClasses(button) {\n      if (button.overflowOptions.icon) {\n        return `${button.overflowOptions.icon}`;\n      }\n      if (button.overflowOptions.iconClass) {\n        return button.overflowOptions.iconClass;\n      }\n      if (button.overflowOptions.svgIcon) {\n        return button.overflowOptions.svgIcon;\n      }\n    }\n    focusButton(index, ev) {\n      // Guard against focusing twice on mousedown.\n      if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n        this.buttonElements[index]?.focus();\n      }\n    }\n  }\n  _class14 = ToolBarButtonGroupComponent;\n  _defineProperty(ToolBarButtonGroupComponent, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ToolBarButtonGroupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class14,\n    selectors: [[\"kendo-toolbar-buttongroup\"]],\n    contentQueries: function _class14_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ToolBarButtonComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttonComponents = _t);\n      }\n    },\n    viewQuery: function _class14_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c23, 5);\n        i0.ɵɵviewQuery(_c24, 5);\n        i0.ɵɵviewQuery(_c25, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sectionButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowListItems = _t);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      fillMode: \"fillMode\",\n      selection: \"selection\",\n      width: \"width\",\n      look: \"look\"\n    },\n    exportAs: [\"kendoToolBarButtonGroup\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class14)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [\"sectionTemplate\", \"\"], [3, \"tabIndex\", \"selection\", \"disabled\", \"width\", \"navigate\", \"focus\"], [\"toolbarButtonGroup\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\", 4, \"ngFor\", \"ngForOf\"], [\"kendoButton\", \"\", \"type\", \"button\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", \"class\", \"k-item k-menu-item\", 3, \"k-disabled\", \"ngStyle\", \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"ngStyle\", \"ngClass\", \"click\"], [\"listItem\", \"\"], [1, \"k-link\", \"k-menu-link\"], [3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-menu-link-text\"], [\"sectionButtonGroup\", \"\"]],\n    template: function _class14_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class14_ng_template_0_Template, 3, 8, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, _class14_ng_template_2_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, _class14_ng_template_4_Template, 3, 8, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    dependencies: [ButtonGroupComponent, NgFor, ButtonComponent, NgStyle, NgClass, NgIf, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ToolBarButtonGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ToolBar DropDownButton for Angular](slug:controltypes_toolbar#drop-down-buttons).\n */\nlet ToolBarDropDownButtonComponent = /*#__PURE__*/(() => {\n  var _class15;\n  class ToolBarDropDownButtonComponent extends ToolBarToolComponent {\n    // showText and showIcon showIcon should be declared first\n    /**\n     * Defines the location of the button text that will be displayed.\n     */\n    set showText(value) {\n      this._showText = value;\n      this.setTextDisplayMode();\n    }\n    get showText() {\n      return this._showText;\n    }\n    /**\n     * Defines the location of the button icon that will be displayed.\n     */\n\n    /**\n     * Sets the text of the DropDownButton\n     * ([see example](slug:controltypes_toolbar#toc-drop-down-buttons)).\n     */\n    set text(text) {\n      this._text = text;\n      this.setTextDisplayMode();\n    }\n    get text() {\n      return this._text;\n    }\n    /**\n     * Defines an icon that will be rendered next to the button text.\n     */\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an SVGIcon to be rendered within the button.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;\n      const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;\n      if (isDevMode() && icon && isIconSet && isIconClassSet) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an icon with a custom CSS class that will be rendered next to the button text.\n     */\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines the location of an image that will be displayed next to the button text.\n     */\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n    /**\n     * Configures the popup of the DropDownButton.\n     *\n     * The available options are:\n     * - `animate:Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass:String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * @hidden\n     */\n    set primary(primary) {\n      this.themeColor = primary ? 'primary' : 'base';\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Button.\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     * * `null`\n     */\n\n    /**\n     * Sets the data of the DropDownButton\n     * ([see example](slug:controltypes_toolbar#drop-down-buttons)).\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n      return this._data;\n    }\n    /**\n     * Fires each time the user clicks a DropDownButton item.\n     * The event data contains the data item that is bound to the clicked list item.\n     */\n\n    get overflowButtons() {\n      return [...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))];\n    }\n    constructor(zone, renderer) {\n      super();\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      /**\n       * Allows showing the default arrow icon or providing alternative one instead.\n       * @default false\n       */\n      _defineProperty(this, \"arrowIcon\", false);\n      /**\n       * Sets the `title` attribute of the underlying button element.\n       * @default ''\n       */\n      _defineProperty(this, \"title\", '');\n      _defineProperty(this, \"showIcon\", 'both');\n      _defineProperty(this, \"fillMode\", 'solid');\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n      _defineProperty(this, \"themeColor\", 'base');\n      /**\n       * The CSS classes that will be rendered on the main button.\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"buttonClass\", void 0);\n      /**\n       * Sets the data item field that represents the item text.\n       * If the data contains only primitive values, do not define it.\n       */\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * Sets the disabled state of the DropDownButton.\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"dropdownButton\", void 0);\n      _defineProperty(this, \"toolbarDropDownButton\", void 0);\n      _defineProperty(this, \"sectionDropDownButton\", void 0);\n      _defineProperty(this, \"overflowListItems\", void 0);\n      _defineProperty(this, \"toolbarOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"overflowOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"_data\", void 0);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true,\n        popupClass: ''\n      });\n      _defineProperty(this, \"focusedIndex\", -1);\n      _defineProperty(this, \"_showText\", 'both');\n      _defineProperty(this, \"_text\", void 0);\n      _defineProperty(this, \"getNextKey\", void 0);\n      _defineProperty(this, \"getPrevKey\", void 0);\n      this.zone = zone;\n      this.renderer = renderer;\n      this.getNextKey = getNextKey();\n      this.getPrevKey = getPrevKey();\n      this.isBuiltInTool = true;\n    }\n    ngOnInit() {\n      this.setTextDisplayMode();\n    }\n    ngAfterViewInit() {\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        this.renderer.addClass(this[`${this.location}DropDownButton`].button.nativeElement, 'k-toolbar-menu-button');\n      });\n    }\n    /**\n     * @hidden\n     */\n    onButtonListClick(ev) {\n      this.focusedIndex = this.overflowListItems.toArray().findIndex(b => b.nativeElement.contains(ev.target));\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    focus(ev = {}) {\n      if (!this.overflows || this.location === 'section') {\n        if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n          this[`${this.location}DropDownButton`]?.focus();\n        }\n      } else if (this.overflowButtons.length > 0) {\n        this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);\n        this.focusButton(this.focusedIndex, ev);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleKey(ev) {\n      if (!this.overflows && (ev.keyCode === this.getPrevKey(this.overflows) || ev.keyCode === this.getNextKey(this.overflows))) {\n        return false;\n      }\n      if (this.overflows && this.location !== 'section') {\n        const peekAtIndex = makePeeker(this.overflowButtons);\n        const isUnmodified = areEqual(this.focusedIndex);\n        this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);\n        this.focusButton(this.focusedIndex, ev);\n        return !isUnmodified(this.focusedIndex);\n      }\n    }\n    /**\n     * @hidden\n     */\n    getText(dataItem) {\n      if (dataItem) {\n        return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n      }\n      return undefined;\n    }\n    /**\n     * @hidden\n     */\n    handleClick(ev, item, index) {\n      this.onButtonListClick(ev);\n      const dataItem = this.data[index];\n      if (item.click) {\n        item.click(dataItem);\n      }\n      this.itemClick.emit(dataItem);\n    }\n    focusButton(index, ev) {\n      if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n        this.overflowButtons[index].nativeElement.focus();\n      }\n    }\n    setTextDisplayMode() {\n      this.toolbarOptions.text = this.showText === 'overflow' ? undefined : this.text;\n      this.overflowOptions.text = this.showText === 'toolbar' ? undefined : this.text;\n    }\n  }\n  _class15 = ToolBarDropDownButtonComponent;\n  _defineProperty(ToolBarDropDownButtonComponent, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(ToolBarDropDownButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class15,\n    selectors: [[\"kendo-toolbar-dropdownbutton\"]],\n    viewQuery: function _class15_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c26, 7, ElementRef);\n        i0.ɵɵviewQuery(_c27, 5);\n        i0.ɵɵviewQuery(_c28, 5);\n        i0.ɵɵviewQuery(_c25, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarDropDownButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sectionDropDownButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowListItems = _t);\n      }\n    },\n    inputs: {\n      arrowIcon: \"arrowIcon\",\n      title: \"title\",\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      popupSettings: \"popupSettings\",\n      look: \"look\",\n      primary: \"primary\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      buttonClass: \"buttonClass\",\n      textField: \"textField\",\n      disabled: \"disabled\",\n      data: \"data\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBarDropDownButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class15)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [\"sectionTemplate\", \"\"], [3, \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"arrowIcon\", \"buttonClass\", \"disabled\", \"tabIndex\", \"data\", \"buttonAttributes\", \"textField\", \"popupSettings\", \"fillMode\", \"themeColor\", \"open\", \"close\", \"itemClick\"], [\"toolbarDropDownButton\", \"\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", \"k-disabled\", 3, \"ngClass\"], [3, \"ngClass\"], [3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-menu-link-text\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"click\"], [\"listItem\", \"\"], [1, \"k-link\", \"k-menu-link\", 3, \"ngClass\"], [\"sectionDropDownButton\", \"\"]],\n    template: function _class15_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class15_ng_template_0_Template, 3, 17, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, _class15_ng_template_2_Template, 5, 6, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, _class15_ng_template_4_Template, 3, 17, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    dependencies: [DropDownButtonComponent, NgClass, NgIf, IconWrapperComponent, NgFor],\n    encapsulation: 2\n  }));\n  return ToolBarDropDownButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ToolBar SplitButton for Angular](slug:controltypes_toolbar#toc-split-buttons).\n */\nlet ToolBarSplitButtonComponent = /*#__PURE__*/(() => {\n  var _class16;\n  class ToolBarSplitButtonComponent extends ToolBarToolComponent {\n    // showText and showIcon showIcon should be declared first\n    /**\n     * Specifies where button text should be displayed\n     */\n    set showText(value) {\n      this._showText = value;\n      this.setTextDisplayMode();\n    }\n    get showText() {\n      return this._showText;\n    }\n    /**\n     * Specifies where button icon should be displayed\n     */\n\n    /**\n     * Sets the text of the SplitButton ([see example](slug:controltypes_toolbar#toc-split-buttons)).\n     */\n    set text(text) {\n      this._text = text;\n      this.setTextDisplayMode();\n    }\n    get text() {\n      return this._text;\n    }\n    /**\n     * Defines the icon that will be rendered next to the button text\n     * ([see example](slug:controltypes_toolbar#toc-split-buttons)).\n     */\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an SVGIcon to be rendered within the main button.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;\n      const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;\n      if (isDevMode() && icon && isIconSet && isIconClassSet) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an icon with a custom CSS class that will be rendered next to the button text.\n     */\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines the location of an image that will be displayed next to the button text.\n     */\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n    /**\n     * When set to `true`, disables a SplitButton item.\n     */\n\n    /**\n     * Configures the popup of the SplitButton.\n     *\n     * The available options are:\n     * - `animate:Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass:String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(value) {\n      this._popupSettings = value;\n    }\n    get popupSettings() {\n      if (!this._popupSettings) {\n        this._popupSettings = {\n          animate: true,\n          popupClass: ''\n        };\n      }\n      return this._popupSettings;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Button.\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     * * `null`\n     */\n\n    /**\n     * @hidden\n     */\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * The CSS classes that will be rendered on the main button.\n     * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n     */\n\n    /**\n     * Sets the data of the SplitButton ([see example](slug:controltypes_toolbar#toc-split-buttons)).\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n      return this._data;\n    }\n    /**\n     * Fires each time the user clicks the main button.\n     */\n\n    ngOnInit() {\n      this.setTextDisplayMode();\n    }\n    get overflowButtons() {\n      return [this.overflowMainButton, ...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))];\n    }\n    constructor() {\n      super();\n      _defineProperty(this, \"showIcon\", 'both');\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"fillMode\", 'solid');\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly.\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n      _defineProperty(this, \"themeColor\", 'base');\n      _defineProperty(this, \"buttonClass\", void 0);\n      /**\n       * The CSS classes that will be rendered on the button which opens the popup.\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"arrowButtonClass\", void 0);\n      /**\n       * Specifies the name of the [font icon](slug:icons#icons-list) that will\n       * be rendered for the button which opens the popup.\n       */\n      _defineProperty(this, \"arrowButtonIcon\", 'caret-alt-down');\n      /**\n       * Specifies the [`SVGIcon`](slug:api_icons_svgicon) that will\n       * be rendered for the button which opens the popup.\n       */\n      _defineProperty(this, \"arrowButtonSvgIcon\", caretAltDownIcon);\n      /**\n       * Configures the text field of the button-list popup.\n       */\n      _defineProperty(this, \"textField\", 'text');\n      _defineProperty(this, \"buttonClick\", new EventEmitter());\n      /**\n       * Fires each time the user clicks the drop-down list.\n       * The event data contains the data item that is bound to the clicked list item.\n       */\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"toolbarOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"overflowOptions\", {\n        text: '',\n        icon: '',\n        iconClass: '',\n        svgIcon: null,\n        imageUrl: ''\n      });\n      _defineProperty(this, \"_data\", void 0);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true,\n        popupClass: ''\n      });\n      _defineProperty(this, \"focusedIndex\", -1);\n      _defineProperty(this, \"_showText\", 'both');\n      _defineProperty(this, \"_text\", void 0);\n      _defineProperty(this, \"getNextKey\", void 0);\n      _defineProperty(this, \"getPrevKey\", void 0);\n      _defineProperty(this, \"toolbarSplitButton\", void 0);\n      _defineProperty(this, \"sectionSplitButton\", void 0);\n      _defineProperty(this, \"overflowMainButton\", void 0);\n      _defineProperty(this, \"overflowListItems\", void 0);\n      this.getNextKey = getNextKey();\n      this.getPrevKey = getPrevKey();\n      this.isBuiltInTool = true;\n    }\n    /**\n     * @hidden\n     */\n    onButtonListClick(ev) {\n      this.focusedIndex = this.overflowButtons.findIndex(b => b.nativeElement.contains(ev.target));\n    }\n    /**\n     * @hidden\n     */\n    onMainButtonClick(ev) {\n      this.buttonClick.emit(ev);\n      this.focusedIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    focus(ev = {}) {\n      if (!this.overflows || this.location === 'section') {\n        if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n          this[`${this.location}SplitButton`].focus();\n        }\n      } else if (this.overflowButtons.length > 0) {\n        this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);\n        this.focusButton(this.focusedIndex, ev);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleKey(ev) {\n      if (!this.overflows && (ev.keyCode === this.getPrevKey(this.overflows) || ev.keyCode === this.getNextKey(this.overflows))) {\n        return false;\n      }\n      if (this.overflows) {\n        const peekAtIndex = makePeeker(this.overflowButtons);\n        const isUnmodified = areEqual(this.focusedIndex);\n        this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);\n        this.focusButton(this.focusedIndex, ev);\n        return !isUnmodified(this.focusedIndex);\n      }\n    }\n    /**\n     * @hidden\n     */\n    getText(dataItem) {\n      if (dataItem) {\n        return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n      }\n      return undefined;\n    }\n    /**\n     * @hidden\n     */\n    handleClick(ev, item, index) {\n      this.onButtonListClick(ev);\n      const dataItem = this.data[index];\n      if (item.click) {\n        item.click(dataItem);\n      }\n      this.itemClick.emit(dataItem);\n    }\n    focusButton(index, ev) {\n      if ((!ev.type || ev.type === 'focus' || ev.type === 'keydown' || ev.type === 'click') && this.location !== 'section') {\n        this.overflowButtons[index].nativeElement.focus();\n      }\n    }\n    setTextDisplayMode() {\n      this.toolbarOptions.text = this.showText === 'overflow' ? undefined : this.text;\n      this.overflowOptions.text = this.showText === 'toolbar' ? undefined : this.text;\n    }\n  }\n  _class16 = ToolBarSplitButtonComponent;\n  _defineProperty(ToolBarSplitButtonComponent, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)();\n  });\n  _defineProperty(ToolBarSplitButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class16,\n    selectors: [[\"kendo-toolbar-splitbutton\"]],\n    viewQuery: function _class16_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c31, 5);\n        i0.ɵɵviewQuery(_c32, 5);\n        i0.ɵɵviewQuery(_c33, 5, ElementRef);\n        i0.ɵɵviewQuery(_c25, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarSplitButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sectionSplitButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowMainButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowListItems = _t);\n      }\n    },\n    inputs: {\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      disabled: \"disabled\",\n      popupSettings: \"popupSettings\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      look: \"look\",\n      buttonClass: \"buttonClass\",\n      arrowButtonClass: \"arrowButtonClass\",\n      arrowButtonIcon: \"arrowButtonIcon\",\n      arrowButtonSvgIcon: \"arrowButtonSvgIcon\",\n      textField: \"textField\",\n      data: \"data\"\n    },\n    outputs: {\n      buttonClick: \"buttonClick\",\n      itemClick: \"itemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBarSplitButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class16)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [\"sectionTemplate\", \"\"], [1, \"k-toolbar-split-button\", 3, \"data\", \"text\", \"icon\", \"iconClass\", \"svgIcon\", \"imageUrl\", \"buttonClass\", \"arrowButtonClass\", \"arrowButtonIcon\", \"arrowButtonSvgIcon\", \"disabled\", \"tabIndex\", \"textField\", \"popupSettings\", \"fillMode\", \"themeColor\", \"buttonClick\", \"open\", \"close\", \"itemClick\"], [\"toolbarSplitButton\", \"\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"ngClass\", \"click\"], [\"overflowMainButton\", \"\"], [3, \"ngClass\"], [3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-menu-link-text\"], [\"tabindex\", \"-1\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"click\"], [\"listItem\", \"\"], [1, \"k-link\", \"k-menu-link\"], [\"sectionSplitButton\", \"\"]],\n    template: function _class16_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class16_ng_template_0_Template, 2, 16, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, _class16_ng_template_2_Template, 6, 8, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, _class16_ng_template_4_Template, 2, 16, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    dependencies: [SplitButtonComponent, NgClass, NgIf, IconWrapperComponent, NgFor],\n    encapsulation: 2\n  }));\n  return ToolBarSplitButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ToolBar Separator for Angular]({% slug controltypes_toolbar %}#toc-separators).\n */\nlet ToolBarSeparatorComponent = /*#__PURE__*/(() => {\n  var _class17;\n  class ToolBarSeparatorComponent extends ToolBarToolComponent {\n    constructor() {\n      super();\n      _defineProperty(this, \"separator\", void 0);\n      this.isBuiltInTool = true;\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return false;\n    }\n    // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n    /**\n     * @hidden\n     */\n    focus() {\n      /* noop */\n    }\n    // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n    /**\n     * @hidden\n     */\n    handleKey() {\n      return false;\n    }\n    ngAfterViewInit() {\n      if (!this.popupTemplate) {\n        this.popupTemplate = this.toolbarTemplate;\n      }\n    }\n  }\n  _class17 = ToolBarSeparatorComponent;\n  _defineProperty(ToolBarSeparatorComponent, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)();\n  });\n  _defineProperty(ToolBarSeparatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class17,\n    selectors: [[\"kendo-toolbar-separator\"]],\n    viewQuery: function _class17_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c34, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.separator = _t.first);\n      }\n    },\n    exportAs: [\"kendoToolBarSeparator\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class17)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"sectionTemplate\", \"\"], [\"popupTemplate\", \"\"], [1, \"k-separator\", \"k-toolbar-separator\"], [1, \"k-item\", \"k-menu-item\"], [1, \"k-separator\", \"k-separator-horizontal\"]],\n    template: function _class17_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class17_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, _class17_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, _class17_ng_template_4_Template, 2, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ToolBarSeparatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI ToolBar Spacer for Angular]({% slug controltypes_toolbar %}#toc-separators).\n */\nlet ToolBarSpacerComponent = /*#__PURE__*/(() => {\n  var _class18;\n  class ToolBarSpacerComponent extends ToolBarToolComponent {\n    constructor() {\n      super();\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"__isSpacer\", true);\n      this.isBuiltInTool = true;\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return false;\n    }\n    // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n    /**\n     * @hidden\n     */\n    focus() {\n      /* noop */\n    }\n    // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n    /**\n     * @hidden\n     */\n    handleKey() {\n      return false;\n    }\n    ngAfterViewInit() {\n      if (!this.popupTemplate) {\n        this.popupTemplate = this.toolbarTemplate;\n      }\n    }\n  }\n  _class18 = ToolBarSpacerComponent;\n  _defineProperty(ToolBarSpacerComponent, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)();\n  });\n  _defineProperty(ToolBarSpacerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class18,\n    selectors: [[\"kendo-toolbar-spacer\"]],\n    exportAs: [\"kendoToolBarSpacer\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => _class18)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [1, \"k-spacer\"]],\n    template: function _class18_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class18_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ToolBarSpacerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet ToolbarCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class19;\n  class ToolbarCustomMessagesComponent extends ToolbarMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class19 = ToolbarCustomMessagesComponent;\n  _defineProperty(ToolbarCustomMessagesComponent, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ToolbarCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class19,\n    selectors: [[\"kendo-toolbar-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolbarMessages,\n      useExisting: forwardRef(() => _class19)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class19_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ToolbarCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n* Utility array that contains all `@progress/kendo-angular-toolbar` related components and directives\n*/\nconst KENDO_TOOLBAR = [ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi']) definition for the ToolBar component.\n *\n * The package exports:\n * - `ToolBarComponent`&mdash;The ToolBarComponent class.\n * - `ToolBarToolComponent`&mdash;The base Tool component class.\n * - `ToolBarButtonComponent`&mdash;The Button Tool component class.\n * - `ToolBarButtonGroupComponent`&mdash;The ButtonGroup Tool component class.\n * - `ToolBarDropDownButtonComponent`&mdash;The DropDownButton Tool component class.\n * - `ToolBarSplitButtonComponent`&mdash;The SplitButton Tool component class.\n * - `ToolBarSeparatorComponent`&mdash;The Separator Tool component class.\n */\nlet ToolBarModule = /*#__PURE__*/(() => {\n  var _class20;\n  class ToolBarModule {}\n  _class20 = ToolBarModule;\n  _defineProperty(ToolBarModule, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)();\n  });\n  _defineProperty(ToolBarModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class20\n  }));\n  _defineProperty(ToolBarModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [ToolBarComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSplitButtonComponent]\n  }));\n  return ToolBarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { KENDO_TOOLBAR, LocalizedToolbarMessagesDirective, RefreshService, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarComponent, ToolBarDropDownButtonComponent, ToolBarModule, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, ToolbarCustomMessagesComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}