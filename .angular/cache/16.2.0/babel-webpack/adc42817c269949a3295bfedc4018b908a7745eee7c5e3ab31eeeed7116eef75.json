{"ast":null,"code":"import { DateObject } from '../common/dateobject';\nimport { approximateStringMatching } from './utils';\nimport { KeyCode } from '../common/keycode';\nimport { Key } from '../common/key';\nimport { extend, isPresent, isDocumentAvailable, millisecondDigitsInFormat, millisecondStepFor, isValidDate, isIOS } from '../common/utils';\nimport { Observable } from '../common/observable';\nimport { DateInputInteractionMode } from './interaction-mode';\nimport { isEqual, cloneDate } from '@progress/kendo-date-math';\nimport { Constants } from '../common/constants';\nconst DEFAULT_SEGMENT_STEP = 1;\nconst DRAG_START = \"dragStart\";\nconst DROP = \"drop\";\nconst TOUCH_START = \"touchstart\";\nconst MOUSE_DOWN = \"mousedown\";\nconst MOUSE_UP = \"mouseup\";\nconst CLICK = \"click\";\nconst INPUT = \"input\";\nconst KEY_DOWN = \"keydown\";\nconst FOCUS = \"focus\";\nconst BLUR = \"blur\";\nconst PASTE = \"paste\";\nconst MOUSE_SCROLL = \"DOMMouseScroll\";\nconst MOUSE_WHEEL = \"mousewheel\";\nconst VALUE_CHANGE = \"valueChange\";\nconst INPUT_END = \"inputEnd\";\nconst BLUR_END = \"blurEnd\";\nconst FOCUS_END = \"focusEnd\";\nconst CHANGE = \"change\";\nconst defaultDateInputOptions = {\n  format: \"d\",\n  hasPlaceholder: false,\n  placeholder: null,\n  cycleTime: true,\n  locale: null,\n  steps: {\n    millisecond: DEFAULT_SEGMENT_STEP,\n    second: DEFAULT_SEGMENT_STEP,\n    minute: DEFAULT_SEGMENT_STEP,\n    hour: DEFAULT_SEGMENT_STEP,\n    day: DEFAULT_SEGMENT_STEP,\n    month: DEFAULT_SEGMENT_STEP,\n    year: DEFAULT_SEGMENT_STEP\n  },\n  formatPlaceholder: null,\n  events: {\n    [VALUE_CHANGE]: null,\n    [INPUT]: null,\n    [INPUT_END]: null,\n    [FOCUS]: null,\n    [FOCUS_END]: null,\n    [BLUR]: null,\n    [BLUR_END]: null,\n    [KEY_DOWN]: null,\n    [MOUSE_WHEEL]: null,\n    [CHANGE]: null\n  },\n  selectNearestSegmentOnFocus: false,\n  selectPreviousSegmentOnBackspace: false,\n  enableMouseWheel: false,\n  allowCaretMode: false,\n  autoSwitchParts: true,\n  autoSwitchKeys: [],\n  twoDigitYearMax: Constants.twoDigitYearMax,\n  autoCorrectParts: true,\n  autoFill: false,\n  toggleDayPeriod: false\n};\nexport class DateInput extends Observable {\n  get value() {\n    return this.dateObject && this.dateObject.getValue();\n  }\n  constructor(element, options) {\n    super(options);\n    this.dateObject = null;\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.currentText = '';\n    this.currentFormat = '';\n    this.interactionMode = DateInputInteractionMode.None;\n    this.previousElementSelection = {\n      start: 0,\n      end: 0\n    };\n    this.init(element, options);\n  }\n  init(element, options) {\n    let dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);\n    if (!isValidDate(dateValue)) {\n      dateValue = null;\n    }\n    this.element = element;\n    // this.element._kendoWidget = this;\n    this.options = extend({}, defaultDateInputOptions, options, {\n      steps: Object.assign(Object.assign({}, defaultDateInputOptions.steps), options.steps)\n    });\n    this.intl = this.options.intlService;\n    this.dateObject = this.createDateObject();\n    this.dateObject.setValue(dateValue);\n    this.setTextAndFormat();\n    this.bindEvents();\n    this.resetSegmentValue = true;\n    this.interactionMode = DateInputInteractionMode.None;\n    this.forceUpdate();\n  }\n  destroy() {\n    this.unbindEvents();\n    this.dateObject = null;\n    super.destroy();\n  }\n  bindEvents() {\n    this.onElementDragStart = this.onElementDragStart.bind(this);\n    this.element.addEventListener(DRAG_START, this.onElementDragStart);\n    this.onElementDrop = this.onElementDrop.bind(this);\n    this.element.addEventListener(DROP, this.onElementDrop);\n    this.onElementClick = this.onElementClick.bind(this);\n    this.element.addEventListener(CLICK, this.onElementClick);\n    this.onElementMouseDown = this.onElementMouseDown.bind(this);\n    this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);\n    this.element.addEventListener(TOUCH_START, this.onElementMouseDown);\n    this.onElementMouseUp = this.onElementMouseUp.bind(this);\n    this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);\n    this.onElementInput = this.onElementInput.bind(this);\n    this.element.addEventListener(INPUT, this.onElementInput);\n    this.onElementKeyDown = this.onElementKeyDown.bind(this);\n    this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);\n    this.onElementFocus = this.onElementFocus.bind(this);\n    this.element.addEventListener(FOCUS, this.onElementFocus);\n    this.onElementBlur = this.onElementBlur.bind(this);\n    this.element.addEventListener(BLUR, this.onElementBlur);\n    this.onElementChange = this.onElementChange.bind(this);\n    this.element.addEventListener(CHANGE, this.onElementChange);\n    this.onElementPaste = this.onElementPaste.bind(this);\n    this.element.addEventListener(PASTE, this.onElementPaste);\n    this.onElementMouseWheel = this.onElementMouseWheel.bind(this);\n    this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n    this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n  }\n  unbindEvents() {\n    this.element.removeEventListener(DRAG_START, this.onElementDragStart);\n    this.element.removeEventListener(DROP, this.onElementDrop);\n    this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);\n    this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);\n    this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);\n    this.element.removeEventListener(CLICK, this.onElementClick);\n    this.element.removeEventListener(INPUT, this.onElementInput);\n    this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);\n    this.element.removeEventListener(FOCUS, this.onElementFocus);\n    this.element.removeEventListener(BLUR, this.onElementBlur);\n    this.element.removeEventListener(CHANGE, this.onElementChange);\n    this.element.removeEventListener(PASTE, this.onElementPaste);\n    this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n    this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n  }\n  setOptions(options, refresh = false) {\n    this.options = extend({}, this.options, options, {\n      steps: Object.assign(Object.assign({}, defaultDateInputOptions.steps), options.steps)\n    });\n    this.setDateObjectOptions();\n    if (refresh) {\n      this.unbindEvents();\n      this.init(this.element, this.options);\n    }\n  }\n  /**\n   * @hidden\n   */\n  setDateObjectOptions() {\n    if (this.dateObject) {\n      const newOptions = this.getDateObjectOptions();\n      this.dateObject.setOptions(newOptions);\n    }\n  }\n  /**\n   * @hidden\n   */\n  resetLocale() {\n    this.unbindEvents();\n    this.init(this.element, this.options);\n  }\n  /**\n   * @hidden\n   */\n  isInCaretMode() {\n    return this.interactionMode === DateInputInteractionMode.Caret;\n  }\n  focus() {\n    this.element.focus();\n    if (this.options.selectNearestSegmentOnFocus) {\n      this.selectNearestSegment(0);\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementDragStart(e) {\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementDrop(e) {\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseDown() {\n    this.mouseDownStarted = true;\n    this.focusedPriorToMouseDown = this.isActive;\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseUp(e) {\n    this.mouseDownStarted = false;\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementClick(e) {\n    this.mouseDownStarted = false;\n    this.switchedPartOnPreviousKeyAction = false;\n    const selection = this.selection;\n    if (this.isInCaretMode()) {\n      // explicitly refresh the input element value\n      // caret mode can change the number of symbols in the element\n      // thus clicking on a segment can result in incorrect selection\n      this.forceUpdate();\n    }\n    if (e.detail === 3) {\n      // when 3 clicks occur, leave the native event to handle the change\n      // this results in selecting the whole element value\n    } else {\n      if (this.isActive && this.options.selectNearestSegmentOnFocus) {\n        const selectionPresent = this.element.selectionStart !== this.element.selectionEnd;\n        const placeholderToggled = isPresent(this.options.placeholder) && !this.dateObject.hasValue() && !this.focusedPriorToMouseDown;\n        // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n        const selectFirstSegment = !selectionPresent && placeholderToggled;\n        const index = selectFirstSegment ? 0 : this.caret()[0];\n        this.selectNearestSegment(index);\n      } else {\n        this.setSelection(this.selectionByIndex(selection.start));\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementInput(e) {\n    this.triggerInput({\n      event: e\n    });\n    const oldElementValue = this.elementValue;\n    if (!this.element || !this.dateObject) {\n      return;\n    }\n    const switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;\n    if (this.isPasteInProgress) {\n      if (this.options.allowCaretMode) {\n        // pasting should leave the input with caret\n        // thus allow direct input instead of selection mode\n        this.resetSegmentValue = false;\n      }\n      this.updateOnPaste(e);\n      this.isPasteInProgress = false;\n      return;\n    }\n    const keyDownEvent = this.keyDownEvent || {};\n    const isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;\n    const isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;\n    const originalInteractionMode = this.interactionMode;\n    if (this.options.allowCaretMode && originalInteractionMode !== DateInputInteractionMode.Caret && !isDeleteKey && !isBackspaceKey) {\n      this.resetSegmentValue = true;\n    }\n    if (this.options.allowCaretMode) {\n      this.interactionMode = DateInputInteractionMode.Caret;\n    } else {\n      this.interactionMode = DateInputInteractionMode.Selection;\n    }\n    const hasCaret = this.isInCaretMode();\n    if (hasCaret && this.keyDownEvent.key === Key.SPACE) {\n      // do not allow custom \"holes\" in the date segments\n      this.restorePreviousInputEventState();\n      return;\n    }\n    const oldExistingDateValue = this.dateObject && this.dateObject.getValue();\n    const oldDateValue = this.dateObject ? this.dateObject.value : null;\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat();\n    this.currentFormat = currentFormat;\n    let oldText = \"\";\n    if (hasCaret) {\n      if (isBackspaceKey || isDeleteKey) {\n        oldText = this.previousElementValue;\n      } else if (originalInteractionMode === DateInputInteractionMode.Caret) {\n        oldText = this.previousElementValue;\n      } else {\n        oldText = currentText;\n      }\n    } else {\n      oldText = currentText;\n    }\n    const newText = this.elementValue;\n    const diff = approximateStringMatching({\n      oldText: oldText,\n      newText: newText,\n      formatPattern: this.currentFormat,\n      selectionStart: this.selection.start,\n      isInCaretMode: hasCaret,\n      keyEvent: this.keyDownEvent\n    });\n    if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {\n      this.switchedPartOnPreviousKeyAction = false;\n    }\n    if (hasCaret && (!diff || diff.length === 0)) {\n      this.restorePreviousInputEventState();\n      return;\n    } else if (hasCaret && diff.length === 1) {\n      if (!diff[0] || !diff[0][0]) {\n        this.restorePreviousInputEventState();\n        return;\n      } else if (hasCaret && diff[0] && (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {\n        this.restorePreviousInputEventState();\n        return;\n      }\n    }\n    const navigationOnly = diff.length === 1 && diff[0][1] === Constants.formatSeparator;\n    const parsePartsResults = [];\n    let switchPart = false;\n    let error = null;\n    if (!navigationOnly) {\n      for (let i = 0; i < diff.length; i++) {\n        const parsePartResult = this.dateObject.parsePart({\n          symbol: diff[i][0],\n          currentChar: diff[i][1],\n          resetSegmentValue: this.resetSegmentValue,\n          cycleSegmentValue: !this.isInCaretMode(),\n          rawTextValue: this.element.value,\n          isDeleting: isBackspaceKey || isDeleteKey,\n          originalFormat: this.currentFormat\n        });\n        parsePartsResults.push(parsePartResult);\n        if (!parsePartResult.value) {\n          error = {\n            type: \"parse\"\n          };\n        }\n        switchPart = parsePartResult.switchToNext;\n      }\n    }\n    if (!this.options.autoSwitchParts) {\n      switchPart = false;\n    }\n    this.resetSegmentValue = false;\n    const hasFixedFormat = this.options.format === this.currentFormat ||\n    // all not fixed formats are 1 symbol, e.g. \"d\"\n    isPresent(this.options.format) && this.options.format.length > 1;\n    const lastParseResult = parsePartsResults[parsePartsResults.length - 1];\n    const lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);\n    const parsingFailedOnDelete = hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue;\n    const resetPart = lastParseResult ? lastParseResult.resetPart : false;\n    const newExistingDateValue = this.dateObject.getValue();\n    const hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);\n    const newDateValue = this.dateObject.value;\n    let symbolForSelection;\n    const currentSelection = this.selection;\n    if (hasCaret) {\n      const diffChar = diff && diff.length > 0 ? diff[0][0] : null;\n      const hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];\n      if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n        if (switchPart) {\n          this.forceUpdateWithSelection();\n          this.switchDateSegment(1);\n        } else if (resetPart) {\n          symbolForSelection = this.currentFormat[currentSelection.start];\n          if (symbolForSelection) {\n            this.forceUpdate();\n            this.setSelection(this.selectionBySymbol(symbolForSelection));\n          } else {\n            this.restorePreviousInputEventState();\n          }\n        } else if (parsingFailedOnDelete) {\n          this.forceUpdate();\n          if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n            this.setSelection(this.selectionBySymbol(diff[0][0]));\n          }\n        } else if (lastParseResultHasNoValue) {\n          if (e.data === \"0\" && hasLeadingZero) {\n            // do not reset element value on a leading zero\n            // wait for consecutive input to determine the value\n          } else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n            this.restorePreviousInputEventState();\n          } else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n            this.forceUpdateWithSelection();\n          } else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n            if (hasExistingDateValueChanged) {\n              this.forceUpdateWithSelection();\n            } else {\n              this.restorePreviousInputEventState();\n            }\n          } else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n            this.forceUpdateWithSelection();\n          } else if (oldDateValue !== newDateValue) {\n            // this can happen on auto correct when no valid value is parsed\n          } else {\n            this.restorePreviousInputEventState();\n          }\n        } else if (!lastParseResultHasNoValue) {\n          // the user types a valid but incomplete date (e.g. year \"123\" with format \"yyyy\")\n          // let them continue typing, but refresh for not fixed formats\n          if (!hasFixedFormat) {\n            this.forceUpdateWithSelection();\n          }\n        }\n      } else {\n        if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {\n          // do not change the selection when a separator is pressed\n          // this should happen only if autoSwitchKeys contains the separator explicitly\n        } else {\n          this.setSelection(this.selectionBySymbol(diff[0][0]));\n        }\n      }\n    } else if (!hasCaret) {\n      this.forceUpdate();\n      if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n        this.setSelection(this.selectionBySymbol(diff[0][0]));\n      }\n      if (this.options.autoSwitchParts) {\n        if (navigationOnly) {\n          this.resetSegmentValue = true;\n          if (!switchedPartOnPreviousKeyAction) {\n            this.switchDateSegment(1);\n          }\n          this.switchedPartOnPreviousKeyAction = true;\n        } else if (switchPart) {\n          this.switchDateSegment(1);\n          this.switchedPartOnPreviousKeyAction = true;\n        }\n      } else {\n        if (lastParseResult && lastParseResult.switchToNext) {\n          // the value is complete and should be switched, but the \"autoSwitchParts\" option prevents this\n          // ensure that the segment value can be reset on next input\n          this.resetSegmentValue = true;\n        } else if (navigationOnly) {\n          this.resetSegmentValue = true;\n          if (!switchedPartOnPreviousKeyAction) {\n            this.switchDateSegment(1);\n          }\n          this.switchedPartOnPreviousKeyAction = true;\n        }\n      }\n      if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {\n        // kendo angular have this UX\n        this.switchDateSegment(-1);\n      }\n    }\n    this.tryTriggerValueChange({\n      oldValue: oldExistingDateValue,\n      event: e\n    });\n    this.triggerInputEnd({\n      event: e,\n      error: error,\n      oldElementValue: oldElementValue,\n      newElementValue: this.elementValue\n    });\n    if (hasCaret) {\n      // a format like \"F\" can dynamically change the resolved format pattern based on the value, e.g.\n      // \"Tuesday, February 1, 2022 3:04:05 AM\" becomes\n      // \"Wednesday, February 2, 2022 3:04:05 AM\" giving a diff of 2 (\"Tuesday\".length - \"Wednesday\".length)\n      this.setTextAndFormat();\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementFocus(e) {\n    if (this.triggerFocus({\n      event: e\n    })) {\n      return;\n    }\n    this.isActive = true;\n    this.interactionMode = DateInputInteractionMode.None;\n    this.switchedPartOnPreviousKeyAction = false;\n    this.refreshElementValue();\n    if (!this.mouseDownStarted) {\n      this.caret(0, this.elementValue.length);\n    }\n    this.mouseDownStarted = false;\n    this.triggerFocusEnd({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementBlur(e) {\n    this.resetSegmentValue = true;\n    this.isActive = false;\n    if (this.triggerBlur({\n      event: e\n    })) {\n      return;\n    }\n    if (this.options.autoFill) {\n      this.autoFill();\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n    this.switchedPartOnPreviousKeyAction = false;\n    this.refreshElementValue();\n    this.triggerBlurEnd({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementChange(e) {\n    this.triggerChange({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementKeyDown(e) {\n    if (this.triggerKeyDown({\n      event: e\n    })) {\n      return;\n    }\n    const {\n      start,\n      end\n    } = this.selection;\n    const event = e;\n    this.keyDownEvent = e;\n    this.previousElementValue = this.element.value;\n    this.previousElementSelection = {\n      start,\n      end\n    };\n    if (this.keyEventMatchesAutoSwitchKeys(e)) {\n      const isTabKey = e.keyCode === KeyCode.TAB;\n      if (isTabKey) {\n        const {\n          start: selectionStart,\n          end: selectionEnd\n        } = this.selection;\n        if (e.shiftKey && isTabKey) {\n          this.switchDateSegment(-1);\n        } else {\n          this.switchDateSegment(1);\n        }\n        if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {\n          // when the selection changes, prevent the default Tab behavior\n          e.preventDefault();\n          return;\n        }\n      } else {\n        // do not allow the \"input\" event to be triggered\n        e.preventDefault();\n        this.switchDateSegment(1);\n        return;\n      }\n    }\n    const symbol = this.currentFormat[this.selection.start];\n    const step = this.getStepFromSymbol(symbol);\n    let shouldPreventDefault = false;\n    const oldElementValue = this.elementValue;\n    if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {\n      return;\n    }\n    switch (e.keyCode) {\n      case KeyCode.ARROW_LEFT:\n        this.switchDateSegment(-1);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_UP:\n        this.modifyDateSegmentValue(step, symbol, event);\n        if (oldElementValue !== this.elementValue) {\n          this.triggerInputEnd({\n            event: e,\n            error: null,\n            newElementValue: this.elementValue,\n            oldElementValue: oldElementValue\n          });\n        }\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_RIGHT:\n        this.switchDateSegment(1);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_DOWN:\n        this.modifyDateSegmentValue(-step, symbol, event);\n        if (oldElementValue !== this.elementValue) {\n          this.triggerInputEnd({\n            event: e,\n            error: null,\n            newElementValue: this.elementValue,\n            oldElementValue: oldElementValue\n          });\n        }\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ENTER:\n        // todo: handle \"change\" event\n        break;\n      case KeyCode.HOME:\n        this.selectNearestSegment(0);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.resetSegmentValue = true;\n        break;\n      case KeyCode.END:\n        this.selectNearestSegment(this.elementValue.length);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.resetSegmentValue = true;\n        break;\n      default:\n        // allow the \"input\" event to handle the change\n        return;\n    }\n    if (shouldPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementPaste() {\n    this.isPasteInProgress = true;\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseWheel(e) {\n    const oldElementValue = this.elementValue;\n    if (!this.options.enableMouseWheel || this.triggerMouseWheel({\n      event: e\n    })) {\n      return;\n    }\n    if (!this.isActive) {\n      return;\n    }\n    const event = e;\n    if (event.shiftKey) {\n      this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n    } else {\n      this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n    }\n    event.returnValue = false;\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n    if (oldElementValue !== this.elementValue) {\n      this.triggerInputEnd({\n        event: e,\n        error: null,\n        newElementValue: this.elementValue,\n        oldElementValue: oldElementValue\n      });\n    }\n  }\n  updateOnPaste(e) {\n    let value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;\n    if (isPresent(value) && this.dateObject.shouldNormalizeCentury()) {\n      value = this.dateObject.normalizeCentury(value);\n    }\n    const oldDateObjectValue = this.dateObject && this.dateObject.getValue();\n    this.writeValue(value);\n    this.tryTriggerValueChange({\n      oldValue: oldDateObjectValue,\n      event: e\n    });\n  }\n  get elementValue() {\n    return (this.element || {}).value || '';\n  }\n  get inputFormat() {\n    if (!this.options.format) {\n      return Constants.defaultDateFormat;\n    }\n    if (typeof this.options.format === 'string') {\n      return this.options.format;\n    } else {\n      return this.options.format.inputFormat;\n    }\n  }\n  get displayFormat() {\n    if (!this.options.format) {\n      return Constants.defaultDateFormat;\n    }\n    if (typeof this.options.format === 'string') {\n      return this.options.format;\n    } else {\n      return this.options.format.displayFormat;\n    }\n  }\n  get selection() {\n    let returnValue = {\n      start: 0,\n      end: 0\n    };\n    if (this.element !== null && this.element.selectionStart !== undefined) {\n      returnValue = {\n        start: this.element.selectionStart,\n        end: this.element.selectionEnd\n      };\n    }\n    return returnValue;\n  }\n  setSelection(selection) {\n    if (this.element && document.activeElement === this.element) {\n      this.element.setSelectionRange(selection.start, selection.end);\n      if (isDocumentAvailable() && isIOS()) {\n        this.element.scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest'\n        });\n      }\n      if (selection.start !== selection.end) {\n        this.interactionMode = DateInputInteractionMode.Selection;\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  selectionBySymbol(symbol) {\n    let start = -1;\n    let end = 0;\n    for (let i = 0; i < this.currentFormat.length; i++) {\n      if (this.currentFormat[i] === symbol) {\n        end = i + 1;\n        if (start === -1) {\n          start = i;\n        }\n      }\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {\n      if (this.currentFormat.length < this.currentText.length) {\n        end += this.currentText.length - this.currentFormat.length;\n      } else {\n        end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));\n      }\n    }\n    return {\n      start,\n      end\n    };\n  }\n  /**\n   * @hidden\n   */\n  selectionByIndex(index) {\n    let selection = {\n      start: index,\n      end: index\n    };\n    for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n      if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {\n        selection = this.selectionBySymbol(this.currentFormat[i]);\n        break;\n      }\n      if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {\n        selection = this.selectionBySymbol(this.currentFormat[j]);\n        break;\n      }\n    }\n    return selection;\n  }\n  switchDateSegment(offset) {\n    const selection = this.selection;\n    if (this.isInCaretMode()) {\n      let start = selection.start;\n      const currentSymbol = this.currentFormat[start - 1];\n      let symbol = \"\";\n      let symbolCandidate = \"\";\n      if (offset < 0) {\n        for (let i = start + offset; i >= 0; i--) {\n          symbolCandidate = this.currentFormat[i];\n          if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {\n            start = i;\n            symbol = symbolCandidate;\n            break;\n          }\n        }\n      } else {\n        for (let i = start + offset; i < this.currentFormat.length; i++) {\n          symbolCandidate = this.currentFormat[i];\n          if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {\n            start = i;\n            symbol = symbolCandidate;\n            break;\n          }\n        }\n      }\n      if (symbol) {\n        this.forceUpdate();\n        this.setSelection(this.selectionBySymbol(symbol));\n        this.interactionMode = DateInputInteractionMode.Selection;\n        return;\n      }\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n    const {\n      start: selectionStart,\n      end: selectionEnd\n    } = this.selection;\n    if (selectionStart < selectionEnd && this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {\n      this.setSelection(this.selectionByIndex(offset > 0 ? selectionStart : selectionEnd - 1));\n      this.resetSegmentValue = true;\n      this.interactionMode = DateInputInteractionMode.None;\n      return;\n    }\n    const previousFormatSymbol = this.currentFormat[selectionStart];\n    let a = selectionStart + offset;\n    while (a > 0 && a < this.currentFormat.length) {\n      if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== Constants.formatSeparator) {\n        break;\n      }\n      a += offset;\n    }\n    if (this.currentFormat[a] === Constants.formatSeparator) {\n      // no known symbol is found\n      return;\n    }\n    let b = a;\n    while (b >= 0 && b < this.currentFormat.length) {\n      if (this.currentFormat[b] !== this.currentFormat[a]) {\n        break;\n      }\n      b += offset;\n    }\n    if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {\n      this.setSelection({\n        start: b + 1,\n        end: a + 1\n      });\n      this.resetSegmentValue = true;\n    } else if (a < b && (a !== selectionStart || b !== selectionEnd)) {\n      this.setSelection({\n        start: a,\n        end: b\n      });\n      this.resetSegmentValue = true;\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n  }\n  modifyDateSegmentValue(offset, symbol = \"\", event = {}) {\n    if (!this.dateObject || this.options.readonly) {\n      return;\n    }\n    const oldValue = this.value;\n    let step = DEFAULT_SEGMENT_STEP;\n    const caret = this.caret();\n    symbol = symbol || this.currentFormat[caret[0]];\n    if (symbol === \"S\" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {\n      const msDigits = millisecondDigitsInFormat(this.inputFormat);\n      step = millisecondStepFor(msDigits);\n    }\n    this.dateObject.modifyPart(symbol, step * offset);\n    this.tryTriggerValueChange({\n      oldValue: oldValue,\n      event: event\n    });\n    this.forceUpdate();\n    this.setSelection(this.selectionBySymbol(symbol));\n  }\n  /**\n   * @hidden\n   */\n  tryTriggerValueChange(args = {\n    oldValue: null,\n    event: {}\n  }) {\n    if (!isEqual(this.value, args.oldValue)) {\n      return this.triggerValueChange(args);\n    }\n  }\n  /**\n   * @hidden\n   */\n  triggerValueChange(args = {\n    oldValue: null,\n    event: {}\n  }) {\n    return this.trigger(VALUE_CHANGE, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerInput(args = {\n    event: {}\n  }) {\n    return this.trigger(INPUT, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerInputEnd(args = {\n    event: {},\n    error: null,\n    oldElementValue: '',\n    newElementValue: ''\n  }) {\n    return this.trigger(INPUT_END, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerFocus(args = {\n    event: {}\n  }) {\n    return this.trigger(FOCUS, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerFocusEnd(args = {\n    event: {}\n  }) {\n    return this.trigger(FOCUS_END, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerBlur(args = {\n    event: {}\n  }) {\n    return this.trigger(BLUR, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerBlurEnd(args = {\n    event: {}\n  }) {\n    return this.trigger(BLUR_END, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerChange(args = {\n    event: {}\n  }) {\n    return this.trigger(CHANGE, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerKeyDown(args = {\n    event: {}\n  }) {\n    return this.trigger(KEY_DOWN, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerMouseWheel(args = {\n    event: {}\n  }) {\n    return this.trigger(MOUSE_WHEEL, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  forceUpdate() {\n    this.setTextAndFormat();\n    this.refreshElementValue();\n  }\n  /**\n   * @hidden\n   */\n  forceUpdateWithSelection() {\n    const {\n      start,\n      end\n    } = this.selection;\n    const elementValueLength = this.elementValue.length;\n    this.forceUpdate();\n    const selectionOffset = this.elementValue.length - elementValueLength;\n    this.setSelection({\n      start: start + selectionOffset,\n      end: end + selectionOffset\n    });\n  }\n  /**\n   * @hidden\n   */\n  setTextAndFormat() {\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat();\n    this.currentFormat = currentFormat;\n    this.currentText = currentText;\n  }\n  /**\n   * @hidden\n   */\n  setElementValue(value) {\n    this.element.value = value;\n  }\n  /**\n   * @hidden\n   */\n  getStepFromSymbol(symbol) {\n    /* eslint-disable no-fallthrough */\n    switch (symbol) {\n      case \"S\":\n        return Number(this.options.steps.millisecond);\n      case \"s\":\n        return Number(this.options.steps.second);\n      case \"m\":\n        return Number(this.options.steps.minute);\n      // represents hour as value from 01 through 12\n      case \"h\":\n      // represents hour as value from 01 through 23\n      case \"H\":\n        return Number(this.options.steps.hour);\n      case \"M\":\n        return Number(this.options.steps.month);\n      // there is no 'D' format specifier for day\n      case \"d\":\n      // used for formats such as \"EEEE, MMMM d, yyyy\",\n      // where \"EEEE\" stands for full name of the day e.g. Monday\n      case \"E\":\n        return Number(this.options.steps.day);\n      // there is no 'Y' format specifier for year\n      case \"y\":\n        return Number(this.options.steps.year);\n      default:\n        return DEFAULT_SEGMENT_STEP;\n    }\n    /* eslint-enable no-fallthrough */\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousInputEventState() {\n    this.restorePreviousElementValue();\n    this.restorePreviousElementSelection();\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousElementValue() {\n    this.setElementValue(this.previousElementValue || '');\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousElementSelection() {\n    const {\n      start,\n      end\n    } = this.previousElementSelection;\n    this.setSelection({\n      start: start || 0,\n      end: end || 0\n    });\n  }\n  writeValue(value) {\n    this.verifyValue(value);\n    this.dateObject = this.getDateObject(value);\n    this.refreshElementValue();\n  }\n  verifyValue(value) {\n    if (value && !isValidDate(value)) {\n      throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n    }\n  }\n  refreshElementValue() {\n    const element = this.element;\n    const format = this.isActive ? this.inputFormat : this.displayFormat;\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat(format);\n    this.currentFormat = currentFormat;\n    this.currentText = currentText;\n    const hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);\n    const showPlaceholder = !this.isActive && hasPlaceholder && !this.dateObject.hasValue();\n    if (hasPlaceholder && isPresent(this.options.placeholder)) {\n      element.placeholder = this.options.placeholder;\n    }\n    const newElementValue = showPlaceholder ? \"\" : currentText;\n    this.previousElementValue = this.elementValue;\n    this.setElementValue(newElementValue);\n  }\n  /**\n   * @hidden\n   */\n  caret(start, end = start) {\n    const isPosition = start !== undefined;\n    let returnValue = [start, start];\n    const element = this.element;\n    if (isPosition && (this.options.disabled || this.options.readonly)) {\n      return undefined;\n    }\n    try {\n      if (element.selectionStart !== undefined) {\n        if (isPosition) {\n          if (isDocumentAvailable() && document.activeElement !== element) {\n            element.focus();\n          }\n          element.setSelectionRange(start, end);\n        }\n        returnValue = [element.selectionStart, element.selectionEnd];\n      }\n    } catch (e) {\n      returnValue = [];\n    }\n    return returnValue;\n  }\n  selectNearestSegment(index) {\n    // Finds the nearest (in both directions) known part.\n    for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n      if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[i]);\n        return;\n      }\n      if (j >= 0 && this.currentFormat[j] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[j]);\n        return;\n      }\n    }\n  }\n  selectDateSegment(symbol) {\n    let begin = -1;\n    let end = 0;\n    for (let i = 0; i < this.currentFormat.length; i++) {\n      if (this.currentFormat[i] === symbol) {\n        end = i + 1;\n        if (begin === -1) {\n          begin = i;\n        }\n      }\n    }\n    if (begin < 0) {\n      begin = 0;\n    }\n    this.caret(0, 0);\n    this.caret(begin, end);\n  }\n  /**\n   * @hidden\n   */\n  getDateObject(value) {\n    const {\n      leadingZero\n    } = this.dateObject || {} || null;\n    this.options.value = value;\n    const dateObject = this.createDateObject();\n    dateObject.setLeadingZero(this.isActive ? leadingZero : null);\n    return dateObject;\n  }\n  /* tslint:disable:align */\n  /**\n   * @hidden\n   */\n  createDateObject() {\n    const defaultOptions = this.getDateObjectOptions();\n    const dateObject = new DateObject(extend({}, defaultOptions));\n    return dateObject;\n  }\n  /**\n   * @hidden\n   */\n  getDateObjectOptions() {\n    const newOptions = {\n      intlService: this.options.intlService,\n      formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : 'formatPattern',\n      format: this.inputFormat,\n      cycleTime: this.options.cycleTime,\n      twoDigitYearMax: this.options.twoDigitYearMax,\n      autoCorrectParts: this.options.autoCorrectParts,\n      value: this.options.value,\n      toggleDayPeriod: this.options.toggleDayPeriod\n    };\n    return newOptions;\n  }\n  /* tslint:enable:align */\n  /**\n   * @hidden\n   */\n  keyEventMatchesAutoSwitchKeys(keyObject) {\n    const autoSwitchKeys = (this.options.autoSwitchKeys || []).map(x => x.toString().toLowerCase().trim());\n    if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 || autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 || autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @hidden\n   */\n  autoFill() {\n    const dateObject = this.dateObject;\n    const currentDate = new Date();\n    let day, month, year, hours, minutes, seconds;\n    if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {\n      year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(), month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(), day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(), hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(), minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(), seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();\n      dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));\n      this.refreshElementValue();\n      this.triggerValueChange();\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}