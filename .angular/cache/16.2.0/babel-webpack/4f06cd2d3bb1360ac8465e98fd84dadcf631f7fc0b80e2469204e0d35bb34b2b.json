{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, SecurityContext, InjectionToken, Optional, Inject, Directive, SkipSelf, Input, isDevMode, QueryList, Component, ContentChildren, ContentChild, forwardRef, Host, Output, HostBinding, Pipe, TemplateRef, ChangeDetectionStrategy, ViewChildren, ViewChild, Self, NgZone, HostListener, ViewEncapsulation, NgModule } from '@angular/core';\nimport { merge, of, Subject, zip as zip$1, from, Subscription, interval, fromEvent, Observable, BehaviorSubject } from 'rxjs';\nimport * as i1$3 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, Keys, isPresent as isPresent$1, anyChanged, TemplateContextDirective, DraggableDirective, EventsOutsideAngularDirective, isChanged as isChanged$1, KendoInput, guid, hasObservers, ResizeSensorComponent, closest as closest$1, isFocusable as isFocusable$1, shouldShowValidationUI, WatermarkOverlayComponent, ResizeBatchService } from '@progress/kendo-angular-common';\nimport * as i1 from '@angular/platform-browser';\nimport * as i1$1 from '@progress/kendo-angular-icons';\nimport { IconWrapperComponent, IconsService, KENDO_ICONS } from '@progress/kendo-angular-icons';\nimport { plusIcon, cancelIcon, lockIcon, unlockIcon, caretAltDownIcon, caretAltRightIcon, caretAltLeftIcon, arrowLeftIcon, arrowRightIcon, sortDescSmallIcon, sortAscSmallIcon, filterClearIcon, filterIcon, columnsIcon, chevronUpIcon, chevronDownIcon, displayInlineFlexIcon, maxWidthIcon, stickIcon, unstickIcon, setColumnPositionIcon, slidersIcon, moreVerticalIcon, reorderIcon, minusIcon, insertMiddleIcon, filePdfIcon, fileExcelIcon } from '@progress/kendo-svg-icons';\nimport { switchMap, take, map, filter, takeUntil, switchMapTo, delay, tap, throttleTime, debounceTime, distinctUntilChanged, skip, auditTime, bufferCount } from 'rxjs/operators';\nimport * as i1$2 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport * as i44 from '@progress/kendo-angular-pager';\nimport { PagerContextService, PagerNavigationService, PagerTemplateDirective, KENDO_PAGER } from '@progress/kendo-angular-pager';\nimport { orderBy, isCompositeFilterDescriptor, groupBy, process, filterBy } from '@progress/kendo-data-query';\nimport { NgFor, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgClass, NgStyle, NgSwitchDefault } from '@angular/common';\nimport { getter } from '@progress/kendo-common';\nimport * as i1$4 from '@progress/kendo-angular-intl';\nimport * as i5 from '@progress/kendo-angular-popup';\nimport { PopupService } from '@progress/kendo-angular-popup';\nimport { ChipListComponent, ChipComponent, ButtonComponent, Button } from '@progress/kendo-angular-buttons';\nimport * as i1$5 from '@progress/kendo-angular-dropdowns';\nimport { DropDownListComponent, AutoCompleteComponent } from '@progress/kendo-angular-dropdowns';\nimport * as i4 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\nimport * as i3 from '@progress/kendo-angular-inputs';\nimport { TextBoxComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, RadioButtonComponent, CheckBoxComponent } from '@progress/kendo-angular-inputs';\nimport { DatePickerComponent, DatePickerCustomMessagesComponent, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService as NavigationService$1 } from '@progress/kendo-angular-dateinputs';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective } from '@progress/kendo-angular-layout';\nimport { saveAs } from '@progress/kendo-file-saver';\nimport * as i5$1 from '@progress/kendo-angular-excel-export';\nimport { workbookOptions, toDataURL, ColumnBase as ColumnBase$1, ColumnComponent as ColumnComponent$1, ColumnGroupComponent as ColumnGroupComponent$1, FooterTemplateDirective as FooterTemplateDirective$1, GroupFooterTemplateDirective as GroupFooterTemplateDirective$1, GroupHeaderColumnTemplateDirective as GroupHeaderColumnTemplateDirective$1, GroupHeaderTemplateDirective as GroupHeaderTemplateDirective$1 } from '@progress/kendo-angular-excel-export';\nimport { PDFExportMarginComponent, PDFExportTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { DragTargetContainerDirective, DropTargetContainerDirective } from '@progress/kendo-angular-utils';\nimport * as i45 from '@progress/kendo-angular-toolbar';\nimport { KENDO_TOOLBAR } from '@progress/kendo-angular-toolbar';\nimport { DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';\n\n/* eslint-disable  no-bitwise */\n/**\n * @hidden\n */\nconst _c0 = [\"kendoGridColGroup\", \"\"];\nfunction _class43_col_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-group-col\", true);\n  }\n}\nfunction _class43_col_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-hierarchy-col\", true);\n  }\n}\nfunction _class43_col_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", column_r4.width, \"px\");\n    i0.ɵɵclassProp(\"k-sorted\", ctx_r2.isSorted(ctx_r2.getColumnComponent(column_r4)));\n  }\n}\nconst _c1 = [\"kendoGridLoading\", \"\"];\nfunction _class45_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 1);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(3, \"div\", 2)(4, \"div\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.loadingText);\n  }\n}\nfunction _class45_1_ng_template_0_Template(rf, ctx) {}\nfunction _class45_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class45_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.loadingTemplate == null ? null : ctx_r1.loadingTemplate.templateRef);\n  }\n}\nconst _c2 = [\"kendoGridGroupHeader\", \"\"];\nfunction _class57_ng_container_0_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 3);\n  }\n}\nfunction _class57_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class57_ng_container_0_td_1_Template, 1, 0, \"td\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.prefixGroupCell(ctx_r0.item));\n  }\n}\nfunction _class57_td_1_ng_container_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate2(\" \", ctx_r6.groupTitle(ctx_r6.item), \": \", i0.ɵɵpipeBind3(2, 2, ctx_r6.item.data, \"value\", ctx_r6.formatForGroup(ctx_r6.item)), \" \");\n  }\n}\nfunction _class57_td_1_ng_container_2_ng_template_4_Template(rf, ctx) {}\nconst _c3 = function (a0, a1, a2, a3, a4, a5, a6, a7) {\n  return {\n    templateRef: a0,\n    group: a1,\n    aggregates: a2,\n    value: a3,\n    field: a4,\n    index: a5,\n    expanded: a6,\n    $implicit: a7\n  };\n};\nfunction _class57_td_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"a\", 6);\n    i0.ɵɵlistener(\"click\", function _class57_td_1_ng_container_2_Template_a_click_1_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r8.toggleGroup(ctx_r8.item));\n    });\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class57_td_1_ng_container_2_ng_container_3_Template, 3, 6, \"ng-container\", 0);\n    i0.ɵɵtemplate(4, _class57_td_1_ng_container_2_ng_template_4_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r5.groupButtonTitle)(\"aria-label\", ctx_r5.groupButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r5.arrowIcon)(\"svgIcon\", ctx_r5.arrowSVGIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.groupHeaderTemplate(ctx_r5.item));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction8(6, _c3, ctx_r5.groupHeaderTemplate(ctx_r5.item), ctx_r5.item.data, ctx_r5.item.data == null ? null : ctx_r5.item.data.aggregates, ctx_r5.item.data == null ? null : ctx_r5.item.data.value, ctx_r5.item.data == null ? null : ctx_r5.item.data.field, ctx_r5.item.index, ctx_r5.isExpanded, ctx_r5.item.data));\n  }\n}\nfunction _class57_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 4)(1, \"p\", 5);\n    i0.ɵɵtemplate(2, _class57_td_1_ng_container_2_Template, 5, 15, \"ng-container\", 0);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r1.logicalRowIndex)(\"logicalColIndex\", 0)(\"logicalSlaveCell\", ctx_r1.skipGroupDecoration)(\"groupItem\", ctx_r1.item)(\"colSpan\", ctx_r1.logicalColSpan());\n    i0.ɵɵattribute(\"colspan\", ctx_r1.groupSpan(ctx_r1.item))(\"role\", ctx_r1.ariaRole())(\"aria-expanded\", ctx_r1.isExpanded);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.skipGroupDecoration);\n  }\n}\nfunction _class57_ng_container_2_td_1_1_ng_template_0_Template(rf, ctx) {}\nconst _c4 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    group: a0,\n    aggregates: a1,\n    value: a2,\n    field: a3,\n    index: a4,\n    $implicit: a5\n  };\n};\nfunction _class57_ng_container_2_td_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class57_ng_container_2_td_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 11);\n  }\n  if (rf & 2) {\n    const column_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", column_r11.groupHeaderColumnTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction6(2, _c4, ctx_r13.item.data, ctx_r13.item.data == null ? null : ctx_r13.item.data.aggregates, ctx_r13.item.data == null ? null : ctx_r13.item.data.value, ctx_r13.item.data == null ? null : ctx_r13.item.data.field, ctx_r13.item.index, ctx_r13.item.data));\n  }\n}\nfunction _class57_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 10);\n    i0.ɵɵtemplate(1, _class57_ng_container_2_td_1_1_Template, 1, 9, null, 0);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const column_r11 = ctx.$implicit;\n    const index_r12 = ctx.index;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r10.logicalRowIndex)(\"logicalColIndex\", index_r12 + 1)(\"logicalSlaveCell\", false)(\"groupItem\", ctx_r10.item)(\"colSpan\", 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r11.groupHeaderColumnTemplateRef);\n  }\n}\nfunction _class57_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class57_ng_container_2_td_1_Template, 2, 6, \"td\", 9);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.groupHeaderColumns);\n  }\n}\nconst _c5 = [\"defaultTemplate\"];\nconst _c6 = function () {\n  return {\n    lastTarget: true\n  };\n};\nfunction _class58_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"context\", i0.ɵɵpureFunction0(2, _c6));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.text, \" \");\n  }\n}\nconst _c7 = function (a0, a2, a3) {\n  return {\n    field: a0,\n    type: \"groupIndicator\",\n    hint: a2,\n    target: a3\n  };\n};\nfunction _class58_kendo_chiplist_1_kendo_chip_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-chip\", 6, 7);\n    i0.ɵɵlistener(\"contentClick\", function _class58_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_contentClick_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const group_r6 = restoredCtx.$implicit;\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r11.directionChange(group_r6));\n    })(\"remove\", function _class58_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_remove_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const group_r6 = restoredCtx.$implicit;\n      const ctx_r13 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r13.remove(group_r6));\n    })(\"menuToggle\", function _class58_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_menuToggle_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const first_r8 = restoredCtx.first;\n      const last_r9 = restoredCtx.last;\n      const group_r6 = restoredCtx.$implicit;\n      const _r10 = i0.ɵɵreference(1);\n      const ctx_r14 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r14.toggleMenu(_r10, first_r8, last_r9, group_r6.field));\n    })(\"keydown.alt.arrowdown\", function _class58_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_keydown_alt_arrowdown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const first_r8 = restoredCtx.first;\n      const last_r9 = restoredCtx.last;\n      const group_r6 = restoredCtx.$implicit;\n      const _r10 = i0.ɵɵreference(1);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      $event.preventDefault();\n      return i0.ɵɵresetView(ctx_r15.toggleMenu(_r10, first_r8, last_r9, group_r6.field));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const group_r6 = ctx.$implicit;\n    const index_r7 = ctx.index;\n    const _r10 = i0.ɵɵreference(1);\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", ctx_r5.getTitle(group_r6))(\"enableDrag\", true)(\"context\", i0.ɵɵpureFunction3(11, _c7, group_r6.field, ctx_r5.groupTitles[index_r7], _r10))(\"label\", ctx_r5.groupTitles[index_r7])(\"removable\", true)(\"hasMenu\", true)(\"icon\", ctx_r5.getDirectionIcon(group_r6))(\"svgIcon\", ctx_r5.getDirectionSvgIcon(group_r6));\n    i0.ɵɵattribute(\"aria-haspopup\", \"menu\")(\"aria-expanded\", ctx_r5.isChipMenuOpen)(\"aria-controls\", ctx_r5.gridId);\n  }\n}\nfunction _class58_kendo_chiplist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-chiplist\", 4);\n    i0.ɵɵtemplate(1, _class58_kendo_chiplist_1_kendo_chip_1_Template, 2, 15, \"kendo-chip\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"navigable\", ctx_r1.navigable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.groups);\n  }\n}\nfunction _class58_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1, \"\\xA0\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵproperty(\"context\", i0.ɵɵpureFunction0(1, _c6));\n  }\n}\nconst _c8 = function (a0, a1) {\n  return {\n    keydown: a0,\n    click: a1\n  };\n};\nfunction _class58_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ul\", 8)(1, \"li\", 9)(2, \"span\", 10);\n    i0.ɵɵelement(3, \"kendo-icon-wrapper\", 11);\n    i0.ɵɵelementStart(4, \"span\", 12);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(6, \"li\", 9)(7, \"span\", 10);\n    i0.ɵɵelement(8, \"kendo-icon-wrapper\", 11);\n    i0.ɵɵelementStart(9, \"span\", 12);\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(13, _c8, ctx_r4.handleKeyDown, ctx_r4.handleClick));\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-disabled\", ctx_r4.first);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r4.first);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r4.rtl ? \"arrow-right\" : \"arrow-left\")(\"svgIcon\", ctx_r4.rtl ? ctx_r4.arrowRightIcon : ctx_r4.arrowLeftIcon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.messageFor(\"groupChipMenuPrevious\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-disabled\", ctx_r4.last);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-disabled\", ctx_r4.last);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r4.rtl ? \"arrow-left\" : \"arrow-right\")(\"svgIcon\", ctx_r4.rtl ? ctx_r4.arrowLeftIcon : ctx_r4.arrowRightIcon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.messageFor(\"groupChipMenuNext\"));\n  }\n}\nconst _c9 = [\"dropdown\"];\nconst _c10 = function () {\n  return {\n    width: \"auto\"\n  };\n};\nfunction _class79_kendo_dropdownlist_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 2, 3);\n    i0.ɵɵlistener(\"valueChange\", function _class79_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.onChange($event));\n    })(\"keydown\", function _class79_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.dropdownKeydown($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r0.operators)(\"value\", ctx_r0.value)(\"svgIcon\", ctx_r0.filterSVGIcon)(\"valuePrimitive\", true)(\"popupSettings\", i0.ɵɵpureFunction0(7, _c10))(\"size\", ctx_r0.size);\n    i0.ɵɵattribute(\"aria-label\", ctx_r0.column && ctx_r0.columnLabel);\n  }\n}\nfunction _class79_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 4);\n    i0.ɵɵlistener(\"click\", function _class79_button_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.clearClick());\n    })(\"keydown\", function _class79_button_1_Template_button_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.clearKeydown($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.filterClearIcon)(\"title\", ctx_r1.clearText)(\"size\", ctx_r1.size);\n  }\n}\nconst _c11 = [\"*\"];\nfunction _class93_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function _class93_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.logicChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\nfunction _class93_kendo_grid_string_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-string-filter-menu-input\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"placeholder\", ctx_r1.extraPlaceholder)(\"menuTabbingService\", ctx_r1.menuTabbingService);\n  }\n}\nfunction _class96_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function _class96_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.logicChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\nfunction _class96_kendo_grid_numeric_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-numeric-filter-menu-input\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"format\", ctx_r1.format)(\"decimals\", ctx_r1.decimals)(\"spinners\", ctx_r1.spinners)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"step\", ctx_r1.step)(\"menuTabbingService\", ctx_r1.menuTabbingService)(\"placeholder\", ctx_r1.extraPlaceholder);\n  }\n}\nfunction _class99_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function _class99_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.logicChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\nfunction _class99_kendo_grid_date_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-date-filter-menu-input\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"activeView\", ctx_r1.activeView)(\"bottomView\", ctx_r1.bottomView)(\"topView\", ctx_r1.topView)(\"format\", ctx_r1.format)(\"formatPlaceholder\", ctx_r1.formatPlaceholder)(\"placeholder\", ctx_r1.placeholder)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"weekNumber\", ctx_r1.weekNumber)(\"menuTabbingService\", ctx_r1.menuTabbingService);\n  }\n}\nfunction _class102_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\")(1, \"kendo-radiobutton\", 2, 3);\n    i0.ɵɵlistener(\"change\", function _class102_li_1_Template_kendo_radiobutton_change_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const item_r1 = restoredCtx.$implicit;\n      const _r2 = i0.ɵɵreference(2);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.onChange(item_r1.value, _r2));\n    })(\"keydown.shift.tab\", function _class102_li_1_Template_kendo_radiobutton_keydown_shift_tab_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.onShiftTab($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"label\", 4);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columnLabel\", ctx_r0.columnLabel)(\"name\", ctx_r0.idPrefix)(\"checked\", ctx_r0.isSelected(item_r1.value));\n    i0.ɵɵattribute(\"id\", ctx_r0.radioId(item_r1.value));\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"for\", ctx_r0.radioId(item_r1.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(item_r1.text);\n  }\n}\nconst _c12 = [\"resetButton\"];\nconst _c13 = [\"filterButton\"];\nfunction _class104_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 9);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"filterService\", ctx_r0.childService)(\"column\", ctx_r0.column)(\"filter\", ctx_r0.childFilter)(\"menuTabbingService\", ctx_r0.menuTabbingService);\n  }\n}\nfunction _class104_ng_container_4_1_ng_template_0_Template(rf, ctx) {}\nfunction _class104_ng_container_4_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class104_ng_container_4_1_ng_template_0_Template, 0, 0, \"ng-template\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.column.filterMenuTemplateRef)(\"ngTemplateOutletContext\", ctx_r4.templateContext);\n  }\n}\nfunction _class104_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class104_ng_container_4_1_Template, 1, 2, null, 10);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.column.filterMenuTemplateRef);\n  }\n}\nconst _c14 = [\"anchor\"];\nconst _c15 = [\"template\"];\nfunction _class105_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-container\", 4);\n    i0.ɵɵlistener(\"close\", function _class105_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.close());\n    })(\"keydown.escape\", function _class105_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.close());\n    })(\"keydown.enter\", function _class105_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"column\", ctx_r2.column)(\"filter\", ctx_r2.filter);\n  }\n}\nconst _c16 = [\"kendoGridFilterCell\", \"\"];\nfunction _class113_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter);\n  }\n}\nfunction _class113_ng_container_0_ng_container_3_1_ng_template_0_Template(rf, ctx) {}\nfunction _class113_ng_container_0_ng_container_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class113_ng_container_0_ng_container_3_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.column.filterCellTemplateRef)(\"ngTemplateOutletContext\", ctx_r3.templateContext);\n  }\n}\nfunction _class113_ng_container_0_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class113_ng_container_0_ng_container_3_1_Template, 1, 2, null, 0);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.column.filterCellTemplateRef);\n  }\n}\nfunction _class113_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0)(1, 1);\n    i0.ɵɵtemplate(2, _class113_ng_container_0_ng_container_2_Template, 2, 2, \"ng-container\", 2);\n    i0.ɵɵtemplate(3, _class113_ng_container_0_ng_container_3_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵelementContainerEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r0.hasTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n  }\n}\nconst _c17 = [\"kendoGridFilterRow\", \"\"];\nfunction _class114_td_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 3);\n  }\n}\nfunction _class114_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 4);\n  }\n}\nfunction _class114_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 5);\n  }\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const columnIndex_r5 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-header-sticky\", column_r4.sticky);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.addStickyStyles(column_r4))(\"ngClass\", column_r4.filterClass)(\"column\", column_r4)(\"filter\", ctx_r2.filter)(\"logicalRowIndex\", ctx_r2.logicalRowIndex)(\"logicalColIndex\", ctx_r2.getLogicalColIndex(columnIndex_r5));\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.filterLabel(column_r4));\n  }\n}\nconst _c18 = [\"applyButton\"];\nconst _c19 = function (a0) {\n  return {\n    \"data-index\": a0\n  };\n};\nfunction _class118_label_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"label\", 3);\n    i0.ɵɵelement(1, \"kendo-checkbox\", 4);\n    i0.ɵɵelementStart(2, \"span\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const column_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoColumnMenuChooserItemChecked\", !column_r2.hidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"inputAttributes\", i0.ɵɵpureFunction1(5, _c19, index_r3.toString()))(\"checkedState\", !column_r2.hidden)(\"disabled\", ctx_r0.isDisabled(column_r2));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r2.displayTitle);\n  }\n}\nfunction _class118_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 6)(1, \"button\", 7, 8);\n    i0.ɵɵlistener(\"click\", function _class118_div_2_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.applyChanges());\n    })(\"keydown.enter\", function _class118_div_2_Template_button_keydown_enter_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      $event.preventDefault();\n      $event.stopPropagation;\n      return i0.ɵɵresetView(ctx_r8.applyChanges());\n    })(\"keydown.space\", function _class118_div_2_Template_button_keydown_space_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      $event.preventDefault();\n      $event.stopPropagation;\n      return i0.ɵɵresetView(ctx_r9.applyChanges());\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 9, 10);\n    i0.ɵɵlistener(\"keydown.tab\", function _class118_div_2_Template_button_keydown_tab_4_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.onTab($event));\n    })(\"click\", function _class118_div_2_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.cancelChanges());\n    })(\"keydown.enter\", function _class118_div_2_Template_button_keydown_enter_4_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r12 = i0.ɵɵnextContext();\n      $event.preventDefault();\n      $event.stopPropagation;\n      return i0.ɵɵresetView(ctx_r12.cancelChanges());\n    })(\"keydown.space\", function _class118_div_2_Template_button_keydown_space_4_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r13 = i0.ɵɵnextContext();\n      $event.preventDefault();\n      $event.stopPropagation;\n      return i0.ɵɵresetView(ctx_r13.cancelChanges());\n    });\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.actionsClass);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r1.applyText);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r1.resetText);\n  }\n}\nconst _c20 = [\"columnList\"];\nfunction _class119_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"kendo-grid-columnlist\", 4, 5);\n    i0.ɵɵlistener(\"apply\", function _class119_ng_template_2_Template_kendo_grid_columnlist_apply_2_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.onApply($event));\n    })(\"columnChange\", function _class119_ng_template_2_Template_kendo_grid_columnlist_columnChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.onChange($event));\n    })(\"keydown.shift.tab\", function _class119_ng_template_2_Template_kendo_grid_columnlist_keydown_shift_tab_2_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.onShiftTab($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.ctx.localization.get(\"columns\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r2.columns)(\"ariaLabel\", ctx_r2.ctx.localization.get(\"columns\"))(\"isLast\", true)(\"applyText\", ctx_r2.ctx.localization.get(\"columnsApply\"))(\"resetText\", ctx_r2.ctx.localization.get(\"columnsReset\"))(\"autoSync\", ctx_r2.autoSync)(\"allowHideAll\", ctx_r2.allowHideAll);\n  }\n}\nfunction _class122_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelementContainer(1, 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r1);\n  }\n}\nfunction _class122_ng_template_1_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 9);\n  }\n}\nfunction _class122_ng_template_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r4.expandedIcon)(\"svgIcon\", ctx_r4.expandedSvgIcon);\n  }\n}\nfunction _class122_ng_template_1_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵelementContainer(1, 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", \"hidden\");\n    i0.ɵɵproperty(\"@state\", ctx_r5.contentState);\n    i0.ɵɵattribute(\"id\", ctx_r5.contentId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.contentTemplate.templateRef);\n  }\n}\nfunction _class122_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵlistener(\"click\", function _class122_ng_template_1_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.onClick($event));\n    })(\"keydown.enter\", function _class122_ng_template_1_Template_div_keydown_enter_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.onClick($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtext(2);\n    i0.ɵɵtemplate(3, _class122_ng_template_1_span_3_Template, 1, 0, \"span\", 6);\n    i0.ɵɵtemplate(4, _class122_ng_template_1_span_4_Template, 2, 2, \"span\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class122_ng_template_1_div_5_Template, 2, 5, \"div\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-selected\", ctx_r2.selected)(\"k-disabled\", ctx_r2.disabled);\n    i0.ɵɵattribute(\"aria-expanded\", ctx_r2.expanded)(\"aria-controls\", ctx_r2.expanded ? ctx_r2.contentId : undefined);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r2.icon)(\"svgIcon\", ctx_r2.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.text, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.contentTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.contentTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.contentTemplate);\n  }\n}\nfunction _class123_kendo_grid_columnmenu_item_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 1);\n    i0.ɵɵlistener(\"itemClick\", function _class123_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.autoSizeAllColumns());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"text\", ctx_r0.ctx.localization.get(\"autosizeAllColumns\"))(\"svgIcon\", ctx_r0.displayInlineFlexIcon);\n  }\n}\nfunction _class124_kendo_grid_columnmenu_item_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 1);\n    i0.ɵɵlistener(\"itemClick\", function _class124_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.autoSizeColumn());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"text\", ctx_r0.ctx.localization.get(\"autosizeThisColumn\"))(\"svgIcon\", ctx_r0.maxWidthIcon);\n  }\n}\nfunction _class125_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnlist\", 2);\n    i0.ɵɵlistener(\"apply\", function _class125_ng_template_1_Template_kendo_grid_columnlist_apply_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onApply($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"applyText\", ctx_r0.ctx.localization.get(\"columnsApply\"))(\"resetText\", ctx_r0.ctx.localization.get(\"columnsReset\"))(\"ariaLabel\", ctx_r0.ctx.localization.get(\"columns\"))(\"columns\", ctx_r0.columns)(\"autoSync\", false)(\"allowHideAll\", false)(\"actionsClass\", ctx_r0.actionsClass)(\"isLast\", ctx_r0.isLast)(\"isExpanded\", ctx_r0.expanded)(\"service\", ctx_r0.service);\n  }\n}\nfunction _class128_ng_template_1_kendo_grid_columnmenu_lock_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-lock\", 3);\n    i0.ɵɵlistener(\"keydown.tab\", function _class128_ng_template_1_kendo_grid_columnmenu_lock_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r3.onTab($event, !ctx_r3.showStick));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r1.service);\n  }\n}\nfunction _class128_ng_template_1_kendo_grid_columnmenu_stick_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-stick\", 3);\n    i0.ɵɵlistener(\"keydown.tab\", function _class128_ng_template_1_kendo_grid_columnmenu_stick_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r5.onTab($event, true));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r2.service);\n  }\n}\nfunction _class128_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class128_ng_template_1_kendo_grid_columnmenu_lock_0_Template, 1, 1, \"kendo-grid-columnmenu-lock\", 2);\n    i0.ɵɵtemplate(1, _class128_ng_template_1_kendo_grid_columnmenu_stick_1_Template, 1, 1, \"kendo-grid-columnmenu-stick\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showLock);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showStick);\n  }\n}\nfunction _class129_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-container\", 2);\n    i0.ɵɵlistener(\"keydown.shift.tab\", function _class129_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    })(\"close\", function _class129_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.close());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"column\", ctx_r0.service.column)(\"menuTabbingService\", ctx_r0.service.menuTabbingService)(\"filter\", ctx_r0.service.filter)(\"actionsClass\", ctx_r0.actionsClass)(\"isLast\", ctx_r0.isLast)(\"isExpanded\", ctx_r0.expanded);\n  }\n}\nconst _c21 = [\"tabbedInterfaceTemplate\"];\nconst _c22 = function (a0, a1) {\n  return {\n    service: a0,\n    column: a1\n  };\n};\nfunction _class134_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-container\", 6);\n    i0.ɵɵlistener(\"keydown.escape\", function _class134_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.close(true));\n    })(\"keydown.enter\", function _class134_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵelementContainer(1, 7);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(8);\n    const _r3 = i0.ɵɵreference(6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.column.columnMenuTemplateRef || ctx_r2.columnMenuTemplate || (ctx_r2.settings.view === \"tabbed\" ? _r5 : _r3))(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c22, ctx_r2.service, ctx_r2.column));\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_sort_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-sort\", 14, 15);\n  }\n  if (rf & 2) {\n    const _r20 = i0.ɵɵreference(1);\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r20)(\"service\", ctx_r10.service);\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-lock\", 14, 16);\n  }\n  if (rf & 2) {\n    const _r21 = i0.ɵɵreference(1);\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r21)(\"service\", ctx_r11.service);\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-stick\", 14, 17);\n  }\n  if (rf & 2) {\n    const _r22 = i0.ɵɵreference(1);\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r22)(\"service\", ctx_r12.service);\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_position_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-position\", 18, 19);\n  }\n  if (rf & 2) {\n    const _r23 = i0.ɵɵreference(1);\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"showLock\", ctx_r13.hasLock)(\"showStick\", ctx_r13.hasStick)(\"kendoGridColumnMenuItem\", _r23)(\"service\", ctx_r13.service)(\"expanded\", ctx_r13.expandedPosition);\n  }\n}\nfunction _class134_ng_template_5_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵstyleProp(\"border-color\", \"rgba(0, 0, 0, 0.08)\");\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_chooser_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-chooser\", 21, 22);\n  }\n  if (rf & 2) {\n    const _r24 = i0.ɵɵreference(1);\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r24)(\"service\", ctx_r15.service)(\"expanded\", ctx_r15.expandedColumns);\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-autosize-column\", 23, 24);\n  }\n  if (rf & 2) {\n    const _r25 = i0.ɵɵreference(1);\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r16.service)(\"kendoGridColumnMenuItem\", _r25)(\"column\", ctx_r16.column);\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-autosize-all-columns\", 25, 26);\n  }\n  if (rf & 2) {\n    const _r26 = i0.ɵɵreference(1);\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r17.service)(\"kendoGridColumnMenuItem\", _r26);\n  }\n}\nfunction _class134_ng_template_5_span_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵstyleProp(\"border-color\", \"rgba(0, 0, 0, 0.08)\");\n  }\n}\nfunction _class134_ng_template_5_kendo_grid_columnmenu_filter_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-filter\", 21, 27);\n  }\n  if (rf & 2) {\n    const _r27 = i0.ɵɵreference(1);\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r27)(\"service\", ctx_r19.service)(\"expanded\", ctx_r19.expandedFilter);\n  }\n}\nfunction _class134_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-container\", 6);\n    i0.ɵɵlistener(\"keydown.escape\", function _class134_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.close(true));\n    })(\"keydown.enter\", function _class134_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵtemplate(1, _class134_ng_template_5_kendo_grid_columnmenu_sort_1_Template, 2, 2, \"kendo-grid-columnmenu-sort\", 8);\n    i0.ɵɵtemplate(2, _class134_ng_template_5_kendo_grid_columnmenu_lock_2_Template, 2, 2, \"kendo-grid-columnmenu-lock\", 8);\n    i0.ɵɵtemplate(3, _class134_ng_template_5_kendo_grid_columnmenu_stick_3_Template, 2, 2, \"kendo-grid-columnmenu-stick\", 8);\n    i0.ɵɵtemplate(4, _class134_ng_template_5_kendo_grid_columnmenu_position_4_Template, 2, 5, \"kendo-grid-columnmenu-position\", 9);\n    i0.ɵɵtemplate(5, _class134_ng_template_5_span_5_Template, 1, 2, \"span\", 10);\n    i0.ɵɵtemplate(6, _class134_ng_template_5_kendo_grid_columnmenu_chooser_6_Template, 2, 3, \"kendo-grid-columnmenu-chooser\", 11);\n    i0.ɵɵtemplate(7, _class134_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, \"kendo-grid-columnmenu-autosize-column\", 12);\n    i0.ɵɵtemplate(8, _class134_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, \"kendo-grid-columnmenu-autosize-all-columns\", 13);\n    i0.ɵɵtemplate(9, _class134_ng_template_5_span_9_Template, 1, 2, \"span\", 10);\n    i0.ɵɵtemplate(10, _class134_ng_template_5_kendo_grid_columnmenu_filter_10_Template, 2, 3, \"kendo-grid-columnmenu-filter\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasSort);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasLock && !ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasStick && !ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasColumnChooser);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasAutoSizeColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasAutoSizeAllColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasFilter);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 33);\n  }\n  if (rf & 2) {\n    const ctx_r35 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r35.filterIcon);\n    i0.ɵɵattribute(\"title\", ctx_r35.ctx.localization.get(\"columnMenuFilterTabTitle\"));\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-container\", 34);\n    i0.ɵɵlistener(\"keydown.shift.tab\", function _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    })(\"close\", function _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r38 = i0.ɵɵnextContext(3);\n      return i0.ɵɵresetView(ctx_r38.close());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r36 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"column\", ctx_r36.service.column)(\"menuTabbingService\", ctx_r36.service.menuTabbingService)(\"filter\", ctx_r36.service.filter)(\"actionsClass\", ctx_r36.actionsClass);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-tabstrip-tab\");\n    i0.ɵɵtemplate(1, _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template, 1, 2, \"ng-template\", 31);\n    i0.ɵɵtemplate(2, _class134_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template, 1, 4, \"ng-template\", 32);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 35);\n  }\n  if (rf & 2) {\n    const ctx_r40 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r40.slidersIcon);\n    i0.ɵɵattribute(\"title\", ctx_r40.ctx.localization.get(\"columnMenuGeneralTabTitle\"));\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-sort\", 14, 15);\n  }\n  if (rf & 2) {\n    const _r51 = i0.ɵɵreference(1);\n    const ctx_r42 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r51)(\"service\", ctx_r42.service);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵstyleProp(\"border-color\", \"rgba(0, 0, 0, 0.08)\");\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-lock\", 14, 16);\n  }\n  if (rf & 2) {\n    const _r52 = i0.ɵɵreference(1);\n    const ctx_r44 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r52)(\"service\", ctx_r44.service);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-stick\", 14, 17);\n  }\n  if (rf & 2) {\n    const _r53 = i0.ɵɵreference(1);\n    const ctx_r45 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r53)(\"service\", ctx_r45.service);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵstyleProp(\"border-color\", \"rgba(0, 0, 0, 0.08)\");\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-position\", 18, 19);\n  }\n  if (rf & 2) {\n    const _r54 = i0.ɵɵreference(1);\n    const ctx_r47 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"showLock\", ctx_r47.hasLock)(\"showStick\", ctx_r47.hasStick)(\"kendoGridColumnMenuItem\", _r54)(\"service\", ctx_r47.service)(\"expanded\", ctx_r47.expandedPosition);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵstyleProp(\"border-color\", \"rgba(0, 0, 0, 0.08)\");\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-autosize-column\", 23, 24);\n  }\n  if (rf & 2) {\n    const _r55 = i0.ɵɵreference(1);\n    const ctx_r49 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"service\", ctx_r49.service)(\"kendoGridColumnMenuItem\", _r55)(\"column\", ctx_r49.column);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-autosize-all-columns\", 25, 26);\n  }\n  if (rf & 2) {\n    const _r56 = i0.ɵɵreference(1);\n    const ctx_r50 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"service\", ctx_r50.service)(\"kendoGridColumnMenuItem\", _r56);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template, 2, 2, \"kendo-grid-columnmenu-sort\", 8);\n    i0.ɵɵtemplate(1, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template, 1, 2, \"span\", 10);\n    i0.ɵɵtemplate(2, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template, 2, 2, \"kendo-grid-columnmenu-lock\", 8);\n    i0.ɵɵtemplate(3, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template, 2, 2, \"kendo-grid-columnmenu-stick\", 8);\n    i0.ɵɵtemplate(4, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template, 1, 2, \"span\", 10);\n    i0.ɵɵtemplate(5, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template, 2, 5, \"kendo-grid-columnmenu-position\", 9);\n    i0.ɵɵtemplate(6, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template, 1, 2, \"span\", 10);\n    i0.ɵɵtemplate(7, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, \"kendo-grid-columnmenu-autosize-column\", 12);\n    i0.ɵɵtemplate(8, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, \"kendo-grid-columnmenu-autosize-all-columns\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasSort);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasSort && (ctx_r41.hasLock || ctx_r41.hasStick || ctx_r41.hasPosition || ctx_r41.hasAutoSizeColumn || ctx_r41.hasAutoSizeAllColumns));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasLock && !ctx_r41.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasStick && !ctx_r41.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", (ctx_r41.hasLock || ctx_r41.hasStick) && !ctx_r41.hasPosition && (ctx_r41.hasAutoSizeColumn || ctx_r41.hasAutoSizeAllColumns));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasPosition && (ctx_r41.hasAutoSizeColumn || ctx_r41.hasAutoSizeAllColumns));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasAutoSizeColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r41.hasAutoSizeAllColumns);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-tabstrip-tab\");\n    i0.ɵɵtemplate(1, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template, 1, 2, \"ng-template\", 31);\n    i0.ɵɵtemplate(2, _class134_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template, 9, 9, \"ng-template\", 32);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 36);\n  }\n  if (rf & 2) {\n    const ctx_r57 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r57.columnsIcon);\n    i0.ɵɵattribute(\"title\", ctx_r57.ctx.localization.get(\"columnMenuColumnsTabTitle\"));\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r60 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-columnlist\", 37);\n    i0.ɵɵlistener(\"apply\", function _class134_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template_kendo_grid_columnlist_apply_0_listener($event) {\n      i0.ɵɵrestoreView(_r60);\n      const ctx_r59 = i0.ɵɵnextContext(3);\n      return i0.ɵɵresetView(ctx_r59.onApply($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r58 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"applyText\", ctx_r58.ctx.localization.get(\"columnsApply\"))(\"resetText\", ctx_r58.ctx.localization.get(\"columnsReset\"))(\"columns\", ctx_r58.columns)(\"autoSync\", false)(\"allowHideAll\", false)(\"actionsClass\", ctx_r58.actionsClass)(\"service\", ctx_r58.service);\n  }\n}\nfunction _class134_ng_template_7_kendo_tabstrip_tab_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-tabstrip-tab\");\n    i0.ɵɵtemplate(1, _class134_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template, 1, 2, \"ng-template\", 31);\n    i0.ɵɵtemplate(2, _class134_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template, 1, 7, \"ng-template\", 32);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class134_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r62 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-tabstrip\", 28, 29);\n    i0.ɵɵlistener(\"keydown.escape\", function _class134_ng_template_7_Template_kendo_tabstrip_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r62);\n      const ctx_r61 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r61.close(true));\n    });\n    i0.ɵɵtemplate(2, _class134_ng_template_7_kendo_tabstrip_tab_2_Template, 3, 0, \"kendo-tabstrip-tab\", 30);\n    i0.ɵɵtemplate(3, _class134_ng_template_7_kendo_tabstrip_tab_3_Template, 3, 0, \"kendo-tabstrip-tab\", 30);\n    i0.ɵɵtemplate(4, _class134_ng_template_7_kendo_tabstrip_tab_4_Template, 3, 0, \"kendo-tabstrip-tab\", 30);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasFilter);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.showGeneralTab);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasColumnChooser);\n  }\n}\nconst _c23 = function (a0) {\n  return {\n    \"k-active\": a0\n  };\n};\nconst _c24 = [\"kendoGridExcelCommand\", \"\"];\nfunction _class138_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class138_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class138_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c25 = [\"kendoGridPDFCommand\", \"\"];\nfunction _class145_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class145_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class145_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c26 = [\"kendoGridHeader\", \"\"];\nfunction _class154_tr_1_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"th\", 6);\n  }\n}\nfunction _class154_tr_1_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"th\", 7);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template(rf, ctx) {}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 18);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r8.displayTitle);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-filter-menu\", 19);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r19.getColumnComponent(column_r8))(\"filter\", ctx_r19.filter)(\"tabIndex\", ctx_r19.tabIndex);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 20);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r20.columnMenuSettings)(\"column\", column_r8)(\"columnMenuTemplate\", ctx_r20.columnMenuTemplate)(\"sort\", ctx_r20.sort)(\"filter\", ctx_r20.filter)(\"sortable\", ctx_r20.sortable)(\"tabIndex\", ctx_r20.tabIndex);\n  }\n}\nconst _c27 = function (a0, a1, a2, a3) {\n  return {\n    templateRef: a0,\n    columnIndex: a1,\n    column: a2,\n    $implicit: a3\n  };\n};\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 13)(2, \"span\", 14);\n    i0.ɵɵtemplate(3, _class154_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(4, _class154_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template, 3, 1, \"ng-container\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class154_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template, 1, 3, \"kendo-grid-filter-menu\", 16);\n    i0.ɵɵtemplate(6, _class154_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template, 1, 8, \"kendo-grid-column-menu\", 17);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"!k-cursor-default\", !ctx_r13.isInteractive(ctx_r13.getColumnComponent(column_r8), \"groupable\") && !ctx_r13.isInteractive(ctx_r13.getColumnComponent(column_r8), \"reorderable\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(6, _c27, column_r8.headerTemplateRef, column_r8.leafIndex, column_r8, column_r8));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r8.headerTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.showFilterMenu && ctx_r13.isFilterable(ctx_r13.getColumnComponent(column_r8)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.showColumnMenu(column_r8));\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template(rf, ctx) {}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 18);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r8.displayTitle);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 25);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵpropertyInterpolate1(\"name\", \"sort-\", ctx_r28.sortDescriptor(ctx_r28.getColumnComponent(column_r8).field).dir, \"-small\");\n    i0.ɵɵproperty(\"svgIcon\", ctx_r28.sortDescriptor(ctx_r28.getColumnComponent(column_r8).field).dir === \"asc\" ? ctx_r28.sortAscSmallIcon : ctx_r28.sortDescSmallIcon);\n    i0.ɵɵattribute(\"aria-label\", ctx_r28.sortableLabel);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 26);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r29.sortOrder(ctx_r29.getColumnComponent(column_r8).field));\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-filter-menu\", 19);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r30 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r30.getColumnComponent(column_r8))(\"filter\", ctx_r30.filter)(\"tabIndex\", ctx_r30.tabIndex);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 20);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r31.columnMenuSettings)(\"column\", column_r8)(\"columnMenuTemplate\", ctx_r31.columnMenuTemplate)(\"sort\", ctx_r31.sort)(\"filter\", ctx_r31.filter)(\"sortable\", ctx_r31.sortable)(\"tabIndex\", ctx_r31.tabIndex);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 13)(2, \"span\", 21, 22);\n    i0.ɵɵlistener(\"click\", function _class154_tr_1_ng_container_3_th_1_ng_container_2_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r39);\n      const _r25 = i0.ɵɵreference(3);\n      const column_r8 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r37 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r37.onSortClick(ctx_r37.getColumnComponent(column_r8), $event, _r25));\n    });\n    i0.ɵɵtemplate(4, _class154_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(5, _class154_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template, 3, 1, \"ng-container\", 11);\n    i0.ɵɵelementStart(6, \"span\");\n    i0.ɵɵtemplate(7, _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template, 1, 3, \"kendo-icon-wrapper\", 23);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(8, _class154_tr_1_ng_container_3_th_1_ng_container_2_span_8_Template, 2, 1, \"span\", 24);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template, 1, 3, \"kendo-grid-filter-menu\", 16);\n    i0.ɵɵtemplate(10, _class154_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template, 1, 8, \"kendo-grid-column-menu\", 17);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(8, _c27, column_r8.headerTemplateRef, column_r8.leafIndex, column_r8, column_r8));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r8.headerTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-sort-icon\", ctx_r14.sortDescriptor(ctx_r14.getColumnComponent(column_r8).field).dir);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.sortDescriptor(ctx_r14.getColumnComponent(column_r8).field).dir);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.showSortNumbering(ctx_r14.getColumnComponent(column_r8)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.showFilterMenu && ctx_r14.isFilterable(ctx_r14.getColumnComponent(column_r8)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.showColumnMenu(column_r8));\n  }\n}\nconst _c28 = function (a0) {\n  return {\n    \"aria-label\": a0\n  };\n};\nfunction _class154_tr_1_ng_container_3_th_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"kendo-checkbox\", 27);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"inputAttributes\", i0.ɵɵpureFunction1(2, _c28, ctx_r15.selectAllCheckboxLabel));\n    i0.ɵɵattribute(\"id\", ctx_r15.selectAllCheckboxId());\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 28);\n  }\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext(2);\n    const last_r10 = ctx_r41.last;\n    const column_r8 = ctx_r41.$implicit;\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"isLast\", last_r10)(\"column\", column_r8)(\"columns\", ctx_r16.columns);\n  }\n}\nconst _c29 = function (a0, a2, a3, a4) {\n  return {\n    field: a0,\n    type: \"column\",\n    column: a2,\n    hint: a3,\n    lastColumn: a4\n  };\n};\nfunction _class154_tr_1_ng_container_3_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"th\", 10);\n    i0.ɵɵlistener(\"keydown\", function _class154_tr_1_ng_container_3_th_1_Template_th_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r44);\n      const column_r8 = i0.ɵɵnextContext().$implicit;\n      const ctx_r42 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r42.onHeaderKeydown(ctx_r42.getColumnComponent(column_r8), $event));\n    });\n    i0.ɵɵtemplate(1, _class154_tr_1_ng_container_3_th_1_ng_container_1_Template, 7, 11, \"ng-container\", 11);\n    i0.ɵɵtemplate(2, _class154_tr_1_ng_container_3_th_1_ng_container_2_Template, 11, 13, \"ng-container\", 11);\n    i0.ɵɵtemplate(3, _class154_tr_1_ng_container_3_th_1_ng_container_3_Template, 2, 4, \"ng-container\", 11);\n    i0.ɵɵtemplate(4, _class154_tr_1_ng_container_3_th_1_span_4_Template, 1, 3, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r45 = i0.ɵɵnextContext();\n    const column_r8 = ctx_r45.$implicit;\n    const columnIndex_r9 = ctx_r45.index;\n    const last_r10 = ctx_r45.last;\n    const levelIndex_r3 = i0.ɵɵnextContext().index;\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-sorted\", ctx_r11.sortState(ctx_r11.getColumnComponent(column_r8)))(\"k-filterable\", ctx_r11.showFilterMenu && ctx_r11.isFilterable(ctx_r11.getColumnComponent(column_r8)) || ctx_r11.showColumnMenu(column_r8))(\"k-first\", ctx_r11.isFirstOnRow(ctx_r11.getColumnComponent(column_r8), columnIndex_r9))(\"k-grid-header-sticky\", column_r8.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalColIndex\", ctx_r11.logicalColumnIndex(column_r8))(\"headerLabelText\", column_r8.title || ctx_r11.getColumnComponent(column_r8).field)(\"colSpan\", column_r8.colspan)(\"rowSpan\", column_r8.rowspan(ctx_r11.totalColumnLevels))(\"enableDrag\", ctx_r11.shouldActivate(column_r8))(\"context\", i0.ɵɵpureFunction4(27, _c29, ctx_r11.getColumnComponent(column_r8).field, column_r8, column_r8.title || ctx_r11.getColumnComponent(column_r8).field, last_r10 && columnIndex_r9 === 0))(\"ngClass\", column_r8.headerClass)(\"ngStyle\", column_r8.sticky ? ctx_r11.addStickyStyles(column_r8) : column_r8.headerStyle);\n    i0.ɵɵattribute(\"aria-sort\", ctx_r11.sortState(ctx_r11.getColumnComponent(column_r8)))(\"rowspan\", column_r8.rowspan(ctx_r11.totalColumnLevels))(\"colspan\", column_r8.colspan)(\"aria-haspopup\", ctx_r11.isNavigable && (ctx_r11.showFilterMenu || ctx_r11.showColumnMenu(column_r8)) ? \"dialog\" : undefined)(\"aria-expanded\", ctx_r11.isNavigable && (ctx_r11.showFilterMenu || ctx_r11.showColumnMenu(column_r8)) ? false : undefined)(\"aria-keyshortcuts\", ctx_r11.isNavigable ? \"Alt + ArrowDown\" : undefined);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r11.isInteractive(ctx_r11.getColumnComponent(column_r8), \"sortable\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isInteractive(ctx_r11.getColumnComponent(column_r8), \"sortable\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isCheckboxColumn(column_r8) && !column_r8.headerTemplateRef && column_r8.showSelectAll);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.resizable);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_2_ng_template_3_Template(rf, ctx) {}\nfunction _class154_tr_1_ng_container_3_th_2_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 18);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r8.displayTitle);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_2_kendo_grid_column_menu_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 31);\n  }\n  if (rf & 2) {\n    const column_r8 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r49.columnMenuSettings)(\"column\", column_r8)(\"columnMenuTemplate\", ctx_r49.columnMenuTemplate);\n  }\n}\nfunction _class154_tr_1_ng_container_3_th_2_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 28);\n  }\n  if (rf & 2) {\n    const ctx_r53 = i0.ɵɵnextContext(2);\n    const last_r10 = ctx_r53.last;\n    const column_r8 = ctx_r53.$implicit;\n    const ctx_r50 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"isLast\", last_r10)(\"column\", column_r8)(\"columns\", ctx_r50.columns);\n  }\n}\nconst _c30 = function (a1, a2, a3) {\n  return {\n    type: \"columnGroup\",\n    column: a1,\n    hint: a2,\n    lastColumn: a3\n  };\n};\nfunction _class154_tr_1_ng_container_3_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 29)(1, \"span\", 13)(2, \"span\", 14);\n    i0.ɵɵtemplate(3, _class154_tr_1_ng_container_3_th_2_ng_template_3_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(4, _class154_tr_1_ng_container_3_th_2_ng_container_4_Template, 3, 1, \"ng-container\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class154_tr_1_ng_container_3_th_2_kendo_grid_column_menu_5_Template, 1, 4, \"kendo-grid-column-menu\", 30);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, _class154_tr_1_ng_container_3_th_2_span_6_Template, 1, 3, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r54 = i0.ɵɵnextContext();\n    const column_r8 = ctx_r54.$implicit;\n    const columnIndex_r9 = ctx_r54.index;\n    const last_r10 = ctx_r54.last;\n    const levelIndex_r3 = i0.ɵɵnextContext().index;\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-first\", ctx_r12.isFirstOnRow(ctx_r12.getColumnComponent(column_r8), columnIndex_r9))(\"k-filterable\", ctx_r12.showColumnMenu(column_r8))(\"k-grid-content-sticky\", column_r8.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalColIndex\", ctx_r12.logicalColumnIndex(column_r8))(\"rowSpan\", column_r8.rowspan(ctx_r12.totalColumnLevels))(\"colSpan\", column_r8.colspan)(\"headerLabelText\", column_r8.title || ctx_r12.getColumnComponent(column_r8).field)(\"enableDrag\", ctx_r12.shouldActivate(column_r8))(\"context\", i0.ɵɵpureFunction3(21, _c30, column_r8, column_r8.title, last_r10 && columnIndex_r9 === 0))(\"ngClass\", column_r8.headerClass)(\"ngStyle\", column_r8.headerStyle);\n    i0.ɵɵattribute(\"rowspan\", column_r8.rowspan(ctx_r12.totalColumnLevels))(\"colspan\", column_r8.colspan);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(25, _c27, column_r8.headerTemplateRef, ctx_r12.lockedColumnsCount + columnIndex_r9, column_r8, column_r8));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r8.headerTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.showColumnMenu(column_r8));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.resizable);\n  }\n}\nfunction _class154_tr_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class154_tr_1_ng_container_3_th_1_Template, 5, 32, \"th\", 8);\n    i0.ɵɵtemplate(2, _class154_tr_1_ng_container_3_th_2_Template, 7, 30, \"th\", 9);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r8 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.isColumnGroupComponent(column_r8));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.isColumnGroupComponent(column_r8));\n  }\n}\nfunction _class154_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 2);\n    i0.ɵɵtemplate(1, _class154_tr_1_th_1_Template, 1, 0, \"th\", 3);\n    i0.ɵɵtemplate(2, _class154_tr_1_th_2_Template, 1, 0, \"th\", 4);\n    i0.ɵɵtemplate(3, _class154_tr_1_ng_container_3_Template, 3, 2, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const levelIndex_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalSlaveRow\", ctx_r0.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r0.columns.length)(\"logicalSlaveCellsCount\", ctx_r0.unlockedColumnsCount)(\"totalColumns\", ctx_r0.totalColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.groups);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.columnsForLevel(levelIndex_r3));\n  }\n}\nfunction _class154_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tr\", 32);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"columns\", ctx_r1.leafColumns)(\"filter\", ctx_r1.filter)(\"groups\", ctx_r1.groups)(\"detailTemplate\", ctx_r1.detailTemplate)(\"lockedColumnsCount\", ctx_r1.lockedColumnsCount)(\"logicalRowIndex\", ctx_r1.totalColumnLevels + 1)(\"logicalSlaveRow\", ctx_r1.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r1.columns.length)(\"logicalSlaveCellsCount\", ctx_r1.unlockedColumnsCount)(\"totalColumns\", ctx_r1.totalColumns);\n  }\n}\nconst _c31 = [\"kendoGridFooter\", \"\"];\nfunction _class155_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 4);\n  }\n}\nfunction _class155_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 5);\n  }\n}\nfunction _class155_ng_container_4_td_1_ng_template_1_Template(rf, ctx) {}\nfunction _class155_ng_container_4_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 7);\n    i0.ɵɵtemplate(1, _class155_ng_container_4_td_1_ng_template_1_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const column_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-footer-sticky\", column_r4.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r6.logicalRowIndex)(\"logicalColIndex\", ctx_r6.logicalColumnIndex(column_r4))(\"ngClass\", column_r4.footerClass)(\"ngStyle\", column_r4.sticky ? ctx_r6.addStickyStyles(column_r4) : column_r4.footerStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(7, _c27, column_r4.footerTemplateRef, column_r4.leafIndex, column_r4, column_r4));\n  }\n}\nfunction _class155_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class155_ng_container_4_td_1_Template, 2, 12, \"td\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.isColumnGroupComponent(column_r4));\n  }\n}\nconst _c32 = [\"kendoGridCell\", \"\"];\nfunction _class161_ng_container_1_ng_container_1_1_ng_template_0_Template(rf, ctx) {}\nfunction _class161_ng_container_1_ng_container_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_1_ng_container_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.column.templateRef)(\"ngTemplateOutletContext\", ctx_r5.templateContext);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const childColumn_r12 = ctx.$implicit;\n    const ctx_r11 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(2, 1, ctx_r11.dataItem, childColumn_r12.field, childColumn_r12.format), \" \");\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template, 3, 5, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6.childColumns);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind3(2, 1, ctx_r7.dataItem, ctx_r7.column.field, ctx_r7.column.format));\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"kendo-checkbox\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridSelectionCheckbox\", ctx_r13.rowIndex)(\"inputAttributes\", i0.ɵɵpureFunction1(3, _c28, ctx_r13.selectionCheckboxLabel));\n    i0.ɵɵattribute(\"id\", ctx_r13.selectionCheckboxId);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_4_ng_template_2_kendo_checkbox_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-checkbox\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(5);\n    i0.ɵɵproperty(\"kendoGridSelectionCheckbox\", ctx_r16.rowIndex)(\"inputAttributes\", i0.ɵɵpureFunction1(4, _c28, ctx_r16.selectionCheckboxLabel))(\"disabled\", true);\n    i0.ɵɵattribute(\"id\", ctx_r16.selectionCheckboxId);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_1_ng_container_1_ng_container_4_ng_template_2_kendo_checkbox_0_Template, 1, 6, \"kendo-checkbox\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.column.showDisabledCheckbox);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_container_1_ng_container_4_ng_container_1_Template, 2, 5, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, _class161_ng_container_1_ng_container_1_ng_container_4_ng_template_2_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const _r14 = i0.ɵɵreference(3);\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.isRowSelectable)(\"ngIfElse\", _r14);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_5_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 12);\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r17.reorderIcon);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_5_2_ng_template_0_Template(rf, ctx) {}\nfunction _class161_ng_container_1_ng_container_1_ng_container_5_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_1_ng_container_1_ng_container_5_2_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.column.rowDragHandleTemplateRef)(\"ngTemplateOutletContext\", ctx_r18.rowReorderTemplateContext);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_container_1_ng_container_5_kendo_icon_wrapper_1_Template, 1, 1, \"kendo-icon-wrapper\", 11);\n    i0.ɵɵtemplate(2, _class161_ng_container_1_ng_container_1_ng_container_5_2_Template, 1, 2, null, 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r9.column.dragHandleTemplate == null ? null : ctx_r9.column.dragHandleTemplate.first));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.column.dragHandleTemplate == null ? null : ctx_r9.column.dragHandleTemplate.first);\n  }\n}\nfunction _class161_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_container_1_1_Template, 1, 2, null, 4);\n    i0.ɵɵtemplate(2, _class161_ng_container_1_ng_container_1_ng_container_2_Template, 2, 1, \"ng-container\", 4);\n    i0.ɵɵtemplate(3, _class161_ng_container_1_ng_container_1_ng_container_3_Template, 3, 5, \"ng-container\", 4);\n    i0.ɵɵtemplate(4, _class161_ng_container_1_ng_container_1_ng_container_4_Template, 4, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(5, _class161_ng_container_1_ng_container_1_ng_container_5_Template, 3, 2, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.column.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isSpanColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isBoundColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isCheckboxColumn && !ctx_r2.isNew);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isRowReorderColumn && !ctx_r2.isNew);\n  }\n}\nfunction _class161_ng_container_1_ng_template_2_0_ng_template_0_Template(rf, ctx) {}\nconst _c33 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nfunction _class161_ng_container_1_ng_template_2_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_1_ng_template_2_0_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r20.loadingTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c33, ctx_r20.column));\n  }\n}\nfunction _class161_ng_container_1_ng_template_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 14);\n  }\n}\nfunction _class161_ng_container_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_1_ng_template_2_0_Template, 1, 4, null, 4);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_template_2_div_1_Template, 1, 0, \"div\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.loadingTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.loadingTemplate);\n  }\n}\nfunction _class161_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_1_ng_container_1_Template, 6, 5, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, _class161_ng_container_1_ng_template_2_Template, 2, 2, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const _r3 = i0.ɵɵreference(3);\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.showLoading)(\"ngIfElse\", _r3);\n  }\n}\nfunction _class161_ng_container_2_1_ng_template_0_Template(rf, ctx) {}\nfunction _class161_ng_container_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class161_ng_container_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r23.column.editTemplateRef)(\"ngTemplateOutletContext\", ctx_r23.editTemplateContext);\n  }\n}\nfunction _class161_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-numerictextbox\", 19);\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"format\", ctx_r26.format)(\"formControl\", ctx_r26.formGroup.get(ctx_r26.column.field));\n  }\n}\nfunction _class161_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-datepicker\", 19);\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"format\", ctx_r27.format)(\"formControl\", ctx_r27.formGroup.get(ctx_r27.column.field));\n  }\n}\nfunction _class161_ng_container_2_ng_container_2_kendo_checkbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-checkbox\", 20);\n  }\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"formControl\", ctx_r28.formGroup.get(ctx_r28.column.field));\n  }\n}\nfunction _class161_ng_container_2_ng_container_2_kendo_textbox_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-textbox\", 20);\n  }\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"formControl\", ctx_r29.formGroup.get(ctx_r29.column.field));\n  }\n}\nfunction _class161_ng_container_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0, 0);\n    i0.ɵɵtemplate(1, _class161_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, \"kendo-numerictextbox\", 16);\n    i0.ɵɵtemplate(2, _class161_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, \"kendo-datepicker\", 16);\n    i0.ɵɵtemplate(3, _class161_ng_container_2_ng_container_2_kendo_checkbox_3_Template, 1, 1, \"kendo-checkbox\", 17);\n    i0.ɵɵtemplate(4, _class161_ng_container_2_ng_container_2_kendo_textbox_4_Template, 1, 1, \"kendo-textbox\", 18);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r24.column.editor);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"numeric\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"boolean\");\n  }\n}\nfunction _class161_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class161_ng_container_2_1_Template, 1, 2, null, 4);\n    i0.ɵɵtemplate(2, _class161_ng_container_2_ng_container_2_Template, 5, 4, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.column.editTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.column.editTemplateRef);\n  }\n}\nconst _c34 = [\"kendoGridTableBody\", \"\"];\nfunction _class163_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 8);\n  }\n}\nfunction _class163_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class163_ng_container_0_ng_container_2_td_1_Template, 1, 0, \"td\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.groups);\n  }\n}\nfunction _class163_ng_container_0_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r5.addRowLogicalIndex())(\"logicalColIndex\", 0);\n  }\n}\nfunction _class163_ng_container_0_td_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 10);\n  }\n  if (rf & 2) {\n    const column_r9 = ctx.$implicit;\n    const columnIndex_r10 = ctx.index;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"left\", column_r9.sticky ? \"0\" : undefined);\n    i0.ɵɵclassProp(\"k-grid-content-sticky\", column_r9.sticky);\n    i0.ɵɵproperty(\"rowIndex\", -1)(\"columnIndex\", ctx_r6.lockedColumnsCount + columnIndex_r10)(\"isNew\", true)(\"column\", column_r9)(\"dataItem\", ctx_r6.newDataItem)(\"ngClass\", column_r9.cssClass)(\"ngStyle\", column_r9.sticky ? ctx_r6.addStickyColumnStyles(column_r9) : column_r9.style)(\"logicalRowIndex\", ctx_r6.addRowLogicalIndex())(\"logicalColIndex\", ctx_r6.logicalColIndex(column_r9))(\"colSpan\", column_r9.colspan);\n    i0.ɵɵattribute(\"colspan\", column_r9.colspan)(\"role\", column_r9.tableCellsRole);\n  }\n}\nfunction _class163_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"tr\", 4);\n    i0.ɵɵtemplate(2, _class163_ng_container_0_ng_container_2_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(3, _class163_ng_container_0_td_3_Template, 1, 2, \"td\", 5);\n    i0.ɵɵtemplate(4, _class163_ng_container_0_td_4_Template, 1, 16, \"td\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r0.addRowLogicalIndex())(\"logicalSlaveRow\", ctx_r0.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r0.columns.length)(\"logicalSlaveCellsCount\", ctx_r0.unlockedColumnsCount())(\"totalColumns\", ctx_r0.totalColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.columns)(\"ngForTrackBy\", ctx_r0.trackByColumns);\n  }\n}\nfunction _class163_tr_1_2_ng_template_0_Template(rf, ctx) {}\nconst _c35 = function (a0) {\n  return {\n    templateRef: a0\n  };\n};\nfunction _class163_tr_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class163_tr_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c35, ctx_r11.noRecordsTemplate == null ? null : ctx_r11.noRecordsTemplate.templateRef));\n  }\n}\nfunction _class163_tr_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r12.noRecordsText, \" \");\n  }\n}\nfunction _class163_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 11)(1, \"td\", 12);\n    i0.ɵɵtemplate(2, _class163_tr_1_2_Template, 1, 3, null, 0);\n    i0.ɵɵtemplate(3, _class163_tr_1_ng_container_3_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"colspan\", ctx_r1.colSpan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef));\n  }\n}\nfunction _class163_ng_container_2_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tr\", 18);\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r20.$implicit;\n    const rowIndex_r15 = ctx_r20.index;\n    const ctx_r16 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"columns\", ctx_r16.columns)(\"groups\", ctx_r16.groups)(\"item\", item_r14)(\"hasDetails\", !!(ctx_r16.detailTemplate == null ? null : ctx_r16.detailTemplate.templateRef))(\"skipGroupDecoration\", ctx_r16.skipGroupDecoration)(\"hasGroupHeaderColumn\", ctx_r16.hasGroupHeaderColumn)(\"groupHeaderColumns\", ctx_r16.groupHeaderColumns)(\"rowIndex\", rowIndex_r15 + 1)(\"totalColumnsCount\", ctx_r16.totalColumnsCount)(\"logicalRowIndex\", ctx_r16.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r16.lockedColumnsCount > 0)(\"totalColumns\", ctx_r16.totalColumns)(\"logicalCellsCount\", ctx_r16.columns.length)(\"logicalSlaveCellsCount\", ctx_r16.groupHeaderSlaveCellsCount);\n  }\n}\nfunction _class163_ng_container_2_tr_2_ng_container_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 8);\n  }\n}\nfunction _class163_ng_container_2_tr_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_2_ng_container_1_td_1_Template, 1, 0, \"td\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r21.groups);\n  }\n}\nfunction _class163_ng_container_2_tr_2_td_2_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 23);\n    i0.ɵɵlistener(\"click\", function _class163_ng_container_2_tr_2_td_2_a_1_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const item_r14 = i0.ɵɵnextContext(3).$implicit;\n      const ctx_r27 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r27.toggleRow(item_r14.index, item_r14.data));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 24);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r14 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r26 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"title\", ctx_r26.detailButtonTitle(item_r14))(\"aria-label\", ctx_r26.detailButtonTitle(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r26.detailButtonIconName(item_r14))(\"svgIcon\", ctx_r26.detailButtonSvgIcon(item_r14));\n  }\n}\nfunction _class163_ng_container_2_tr_2_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 21);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_2_td_2_a_1_Template, 2, 4, \"a\", 22);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    const rowIndex_r15 = ctx_r31.index;\n    const item_r14 = ctx_r31.$implicit;\n    const ctx_r22 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r22.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", 0)(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"detailExpandCell\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.detailTemplate.showIf(item_r14.data, item_r14.index));\n  }\n}\nconst _c36 = function (a0, a1) {\n  return {\n    dataItem: a0,\n    index: a1\n  };\n};\nconst _c37 = function (a0, a1) {\n  return {\n    index: a0,\n    dataItem: a1\n  };\n};\nfunction _class163_ng_container_2_tr_2_ng_container_3_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 26);\n  }\n  if (rf & 2) {\n    const ctx_r35 = i0.ɵɵnextContext();\n    const column_r32 = ctx_r35.$implicit;\n    const columnIndex_r33 = ctx_r35.index;\n    const ctx_r36 = i0.ɵɵnextContext(2);\n    const item_r14 = ctx_r36.$implicit;\n    const rowIndex_r15 = ctx_r36.index;\n    const ctx_r34 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-content-sticky\", column_r32.sticky)(\"k-touch-action-none\", ctx_r34.isSelectable(i0.ɵɵpureFunction2(28, _c36, item_r14.data, item_r14.index)) && ctx_r34.selectable.drag)(\"k-grid-edit-cell\", ctx_r34.isEditingCell(item_r14.index, column_r32))(\"k-selected\", ctx_r34.isSelectable && ctx_r34.cellSelectionService.isCellSelected(item_r14, column_r32));\n    i0.ɵɵproperty(\"rowIndex\", item_r14.index)(\"columnIndex\", ctx_r34.lockedColumnsCount + columnIndex_r33)(\"column\", column_r32)(\"dataItem\", item_r14.data)(\"isLoading\", ctx_r34.isLoading)(\"isVirtual\", ctx_r34.isVirtual)(\"loadingTemplate\", ctx_r34.cellLoadingTemplate)(\"logicalRowIndex\", ctx_r34.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", ctx_r34.logicalColIndex(column_r32))(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"colIndex\", columnIndex_r33)(\"colSpan\", column_r32.colspan)(\"rowSpan\", column_r32.cellRowspan ? ctx_r34.getRowspan(i0.ɵɵpureFunction2(31, _c37, rowIndex_r15, item_r14), column_r32, ctx_r34.lockedColumnsCount + columnIndex_r33) : 1)(\"ngClass\", column_r32.cssClass)(\"ngStyle\", column_r32.sticky ? ctx_r34.addStickyColumnStyles(column_r32) : column_r32.style);\n    i0.ɵɵattribute(\"data-kendo-grid-column-index\", ctx_r34.lockedColumnsCount + columnIndex_r33)(\"role\", column_r32.tableCellsRole)(\"aria-selected\", ctx_r34.lockedColumnsCount < 1 && ctx_r34.isSelectable(i0.ɵɵpureFunction2(34, _c36, item_r14.data, item_r14.index)) ? ctx_r34.isAriaSelected(item_r14, column_r32) : undefined)(\"colspan\", column_r32.colspan);\n  }\n}\nfunction _class163_ng_container_2_tr_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_2_ng_container_3_td_1_Template, 1, 37, \"td\", 25);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r32 = ctx.$implicit;\n    const columnIndex_r33 = ctx.index;\n    const rowIndex_r15 = i0.ɵɵnextContext(2).index;\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r32.cellRowspan ? !ctx_r23.shouldSkipCell(rowIndex_r15, ctx_r23.lockedColumnsCount + columnIndex_r33) : true);\n  }\n}\nfunction _class163_ng_container_2_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 19);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_2_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(2, _class163_ng_container_2_tr_2_td_2_Template, 2, 6, \"td\", 20);\n    i0.ɵɵtemplate(3, _class163_ng_container_2_tr_2_ng_container_3_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r38 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r38.$implicit;\n    const rowIndex_r15 = ctx_r38.index;\n    const ctx_r17 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r17.isOdd(item_r14) ? \"k-table-alt-row\" : \"\");\n    i0.ɵɵclassProp(\"k-grid-row-sticky\", ctx_r17.rowSticky ? ctx_r17.rowSticky(i0.ɵɵpureFunction2(27, _c36, item_r14.data, item_r14.index)) : false)(\"k-master-row\", true)(\"k-expanded\", ctx_r17.isDataItem(item_r14) && ctx_r17.isExpanded(item_r14))(\"k-grid-edit-row\", ctx_r17.isEditingRow(item_r14.index))(\"k-selected\", ctx_r17.isSelectable(i0.ɵɵpureFunction2(30, _c36, item_r14.data, item_r14.index)) && ctx_r17.isRowSelected(item_r14));\n    i0.ɵɵproperty(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"logicalRowIndex\", ctx_r17.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r17.lockedColumnsCount > 0)(\"totalColumns\", ctx_r17.totalColumns)(\"logicalCellsCount\", ctx_r17.columns.length)(\"logicalSlaveCellsCount\", ctx_r17.unlockedColumnsCount(item_r14))(\"ngClass\", ctx_r17.rowClass(i0.ɵɵpureFunction2(33, _c36, item_r14.data, item_r14.index)));\n    i0.ɵɵattribute(\"aria-selected\", ctx_r17.lockedColumnsCount < 1 ? ctx_r17.isSelectable(i0.ɵɵpureFunction2(36, _c36, item_r14.data, item_r14.index)) && ctx_r17.isRowSelected(item_r14) : undefined)(\"data-kendo-grid-item-index\", item_r14.index);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r17.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r17.detailTemplate == null ? null : ctx_r17.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r17.columns)(\"ngForTrackBy\", ctx_r17.trackByColumns);\n  }\n}\nfunction _class163_ng_container_2_tr_3_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 32);\n  }\n}\nfunction _class163_ng_container_2_tr_3_ng_template_4_Template(rf, ctx) {}\nconst _c38 = function (a0, a1, a2) {\n  return {\n    dataItem: a0,\n    rowIndex: a1,\n    $implicit: a2\n  };\n};\nfunction _class163_ng_container_2_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 27);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_3_td_1_Template, 1, 0, \"td\", 28);\n    i0.ɵɵelement(2, \"td\", 29);\n    i0.ɵɵelementStart(3, \"td\", 30);\n    i0.ɵɵtemplate(4, _class163_ng_container_2_tr_3_ng_template_4_Template, 0, 0, \"ng-template\", 31);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r42 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r42.$implicit;\n    const rowIndex_r15 = ctx_r42.index;\n    const ctx_r18 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"logicalRowIndex\", ctx_r18.logicalRowIndex(rowIndex_r15) + 1)(\"logicalSlaveRow\", false)(\"logicalCellsCount\", 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r18.groups);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r18.logicalRowIndex(rowIndex_r15) + 1)(\"logicalColIndex\", 0)(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"colIndex\", 0)(\"colSpan\", ctx_r18.allColumnsSpan + 1);\n    i0.ɵɵattribute(\"colspan\", ctx_r18.columnsSpan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.detailTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(15, _c38, item_r14.data, item_r14.index, item_r14.data));\n  }\n}\nfunction _class163_ng_container_2_tr_4_ng_container_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 32);\n  }\n}\nfunction _class163_ng_container_2_tr_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_4_ng_container_1_td_1_Template, 1, 0, \"td\", 28);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r43 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r43.groups);\n  }\n}\nfunction _class163_ng_container_2_tr_4_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 9);\n  }\n  if (rf & 2) {\n    const rowIndex_r15 = i0.ɵɵnextContext(2).index;\n    const ctx_r44 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r44.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", 0);\n  }\n}\nfunction _class163_ng_container_2_tr_4_td_3_ng_template_1_Template(rf, ctx) {}\nconst _c39 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    templateRef: a0,\n    group: a1,\n    field: a2,\n    column: a3,\n    aggregates: a4,\n    $implicit: a5\n  };\n};\nfunction _class163_ng_container_2_tr_4_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 35);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_4_td_3_ng_template_1_Template, 0, 0, \"ng-template\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const column_r49 = ctx.$implicit;\n    const ctx_r52 = i0.ɵɵnextContext(2);\n    const rowIndex_r15 = ctx_r52.index;\n    const item_r14 = ctx_r52.$implicit;\n    const ctx_r45 = i0.ɵɵnextContext();\n    let tmp_3_0;\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r45.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", ctx_r45.logicalColIndex(column_r49));\n    i0.ɵɵattribute(\"data-skip\", ctx_r45.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction6(4, _c39, column_r49.groupFooterTemplateRef, item_r14.data, column_r49.field, column_r49, (tmp_3_0 = item_r14.data) == null ? null : tmp_3_0.aggregates, (tmp_3_0 = item_r14.data) == null ? null : tmp_3_0.aggregates));\n  }\n}\nfunction _class163_ng_container_2_tr_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 33);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_4_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(2, _class163_ng_container_2_tr_4_td_2_Template, 1, 2, \"td\", 5);\n    i0.ɵɵtemplate(3, _class163_ng_container_2_tr_4_td_3_Template, 2, 11, \"td\", 34);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r53 = i0.ɵɵnextContext();\n    const rowIndex_r15 = ctx_r53.index;\n    const item_r14 = ctx_r53.$implicit;\n    const ctx_r19 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r19.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r19.lockedColumnsCount > 0)(\"totalColumns\", ctx_r19.totalColumns)(\"logicalCellsCount\", ctx_r19.columns.length)(\"logicalSlaveCellsCount\", ctx_r19.unlockedColumnsCount(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r19.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r19.detailTemplate == null ? null : ctx_r19.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r19.footerColumns)(\"ngForTrackBy\", ctx_r19.trackByColumns);\n  }\n}\nfunction _class163_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class163_ng_container_2_tr_1_Template, 1, 14, \"tr\", 14);\n    i0.ɵɵtemplate(2, _class163_ng_container_2_tr_2_Template, 4, 39, \"tr\", 15);\n    i0.ɵɵtemplate(3, _class163_ng_container_2_tr_3_Template, 5, 19, \"tr\", 16);\n    i0.ɵɵtemplate(4, _class163_ng_container_2_tr_4_Template, 4, 9, \"tr\", 17);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r14 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isGroup(item_r14) && ctx_r2.isParentGroupExpanded(item_r14) && ctx_r2.showGroupHeader(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isDataItem(item_r14) && (!item_r14.group || ctx_r2.isDataItemInExpandedGroup(item_r14)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isDataItem(item_r14) && (!item_r14.group || ctx_r2.isDataItemInExpandedGroup(item_r14)) && (ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef) && ctx_r2.detailTemplate.showIf(item_r14.data, item_r14.index) && ctx_r2.isExpanded(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isFooter(item_r14) && item_r14.group && (ctx_r2.isFooterItemInExpandedGroup(item_r14) || ctx_r2.showGroupFooters && ctx_r2.isParentGroupExpanded(item_r14.group)) && !item_r14.data.hideFooter);\n  }\n}\nfunction _class163_kendo_resize_sensor_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r55 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 36);\n    i0.ɵɵlistener(\"resize\", function _class163_kendo_resize_sensor_3_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r55);\n      const ctx_r54 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r54.resizeHandler());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c40 = [\"kendoGridEditCommand\", \"\"];\nfunction _class164_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class164_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class164_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c41 = [\"kendoGridCancelCommand\", \"\"];\nfunction _class165_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class165_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class165_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c42 = [\"kendoGridSaveCommand\", \"\"];\nfunction _class166_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class166_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class166_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c43 = [\"kendoGridRemoveCommand\", \"\"];\nfunction _class167_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class167_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class167_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c44 = [\"kendoGridAddCommand\", \"\"];\nfunction _class168_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class168_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class168_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nfunction _class191_0_ng_template_0_Template(rf, ctx) {}\nconst _c45 = function (a0) {\n  return {\n    aggregates: a0\n  };\n};\nfunction _class191_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class191_0_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.statusBarTemplate == null ? null : ctx_r0.statusBarTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c45, ctx_r0.aggregates));\n  }\n}\nconst _c46 = [\"container\"];\nconst _c47 = [\"lockedContainer\"];\nconst _c48 = [\"lockedTable\"];\nconst _c49 = [\"table\"];\nfunction _class198_div_0_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"height\", ctx_r9.totalHeight, \"px\");\n  }\n}\nconst _c50 = function (a0, a1, a2, a3) {\n  return {\n    keydown: a0,\n    scroll: a1,\n    mousewheel: a2,\n    DOMMouseScroll: a3\n  };\n};\nfunction _class198_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11, 12)(2, \"div\", 3)(3, \"table\", 13, 14);\n    i0.ɵɵelement(5, \"colgroup\", 6)(6, \"tbody\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(7, \"kendo-resize-sensor\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(8, _class198_div_0_div_8_Template, 2, 2, \"div\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction4(30, _c50, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))(\"scope\", ctx_r0);\n    i0.ɵɵadvance(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r0.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true)(\"size\", ctx_r0.size);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"groups\", ctx_r0.groups)(\"columns\", ctx_r0.lockedLeafColumns)(\"detailTemplate\", ctx_r0.detailTemplate)(\"sort\", ctx_r0.sort);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"groups\", ctx_r0.groups)(\"isLocked\", true)(\"data\", ctx_r0.data)(\"noRecordsText\", \"\")(\"columns\", ctx_r0.lockedLeafColumns)(\"totalColumnsCount\", ctx_r0.leafColumns.length)(\"totalColumns\", ctx_r0.columns)(\"detailTemplate\", ctx_r0.detailTemplate)(\"showGroupFooters\", ctx_r0.showFooter)(\"skip\", ctx_r0.skip)(\"selectable\", ctx_r0.selectable)(\"trackBy\", ctx_r0.trackBy)(\"filterable\", ctx_r0.filterable)(\"rowClass\", ctx_r0.rowClass)(\"isLoading\", ctx_r0.loading)(\"isVirtual\", ctx_r0.isVirtual)(\"cellLoadingTemplate\", ctx_r0.cellLoadingTemplate);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isVirtual);\n  }\n}\nfunction _class198_kendo_resize_sensor_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\");\n  }\n}\nfunction _class198_kendo_resize_sensor_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\");\n  }\n}\nfunction _class198_div_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"height\", ctx_r5.totalHeight, \"px\");\n  }\n}\nfunction _class198_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r6.totalWidth, \"px\");\n  }\n}\nconst _c51 = function () {\n  return [];\n};\nfunction _class199_0_ng_template_0_Template(rf, ctx) {}\nfunction _class199_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class199_0_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.toolbarTemplateRef)(\"ngTemplateOutletContext\", ctx_r0.context);\n  }\n}\nconst _c52 = [\"lockedHeader\"];\nconst _c53 = [\"header\"];\nconst _c54 = [\"ariaRoot\"];\nconst _c55 = [\"footer\"];\nfunction _class202_kendo_grid_toolbar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-toolbar\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"size\", ctx_r0.size)(\"navigable\", ctx_r0.navigation.toolbarEnabled);\n    i0.ɵɵattribute(\"aria-label\", ctx_r0.messageFor(\"topToolbarLabel\"))(\"aria-controls\", ctx_r0.ariaRootId);\n  }\n}\nfunction _class202_kendo_pager_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r15 = i0.ɵɵreference(1);\n    const ctx_r16 = i0.ɵɵnextContext();\n    const _r12 = i0.ɵɵreference(17);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r16.pagerTemplate ? ctx_r16.pagerTemplate == null ? null : ctx_r16.pagerTemplate.templateRef : _r12)(\"ngTemplateOutletContext\", _r15.templateContext);\n  }\n}\nfunction _class202_kendo_pager_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-pager\", 16, 17);\n    i0.ɵɵlistener(\"pageChange\", function _class202_kendo_pager_4_Template_kendo_pager_pageChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r17.notifyPageChange(\"pager\", $event));\n    });\n    i0.ɵɵtemplate(2, _class202_kendo_pager_4_ng_template_2_Template, 1, 2, \"ng-template\", 18);\n    i0.ɵɵelement(3, \"kendo-pager-messages\", 19);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"navigable\", ctx_r1.navigation.pagerEnabled)(\"pageSize\", ctx_r1.pageSize)(\"total\", ctx_r1.view.total)(\"skip\", ctx_r1.skip)(\"size\", ctx_r1.size)(\"responsive\", ctx_r1.normalizedPageableSettings.responsive && !ctx_r1.pagerTemplate)(\"buttonCount\", ctx_r1.normalizedPageableSettings.buttonCount)(\"info\", ctx_r1.normalizedPageableSettings.info)(\"pageSizeValues\", ctx_r1.normalizedPageableSettings.pageSizes)(\"previousNext\", ctx_r1.normalizedPageableSettings.previousNext)(\"type\", ctx_r1.normalizedPageableSettings.type);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ariaLabel\", ctx_r1.messageFor(\"pagerLabel\"))(\"firstPage\", ctx_r1.messageFor(\"pagerFirstPage\"))(\"inputLabel\", ctx_r1.messageFor(\"pagerInputLabel\"))(\"previousPage\", ctx_r1.messageFor(\"pagerPreviousPage\"))(\"nextPage\", ctx_r1.messageFor(\"pagerNextPage\"))(\"lastPage\", ctx_r1.messageFor(\"pagerLastPage\"))(\"selectPage\", ctx_r1.messageFor(\"pagerSelectPage\"))(\"page\", ctx_r1.messageFor(\"pagerPage\"))(\"itemsPerPage\", ctx_r1.messageFor(\"pagerItemsPerPage\"))(\"items\", ctx_r1.messageFor(\"pagerItems\"))(\"of\", ctx_r1.messageFor(\"pagerOf\"))(\"pageNumberInputTitle\", ctx_r1.messageFor(\"pagerPageNumberInputTitle\"));\n  }\n}\nfunction _class202_kendo_grid_group_panel_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-grid-group-panel\", 21);\n    i0.ɵɵlistener(\"change\", function _class202_kendo_grid_group_panel_5_Template_kendo_grid_group_panel_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r19.groupChange.emit($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"navigable\", ctx_r2.navigation.toolbarEnabled)(\"text\", ctx_r2.groupableEmptyText)(\"groups\", ctx_r2.group);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.messageFor(\"groupPanelLabel\"))(\"aria-controls\", ctx_r2.ariaRootId);\n  }\n}\nfunction _class202_ng_container_8_div_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 33, 34)(2, \"table\", 35);\n    i0.ɵɵelement(3, \"colgroup\", 30)(4, \"thead\", 36);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r23.lockedWidth, \"px\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r23.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true)(\"size\", ctx_r23.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r23.lockedLeafColumns)(\"groups\", ctx_r23.group)(\"detailTemplate\", ctx_r23.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"resizable\", ctx_r23.resizable)(\"scrollable\", true)(\"columns\", ctx_r23.lockedColumns)(\"totalColumnLevels\", ctx_r23.totalColumnLevels)(\"sort\", ctx_r23.sort)(\"groups\", ctx_r23.group)(\"filter\", ctx_r23.filter)(\"filterable\", ctx_r23.filterable)(\"groupable\", ctx_r23.showGroupPanel)(\"reorderable\", ctx_r23.reorderable)(\"sortable\", ctx_r23.sortable)(\"columnMenu\", ctx_r23.columnMenuOptions)(\"columnMenuTemplate\", ctx_r23.columnMenuTemplate)(\"totalColumnsCount\", ctx_r23.leafColumns.length)(\"totalColumns\", ctx_r23.columnsContainer)(\"detailTemplate\", ctx_r23.detailTemplate)(\"tabIndex\", ctx_r23.navigation.tableEnabled ? \"-1\" : \"0\");\n  }\n}\nfunction _class202_ng_container_8_div_1_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 37);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r25.columnsContainer.unlockedWidth, \"px\");\n  }\n}\nfunction _class202_ng_container_8_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25);\n    i0.ɵɵtemplate(1, _class202_ng_container_8_div_1_div_1_Template, 5, 26, \"div\", 26);\n    i0.ɵɵelementStart(2, \"div\", 27, 28)(4, \"table\", 29);\n    i0.ɵɵelement(5, \"colgroup\", 30)(6, \"thead\", 31);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, _class202_ng_container_8_div_1_div_7_Template, 2, 2, \"div\", 32);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding\", ctx_r21.headerPadding);\n    i0.ɵɵclassProp(\"k-grid-draggable-header\", ctx_r21.groupable || ctx_r21.reorderable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r21.isLocked);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx_r21.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx_r21.lockedWidth + ctx_r21.scrollbarWidth + 2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r21.nonLockedWidth, \"px\");\n    i0.ɵɵproperty(\"virtualColumns\", ctx_r21.virtualColumns)(\"size\", ctx_r21.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r21.headerLeafColumns)(\"groups\", ctx_r21.isLocked ? i0.ɵɵpureFunction0(33, _c51) : ctx_r21.group)(\"detailTemplate\", ctx_r21.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"resizable\", ctx_r21.resizable)(\"scrollable\", true)(\"columns\", ctx_r21.headerColumns)(\"totalColumnLevels\", ctx_r21.totalColumnLevels)(\"sort\", ctx_r21.sort)(\"filter\", ctx_r21.filter)(\"filterable\", ctx_r21.filterable)(\"groupable\", ctx_r21.showGroupPanel)(\"reorderable\", ctx_r21.reorderable)(\"groups\", ctx_r21.isLocked ? i0.ɵɵpureFunction0(34, _c51) : ctx_r21.group)(\"sortable\", ctx_r21.sortable)(\"columnMenu\", ctx_r21.columnMenuOptions)(\"columnMenuTemplate\", ctx_r21.columnMenuTemplate)(\"lockedColumnsCount\", ctx_r21.lockedLeafColumns.length)(\"totalColumnsCount\", ctx_r21.leafColumns.length)(\"totalColumns\", ctx_r21.columnsContainer)(\"detailTemplate\", ctx_r21.detailTemplate)(\"tabIndex\", ctx_r21.navigation.tableEnabled ? \"-1\" : \"0\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r21.virtualColumns);\n  }\n}\nfunction _class202_ng_container_8_div_3_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 44)(1, \"table\", 45);\n    i0.ɵɵelement(2, \"colgroup\", 30)(3, \"tfoot\", 46);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r27.lockedWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r27.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true)(\"size\", ctx_r27.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r27.lockedLeafColumns)(\"groups\", ctx_r27.group)(\"detailTemplate\", ctx_r27.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"scrollable\", true)(\"groups\", ctx_r27.group)(\"columns\", ctx_r27.lockedLeafColumns)(\"detailTemplate\", ctx_r27.detailTemplate)(\"logicalRowIndex\", ctx_r27.ariaRowCount)(\"totalColumns\", ctx_r27.columnsContainer);\n  }\n}\nfunction _class202_ng_container_8_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 38);\n    i0.ɵɵtemplate(1, _class202_ng_container_8_div_3_div_1_Template, 4, 15, \"div\", 39);\n    i0.ɵɵelementStart(2, \"div\", 40, 41)(4, \"table\", 42);\n    i0.ɵɵelement(5, \"colgroup\", 30)(6, \"tfoot\", 43);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding\", ctx_r22.headerPadding);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.lockedLeafColumns.length);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx_r22.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx_r22.lockedWidth + ctx_r22.scrollbarWidth + 3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r22.nonLockedWidth, \"px\");\n    i0.ɵɵproperty(\"size\", ctx_r22.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r22.headerLeafColumns)(\"groups\", ctx_r22.isLocked ? i0.ɵɵpureFunction0(18, _c51) : ctx_r22.group)(\"detailTemplate\", ctx_r22.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r22.ariaRowCount)(\"scrollable\", true)(\"groups\", ctx_r22.isLocked ? i0.ɵɵpureFunction0(19, _c51) : ctx_r22.group)(\"columns\", ctx_r22.headerColumns)(\"lockedColumnsCount\", ctx_r22.lockedLeafColumns.length)(\"detailTemplate\", ctx_r22.detailTemplate)(\"totalColumns\", ctx_r22.columnsContainer);\n  }\n}\nfunction _class202_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class202_ng_container_8_div_1_Template, 8, 35, \"div\", 22);\n    i0.ɵɵelementStart(2, \"kendo-grid-list\", 23);\n    i0.ɵɵlistener(\"pageChange\", function _class202_ng_container_8_Template_kendo_grid_list_pageChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r29.notifyPageChange(\"list\", $event));\n    })(\"scrollBottom\", function _class202_ng_container_8_Template_kendo_grid_list_scrollBottom_2_listener() {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r31.notifyScrollBottom());\n    })(\"contentScroll\", function _class202_ng_container_8_Template_kendo_grid_list_contentScroll_2_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r32.contentScroll.emit($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class202_ng_container_8_div_3_Template, 7, 20, \"div\", 24);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.hideHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", ctx_r4.view)(\"rowHeight\", ctx_r4.rowHeight)(\"detailRowHeight\", ctx_r4.detailRowHeight)(\"total\", ctx_r4.totalCount)(\"take\", ctx_r4.pageSize)(\"groups\", ctx_r4.group)(\"groupable\", ctx_r4.groupable)(\"skip\", ctx_r4.skip)(\"trackBy\", ctx_r4.trackBy)(\"columns\", ctx_r4.columnsContainer)(\"selectable\", ctx_r4.selectable)(\"filterable\", ctx_r4.filterable)(\"detailTemplate\", ctx_r4.detailTemplate)(\"noRecordsTemplate\", ctx_r4.noRecordsTemplate)(\"size\", ctx_r4.size)(\"rowClass\", ctx_r4.rowClass)(\"rowSticky\", ctx_r4.rowSticky)(\"loading\", ctx_r4.loading)(\"isVirtual\", ctx_r4.isVirtual)(\"cellLoadingTemplate\", ctx_r4.cellLoadingTemplate == null ? null : ctx_r4.cellLoadingTemplate.templateRef)(\"loadingTemplate\", ctx_r4.loadingTemplate == null ? null : ctx_r4.loadingTemplate.templateRef)(\"virtualColumns\", ctx_r4.virtualColumns)(\"enableDrag\", ctx_r4.marqueeSelection)(\"sort\", ctx_r4.sort);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.showFooter);\n  }\n}\nfunction _class202_ng_container_9_thead_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"thead\", 52);\n  }\n  if (rf & 2) {\n    const ctx_r33 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"resizable\", ctx_r33.resizable)(\"scrollable\", false)(\"columns\", ctx_r33.visibleColumns)(\"totalColumnLevels\", ctx_r33.totalColumnLevels)(\"totalColumns\", ctx_r33.columnsContainer)(\"groups\", ctx_r33.group)(\"groupable\", ctx_r33.showGroupPanel)(\"reorderable\", ctx_r33.reorderable)(\"sort\", ctx_r33.sort)(\"sortable\", ctx_r33.sortable)(\"filter\", ctx_r33.filter)(\"filterable\", ctx_r33.filterable)(\"columnMenu\", ctx_r33.columnMenuOptions)(\"columnMenuTemplate\", ctx_r33.columnMenuTemplate)(\"detailTemplate\", ctx_r33.detailTemplate)(\"tabIndex\", ctx_r33.navigation.tableEnabled ? \"-1\" : \"0\");\n  }\n}\nfunction _class202_ng_container_9_tfoot_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tfoot\", 53);\n  }\n  if (rf & 2) {\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", false)(\"logicalRowIndex\", ctx_r34.ariaRowCount)(\"groups\", ctx_r34.group)(\"columns\", ctx_r34.leafColumns)(\"detailTemplate\", ctx_r34.detailTemplate)(\"totalColumns\", ctx_r34.columnsContainer);\n  }\n}\nfunction _class202_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"table\", 47);\n    i0.ɵɵelement(2, \"colgroup\", 48);\n    i0.ɵɵtemplate(3, _class202_ng_container_9_thead_3_Template, 1, 16, \"thead\", 49);\n    i0.ɵɵelement(4, \"tbody\", 50);\n    i0.ɵɵtemplate(5, _class202_ng_container_9_tfoot_5_Template, 1, 6, \"tfoot\", 51);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"table-layout\", ctx_r5.resizable ? \"fixed\" : null);\n    i0.ɵɵproperty(\"size\", ctx_r5.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r5.leafColumns)(\"groups\", ctx_r5.group)(\"sort\", ctx_r5.sort)(\"detailTemplate\", ctx_r5.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.hideHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"isLoading\", ctx_r5.loading)(\"groups\", ctx_r5.group)(\"data\", ctx_r5.view)(\"skip\", ctx_r5.skip)(\"columns\", ctx_r5.leafColumns)(\"selectable\", ctx_r5.selectable)(\"filterable\", ctx_r5.filterable)(\"noRecordsTemplate\", ctx_r5.noRecordsTemplate)(\"detailTemplate\", ctx_r5.detailTemplate)(\"showGroupFooters\", ctx_r5.showGroupFooters)(\"trackBy\", ctx_r5.trackBy)(\"rowClass\", ctx_r5.rowClass)(\"enableDrag\", ctx_r5.marqueeSelection);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.showFooter);\n  }\n}\nfunction _class202_div_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 54);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"loadingTemplate\", ctx_r6.loadingTemplate);\n  }\n}\nfunction _class202_kendo_grid_status_bar_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-status-bar\", 55);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"statusBarTemplate\", ctx_r7.statusBarTemplate);\n  }\n}\nfunction _class202_kendo_pager_12_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 20);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r35 = i0.ɵɵreference(1);\n    const ctx_r36 = i0.ɵɵnextContext();\n    const _r12 = i0.ɵɵreference(17);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r36.pagerTemplate ? ctx_r36.pagerTemplate == null ? null : ctx_r36.pagerTemplate.templateRef : _r12)(\"ngTemplateOutletContext\", _r35.templateContext);\n  }\n}\nfunction _class202_kendo_pager_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r38 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-pager\", 56, 57);\n    i0.ɵɵlistener(\"pageChange\", function _class202_kendo_pager_12_Template_kendo_pager_pageChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r38);\n      const ctx_r37 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r37.notifyPageChange(\"pager\", $event));\n    });\n    i0.ɵɵtemplate(2, _class202_kendo_pager_12_ng_template_2_Template, 1, 2, \"ng-template\", 18);\n    i0.ɵɵelement(3, \"kendo-pager-messages\", 19);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"navigable\", ctx_r8.navigation.pagerEnabled)(\"pageSize\", ctx_r8.pageSize)(\"total\", ctx_r8.view.total)(\"skip\", ctx_r8.skip)(\"size\", ctx_r8.size)(\"responsive\", ctx_r8.normalizedPageableSettings.responsive && !ctx_r8.pagerTemplate)(\"buttonCount\", ctx_r8.normalizedPageableSettings.buttonCount)(\"info\", ctx_r8.normalizedPageableSettings.info)(\"pageSizeValues\", ctx_r8.normalizedPageableSettings.pageSizes)(\"previousNext\", ctx_r8.normalizedPageableSettings.previousNext)(\"type\", ctx_r8.normalizedPageableSettings.type);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ariaLabel\", ctx_r8.messageFor(\"pagerLabel\"))(\"firstPage\", ctx_r8.messageFor(\"pagerFirstPage\"))(\"inputLabel\", ctx_r8.messageFor(\"pagerInputLabel\"))(\"previousPage\", ctx_r8.messageFor(\"pagerPreviousPage\"))(\"nextPage\", ctx_r8.messageFor(\"pagerNextPage\"))(\"lastPage\", ctx_r8.messageFor(\"pagerLastPage\"))(\"selectPage\", ctx_r8.messageFor(\"pagerSelectPage\"))(\"page\", ctx_r8.messageFor(\"pagerPage\"))(\"itemsPerPage\", ctx_r8.messageFor(\"pagerItemsPerPage\"))(\"items\", ctx_r8.messageFor(\"pagerItems\"))(\"of\", ctx_r8.messageFor(\"pagerOf\"))(\"pageNumberInputTitle\", ctx_r8.messageFor(\"pagerPageNumberInputTitle\"));\n  }\n}\nfunction _class202_kendo_grid_toolbar_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-toolbar\", 58);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"size\", ctx_r9.size)(\"navigable\", ctx_r9.navigation.toolbarEnabled);\n    i0.ɵɵattribute(\"aria-label\", ctx_r9.messageFor(\"bottomToolbarLabel\"))(\"aria-controls\", ctx_r9.ariaRootId);\n  }\n}\nfunction _class202_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 59);\n    i0.ɵɵtext(1);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r11.getHintSettings(\"hintIcon\"))(\"svgIcon\", ctx_r11.getHintSettings(\"hintSVGIcon\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r11.hintText, \" \");\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_prev_buttons_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-prev-buttons\", 64);\n  }\n  if (rf & 2) {\n    const ctx_r39 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"size\", ctx_r39.size);\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_numeric_buttons_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-numeric-buttons\", 65);\n  }\n  if (rf & 2) {\n    const ctx_r40 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"size\", ctx_r40.size)(\"buttonCount\", ctx_r40.normalizedPageableSettings.buttonCount);\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_input_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-input\", 64);\n  }\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"size\", ctx_r41.size);\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_next_buttons_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-next-buttons\", 64);\n  }\n  if (rf & 2) {\n    const ctx_r42 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"size\", ctx_r42.size);\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_page_sizes_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-page-sizes\", 66);\n  }\n  if (rf & 2) {\n    const ctx_r43 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"size\", ctx_r43.size)(\"pageSizes\", ctx_r43.normalizedPageableSettings.pageSizes);\n  }\n}\nfunction _class202_ng_template_16_kendo_pager_info_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-info\");\n  }\n}\nfunction _class202_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 60);\n    i0.ɵɵtemplate(1, _class202_ng_template_16_kendo_pager_prev_buttons_1_Template, 1, 1, \"kendo-pager-prev-buttons\", 61);\n    i0.ɵɵtemplate(2, _class202_ng_template_16_kendo_pager_numeric_buttons_2_Template, 1, 2, \"kendo-pager-numeric-buttons\", 62);\n    i0.ɵɵtemplate(3, _class202_ng_template_16_kendo_pager_input_3_Template, 1, 1, \"kendo-pager-input\", 61);\n    i0.ɵɵtemplate(4, _class202_ng_template_16_kendo_pager_next_buttons_4_Template, 1, 1, \"kendo-pager-next-buttons\", 61);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class202_ng_template_16_kendo_pager_page_sizes_5_Template, 1, 2, \"kendo-pager-page-sizes\", 63);\n    i0.ɵɵtemplate(6, _class202_ng_template_16_kendo_pager_info_6_Template, 1, 0, \"kendo-pager-info\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.previousNext);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.type === \"numeric\" && ctx_r13.normalizedPageableSettings.buttonCount > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.type === \"input\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.previousNext);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.pageSizes);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.normalizedPageableSettings.info);\n  }\n}\nfunction _class202_div_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 67);\n  }\n}\nconst _c224 = [[[\"kendo-toolbar\"]]];\nconst _c225 = function (a0) {\n  return {\n    hintTemplate: a0\n  };\n};\nconst _c226 = [\"kendo-toolbar\"];\nconst append = element => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  let appended = false;\n  return () => {\n    if (!appended) {\n      document.body.appendChild(element);\n      appended = true;\n    }\n    return element;\n  };\n};\n/**\n * @hidden\n */\nconst getDocument$1 = element => element.ownerDocument.documentElement;\n/**\n * @hidden\n */\nconst getWindow$1 = element => element.ownerDocument.defaultView;\n/**\n * @hidden\n */\nconst offset = element => {\n  const {\n    clientTop,\n    clientLeft\n  } = getDocument$1(element);\n  const {\n    pageYOffset,\n    pageXOffset\n  } = getWindow$1(element);\n  const {\n    top,\n    left\n  } = element.getBoundingClientRect();\n  return {\n    top: top + pageYOffset - clientTop,\n    left: left + pageXOffset - clientLeft\n  };\n};\n/**\n * @hidden\n * If the target is before the draggable element, returns `true`.\n *\n * DOCUMENT_POSITION_FOLLOWING = 4\n */\nconst isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;\n/**\n * @hidden\n * If the container and the element are the same\n * or if the container holds (contains) the element, returns `true`.\n *\n * DOCUMENT_POSITION_CONTAINED_BY = 16\n */\nconst contains$2 = (element, container) => element === container || (container.compareDocumentPosition(element) & 16) !== 0;\n/**\n * @hidden\n */\nconst position = (target, before) => {\n  const targetRect = offset(target);\n  const {\n    offsetWidth,\n    offsetHeight\n  } = target;\n  const left = targetRect.left + (before ? 0 : offsetWidth);\n  const top = targetRect.top;\n  const height = offsetHeight;\n  return {\n    left,\n    top,\n    height\n  };\n};\n\n/**\n * @hidden\n */\nlet DragAndDropService = /*#__PURE__*/(() => {\n  var _class;\n  class DragAndDropService {\n    constructor() {\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"register\", []);\n      _defineProperty(this, \"lastTarget\", null);\n    }\n    add(target) {\n      this.register.push(target);\n    }\n    remove(target) {\n      this.register = this.register.filter(current => current !== target);\n    }\n    notifyDrag(draggable, element, mouseEvent) {\n      const target = this.targetFor(element);\n      if (this.lastTarget === target) {\n        return;\n      }\n      this.changes.next({\n        draggable,\n        mouseEvent,\n        target: this.lastTarget,\n        type: 'leave'\n      });\n      if (target) {\n        this.changes.next({\n          draggable,\n          mouseEvent,\n          target,\n          type: 'enter'\n        });\n      }\n      this.lastTarget = target;\n    }\n    notifyDrop(draggable, mouseEvent) {\n      const target = draggable && draggable.element && this.targetFor(draggable.element.nativeElement);\n      if (target && this.lastTarget === target) {\n        this.lastTarget = null;\n        return;\n      }\n      this.changes.next({\n        draggable,\n        mouseEvent,\n        target: this.lastTarget,\n        type: 'drop'\n      });\n      this.lastTarget = null;\n    }\n    targetFor(element) {\n      const comparer = contains$2.bind(null, element);\n      return this.register.find(({\n        element: {\n          nativeElement\n        }\n      }) => comparer(nativeElement));\n    }\n  }\n  _class = DragAndDropService;\n  _defineProperty(DragAndDropService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)();\n  });\n  _defineProperty(DragAndDropService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return DragAndDropService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst updateClass = (element, valid, svg) => {\n  const icon = element.querySelector('.k-icon');\n  if (svg) {\n    const svg = icon.firstElementChild;\n    svg.removeChild(svg.firstElementChild);\n    const path = valid ? plusIcon.content : cancelIcon.content;\n    icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;\n  }\n  icon.setAttribute('class', icon.getAttribute('class').replace(/(plus|cancel)/, valid ? 'plus' : 'cancel'));\n};\nconst updateLock = (element, locked = null, svg) => {\n  const icon = element.querySelectorAll('.k-icon')[1];\n  const value = locked === null ? '' : locked ? `k${svg ? '-svg' : ''}-i-lock` : `k${svg ? '-svg' : ''}-i-unlock`;\n  if (svg) {\n    icon.setAttribute('class', icon.getAttribute('class').replace(/(k-svg-i-unlock|k-svg-i-lock)/, '').trim() + ` ${value}`);\n    icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;\n  } else {\n    icon.setAttribute('class', icon.getAttribute('class').replace(/(k-i-unlock|k-i-lock)/, '').trim() + ` ${value}`);\n  }\n};\nconst decorate = element => {\n  element.className = 'k-header k-drag-clue';\n  element.style.position = 'absolute';\n  element.style.zIndex = '20000';\n};\nconst svgIconsMarkup = (viewBox, content, safeTitle) => `\n    <span class=\"k-icon k-svg-icon k-drag-status k-svg-i-cancel\">\n        <svg \n            xmlns=\"http://www.w3.org/2000/svg\"\n            xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n            viewBox=\"${viewBox}\"\n            aria-hidden=\"true\">\n            ${content}\n        </svg>\n        <span class=\"k-icon k-svg-icon k-icon-modifier\">\n            <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                viewBox=\"${viewBox}\"\n                aria-hidden=\"true\">\n            </svg>\n        </span>\n    </span>\n    ${safeTitle}`;\nconst fontIconsMarkup = safeTitle => `\n    <span class=\"k-icon k-font-icon k-drag-status k-i-cancel\">\n        <span class=\"k-icon k-font-icon k-icon-modifier\"></span>\n    </span>\n    ${safeTitle}`;\n/**\n * @hidden\n */\nlet DragHintService = /*#__PURE__*/(() => {\n  var _class2;\n  class DragHintService {\n    constructor(santizer, iconsService) {\n      _defineProperty(this, \"santizer\", void 0);\n      _defineProperty(this, \"iconsService\", void 0);\n      _defineProperty(this, \"dom\", void 0);\n      _defineProperty(this, \"cancelIcon\", cancelIcon);\n      this.santizer = santizer;\n      this.iconsService = iconsService;\n    }\n    create(title) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.dom = document.createElement(\"div\");\n      decorate(this.dom);\n      const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);\n      const innerHtml = this.isSVG ? svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) : fontIconsMarkup(safeTitle);\n      this.dom.innerHTML = innerHtml;\n    }\n    attach() {\n      return append(this.dom);\n    }\n    remove() {\n      if (this.dom && this.dom.parentNode) {\n        (function (el) {\n          setTimeout(() => document.body.removeChild(el));\n        })(this.dom); // hack for IE + pointer events!\n        this.dom = null;\n      }\n    }\n    show() {\n      this.dom.style.display = \"\";\n    }\n    hide() {\n      this.dom.style.display = \"none\";\n    }\n    enable() {\n      updateClass(this.dom, true, this.isSVG);\n    }\n    disable() {\n      updateClass(this.dom, false, this.isSVG);\n    }\n    removeLock() {\n      updateLock(this.dom, false, this.isSVG);\n    }\n    toggleLock(locked) {\n      updateLock(this.dom, locked, this.isSVG);\n    }\n    move(move) {\n      this.dom.style.top = move.pageY + 'px';\n      this.dom.style.left = move.pageX + 'px';\n    }\n    get isSVG() {\n      return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === 'svg';\n    }\n  }\n  _class2 = DragHintService;\n  _defineProperty(DragHintService, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i1$1.IconsService));\n  });\n  _defineProperty(DragHintService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return DragHintService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DropCueService = /*#__PURE__*/(() => {\n  var _class3;\n  class DropCueService {\n    constructor() {\n      _defineProperty(this, \"dom\", void 0);\n    }\n    create() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.dom = document.createElement(\"div\");\n      this.dom.className = 'k-grouping-dropclue';\n      this.hide();\n    }\n    attach() {\n      return append(this.dom);\n    }\n    remove() {\n      if (this.dom && this.dom.parentElement) {\n        document.body.removeChild(this.dom);\n        this.dom = null;\n      }\n    }\n    hide() {\n      this.dom.style.display = \"none\";\n    }\n    position({\n      left,\n      top,\n      height\n    }) {\n      this.dom.style.display = 'block';\n      this.dom.style.height = height + 'px';\n      this.dom.style.top = top + 'px';\n      const width = this.dom.offsetWidth / 2;\n      this.dom.style.left = left - width + 'px';\n    }\n  }\n  _class3 = DropCueService;\n  _defineProperty(DropCueService, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)();\n  });\n  _defineProperty(DropCueService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  }));\n  return DropCueService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EMPTY_REGEX = /^\\s*$/;\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isBlank = value => value === null || value === undefined;\n/**\n * @hidden\n */\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\nconst isTruthy = value => !!value;\n/**\n * @hidden\n */\nconst isNullOrEmptyString = value => isBlank(value) || EMPTY_REGEX.test(value);\n/**\n * @hidden\n */\nconst observe = list => merge(of(list), list.changes);\n/**\n * @hidden\n */\nconst isUniversal = () => typeof document === 'undefined';\n/**\n * @hidden\n */\nconst isString = value => typeof value === 'string';\n/**\n * @hidden\n */\nconst isNumber = value => typeof value === \"number\" && !isNaN(value);\n/**\n * @hidden\n */\nconst extractFormat = format => {\n  if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {\n    return format.slice(3, format.length - 1);\n  }\n  return format;\n};\n/**\n * @hidden\n */\nconst not = fn => (...args) => !fn(...args);\n/**\n * @hidden\n */\nconst or = (...conditions) => value => conditions.reduce((acc, x) => acc || x(value), false);\n/**\n * @hidden\n */\nconst and = (...conditions) => value => conditions.reduce((acc, x) => acc && x(value), true);\n/**\n * @hidden\n */\nconst Skip = new InjectionToken(\"Skip\");\n/**\n * @hidden\n */\nconst createPromise = () => {\n  let resolveFn, rejectFn;\n  const promise = new Promise((resolve, reject) => {\n    resolveFn = data => {\n      resolve(data);\n      return promise;\n    };\n    rejectFn = data => {\n      reject(data);\n      return promise;\n    };\n  });\n  promise.resolve = resolveFn;\n  promise.reject = rejectFn;\n  return promise;\n};\n/** @hidden */\nconst iterator = getIterator$1();\n// TODO: Move to kendo-common\nfunction getIterator$1() {\n  if (typeof Symbol === 'function' && Symbol.iterator) {\n    return Symbol.iterator;\n  }\n  const keys = Object.getOwnPropertyNames(Map.prototype);\n  const proto = Map.prototype;\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {\n      return key;\n    }\n  }\n}\nconst FRAME_DURATION = 1000 / 60;\nconst wnd = typeof window !== 'undefined' ? window : {};\n/** @hidden */\nconst requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));\n/** @hidden */\nconst cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;\n/**\n * @hidden\n */\nconst detectIE = () => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf('MSIE ');\n  const trident = ua.indexOf('Trident/');\n  return msie > 0 || trident > 0;\n};\n/**\n * @hidden\n */\nconst nodesToArray = nodes => [].slice.call(nodes);\n/**\n * @hidden\n */\nconst replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\\{\\\\s*${name}\\\\s*\\}`, 'g'), value);\n/**\n * @hidden\n */\nconst recursiveFlatMap = item => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [{\n  ...item\n}];\n/**\n * @hidden\n */\nconst isGroupResult = obj => {\n  return 'aggregates' in obj && 'items' in obj && 'field' in obj && 'value' in obj;\n};\n/**\n * @hidden\n */\nconst roundDown = value => Math.floor(value * 100) / 100;\n\n/**\n * @hidden\n */\nconst FOCUS_ROOT_ACTIVE = new InjectionToken('focus-root-initial-active-state');\n/**\n * @hidden\n */\nlet FocusRoot = /*#__PURE__*/(() => {\n  var _class4;\n  class FocusRoot {\n    constructor(active = false) {\n      _defineProperty(this, \"active\", void 0);\n      _defineProperty(this, \"groups\", new Set());\n      this.active = active;\n    }\n    registerGroup(group) {\n      if (this.active) {\n        this.groups.add(group);\n      }\n    }\n    unregisterGroup(group) {\n      if (this.active) {\n        this.groups.delete(group);\n      }\n    }\n    activate() {\n      if (this.active) {\n        this.groups.forEach(f => f.activate());\n      }\n    }\n    deactivate() {\n      if (this.active) {\n        this.groups.forEach(f => f.deactivate());\n      }\n    }\n  }\n  _class4 = FocusRoot;\n  _defineProperty(FocusRoot, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵinject(FOCUS_ROOT_ACTIVE, 8));\n  });\n  _defineProperty(FocusRoot, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac\n  }));\n  return FocusRoot;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\nconst NODE_NAME_PREDICATES = {};\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\nconst matchesClasses = classNames => element => hasClasses(element, classNames);\n/**\n * @hidden\n */\nconst matchesNodeName = nodeName => {\n  if (!NODE_NAME_PREDICATES[nodeName]) {\n    NODE_NAME_PREDICATES[nodeName] = element => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n  }\n  return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n  return node;\n};\n/**\n * @hidden\n */\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n  if (node !== scope) {\n    return node;\n  }\n};\n/**\n * @hidden\n */\nconst contains$1 = (parent, node, matchSelf = false) => {\n  const outside = !closest(node, child => child === parent);\n  if (outside) {\n    return false;\n  }\n  const el = closest(node, child => child === node);\n  return el && (matchSelf || el !== parent);\n};\n/**\n * @hidden\n */\nconst isVisible = element => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0;\n  // Elements can have zero size due to styling, but they will still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\nconst isFocusable = element => {\n  if (!element.tagName) {\n    return false;\n  }\n  const tagName = element.tagName.toLowerCase();\n  const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n  const focusable = !element.disabled && focusableRegex.test(tagName);\n  return focusable || hasTabIndex;\n};\n/**\n * @hidden\n */\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n  if (!isFocusable(element)) {\n    return false;\n  }\n  const visible = !checkVisibility || isVisible(element);\n  const ariaHidden = element.getAttribute('aria-hidden') === 'true';\n  const tabIndex = element.getAttribute('tabIndex');\n  return visible && !ariaHidden && tabIndex !== '-1';\n};\n/**\n * @hidden\n */\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n  node = node.firstChild;\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n      if (element) {\n        return element;\n      }\n    }\n    node = node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\nconst findLastElement = (node, predicate, matchSelf = true) => {\n  let last = null;\n  findElement(node, node => {\n    if (predicate(node)) {\n      last = node;\n    }\n    return false;\n  }, matchSelf);\n  return last;\n};\n/**\n * @hidden\n */\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility));\n};\n/**\n * @hidden\n */\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\nconst findLastFocusableChild = (element, checkVisibility = true) => {\n  return findLastElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\nfunction rtlScrollPosition(position, element, initial) {\n  let result = position;\n  if (initial < 0) {\n    result = -position;\n  } else if (initial > 0) {\n    result = element.scrollWidth - element.offsetWidth - position;\n  }\n  return result;\n}\nconst isButton = matchesNodeName('button');\nconst isInputTag = matchesNodeName('input');\nconst isKendoInputTag = matchesNodeName('kendo-checkbox') || matchesNodeName('kendo-textbox');\nconst navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;\nconst isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);\nconst isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element) || isKendoInputTag(element));\n/**\n * @hidden\n */\nclass DefaultFocusableElement {\n  get enabled() {\n    return this.focusable && !this.focusable.disabled;\n  }\n  get visible() {\n    return this.focusable && isVisible(this.focusable);\n  }\n  constructor(host, renderer) {\n    _defineProperty(this, \"renderer\", void 0);\n    _defineProperty(this, \"element\", void 0);\n    _defineProperty(this, \"focusable\", void 0);\n    this.renderer = renderer;\n    this.element = host.nativeElement;\n    this.focusable = findFocusable(this.element, false) || this.element;\n  }\n  isNavigable() {\n    return this.canFocus() && isNavigable(this.element);\n  }\n  toggle(active) {\n    this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');\n  }\n  focus() {\n    if (this.focusable) {\n      this.focusable.focus();\n    }\n  }\n  canFocus() {\n    return this.visible && this.enabled;\n  }\n  hasFocus() {\n    return isDocumentAvailable() && document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);\n  }\n}\n\n/**\n * @hidden\n */\nconst CELL_CONTEXT = new InjectionToken('grid-cell-context');\n/**\n * @hidden\n */\nconst EMPTY_CELL_CONTEXT = {};\n\n/**\n * @hidden\n */\nlet GridToolbarNavigationService = /*#__PURE__*/(() => {\n  var _class6;\n  class GridToolbarNavigationService {\n    constructor(renderer) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"navigableElements\", []);\n      _defineProperty(this, \"currentActiveIndex\", 0);\n      _defineProperty(this, \"defaultFocusableSelector\", `\n        [kendogridtoolbarfocusable],\n        [kendogridaddcommand],\n        [kendogridcancelcommand],\n        [kendogrideditcommand],\n        [kendogridremovecommand],\n        [kendogridsavecommand],\n        [kendogridexcelcommand],\n        [kendogridpdfcommand]\n    `);\n      this.renderer = renderer;\n    }\n    notify() {\n      // ensure focusable elements are in the same order as in the DOM\n      this.navigableElements = this.navigableElements.length && this.navigableElements[0]?.parentElement ? Array.from(this.navigableElements[0]?.parentElement?.querySelectorAll(this.defaultFocusableSelector) || []) : [];\n      this.currentActiveIndex = 0;\n      this.updateFocus();\n    }\n    focus() {\n      this.navigableElements[this.currentActiveIndex]?.focus();\n    }\n    updateFocus() {\n      if (!this.navigableElements.length) {\n        return;\n      }\n      this.navigableElements.forEach(el => {\n        this.renderer.setAttribute(el, 'tabindex', '-1');\n      });\n      this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], 'tabindex', '0');\n      if (isDocumentAvailable() && document.activeElement.closest('.k-toolbar')) {\n        this.navigableElements[this.currentActiveIndex].focus();\n      }\n    }\n  }\n  _class6 = GridToolbarNavigationService;\n  _defineProperty(GridToolbarNavigationService, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵinject(i0.Renderer2));\n  });\n  _defineProperty(GridToolbarNavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  }));\n  return GridToolbarNavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * The Context service is used to provide common\n * services and DI tokens for a Grid instance.\n *\n * This keeps the constructor parameters stable\n * and a avoids dependency cycles between components.\n */\nlet ContextService = /*#__PURE__*/(() => {\n  var _class7;\n  class ContextService {\n    constructor(renderer, localization) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"topToolbarNavigation\", void 0);\n      _defineProperty(this, \"bottomToolbarNavigation\", void 0);\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"groupBindingDirective\", void 0);\n      this.renderer = renderer;\n      this.localization = localization;\n      this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);\n      this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);\n    }\n  }\n  _class7 = ContextService;\n  _defineProperty(ContextService, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i1$2.LocalizationService));\n  });\n  _defineProperty(ContextService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac\n  }));\n  return ContextService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive that controls the way focusable elements receive\n * [focus in a navigable Grid]({% slug keyboard_navigation_grid %}).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [navigable]=\"true\">\n *    <kendo-grid-column>\n *       <ng-template kendoGridCellTemplate let-dataItem>\n *          <!-- The first focusable element will be focused when pressing Enter on the cell -->\n *          <input type=\"text\" kendoGridFocusable [value]=\"dataItem.ProductName\" style=\"margin-right: 8px;\" />\n *          <button kendoGridFocusable>Update</button>\n *       </ng-template>\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet FocusableDirective = /*#__PURE__*/(() => {\n  var _class8;\n  class FocusableDirective {\n    /**\n     * @hidden\n     */\n    set enabled(value) {\n      if (value === '') {\n        value = true;\n      } else {\n        value = Boolean(value);\n      }\n      if (value !== this.enabled) {\n        this._enabled = value;\n        if (this.element) {\n          this.element.toggle(this.active && value);\n        }\n      }\n    }\n    get enabled() {\n      return this._enabled;\n    }\n    constructor(cellContext, hostElement, renderer, ctx) {\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"active\", true);\n      _defineProperty(this, \"group\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"_enabled\", true);\n      this.cellContext = cellContext;\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.ctx = ctx;\n      if (this.cellContext) {\n        this.group = this.cellContext.focusGroup;\n      }\n      if (this.group) {\n        this.group.registerElement(this);\n      }\n    }\n    ngAfterViewInit() {\n      if (!this.element && this.ctx.navigable) {\n        this.element = new DefaultFocusableElement(this.hostElement, this.renderer);\n      }\n      if (this.group && this.element) {\n        this.toggle(this.group.isActive);\n      }\n    }\n    ngOnDestroy() {\n      if (this.group) {\n        this.group.unregisterElement(this);\n      }\n    }\n    /**\n     * @hidden\n     */\n    toggle(active) {\n      if (this.element && active !== this.active) {\n        this.element.toggle(this.enabled && active);\n        this.active = active;\n      }\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n      return this.enabled && this.element && this.element.canFocus();\n    }\n    /**\n     * @hidden\n     */\n    isNavigable() {\n      return this.enabled && this.element && this.element.isNavigable();\n    }\n    /**\n     * @hidden\n     */\n    focus() {\n      if (this.enabled && this.element) {\n        this.element.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    hasFocus() {\n      return this.enabled && this.element && this.element.hasFocus();\n    }\n    /**\n     * @hidden\n     */\n    registerElement(element) {\n      this.element = element;\n    }\n  }\n  _class8 = FocusableDirective;\n  _defineProperty(FocusableDirective, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵdirectiveInject(CELL_CONTEXT, 12), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(FocusableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class8,\n    selectors: [[\"\", \"kendoGridFocusable\", \"\"], [\"\", \"kendoGridEditCommand\", \"\"], [\"\", \"kendoGridRemoveCommand\", \"\"], [\"\", \"kendoGridSaveCommand\", \"\"], [\"\", \"kendoGridCancelCommand\", \"\"], [\"\", \"kendoGridSelectionCheckbox\", \"\"]],\n    inputs: {\n      enabled: [\"kendoGridFocusable\", \"enabled\"]\n    },\n    standalone: true\n  }));\n  return FocusableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass GridFocusableElement {\n  constructor(navigationService) {\n    _defineProperty(this, \"navigationService\", void 0);\n    this.navigationService = navigationService;\n  }\n  focus() {\n    this.navigationService.focusCell();\n  }\n  toggle(active) {\n    this.navigationService.toggle(active);\n  }\n  canFocus() {\n    return true;\n  }\n  hasFocus() {\n    return this.navigationService.hasFocus();\n  }\n  isNavigable() {\n    return false;\n  }\n}\n\n/**\n * @hidden\n */\nclass NavigationCursor {\n  set metadata(value) {\n    this._metadata = value;\n    if (isPresent(value)) {\n      const newActiveCol = value.hasDetailTemplate ? 1 : 0;\n      const shouldChange = this.activeRow < value.headerRows && this.activeCol === 0;\n      if (shouldChange && newActiveCol !== this.activeCol) {\n        this.activeCol = newActiveCol;\n        this.reset();\n      }\n    }\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  get row() {\n    return this.model.findRow(this.activeRow);\n  }\n  get cell() {\n    const row = this.row;\n    if (row) {\n      return this.model.findCell(this.activeCol, row);\n    }\n  }\n  get dataRowIndex() {\n    const row = this.row;\n    if (row) {\n      return row.dataRowIndex;\n    }\n    return -1;\n  }\n  constructor(model) {\n    _defineProperty(this, \"model\", void 0);\n    _defineProperty(this, \"changes\", new Subject());\n    _defineProperty(this, \"activeRow\", 0);\n    _defineProperty(this, \"activeCol\", 0);\n    _defineProperty(this, \"virtualCol\", 0);\n    _defineProperty(this, \"virtualRow\", 0);\n    _defineProperty(this, \"_metadata\", void 0);\n    this.model = model;\n  }\n  /**\n   * Assumes and announces a new cursor position.\n   */\n  reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {\n    if (this.activate(rowIndex, colIndex, force)) {\n      this.virtualRow = rowIndex;\n      this.virtualCol = colIndex;\n    }\n  }\n  activate(rowIndex, colIndex, force) {\n    if (!force && this.isActiveRange(rowIndex, colIndex)) {\n      return false;\n    }\n    const prevColIndex = this.activeCol;\n    const prevRowIndex = this.activeRow;\n    this.activeCol = colIndex;\n    this.activeRow = rowIndex;\n    this.changes.next({\n      colIndex,\n      prevColIndex,\n      prevRowIndex,\n      rowIndex\n    });\n    return true;\n  }\n  isActiveRange(rowIndex, colIndex) {\n    if (this.activeRow !== rowIndex) {\n      return false;\n    }\n    const cell = this.cell;\n    const {\n      start,\n      end\n    } = this.model.cellRange(cell);\n    return !cell || start <= colIndex && colIndex <= end;\n  }\n  /**\n   * Assumes a new cursor position without announcing it.\n   */\n  assume(rowIndex = this.activeRow, colIndex = this.activeCol) {\n    this.virtualRow = rowIndex;\n    this.virtualCol = colIndex;\n    this.activeCol = colIndex;\n    this.activeRow = rowIndex;\n  }\n  /**\n   * Announces a current cursor position to subscribers.\n   */\n  announce() {\n    this.changes.next({\n      colIndex: this.activeCol,\n      prevColIndex: this.activeCol,\n      prevRowIndex: this.activeRow,\n      rowIndex: this.activeRow\n    });\n  }\n  activateVirtualCell(cell) {\n    const rowRange = this.model.rowRange(cell);\n    const cellRange = this.model.cellRange(cell);\n    const activeCol = this.activeCol;\n    const activeRow = this.activeRow;\n    if (rowRange.start <= activeRow && activeRow <= rowRange.end && cellRange.start <= activeCol && activeCol <= cellRange.end) {\n      this.activeRow = cell.rowIndex;\n      this.activeCol = cell.colIndex;\n      return true;\n    }\n  }\n  isActive(rowIndex, colIndex) {\n    return this.activeCol === colIndex && this.activeRow === rowIndex;\n  }\n  moveUp(offset = 1) {\n    return this.offsetRow(-offset);\n  }\n  moveDown(offset = 1) {\n    return this.offsetRow(offset);\n  }\n  moveLeft(offset = 1) {\n    return this.offsetCol(-offset);\n  }\n  moveRight(offset = 1) {\n    return this.offsetCol(offset);\n  }\n  lastCellIndex(row) {\n    return this.metadata.columns.leafColumnsToRender.length - 1 + (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);\n  }\n  offsetCol(offset) {\n    const prevRow = this.model.findRow(this.virtualRow);\n    const lastIndex = this.lastCellIndex(prevRow);\n    const virtualCol = this.virtualCol;\n    this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));\n    let nextColIndex = this.virtualCol;\n    const nextRowIndex = this.virtualRow;\n    let cell = this.model.findCell(this.virtualCol, prevRow);\n    if (!cell && this.metadata.virtualColumns) {\n      return this.activate(nextRowIndex, nextColIndex);\n    }\n    if (!cell && this.metadata.hasDetailTemplate) {\n      this.virtualCol += 1;\n      return false;\n    }\n    if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {\n      nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);\n      const nextCell = this.model.findCell(nextColIndex, prevRow);\n      if (!nextCell) {\n        this.virtualCol = nextColIndex;\n        return this.activate(cell.rowIndex, nextColIndex);\n      }\n      if (cell !== nextCell) {\n        cell = nextCell;\n        this.virtualCol = cell.colIndex;\n      } else {\n        this.virtualCol = virtualCol;\n      }\n      return this.activate(cell.rowIndex, this.virtualCol);\n    }\n    this.virtualCol = cell.colIndex;\n    return this.activate(cell.rowIndex, cell.colIndex);\n  }\n  offsetRow(offset) {\n    let nextColIndex = this.virtualCol;\n    if (this.metadata && this.metadata.isVirtual) {\n      const maxIndex = this.metadata.maxLogicalRowIndex;\n      let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));\n      if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {\n        nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;\n        nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));\n      }\n      if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {\n        if (this.model.lastRow.index !== maxIndex) {\n          // Don't attempt to navigate past the last collapsed row.\n          nextIndex--;\n        }\n      }\n      const nextRow = this.model.findRow(nextIndex);\n      if (nextRow) {\n        // remove duplication\n        let cell = this.model.findCell(this.virtualCol, nextRow);\n        if (!cell) {\n          return;\n        }\n        if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {\n          cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));\n          if (!cell) {\n            return;\n          }\n        }\n        nextIndex = cell.rowIndex;\n        nextColIndex = cell.colIndex;\n      }\n      this.virtualRow = nextIndex;\n      return this.activate(nextIndex, nextColIndex);\n    }\n    const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);\n    if (!nextRow) {\n      return false;\n    }\n    let cell = this.model.findCell(this.virtualCol, nextRow);\n    if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {\n      // spanned cell go to next\n      const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;\n      cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));\n    }\n    if (!cell && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {\n      return this.activate(this.virtualRow + offset, this.virtualCol);\n    }\n    this.virtualRow = cell.rowIndex;\n    return this.activate(this.virtualRow, cell.colIndex);\n  }\n}\n\n/**\n * @hidden\n */\nclass ItemMap {\n  constructor() {\n    _defineProperty(this, \"count\", 0);\n    _defineProperty(this, \"items\", {});\n  }\n  get first() {\n    if (this.count > 0) {\n      let result;\n      this.forEach(item => {\n        result = item;\n        return true;\n      });\n      return result;\n    }\n  }\n  get last() {\n    if (this.count > 0) {\n      const keys = Object.keys(this.items);\n      return this.items[keys[keys.length - 1]];\n    }\n  }\n  removeItem(key) {\n    if (this.items[key]) {\n      delete this.items[key];\n      this.count--;\n    }\n  }\n  setItem(key, item) {\n    if (!this.items[key]) {\n      this.count++;\n    }\n    this.items[key] = item;\n  }\n  getItem(key) {\n    return this.items[key];\n  }\n  toArray() {\n    const result = [];\n    this.forEach(item => {\n      result.push(item);\n    });\n    return result;\n  }\n  forEach(callback) {\n    for (const key in this.items) {\n      if (this.items.hasOwnProperty(key) && callback(this.items[key])) {\n        return this.items[key];\n      }\n    }\n  }\n  find(callback) {\n    return this.forEach(callback);\n  }\n}\n\n/**\n * @hidden\n *\n * Contains information for the currently rendered rows and cells.\n */\nclass NavigationModel {\n  constructor() {\n    _defineProperty(this, \"rows\", new ItemMap());\n  }\n  get firstRow() {\n    return this.rows.first;\n  }\n  get lastRow() {\n    return this.rows.last;\n  }\n  registerCell(cell) {\n    const row = this.rows.getItem(cell.logicalRowIndex);\n    if (!row) {\n      return;\n    }\n    const colIndex = cell.logicalColIndex;\n    const modelCell = {\n      uid: cell.uid,\n      colIndex,\n      rowIndex: row.index,\n      colSpan: cell.colSpan,\n      rowSpan: cell.rowSpan,\n      detailExpandCell: cell.detailExpandCell,\n      dataItem: row.dataItem,\n      dataRowIndex: row.dataRowIndex,\n      focusGroup: cell.focusGroup\n    };\n    row.cells.setItem(colIndex, modelCell);\n    if (cell.groupItem) {\n      row.groupItem = cell.groupItem;\n    }\n    return modelCell;\n  }\n  unregisterCell(index, rowIndex, cell) {\n    const row = this.rows.getItem(rowIndex);\n    if (row) {\n      const match = row.cells.getItem(index);\n      if (match && match.uid === cell.uid) {\n        row.cells.removeItem(index);\n      }\n    }\n  }\n  registerRow(row) {\n    const modelRow = {\n      uid: row.uid,\n      index: row.logicalRowIndex,\n      dataItem: row.dataItem,\n      dataRowIndex: row.dataRowIndex,\n      cells: new ItemMap()\n    };\n    this.rows.setItem(row.logicalRowIndex, modelRow);\n  }\n  updateRow(row) {\n    const current = this.rows.getItem(row.logicalRowIndex);\n    if (current) {\n      Object.assign(current, {\n        dataItem: row.dataItem,\n        dataRowIndex: row.dataRowIndex\n      });\n    }\n  }\n  unregisterRow(index, row) {\n    const match = this.rows.getItem(index);\n    if (match && match.uid === row.uid) {\n      this.rows.removeItem(index);\n    }\n  }\n  cellRange(cell) {\n    if (cell) {\n      const start = cell.colIndex;\n      const end = cell.colIndex + (cell.colSpan || 1) - 1;\n      return {\n        start,\n        end\n      };\n    }\n    return {};\n  }\n  rowRange(cell) {\n    if (cell) {\n      const start = cell.rowIndex;\n      const end = cell.rowIndex + (cell.rowSpan || 1) - 1;\n      return {\n        start,\n        end\n      };\n    }\n    return {};\n  }\n  nextRow(rowIndex, offset) {\n    const rows = this.rows.toArray();\n    const row = this.rows.getItem(rowIndex);\n    const position = rows.indexOf(row);\n    const next = rows[position + offset];\n    return next;\n  }\n  findRow(index) {\n    return this.rows.getItem(index);\n  }\n  findCell(index, row) {\n    if (!row) {\n      return;\n    }\n    const rowIndex = row.index;\n    let cell = row.cells.getItem(index);\n    let currentIndex = rowIndex;\n    while (!cell && row) {\n      row = this.rows.getItem(currentIndex);\n      cell = this.rowCell(index, row);\n      currentIndex--;\n    }\n    if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {\n      return cell;\n    }\n  }\n  rowCell(index, row) {\n    if (!row || !row.cells.count) {\n      return;\n    }\n    const firstCell = row.cells.first;\n    let cell,\n      currentIndex = index;\n    while (!cell && currentIndex >= firstCell.colIndex) {\n      cell = row.cells.getItem(currentIndex);\n      currentIndex--;\n    }\n    if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {\n      return cell;\n    }\n  }\n}\n\n/**\n * @hidden\n */\nlet DomEventsService = /*#__PURE__*/(() => {\n  var _class13;\n  class DomEventsService {\n    constructor() {\n      _defineProperty(this, \"cellClick\", new EventEmitter());\n      _defineProperty(this, \"cellMousedown\", new EventEmitter());\n      _defineProperty(this, \"cellMouseup\", new EventEmitter());\n      _defineProperty(this, \"click\", new EventEmitter());\n      _defineProperty(this, \"keydown\", new EventEmitter());\n      _defineProperty(this, \"focus\", new EventEmitter());\n      _defineProperty(this, \"focusIn\", new EventEmitter());\n      _defineProperty(this, \"focusOut\", new EventEmitter());\n      _defineProperty(this, \"windowBlur\", new EventEmitter());\n      _defineProperty(this, \"paste\", new EventEmitter());\n    }\n  }\n  _class13 = DomEventsService;\n  _defineProperty(DomEventsService, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)();\n  });\n  _defineProperty(DomEventsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class13,\n    factory: _class13.ɵfac\n  }));\n  return DomEventsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns a respective boolean if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * Arguments for the `cellClose` event.\n */\nclass CellCloseEvent extends PreventableEvent {\n  constructor(options) {\n    super();\n    _defineProperty(this, \"isNew\", void 0);\n    _defineProperty(this, \"dataItem\", void 0);\n    _defineProperty(this, \"rowIndex\", void 0);\n    _defineProperty(this, \"sender\", void 0);\n    /**\n     * @hidden\n     */\n    _defineProperty(this, \"action\", 'cellClose');\n    /**\n     * The Grid column that will be closed.\n     */\n    _defineProperty(this, \"column\", void 0);\n    /**\n     * The [FormGroup](link:site.data.urls.angular['formgroupapi']) that is used to edit the cell which will be closed.\n     */\n    _defineProperty(this, \"formGroup\", void 0);\n    /**\n     * The DOM event that caused the `cellClose` event.\n     * May not be present if `cellClose` was caused by an API call.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    Object.assign(this, options);\n  }\n}\n\n/**\n * @hidden\n */\nconst isEqual = index => item => item.index === index;\n/**\n * @hidden\n */\nconst isNotEqual = index => item => item.index !== index;\n/**\n * @hidden\n */\nconst isNewRow = index => index === -1 || index === undefined;\n/**\n * @hidden\n */\nlet EditService = /*#__PURE__*/(() => {\n  var _class16;\n  class EditService {\n    constructor(ngZone) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"changed\", void 0);\n      _defineProperty(this, \"editedIndices\", []);\n      _defineProperty(this, \"newItemGroup\", void 0);\n      _defineProperty(this, \"keepEditCell\", false);\n      _defineProperty(this, \"keepCellTimeout\", void 0);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"closingCell\", false);\n      _defineProperty(this, \"changedSource\", new Subject());\n      this.ngZone = ngZone;\n      this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));\n    }\n    editRow(index, group = undefined) {\n      this.editedIndices.push({\n        index,\n        group\n      });\n      this.onChanged();\n    }\n    addRow(group) {\n      this.newItemGroup = {\n        group\n      };\n      this.onChanged();\n    }\n    editCell(rowIndex, column, group) {\n      if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {\n        return;\n      }\n      this.preventCellClose();\n      if (!this.closeCell()) {\n        this.editRow(rowIndex, group);\n        this.column = column;\n        this.onChanged();\n      }\n    }\n    isEditing() {\n      return this.editedIndices.length > 0;\n    }\n    isEditingCell() {\n      return this.isEditing() && this.column !== undefined;\n    }\n    get hasNewItem() {\n      return isPresent(this.newItemGroup);\n    }\n    get newDataItem() {\n      if (this.hasNewItem) {\n        return this.newItemGroup.group.value;\n      }\n      return {};\n    }\n    close(index) {\n      if (isNewRow(index)) {\n        this.newItemGroup = undefined;\n        return;\n      }\n      this.editedIndices = this.editedIndices.filter(isNotEqual(index));\n      delete this.column;\n      this.onChanged();\n    }\n    closeCell(originalEvent) {\n      if (this.column && !this.closingCell) {\n        return this.ngZone.run(() => {\n          const {\n            index,\n            group\n          } = this.editedIndices[0];\n          const args = new CellCloseEvent({\n            column: this.column,\n            formGroup: group,\n            originalEvent: originalEvent,\n            rowIndex: index\n          });\n          this.closingCell = true;\n          this.changes.emit(args);\n          this.closingCell = false;\n          if (!args.isDefaultPrevented()) {\n            this.cancelCell();\n          }\n          return args.isDefaultPrevented();\n        });\n      }\n    }\n    cancelCell() {\n      if (this.column) {\n        this.editedIndices = [];\n        delete this.column;\n        this.onChanged();\n      }\n    }\n    shouldCloseCell() {\n      return this.column && !this.keepEditCell;\n    }\n    preventCellClose() {\n      this.ngZone.runOutsideAngular(() => {\n        window.clearTimeout(this.keepCellTimeout);\n        this.keepEditCell = true;\n        this.keepCellTimeout = window.setTimeout(() => {\n          this.keepEditCell = false;\n        }, 0);\n      });\n    }\n    context(index) {\n      if (isNewRow(index)) {\n        return this.newItemGroup;\n      }\n      return this.findByIndex(index);\n    }\n    columnContext(index, column) {\n      if (isNewRow(index)) {\n        return this.newItemGroup;\n      }\n      if (!this.column || column === this.column) {\n        return this.findByIndex(index);\n      }\n    }\n    isEdited(index) {\n      if (isNewRow(index) && isPresent(this.newItemGroup)) {\n        return true;\n      }\n      return !this.column && isPresent(this.findByIndex(index));\n    }\n    hasEdited(index) {\n      return isPresent(this.context(index));\n    }\n    isEditedColumn(index, column) {\n      if (this.column && this.column === column) {\n        return isPresent(this.findByIndex(index));\n      }\n      return false;\n    }\n    beginEdit(rowIndex) {\n      this.changes.emit({\n        action: 'edit',\n        rowIndex\n      });\n    }\n    beginAdd() {\n      this.changes.emit({\n        action: 'add'\n      });\n    }\n    endEdit(rowIndex) {\n      const {\n        group: formGroup\n      } = this.context(rowIndex);\n      this.changes.emit({\n        action: 'cancel',\n        rowIndex,\n        formGroup,\n        isNew: isNewRow(rowIndex)\n      });\n    }\n    save(rowIndex) {\n      const {\n        group: formGroup\n      } = this.context(rowIndex);\n      this.changes.emit({\n        action: 'save',\n        rowIndex,\n        formGroup,\n        isNew: isNewRow(rowIndex)\n      });\n    }\n    remove(rowIndex) {\n      this.changes.emit({\n        action: 'remove',\n        rowIndex\n      });\n    }\n    findByIndex(index) {\n      return this.editedIndices.find(isEqual(index));\n    }\n    onChanged() {\n      this.ngZone.runOutsideAngular(() => {\n        this.changedSource.next();\n      });\n    }\n  }\n  _class16 = EditService;\n  _defineProperty(EditService, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(EditService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class16,\n    factory: _class16.ɵfac\n  }));\n  return EditService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst getGroupRowArgs = groupItem => {\n  if (!isPresent(groupItem)) {\n    return null;\n  }\n  return {\n    group: groupItem.data,\n    groupIndex: groupItem.index,\n    parentGroup: getGroupRowArgs(groupItem.parentGroup)\n  };\n};\nconst isChildIndex = (targetIndex, parentIndex) => {\n  const sameIndex = parentIndex === targetIndex;\n  const lastSeparatorIndex = targetIndex.lastIndexOf('_');\n  const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;\n  return !sameIndex && sameSubGroupIndex;\n};\n/**\n * @hidden\n */\nlet GroupsService = /*#__PURE__*/(() => {\n  var _class17;\n  class GroupsService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n      _defineProperty(this, \"userCallback\", void 0);\n      _defineProperty(this, \"rowState\", new Set());\n    }\n    reset() {\n      this.rowState.clear();\n    }\n    ngOnDestroy() {\n      this.reset();\n    }\n    isExpanded(groupArgs) {\n      if (this.userCallback) {\n        return this.userCallback(groupArgs);\n      }\n      return !this.rowState.has(groupArgs.groupIndex);\n    }\n    isInExpandedGroup(groupItem) {\n      let expanded = true;\n      while (groupItem && expanded) {\n        expanded = this.isExpanded({\n          group: groupItem.data,\n          groupIndex: groupItem.index,\n          parentGroup: getGroupRowArgs(groupItem.parentGroup)\n        });\n        groupItem = groupItem.parentGroup;\n      }\n      return expanded;\n    }\n    toggleRow(groupItem, emit = true) {\n      const parentGroup = getGroupRowArgs(groupItem.parentGroup);\n      const expand = !this.isExpanded({\n        group: groupItem.data,\n        groupIndex: groupItem.index,\n        parentGroup\n      });\n      this.changes.next({\n        group: groupItem.data,\n        expand,\n        groupIndex: groupItem.index,\n        parentGroup,\n        emit\n      });\n      // if usercallback is given, the rowState should be ignored\n      if (this.userCallback) {\n        return;\n      }\n      if (expand) {\n        this.rowState.delete(groupItem.index);\n      } else {\n        this.rowState.add(groupItem.index);\n      }\n    }\n    expandChildren(parentIndex) {\n      this.rowState.forEach(index => isChildIndex(index, parentIndex) && this.rowState.delete(index));\n    }\n  }\n  _class17 = GroupsService;\n  _defineProperty(GroupsService, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)();\n  });\n  _defineProperty(GroupsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class17,\n    factory: _class17.ɵfac\n  }));\n  return GroupsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `detailCollapse` event.\n */\nclass DetailCollapseEvent extends PreventableEvent {\n  constructor(args) {\n    super();\n    /**\n     * The collapsed row `dataItem`.\n     */\n    _defineProperty(this, \"dataItem\", void 0);\n    /**\n     * The collapsed row index.\n     */\n    _defineProperty(this, \"index\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * Arguments for the `detailExpand` event.\n */\nclass DetailExpandEvent extends PreventableEvent {\n  constructor(args) {\n    super();\n    /**\n     * The expanded row `dataItem`.\n     */\n    _defineProperty(this, \"dataItem\", void 0);\n    /**\n     * The expanded row index.\n     */\n    _defineProperty(this, \"index\", void 0);\n    Object.assign(this, args);\n  }\n}\n\n/**\n * @hidden\n */\nlet DetailsService = /*#__PURE__*/(() => {\n  var _class20;\n  class DetailsService {\n    constructor() {\n      _defineProperty(this, \"userCallback\", void 0);\n      _defineProperty(this, \"changes\", new Subject());\n      _defineProperty(this, \"rowState\", new Set());\n    }\n    ngOnDestroy() {\n      this.rowState.clear();\n    }\n    isExpanded(index, dataItem) {\n      if (this.userCallback) {\n        return this.userCallback({\n          index,\n          dataItem\n        });\n      }\n      return this.rowState.has(index);\n    }\n    toggleRow(index, dataItem) {\n      if (this.isExpanded(index, dataItem)) {\n        this.collapseRow(index, dataItem);\n      } else {\n        this.expandRow(index, dataItem);\n      }\n    }\n    expandRow(index, dataItem) {\n      const prevented = this.emitEvent({\n        dataItem,\n        index,\n        expand: true\n      });\n      if (!prevented && !this.userCallback) {\n        this.rowState.add(index);\n      }\n    }\n    collapseRow(index, dataItem) {\n      const prevented = this.emitEvent({\n        dataItem,\n        index,\n        expand: false\n      });\n      if (!prevented && !this.userCallback) {\n        this.rowState.delete(index);\n      }\n    }\n    emitEvent(args) {\n      const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);\n      this.changes.next(eventArg);\n      return eventArg.isDefaultPrevented();\n    }\n  }\n  _class20 = DetailsService;\n  _defineProperty(DetailsService, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)();\n  });\n  _defineProperty(DetailsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class20,\n    factory: _class20.ɵfac\n  }));\n  return DetailsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ScrollRequestService = /*#__PURE__*/(() => {\n  var _class21;\n  class ScrollRequestService {\n    constructor() {\n      _defineProperty(this, \"requests\", new Subject());\n    }\n    scrollTo(request, adjustIndex = true) {\n      this.requests.next({\n        request,\n        adjustIndex\n      });\n    }\n    scrollToItem(request) {\n      this.requests.next({\n        request\n      });\n    }\n  }\n  _class21 = ScrollRequestService;\n  _defineProperty(ScrollRequestService, \"\\u0275fac\", function _class21_Factory(t) {\n    return new (t || _class21)();\n  });\n  _defineProperty(ScrollRequestService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class21,\n    factory: _class21.ɵfac\n  }));\n  return ScrollRequestService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column cell template of the Grid.\n * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag with the\n * `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag [see example](slug:templates_columns_grid#toc-cell-template).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex=\"columnIndex\"` syntax.\n * - `rowIndex`&mdash;The current data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.\n * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\" ...>\n *   <kendo-grid-column field=\"ProductName\">\n *     <ng-template kendoGridCellTemplate let-dataItem let-rowIndex=\"rowIndex\" let-column=\"column\">\n *       Data Row: {{rowIndex}}\n *     </ng-template>\n *   </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet CellTemplateDirective = /*#__PURE__*/(() => {\n  var _class22;\n  class CellTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class22 = CellTemplateDirective;\n  _defineProperty(CellTemplateDirective, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(CellTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class22,\n    selectors: [[\"\", \"kendoGridCellTemplate\", \"\"]],\n    standalone: true\n  }));\n  return CellTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column edit-cell template of the Grid ([see example](slug:custom_reactive_editing_grid#toc-setting-up-custom-inputs)).\n * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`\n * tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag.\n *\n * The template context is set to the current form group and the following additional fields are passed:\n * - `formGroup`&mdash;The current [FormGroup](link:site.data.urls.angular['formgroupapi']). Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax, for example, `let-formGroup`. If you use the Grid inside [Template-Driven Forms](link:site.data.urls.angular['forms']), it will be `undefined`.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex` is `-1`. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n * - `dataItem`&mdash;The current data item. Use it as an alias for a template variable by utilizing the `let-dataItem=\"dataItem\"` syntax.\n * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n * - `isNew`&mdash;The state of the current item. Use it as an alias for a template variable by utilizing the `let-isNew=\"isNew\"` syntax.\n */\nlet EditTemplateDirective = /*#__PURE__*/(() => {\n  var _class23;\n  class EditTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class23 = EditTemplateDirective;\n  _defineProperty(EditTemplateDirective, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(EditTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class23,\n    selectors: [[\"\", \"kendoGridEditTemplate\", \"\"]],\n    standalone: true\n  }));\n  return EditTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column header cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).\n * Helps to customize the table header cell for the column.\n * To define a header template, nest an `<ng-template>` tag with the\n * `kendoGridHeaderTemplate` directive inside the `<kendo-grid-column>` tag.\n *\n *  The template context is set to the current column and then the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *    <kendo-grid-column field=\"ProductName\">\n *       <ng-template kendoGridHeaderTemplate let-column let-columnIndex=\"columnIndex\">\n *          {{column.field}}({{columnIndex}})\n *       </ng-template>\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet HeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class24;\n  class HeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class24 = HeaderTemplateDirective;\n  _defineProperty(HeaderTemplateDirective, \"\\u0275fac\", function _class24_Factory(t) {\n    return new (t || _class24)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(HeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class24,\n    selectors: [[\"\", \"kendoGridHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return HeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column footer cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).\n * Helps to customize the table footer cell for the column.\n * To define a footer template, nest an `<ng-template>` tag with the\n * [kendoGridFooterTemplate]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.\n *\n * The template context is set to the current column and the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * For more information on how to display aggregates in the footer of the Grid,\n * refer to the article on [aggregates]({% slug groupable_grid_with_aggregates %}).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\" scrollable=\"none\">\n *    <kendo-grid-column field=\"ProductName\">\n *       <ng-template kendoGridFooterTemplate let-column let-columnIndex=\"columnIndex\">\n *          {{column.field}}({{columnIndex}})\n *       </ng-template>\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet FooterTemplateDirective = /*#__PURE__*/(() => {\n  var _class25;\n  class FooterTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class25 = FooterTemplateDirective;\n  _defineProperty(FooterTemplateDirective, \"\\u0275fac\", function _class25_Factory(t) {\n    return new (t || _class25)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(FooterTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class25,\n    selectors: [[\"\", \"kendoGridFooterTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FooterTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the template for the column menu in the Grid. Provides an option for\n * customizing the content of the column menu for all or for specific columns.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuTemplate` directive inside the `<kendo-grid>` or the `<kendo-grid-column>` component.\n *\n * The template context is passes through the following fields:\n * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}).\n * - `column`&mdash;Represents the Grid column.\n *\n * @example\n * ```html\n * <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-sort [service]=\"service\"></kendo-grid-columnmenu-sort>\n *   </ng-template>\n *   <kendo-grid-column field=\"Field1\">\n *     <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *       <kendo-grid-columnmenu-lock [service]=\"service\"></kendo-grid-columnmenu-lock>\n *       <kendo-grid-columnmenu-sort [service]=\"service\"></kendo-grid-columnmenu-sort>\n *     </ng-template>\n *   </kendo-grid-column>\n *   <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuTemplateDirective = /*#__PURE__*/(() => {\n  var _class26;\n  class ColumnMenuTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class26 = ColumnMenuTemplateDirective;\n  _defineProperty(ColumnMenuTemplateDirective, \"\\u0275fac\", function _class26_Factory(t) {\n    return new (t || _class26)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(ColumnMenuTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class26,\n    selectors: [[\"\", \"kendoGridColumnMenuTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ColumnMenuTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// Incremented each time the service is instantiated.\nlet sequence = 0;\n/**\n * @hidden\n */\nlet IdService = /*#__PURE__*/(() => {\n  var _class27;\n  class IdService {\n    constructor() {\n      _defineProperty(this, \"prefix\", void 0);\n      this.prefix = `k-grid${sequence++}`;\n    }\n    gridId() {\n      return this.prefix;\n    }\n    cellId(rowIndex, colIndex) {\n      return `${this.prefix}-r${rowIndex}c${colIndex}`;\n    }\n    selectionCheckboxId(itemIndex) {\n      return `${this.prefix}-checkbox${itemIndex}`;\n    }\n    selectAllCheckboxId() {\n      return `${this.prefix}-select-all`;\n    }\n  }\n  _class27 = IdService;\n  _defineProperty(IdService, \"\\u0275fac\", function _class27_Factory(t) {\n    return new (t || _class27)();\n  });\n  _defineProperty(IdService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class27,\n    factory: _class27.ɵfac\n  }));\n  return IdService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst ColumnMenuErrorMessages = {\n  autoSizeColumn: `The auto size column does not work with enabled virtual columns.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,\n  autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,\n  serviceInput: `The service input of the predefined column menu components is mandatory.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`\n};\n/**\n * @hidden\n */\nconst ClipboardErrorMessages = {\n  activeCellNavigable: `Grid must be navigable to use \"activeCell\" as clipboard target type.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,\n  selectionSelectable: `Grid must be selectable to use \"selection\" as clipboard target type.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`\n};\n/**\n * @hidden\n */\nconst ColumnConfigurationErrorMessages = {\n  fieldName: field => `Grid column field name '${field}' does not look like a valid JavaScript identifier.\n        Identifiers can contain only alphanumeric characters (including \"$\" or \"_\"), and may not start with a digit.\n        Please use only valid identifier names to ensure error-free operation.`,\n  width: (value, parsedValue) => `Expected numeric value for column width, but got a string \"${value}\". Treating as ${parsedValue}px.`,\n  invalidColumn: column => `Invalid column ${column}.`,\n  requiredWidth: columnType => `${columnType} columns feature requires all columns to have set width.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,\n  requiredScroll: columnType => `${columnType} columns are only supported when scrolling is enabled.\n    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,\n  groupColumnContent: 'ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.',\n  lockedParent: 'Locked child columns require their parent columns to be locked.',\n  columnNested: 'Columns can be nested only inside ColumnGroupComponent',\n  nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`\n};\n/**\n * @hidden\n */\nconst GridConfigurationErrorMessages = {\n  functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,\n  incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,\n  nonLockedColumnPresent: 'There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations',\n  rowHeightVirtual: `The virtual scrolling functionality requires setting the rowHeight (and detailRowHeight when there are detail rows).\n        Row height and detail row height settings should be set only when virtual scrolling mode is enabled.\n        See https://www.telerik.com/kendo-angular-ui/components/grid/scroll-modes/virtual/#toc-getting-started.`,\n  focusNavigable: 'The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.',\n  expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called\n        when using the ${directiveName} directive or the ${callbackName} callback.\n        These methods are provided only for backwards compatibility with legacy versions.`,\n  requiredEditService: `The default edit service of the editing directives works only when binding to plain array.\n        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,\n  requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,\n  groupBindingDirectives: `Using the \"kendoGridGroupBinding\" directive in combination with the \"kendoGridExpandGroupBy\" directive\n        or the \"isGroupExpanded\" callback is not supported. To use grouping with the \"kendoGridGroupBinding\" directive,\n        set the Grid \"groupable\" property to \"true\".`,\n  unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`,\n  unsupportedToolbarConfig: `\n        Defining both a toolbar template and a ToolBarComponent within the Grid is not supported.\n        Please use either the ToolBarComponent or a custom template.`\n};\n\n/**\n * @hidden\n */\nconst isSpanColumn = column => column.isSpanColumn;\n/**\n * @hidden\n */\nconst isCheckboxColumn = column => column.isCheckboxColumn;\n/**\n * @hidden\n */\nconst isRowReorderColumn = column => column.isRowReorderColumn;\nconst isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);\n/**\n * The base class for the column components of the Grid.\n */\nlet ColumnBase = /*#__PURE__*/(() => {\n  var _class28;\n  class ColumnBase {\n    /**\n     * @hidden\n     */\n    set leafIndex(value) {\n      this._leafIndex = value;\n    }\n    /**\n     * @hidden\n     */\n    get leafIndex() {\n      return this._leafIndex;\n    }\n    /**\n     * The width of the column (in pixels).\n     */\n    set width(value) {\n      if (typeof value === 'string') {\n        const parsedValue = this._width = parseInt(value, 10);\n        if (isDevMode()) {\n          console.warn(ColumnConfigurationErrorMessages.width(value, parsedValue));\n        }\n      } else {\n        this._width = value;\n      }\n    }\n    get width() {\n      return this._width;\n    }\n    /**\n     * Indicates whether the column will be resized during initialization so that it fits its header and row content.\n     */\n\n    /**\n     * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).\n     *\n     * @default false\n     *\n     */\n    set locked(value) {\n      this._locked = value;\n    }\n    get locked() {\n      return this._locked;\n    }\n    /**\n     * @hidden\n     */\n    get level() {\n      if (this.parent && isSpanColumn(this.parent)) {\n        return this.parent.level;\n      }\n      return this.parent ? this.parent.level + 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n    get isLocked() {\n      return this.parent ? this.parent.isLocked : this.locked;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n      return 1;\n    }\n    /**\n     * @hidden\n     */\n    rowspan(totalColumnLevels) {\n      return this.level < totalColumnLevels ? totalColumnLevels - this.level + 1 : 1;\n    }\n    /**\n     * @hidden\n     */\n    get headerTemplateRef() {\n      const template = this.headerTemplates.first;\n      return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get footerTemplateRef() {\n      return this.footerTemplate ? this.footerTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get columnMenuTemplateRef() {\n      const template = this.columnMenuTemplates.first;\n      return template ? template.templateRef : null;\n    }\n    /**\n     * @hidden\n     */\n    get displayTitle() {\n      return this.title;\n    }\n    /**\n     * @hidden\n     */\n    get isVisible() {\n      return !this.hidden && this.matchesMedia;\n    }\n    /**\n     * @hidden\n     */\n    constructor(parent, idService) {\n      _defineProperty(this, \"parent\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isReordered\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"initialMaxResizableWidth\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"initialMinResizableWidth\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"matchesMedia\", true);\n      /**\n       * The column index after reordering. The `orderIndex` is a read-only property. Setting this field does not affect column order.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"orderIndex\", 0);\n      _defineProperty(this, \"_leafIndex\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isColumnGroup\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isSpanColumn\", false);\n      /**\n       * Indicates whether the column is resizable.\n       * @default true\n       */\n      _defineProperty(this, \"resizable\", true);\n      /**\n       * Indicates whether the column is reorderable.\n       * @default true\n       */\n      _defineProperty(this, \"reorderable\", true);\n      /**\n       * The width (in pixels) below which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).\n       * The `autoFitColumn` and `autoFitColumns` methods have higher priority.\n       * @default 10\n       */\n      _defineProperty(this, \"minResizableWidth\", 10);\n      /**\n       * The width (in pixels) above which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).\n       * By default, the maximum width is not restricted.\n       * The `autoFitColumn` and `autoFitColumns` methods have higher priority.\n       */\n      _defineProperty(this, \"maxResizableWidth\", void 0);\n      /**\n       * The title of the column.\n       */\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"autoSize\", void 0);\n      _defineProperty(this, \"_locked\", false);\n      /**\n       * Determines whether the column will be always visible when scrolling the Grid horizontally.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"sticky\", false);\n      /**\n       * Sets the visibility of the column ([see example](slug:hidden_columns_grid#toc-using-the-built-in-options)).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"hidden\", void 0);\n      /**\n       * Sets the condition that needs to be satisfied for a column to remain visible ([see example]({% slug styling_responsive_grid %}#toc-columns)).\n       * If you set the `hidden` property, the behavior of `media` is overridden.\n       *\n       * Accepts the device identifiers that are [available in Bootstrap 4](https://v4-alpha.getbootstrap.com/layout/grid/#grid-options)\n       * ([see example](slug:styling_responsive_grid)):\n       */\n      _defineProperty(this, \"media\", void 0);\n      /**\n       * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.\n       * @default true\n       */\n      _defineProperty(this, \"lockable\", true);\n      /**\n       * Specifies if the column can be stuck or unstuck from the column menu.\n       * @default true\n       */\n      _defineProperty(this, \"stickable\", true);\n      /**\n       * Specifies if the column menu will be shown for the column.\n       * @default true\n       */\n      _defineProperty(this, \"columnMenu\", true);\n      /**\n       * Specifies if the column will be included in the column-chooser list.\n       * @default true\n       */\n      _defineProperty(this, \"includeInChooser\", true);\n      /**\n       * Allows setting the `role` attribute for the table cells (excluding the footer and header ones) of the column.\n       * @default \"gridcell\"\n       */\n      _defineProperty(this, \"tableCellsRole\", 'gridcell');\n      /**\n       * Sets the custom styles for the table cells (excluding the footer and header ones) of the column. Under the hood,\n       * to apply the property, the `style` option uses the\n       * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).\n       *\n       */\n      _defineProperty(this, \"style\", void 0);\n      /**\n       * Sets the custom styles for the header cell of the column. Under the hood, to apply the property,\n       * the `headerStyle` option uses the\n       * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).\n       *\n       */\n      _defineProperty(this, \"headerStyle\", void 0);\n      /**\n       * Sets the custom styles for the filter row cell. Under the hood, to apply the property,\n       * the `filterStyle` option uses the\n       * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).\n       *\n       */\n      _defineProperty(this, \"filterStyle\", void 0);\n      /**\n       * Sets the custom styles for the footer cell of the column. Under the hood, to apply the property,\n       * the `footerStyle` option uses the\n       * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).\n       *\n       */\n      _defineProperty(this, \"footerStyle\", void 0);\n      /**\n       * Sets the custom CSS classes to the column cells. Under the hood, to apply the property, the `class` option uses the\n       * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).\n       * To customize header and footer column cells, use the [headerClass]({% slug api_grid_columncomponent %}#toc-headerclass)\n       * and [footerClass]({% slug api_grid_columncomponent %}#toc-footerclass) inputs.\n       *\n       */\n      _defineProperty(this, \"cssClass\", void 0);\n      /**\n       * Sets the custom CSS classes to the column header cell. Under the hood, to apply the property,\n       * the `headerClass` option uses the\n       * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).\n       *\n       */\n      _defineProperty(this, \"headerClass\", void 0);\n      /**\n       * Sets the custom CSS classes to the filter row cell. Under the hood, to apply the property,\n       * the `filterClass` option uses the\n       * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).\n       *\n       */\n      _defineProperty(this, \"filterClass\", void 0);\n      /**\n       * Sets the custom CSS classes to the column footer cell. Under the hood, to apply the property,\n       * the `footerClass` option uses the\n       * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).\n       *\n       */\n      _defineProperty(this, \"footerClass\", void 0);\n      /**\n       * Defines a function that is used to determine the rowspan of each column cell.\n       */\n      _defineProperty(this, \"cellRowspan\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerTemplates\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"footerTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"columnMenuTemplates\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"resizeStartWidth\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"idService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"implicitWidth\", void 0);\n      _defineProperty(this, \"_width\", void 0);\n      this.parent = parent;\n      this.idService = idService;\n      if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {\n        throw new Error(ColumnConfigurationErrorMessages.columnNested);\n      }\n    }\n    ngOnChanges(changes) {\n      if (isDevMode() && changes['cellRowspan'] && typeof changes['cellRowspan'].currentValue !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('cellRowspan', changes['cellRowspan'].currentValue));\n      }\n    }\n  }\n  _class28 = ColumnBase;\n  _defineProperty(ColumnBase, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)(i0.ɵɵdirectiveInject(_class28), i0.ɵɵdirectiveInject(IdService));\n  });\n  _defineProperty(ColumnBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class28,\n    selectors: [[\"kendo-grid-column-base\"]],\n    contentQueries: function _class28_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);\n      }\n    },\n    inputs: {\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      minResizableWidth: \"minResizableWidth\",\n      maxResizableWidth: \"maxResizableWidth\",\n      title: \"title\",\n      width: \"width\",\n      autoSize: \"autoSize\",\n      locked: \"locked\",\n      sticky: \"sticky\",\n      hidden: \"hidden\",\n      media: \"media\",\n      lockable: \"lockable\",\n      stickable: \"stickable\",\n      columnMenu: \"columnMenu\",\n      includeInChooser: \"includeInChooser\",\n      tableCellsRole: \"tableCellsRole\",\n      style: \"style\",\n      headerStyle: \"headerStyle\",\n      filterStyle: \"filterStyle\",\n      footerStyle: \"footerStyle\",\n      cssClass: [\"class\", \"cssClass\"],\n      headerClass: \"headerClass\",\n      filterClass: \"filterClass\",\n      footerClass: \"footerClass\",\n      cellRowspan: \"cellRowspan\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class28_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ColumnBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the group-header cell template of the Grid which helps to customize the content of the group header item.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderTemplate`\n * directive inside `<kendo-grid-column>`. ([See example](slug:grouping_grid_templates#toc-header-template)).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n * - `index`&mdash;The index of the current group.\n * - `expanded`&mdash;A boolean value indicating if the group is currently expanded.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *    <kendo-grid-column field=\"ProductName\">\n *       <ng-template kendoGridGroupHeaderTemplate let-group let-field=\"field\" let-value=\"value\">\n *          <strong>{{field}}</strong>: {{value}}\n *       </ng-template>\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet GroupHeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class29;\n  class GroupHeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class29 = GroupHeaderTemplateDirective;\n  _defineProperty(GroupHeaderTemplateDirective, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(GroupHeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class29,\n    selectors: [[\"\", \"kendoGridGroupHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return GroupHeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the group-header column template of the Grid which helps to customize the content of the group headers.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`\n * directive inside `<kendo-grid-column>`. ([See example](slug:grouping_grid_templates#toc-header-column-template)).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * ```html\n * <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *     <ng-template kendoGridGroupHeaderColumnTemplate let-group=\"group\" let-aggregates=\"aggregates\">\n *         <span title=\"Group Header Column Template for ProductName\">\n *             Count: {{ aggregates.Discontinued.count }}\n *         </span>\n *     </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet GroupHeaderColumnTemplateDirective = /*#__PURE__*/(() => {\n  var _class30;\n  class GroupHeaderColumnTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class30 = GroupHeaderColumnTemplateDirective;\n  _defineProperty(GroupHeaderColumnTemplateDirective, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(GroupHeaderColumnTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class30,\n    selectors: [[\"\", \"kendoGridGroupHeaderColumnTemplate\", \"\"]],\n    standalone: true\n  }));\n  return GroupHeaderColumnTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column group footer cell template of the Grid which helps to customize the group footer cell for the column.\n * To define the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive\n * inside `<kendo-grid-column>`.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `column`&mdash;Defines an instance of the `ColumnComponent` option.\n * - `field`&mdash;The current column field name.\n * - `group`&mdash;The current group data item.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *    <kendo-grid-column field=\"ProductName\">\n *       <ng-template kendoGridGroupFooterTemplate let-aggregates let-field=\"field\">\n *          Count: {{aggregates[field].count}}\n *       </ng-template>\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet GroupFooterTemplateDirective = /*#__PURE__*/(() => {\n  var _class31;\n  class GroupFooterTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class31 = GroupFooterTemplateDirective;\n  _defineProperty(GroupFooterTemplateDirective, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(GroupFooterTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class31,\n    selectors: [[\"\", \"kendoGridGroupFooterTemplate\", \"\"]],\n    standalone: true\n  }));\n  return GroupFooterTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the filter-cell template.\n * Helps to customize the content of the filter cell. To define the filter cell template, nest an `<ng-template>` tag with the\n * `kendoGridFilterCellTemplate` directive inside a `<kendo-grid-column>` tag ([see example]({% slug filter_row %}#toc-custom-filters)).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by utilizing the `let-filter=\"filter\"` syntax.\n *\n * ```html\n * <kendo-grid-column field=\"CategoryID\" title=\"Category\">\n *     <ng-template kendoGridFilterCellTemplate\n *         let-column=\"column\"\n *         let-filter=\"filter\"\n *         >\n *         ...\n *    </ng-template>\n *    ...\n * </kendo-grid-column>\n * ```\n */\nlet FilterCellTemplateDirective = /*#__PURE__*/(() => {\n  var _class32;\n  class FilterCellTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class32 = FilterCellTemplateDirective;\n  _defineProperty(FilterCellTemplateDirective, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(FilterCellTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class32,\n    selectors: [[\"\", \"kendoGridFilterCellTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FilterCellTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the filter-menu template.\n * Helps to customize the content of the filter menu. To define the filter menu template, nest an `<ng-template>` tag with the\n * `kendoGridFilterMenuTemplate` directive inside a `<kendo-grid-column>` tag\n * ([see example]({% slug filter_menu %}#toc-custom-filters)).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by utilizing the `let-filter=\"filter\"` syntax.\n * - `filterService`&mdash;Represents the [`FilterService`]({% slug api_grid_filterservice %}). Use it as an alias for a template variable by utilizing the `let-filterService=\"filterService\"` syntax.\n *\n * ```html\n * <kendo-grid-column field=\"CategoryID\" title=\"Category\">\n *     <ng-template kendoGridFilterMenuTemplate\n *         let-column=\"column\"\n *         let-filter=\"filter\"\n *         let-filterService=\"filterService\"\n *         >\n *         ...\n *    </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet FilterMenuTemplateDirective = /*#__PURE__*/(() => {\n  var _class33;\n  class FilterMenuTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class33 = FilterMenuTemplateDirective;\n  _defineProperty(FilterMenuTemplateDirective, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(FilterMenuTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class33,\n    selectors: [[\"\", \"kendoGridFilterMenuTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FilterMenuTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction isColumnComponent(column) {\n  return isPresent(column.field);\n}\n/**\n * Represents the column of the Grid. [See example](slug:columns_config#toc-using-the-column-component)\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *   <kendo-grid-column field=\"ProductID\" title=\"Product ID\"></kendo-grid-column>\n *   <kendo-grid-column field=\"ProductName\" title=\"Product Name\"></kendo-grid-column>\n *   <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ColumnComponent = /*#__PURE__*/(() => {\n  var _class34;\n  class ColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      /**\n       * The field to which the column is bound.\n       */\n      _defineProperty(this, \"field\", void 0);\n      /**\n       * The format that is applied to the value before it is displayed. For more information on the supported date and number formats,\n       * refer to the [Column Formats](slug:formats_columns_grid) documentation article.\n       */\n      _defineProperty(this, \"format\", void 0);\n      /**\n       * Allows the user to click the column headers and emits the `sortChange` event. [See example](slug:sorting_grid).\n       *\n       * @default true\n       */\n      _defineProperty(this, \"sortable\", true);\n      /**\n       * Determines if the column can be dragged to the group panel.\n       * If set to `false`, you can group the columns by the column field by using the API of the Grid.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"groupable\", true);\n      /**\n       * Defines the editor type. [See example](slug:inline_editing_grid#toc-using-reactive-forms).\n       * Used when the column enters the edit mode.\n       *\n       * @default 'text'\n       */\n      _defineProperty(this, \"editor\", 'text');\n      /**\n       * Defines the filter type that is displayed inside the filter row. [See example](slug:filtering_grid#toc-filter-data-types).\n       *\n       * @default 'text'\n       */\n      _defineProperty(this, \"filter\", 'text');\n      /**\n       * Defines if a filter UI will be displayed for this column. [See example](slug:filtering_grid).\n       *\n       * @default true\n       */\n      _defineProperty(this, \"filterable\", true);\n      /**\n       * Defines whether the column is editable. [See example](slug:make_fields_uneditable_grid).\n       *\n       * @default true\n       */\n      _defineProperty(this, \"editable\", true);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"groupHeaderTemplate\", void 0);\n      _defineProperty(this, \"groupHeaderColumnTemplate\", void 0);\n      _defineProperty(this, \"groupFooterTemplate\", void 0);\n      _defineProperty(this, \"editTemplate\", void 0);\n      _defineProperty(this, \"filterCellTemplate\", void 0);\n      _defineProperty(this, \"filterMenuTemplate\", void 0);\n    }\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n    get groupHeaderTemplateRef() {\n      return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;\n    }\n    get groupHeaderColumnTemplateRef() {\n      return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;\n    }\n    get groupFooterTemplateRef() {\n      return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;\n    }\n    get editTemplateRef() {\n      return this.editTemplate ? this.editTemplate.templateRef : undefined;\n    }\n    get filterCellTemplateRef() {\n      return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;\n    }\n    get filterMenuTemplateRef() {\n      return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;\n    }\n    get displayTitle() {\n      return this.title === undefined ? this.field : this.title;\n    }\n    ngAfterViewInit() {\n      this.initialMaxResizableWidth = this.maxResizableWidth;\n      this.initialMinResizableWidth = this.minResizableWidth;\n    }\n  }\n  _class34 = ColumnComponent;\n  _defineProperty(ColumnComponent, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(ColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class34,\n    selectors: [[\"kendo-grid-column\"]],\n    contentQueries: function _class34_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);\n      }\n    },\n    inputs: {\n      field: \"field\",\n      format: \"format\",\n      sortable: \"sortable\",\n      groupable: \"groupable\",\n      editor: \"editor\",\n      filter: \"filter\",\n      filterable: \"filterable\",\n      editable: \"editable\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class34)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class34_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction isSpanColumnComponent(column) {\n  return column.isSpanColumn;\n}\n/**\n * Represents a column which can be spanned over multiple data cells while the individual\n * header and footer cells are retained ([see example]({% slug spanned_columns_grid %})).\n * Enables you to achieve more flexible layout while keeping the built-in UI element for\n * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and\n * [grouping]({% slug grouping_grid %}). Wrap the columns that will be\n * merged inside the `<kendo-grid-span-column>` tag.\n *\n * ```html\n * <kendo-grid-span-column>\n *   <kendo-grid-column field=\"field1\"></kendo-grid-column>\n *   <kendo-grid-column field=\"field2\"></kendo-grid-column>\n *   <ng-template kendoGridCellTemplate let-dataItem>\n *     <h5>{{ dataItem.field1 }}</h5>\n *     <p>{{ dataItem.field2 }}</p>\n *   </ng-template>\n * </kendo-grid-span-column>\n * ```\n */\nlet SpanColumnComponent = /*#__PURE__*/(() => {\n  var _class35;\n  class SpanColumnComponent extends ColumnBase {\n    /**\n     * Defines whether the edit template of the column will be rendered.\n     * To enable the editing functionality for a spanned column, set an edit template for it ([see example](slug:custom_reactive_editing_grid)).\n     * @default false\n     */\n    set editable(value) {\n      this._editable = value;\n    }\n    get editable() {\n      return isPresent(this.editTemplateRef) && this._editable;\n    }\n    /**\n     * @hidden\n     * added for backwards compitability\n     */\n    set width(_value) {}\n    get width() {\n      return this.childColumns.reduce((total, column) => total + column.width, 0);\n    }\n    /**\n     * @hidden\n     */\n    get leafIndex() {\n      return this.childColumns.first.leafIndex;\n    }\n    constructor(parent, idService) {\n      super(parent, idService);\n      /*\n       * @hidden\n       */\n      _defineProperty(this, \"isSpanColumn\", true);\n      _defineProperty(this, \"template\", new QueryList());\n      _defineProperty(this, \"editTemplate\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"childColumns\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerStyle\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"footerStyle\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerClass\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"footerClass\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"includeInChooser\", false);\n      _defineProperty(this, \"_editable\", true);\n      if (parent && parent.isSpanColumn) {\n        throw new Error(ColumnConfigurationErrorMessages.nestedInside('SpanColumnComponent', 'SpanColumnComponent'));\n      }\n    }\n    /**\n     * @hidden\n     */\n    get templateRef() {\n      const template = this.template.first;\n      return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get editTemplateRef() {\n      const editTemplate = this.editTemplate.first;\n      return editTemplate ? editTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n      return this.childColumns.filter(c => c.isVisible).length;\n    }\n    /**\n     * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).\n     * @default false\n     */\n    set locked(value) {\n      this._locked = value;\n    }\n    get locked() {\n      return this._locked || this.childColumns.some(c => c.locked);\n    }\n    get childrenArray() {\n      return this.childColumns.toArray();\n    }\n    get hasChildren() {\n      return this.childColumns.length > 0;\n    }\n  }\n  _class35 = SpanColumnComponent;\n  _defineProperty(SpanColumnComponent, \"\\u0275fac\", function _class35_Factory(t) {\n    return new (t || _class35)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(SpanColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class35,\n    selectors: [[\"kendo-grid-span-column\"]],\n    contentQueries: function _class35_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childColumns = _t);\n      }\n    },\n    inputs: {\n      editable: \"editable\",\n      locked: \"locked\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class35)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class35_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SpanColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst expandColumns = columns => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []);\n/**\n * @hidden\n */\nconst expandColumnsWithSpan = columns => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? [column].concat(column.childrenArray) : [column]), []);\n/**\n * @hidden\n */\nconst columnsToRender = columns => expandColumns(columns).filter(x => x.isVisible);\nconst sumProp = prop => array => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);\n/**\n * @hidden\n */\nconst sumColumnWidths = sumProp('width');\n/**\n * @hidden\n */\nconst columnsSpan = sumProp('colspan');\nconst validField = new RegExp(`^[$A-Z\\_a-z][$A-Z\\_a-z0-9\\\\.]*$`);\n/**\n * @hidden\n */\nconst isValidFieldName = fieldName => !isNullOrEmptyString(fieldName) && validField.test(fieldName) && fieldName[0] !== \".\" && fieldName[fieldName.length - 1] !== \".\";\n/**\n * @hidden\n */\nconst children = column => column.children.filter(child => child !== column);\n/**\n * @hidden\n */\nconst leafColumns = columns => {\n  return columns.reduce((acc, column) => {\n    if (column.isColumnGroup) {\n      acc = acc.concat(leafColumns(children(column)));\n    } else if (column.isSpanColumn) {\n      acc = acc.concat(column.childrenArray);\n    } else {\n      acc.push(column);\n    }\n    return acc;\n  }, []).filter(x => x.isVisible);\n};\n/**\n * @hidden\n */\nconst someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);\n/**\n * @hidden\n */\nconst resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);\n/**\n * @hidden\n */\nconst sortColumns = columns => orderBy(columns, [{\n  field: 'orderIndex',\n  dir: 'asc'\n}]);\n/**\n * @hidden\n */\nconst isInSpanColumn$1 = column => isTruthy(column.parent) && isSpanColumnComponent(column.parent);\n\n/**\n * @hidden\n */\nconst isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;\n/**\n * @hidden\n */\nconst resizeArgs = (column, extra) => Object.assign({\n  columns: leafColumns([column]),\n  locked: isLocked(column)\n}, extra);\n/**\n * @hidden\n */\nlet ColumnResizingService = /*#__PURE__*/(() => {\n  var _class36;\n  class ColumnResizingService {\n    constructor() {\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"adjacentColumn\", void 0);\n      _defineProperty(this, \"areColumnsReordered\", false);\n      _defineProperty(this, \"isShiftPressed\", false);\n      _defineProperty(this, \"originalWidth\", void 0);\n      _defineProperty(this, \"draggedGroupColumn\", void 0);\n      _defineProperty(this, \"resizedColumns\", void 0);\n      _defineProperty(this, \"autoFitResize\", false);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"tables\", []);\n      _defineProperty(this, \"batch\", null);\n    }\n    start(column) {\n      this.trackColumns(column);\n      const columns = (this.column.isColumnGroup ? [column] : []).concat(leafColumns([column]));\n      this.changes.emit({\n        columns: columns,\n        locked: isLocked(this.column),\n        type: 'start'\n      });\n    }\n    resizeColumns(deltaPercent) {\n      const action = resizeArgs(this.column, {\n        deltaPercent,\n        type: 'resizeColumn'\n      });\n      this.changes.emit(action);\n    }\n    resizeTable(column, delta) {\n      const action = resizeArgs(column, {\n        delta,\n        type: 'resizeTable'\n      });\n      this.changes.emit(action);\n    }\n    resizedColumn(state) {\n      this.resizedColumns.push(state);\n    }\n    end() {\n      this.changes.emit({\n        columns: [],\n        resizedColumns: this.resizedColumns,\n        type: 'end'\n      });\n      this.restoreInitialMaxMinWidths();\n      this.adjacentColumn = null;\n      this.draggedGroupColumn = null;\n      this.autoFitResize = false;\n    }\n    registerTable(tableMetadata) {\n      this.tables.push(tableMetadata);\n      const unregisterTable = () => {\n        this.tables.splice(this.tables.indexOf(tableMetadata), 1);\n      };\n      return unregisterTable;\n    }\n    measureColumns(info) {\n      if (this.batch !== null) {\n        this.batch.push(...info);\n      } else {\n        this.autoFitBatch(info, () => this.end());\n      }\n    }\n    autoFit(...columns) {\n      const nonLockedColumns = columns.filter(column => !column.isLocked);\n      this.autoFitStart(nonLockedColumns);\n      this.autoFitBatch(this.batch, () => {\n        if (nonLockedColumns.length < columns.length) {\n          const lockedColumns = columns.filter(column => column.isLocked);\n          this.autoFitStart(lockedColumns);\n          this.autoFitBatch(this.batch, () => this.end());\n        } else {\n          this.end();\n        }\n      });\n    }\n    trackColumns(column) {\n      this.resizedColumns = [];\n      this.column = column;\n    }\n    autoFitStart(columns) {\n      this.batch = [];\n      this.resizedColumns = [];\n      if (columns.length === 0) {\n        return;\n      }\n      const locked = columns[0].isLocked;\n      this.changes.emit({\n        type: 'start',\n        columns,\n        locked\n      });\n      this.changes.emit({\n        type: 'triggerAutoFit',\n        columns,\n        locked\n      });\n    }\n    autoFitBatch(info, onComplete) {\n      const locked = info.length > 0 ? info[0].column.isLocked : false;\n      const observables = this.tables.filter(table => table.locked === locked).map(table => table.autoFit(info));\n      zip$1(...observables).pipe(take(1)).subscribe(widths => {\n        this.changes.emit({\n          columns: info.map(i => i.column),\n          type: 'autoFitComplete',\n          widths,\n          locked\n        });\n        if (onComplete) {\n          onComplete();\n        }\n      });\n      this.batch = null;\n    }\n    restoreInitialMaxMinWidths() {\n      if (this.adjacentColumn) {\n        this.adjacentColumn.maxResizableWidth = this.adjacentColumn.initialMaxResizableWidth;\n        this.adjacentColumn.minResizableWidth = this.adjacentColumn.initialMinResizableWidth;\n      }\n      if (this.column) {\n        this.column.maxResizableWidth = this.column.initialMaxResizableWidth;\n        this.column.minResizableWidth = this.column.initialMinResizableWidth;\n      }\n    }\n  }\n  _class36 = ColumnResizingService;\n  _defineProperty(ColumnResizingService, \"\\u0275fac\", function _class36_Factory(t) {\n    return new (t || _class36)();\n  });\n  _defineProperty(ColumnResizingService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class36,\n    factory: _class36.ɵfac\n  }));\n  return ColumnResizingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;\nconst matchHeaderCell = matchesNodeName('th');\nconst matchDataCell = matchesNodeName('td');\nconst matchFooterCell = matchesNodeName('.k-grid-footer td');\nconst matchCell = element => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);\nconst gridCell = (element, gridElement) => {\n  let target = closest(element, matchCell);\n  while (target && !isInSameGrid(target, gridElement)) {\n    target = closest(target.parentElement, matchCell);\n  }\n  return target;\n};\nconst targetCell = (target, gridElement) => {\n  const cell = gridCell(target, gridElement);\n  const row = closest(cell, matchesNodeName('tr'));\n  if (cell && row) {\n    let rowIndex = row.getAttribute('aria-rowindex') || row.getAttribute('data-kendo-grid-row-index');\n    rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;\n    let colIndex = cell.getAttribute('aria-colindex');\n    colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;\n    if (rowIndex !== null && colIndex !== null) {\n      return {\n        colIndex,\n        rowIndex,\n        element: cell\n      };\n    }\n  }\n};\nconst isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight || keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;\nconst isNavigationKey = keyCode => isArrowKey(keyCode) || keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;\nconst isInput = matchesNodeName('input');\nconst isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';\nconst isPrintableCharacter = str => str.length === 1 && str.match(/\\S/);\nconst resizeStep = 10;\n/**\n * @hidden\n */\nclass NavigationViewport {\n  constructor(firstItemIndex, lastItemIndex) {\n    _defineProperty(this, \"firstItemIndex\", void 0);\n    _defineProperty(this, \"lastItemIndex\", void 0);\n    this.firstItemIndex = firstItemIndex;\n    this.lastItemIndex = lastItemIndex;\n  }\n  containsRow(dataRowIndex) {\n    const headerRow = dataRowIndex < 0;\n    return headerRow || dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex;\n  }\n  intersects(start, end) {\n    return start <= this.firstItemIndex && this.lastItemIndex <= end || this.firstItemIndex <= start && start <= this.lastItemIndex || this.firstItemIndex <= end && end <= this.lastItemIndex;\n  }\n}\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class38;\n  class NavigationService {\n    set metadata(value) {\n      this.meta = value;\n      this.cursor.metadata = value;\n    }\n    get metadata() {\n      return this.meta;\n    }\n    get enabled() {\n      return this.alive;\n    }\n    get pagerEnabled() {\n      return this.alive && this.pagerIsNavigable;\n    }\n    get tableEnabled() {\n      return this.alive && this.tableIsNavigable;\n    }\n    get toolbarEnabled() {\n      return this.alive && this.toolbarIsNavigable;\n    }\n    get activeCell() {\n      if (this.mode !== 0 /* NavigationMode.Standby */) {\n        return this.cursor.cell;\n      }\n    }\n    get activeRow() {\n      if (this.mode !== 0 /* NavigationMode.Standby */) {\n        return Object.assign({}, this.cursor.row, {\n          cells: this.cursor.row?.cells.toArray()\n        });\n      }\n    }\n    get isColumnResizable() {\n      const allColumns = Array.from(this.ctx.grid.columnsContainer.allColumns);\n      const column = allColumns.find(col => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);\n      if (!column.parent) {\n        if (column.isColumnGroup) {\n          return this.activeCell.colIndex + this.activeCell.colSpan !== this.ctx.grid.columnsContainer.leafColumnsToRender.length;\n        } else {\n          return this.activeCell.colIndex !== this.ctx.grid.columnsContainer.leafColumnsToRender.length - 1;\n        }\n      } else {\n        const columnGroup = column.parent;\n        const columnGroupChildren = Array.from(columnGroup.children).sort((a, b) => a.orderIndex - b.orderIndex);\n        const columnIndexInsideGroup = columnGroupChildren.indexOf(column);\n        if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {\n          return column.orderIndex - columnGroupChildren[0]['orderIndex'] !== columnGroupChildren.length - 1;\n        }\n        return columnIndexInsideGroup !== columnGroupChildren.length - 1;\n      }\n    }\n    get activeDataRow() {\n      return Math.max(0, this.activeRowIndex - this.meta.headerRows);\n    }\n    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, resizeService, focusableParent) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"pagerContextService\", void 0);\n      _defineProperty(this, \"scrollRequestService\", void 0);\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"detailsService\", void 0);\n      _defineProperty(this, \"focusRoot\", void 0);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"resizeService\", void 0);\n      _defineProperty(this, \"focusableParent\", void 0);\n      _defineProperty(this, \"changes\", void 0);\n      _defineProperty(this, \"cellKeydown\", new EventEmitter());\n      _defineProperty(this, \"viewport\", void 0);\n      _defineProperty(this, \"columnViewport\", void 0);\n      _defineProperty(this, \"activeRowIndex\", 0);\n      _defineProperty(this, \"alive\", false);\n      _defineProperty(this, \"active\", true);\n      _defineProperty(this, \"mode\", 0 /* NavigationMode.Standby */);\n      _defineProperty(this, \"model\", new NavigationModel());\n      _defineProperty(this, \"cursor\", new NavigationCursor(this.model));\n      _defineProperty(this, \"meta\", void 0);\n      _defineProperty(this, \"subs\", void 0);\n      _defineProperty(this, \"pendingRowIndex\", void 0);\n      _defineProperty(this, \"virtualCell\", void 0);\n      _defineProperty(this, \"pagerIsNavigable\", false);\n      _defineProperty(this, \"tableIsNavigable\", false);\n      _defineProperty(this, \"toolbarIsNavigable\", false);\n      _defineProperty(this, \"lastCellRowIndex\", void 0);\n      this.zone = zone;\n      this.domEvents = domEvents;\n      this.pagerContextService = pagerContextService;\n      this.scrollRequestService = scrollRequestService;\n      this.groupsService = groupsService;\n      this.detailsService = detailsService;\n      this.focusRoot = focusRoot;\n      this.editService = editService;\n      this.cd = cd;\n      this.ctx = ctx;\n      this.resizeService = resizeService;\n      this.focusableParent = focusableParent;\n      this.changes = this.cursor.changes;\n    }\n    init(meta, navigableOptions) {\n      this.setActiveSections(navigableOptions);\n      this.alive = true;\n      this.focusRoot.active = true;\n      this.metadata = meta;\n      const onStableSubscriber = (...operators) => args => this.zone.isStable ? from([true]).pipe(map(() => args)) : this.zone.onStable.pipe(take(1), map(() => args), ...operators);\n      const onStable = onStableSubscriber();\n      this.subs = new Subscription();\n      this.subs.add(this.cursor.changes.subscribe(args => this.onCursorChanges(args)));\n      this.subs.add(this.domEvents.focus.pipe(switchMap(onStable)).subscribe(args => this.navigateTo(args.target)));\n      this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus)))).subscribe(args => this.onFocusOut(args)));\n      this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */)).subscribe(() => this.onWindowBlur()));\n      this.subs.add(\n      // Closing the editor will not always trigger focusout in Firefox.\n      // To get around this, we ensure that the cell is closed after editing.\n      this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* NavigationMode.Content */), filter(e => e.action === 'cellClose' && !e.prevented), switchMap(onStable)).subscribe(() => this.leaveCell()));\n      this.subs.add(this.pagerContextService.pageChange.subscribe(() => this.cursor.reset(0, 0)));\n      this.subs.add(this.domEvents.keydown.subscribe(args => this.onKeydown(args)));\n      this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2 /* NavigationMode.Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(\n      // Timeout if focusOut doesn't fire very soon\n      interval(0).pipe(take(1)))))).subscribe(() => this.onTabout()));\n      if (this.focusableParent) {\n        const element = new GridFocusableElement(this);\n        this.focusableParent.registerElement(element);\n      }\n      this.deactivateElements();\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n      this.alive = false;\n    }\n    registerCell(cell) {\n      if (cell.logicalRowIndex !== this.pendingRowIndex) {\n        const modelCell = this.model.registerCell(cell);\n        if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {\n          this.virtualCell = false;\n        }\n      }\n    }\n    registerCellOnCurrentRow(cell) {\n      if (cell.logicalRowIndex === this.pendingRowIndex) {\n        this.model.registerCell(cell);\n      }\n    }\n    unregisterCell(index, rowIndex, cell) {\n      this.model.unregisterCell(index, rowIndex, cell);\n    }\n    registerRow(row) {\n      this.model.registerRow(row);\n      this.pendingRowIndex = row.logicalRowIndex;\n    }\n    updateRow(row) {\n      this.model.updateRow(row);\n    }\n    unregisterRow(index, row) {\n      this.model.unregisterRow(index, row);\n      const lastRow = this.model.lastRow;\n      if (lastRow && this.mode === 0 /* NavigationMode.Standby */) {\n        const maxIndex = this.needsViewport() && this.viewport ? this.viewport.lastItemIndex : lastRow.index;\n        if (this.activeRowIndex > maxIndex) {\n          this.cursor.reset(0, 0);\n        }\n      }\n    }\n    isCellFocusable(cell) {\n      return this.alive && this.active && this.mode !== 2 /* NavigationMode.Content */ && this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);\n    }\n    isCellFocused(cell) {\n      return this.mode === 1 /* NavigationMode.Cursor */ && this.isCellFocusable(cell);\n    }\n    navigateTo(el) {\n      if (!this.alive || !isDocumentAvailable()) {\n        return;\n      }\n      const cell = targetCell(el, this.meta.gridElement.nativeElement);\n      if (!cell) {\n        return;\n      }\n      const oldMode = this.mode;\n      const focusInCell = contains$1(cell.element, document.activeElement);\n      const focusInActiveRowContent = this.mode === 2 /* NavigationMode.Content */ && this.activeRowIndex === cell.rowIndex && el !== cell.element;\n      if (focusInCell) {\n        this.mode = 2 /* NavigationMode.Content */;\n        this.cursor.reset(cell.rowIndex, cell.colIndex);\n        this.activateRow();\n      } else if (!focusInActiveRowContent) {\n        this.mode = 1 /* NavigationMode.Cursor */;\n        this.deactivateElements();\n        const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);\n        const isCursor = oldMode === 1 /* NavigationMode.Cursor */ && alreadyActive;\n        if (!isCursor) {\n          this.cursor.reset(cell.rowIndex, cell.colIndex);\n        }\n      }\n    }\n    tryFocus(el) {\n      this.activateElements();\n      const focusable = findFocusableChild(el);\n      if (focusable) {\n        const cell = targetCell(focusable, this.meta.gridElement.nativeElement);\n        if (cell) {\n          this.cursor.reset(cell.rowIndex, cell.colIndex);\n          this.deactivateElements();\n          this.enterCell();\n        }\n        focusable.focus();\n      } else {\n        this.deactivateElements();\n      }\n      return !!focusable;\n    }\n    needsViewport() {\n      return this.meta && this.meta.isVirtual;\n    }\n    setViewport(firstItemIndex, lastItemIndex) {\n      this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n      if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {\n        const dataRowIndex = this.activeDataRow;\n        const ahead = firstItemIndex - dataRowIndex;\n        const behind = dataRowIndex - lastItemIndex;\n        if (ahead > 0) {\n          this.cursor.reset(firstItemIndex + this.meta.headerRows);\n        } else if (behind > 0) {\n          this.cursor.reset(lastItemIndex - this.meta.headerRows);\n        }\n      }\n    }\n    setColumnViewport(firstItemIndex, lastItemIndex) {\n      this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n      if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {\n        const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;\n        const ahead = firstItemIndex - activeColumnIndex;\n        const behind = activeColumnIndex - lastItemIndex;\n        if (ahead > 0) {\n          this.cursor.reset(undefined, firstItemIndex, false);\n        } else if (behind > 0) {\n          this.cursor.reset(undefined, lastItemIndex, false);\n        }\n      }\n    }\n    focusCell(rowIndex = undefined, colIndex = undefined) {\n      this.mode = 1 /* NavigationMode.Cursor */;\n      this.cursor.reset(rowIndex, colIndex);\n      return this.activeCell;\n    }\n    focusCellByElement(el) {\n      const cell = targetCell(el, this.meta.gridElement.nativeElement);\n      if (cell) {\n        return this.focusCell(cell.rowIndex, cell.colIndex);\n      }\n    }\n    focusNextCell(wrap = true) {\n      return this.focusAdjacentCell(true, wrap);\n    }\n    focusPrevCell(wrap = true) {\n      return this.focusAdjacentCell(false, wrap);\n    }\n    toggle(active) {\n      this.active = active;\n      this.cursor.announce();\n    }\n    hasFocus() {\n      return this.mode === 1 /* NavigationMode.Cursor */ || this.mode === 2 /* NavigationMode.Content */;\n    }\n\n    autoFocusCell(start, end) {\n      return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);\n    }\n    setActiveSections(navigableOptions) {\n      this.pagerIsNavigable = navigableOptions.includes('pager');\n      this.tableIsNavigable = navigableOptions.includes('table');\n      this.toolbarIsNavigable = navigableOptions.includes('toolbar');\n    }\n    focusAdjacentCell(fwd, wrap) {\n      this.focusCell();\n      let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();\n      if (wrap && !success) {\n        success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);\n        if (success) {\n          const row = this.cursor.row;\n          const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row);\n          this.cursor.reset(row.index, colIdx);\n        }\n      }\n      if (success) {\n        return this.activeCell;\n      } else {\n        this.mode = 0 /* NavigationMode.Standby */;\n        this.cursor.announce();\n      }\n      return null;\n    }\n    enterCell() {\n      const cell = this.cursor.cell;\n      if (!cell) {\n        return;\n      }\n      const group = cell.focusGroup;\n      const focusable = group && group.canFocus();\n      this.mode = focusable ? 2 /* NavigationMode.Content */ : 1 /* NavigationMode.Cursor */;\n      this.cursor.announce();\n      if (focusable) {\n        this.activateRow();\n        group.focus();\n      }\n    }\n    leaveCell() {\n      const cell = this.cursor.cell;\n      if (!cell) {\n        return;\n      }\n      const group = cell.focusGroup;\n      const focusable = group && group.canFocus();\n      if (!focusable) {\n        this.deactivateElements();\n      }\n      this.mode = 1 /* NavigationMode.Cursor */;\n      this.cursor.announce();\n    }\n    activateElements() {\n      this.focusRoot.activate();\n    }\n    deactivateElements() {\n      this.focusRoot.deactivate();\n    }\n    activateRow() {\n      this.cursor.row.cells.forEach(cell => cell.focusGroup && cell.focusGroup.activate());\n    }\n    moveCursorFwd() {\n      this.lastCellRowIndex = this.activeCell.rowIndex;\n      return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();\n    }\n    moveCursorBwd() {\n      this.lastCellRowIndex = this.activeCell.rowIndex;\n      return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();\n    }\n    onCursorKeydown(args) {\n      let preventDefault = false;\n      const modifier = args.ctrlKey || args.metaKey;\n      let step = modifier ? 5 : 1;\n      const rowspan = +args.target?.getAttribute('rowspan');\n      let rowspanOffset = 0;\n      if (!this.onCellKeydown(args)) {\n        return;\n      }\n      const row = this.cursor.row;\n      const dir = args.keyCode === Keys.ArrowDown ? 'Down' : 'Up';\n      const right = args.keyCode === Keys.ArrowRight;\n      switch (args.keyCode) {\n        case Keys.ArrowDown:\n        case Keys.ArrowUp:\n          if (rowspan > 1) {\n            rowspanOffset = this.calculateRowspanOffset(dir, rowspan);\n            step += rowspanOffset;\n          }\n          if (args.shiftKey) {\n            if (this.ctx.grid.blockArrowSelection) {\n              return;\n            }\n            preventDefault = this.cursor[`move${dir}`](step);\n            if (this.activeRow?.dataItem) {\n              const sign = dir === 'Down' ? 1 : -1;\n              this.handleVerticalArrowSelection(sign * step);\n            }\n          } else {\n            preventDefault = this.cursor[`move${dir}`](step);\n          }\n          this.lastCellRowIndex = this.activeRowIndex;\n          break;\n        case Keys.ArrowRight:\n        case Keys.ArrowLeft:\n          if (args.altKey && this.ctx.grid.resizable && this.isColumnResizable) {\n            this.columnResize(right);\n            break;\n          }\n          if (args.shiftKey) {\n            if (this.ctx.grid.blockArrowSelection) {\n              return;\n            }\n            preventDefault = this[`moveCursor${right ? 'Fwd' : 'Bwd'}`]();\n            this.handleHorizontalArrowSelection(args);\n          } else {\n            preventDefault = this[`moveCursor${right ? 'Fwd' : 'Bwd'}`]();\n          }\n          break;\n        case Keys.PageDown:\n          if (this.metadata.isVirtual && this.viewport) {\n            let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;\n            if (this.metadata.hasDetailTemplate) {\n              nextItemIndex++;\n            }\n            nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);\n            this.cursor.reset(nextItemIndex);\n            preventDefault = true;\n          } else if (this.metadata.hasPager) {\n            this.zone.run(() => this.pagerContextService.nextPage());\n            preventDefault = true;\n          }\n          break;\n        case Keys.PageUp:\n          if (this.metadata.isVirtual && this.viewport) {\n            const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;\n            const firstItemIndex = this.viewport.firstItemIndex;\n            const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);\n            this.cursor.reset(nextItemIndex);\n            preventDefault = true;\n          } else if (this.metadata.hasPager) {\n            this.zone.run(() => this.pagerContextService.prevPage());\n            preventDefault = true;\n          }\n          break;\n        case Keys.Home:\n          if (modifier) {\n            if (this.meta.isVirtual) {\n              this.cursor.reset(this.meta.headerRows, 0, false);\n            } else {\n              this.cursor.reset(this.model.firstRow.index, 0, false);\n            }\n          } else {\n            let firstColumnIndex = 0;\n            if (this.meta.hasDetailTemplate && row.index < this.meta.headerRows) {\n              firstColumnIndex = 1;\n            }\n            this.cursor.reset(row.index, firstColumnIndex, false);\n          }\n          preventDefault = true;\n          break;\n        case Keys.End:\n          if (modifier) {\n            if (this.meta.isVirtual) {\n              let lastRowIndex = this.meta.maxLogicalRowIndex;\n              if (this.meta.hasDetailTemplate) {\n                lastRowIndex--;\n              }\n              this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);\n            } else {\n              this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);\n            }\n          } else {\n            const lastIndex = this.cursor.lastCellIndex(row);\n            const cell = this.model.findCell(lastIndex, row);\n            if (cell) {\n              this.cursor.reset(cell.rowIndex, cell.colIndex);\n            } else {\n              this.cursor.reset(row.index, lastIndex);\n            }\n          }\n          preventDefault = true;\n          break;\n        case Keys.Enter:\n        case Keys.F2:\n          {\n            const groupItem = row.groupItem;\n            if (groupItem) {\n              this.zone.run(() => this.groupsService.toggleRow(groupItem));\n            } else if (this.cursor.cell.detailExpandCell) {\n              this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));\n            } else {\n              this.enterCell();\n              if (!this.cursor.cell.focusGroup.isNavigable()) {\n                preventDefault = true;\n              }\n            }\n            break;\n          }\n        default:\n          if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {\n            this.enterCell();\n          }\n      }\n      if (preventDefault) {\n        args.preventDefault();\n      }\n    }\n    columnResize(onRightArrow) {\n      const column = this.ctx.grid.columnsContainer.allColumns.find(col => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);\n      this.resizeService.start(column);\n      this.resizeService.resizeColumns(onRightArrow ? resizeStep : -1 * resizeStep);\n      if (this.resizeService.resizeColumns.length > 0) {\n        this.resizeService.end();\n      }\n    }\n    onContentKeydown(args) {\n      if (!this.onCellKeydown(args)) {\n        return;\n      }\n      const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);\n      if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {\n        this.leaveCell();\n        this.cursor.reset();\n        args.stopPropagation();\n      } else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {\n        this.onCursorKeydown(args);\n        if (args.defaultPrevented) {\n          this.leaveCell();\n        }\n      }\n    }\n    onCellKeydown(args) {\n      if (this.editService.isEditingCell()) {\n        const confirm = args.keyCode === Keys.Enter;\n        const cancel = args.keyCode === Keys.Escape;\n        const navigate = isNavigationKey(args.keyCode);\n        if (confirm) {\n          this.editService.closeCell(args);\n        } else if (cancel) {\n          this.editService.closeCell(args);\n          this.cd.detectChanges();\n        } else if (navigate) {\n          return false;\n        }\n      }\n      this.cellKeydown.emit(args);\n      return true;\n    }\n    onCursorChanges(args) {\n      this.activeRowIndex = args.rowIndex;\n      const dataRowIndex = this.activeDataRow;\n      if (this.meta && this.meta.isVirtual && args.rowIndex >= this.meta.headerRows && this.viewport && !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1) {\n        this.scrollRequestService.scrollTo({\n          row: dataRowIndex\n        });\n      }\n      if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {\n        const cell = this.activeCell;\n        const {\n          start,\n          end\n        } = this.model.cellRange(cell);\n        if (!cell) {\n          this.virtualCell = true;\n        }\n        if (!cell && this.mode !== 0 /* NavigationMode.Standby */ || cell && !this.columnViewport.intersects(start, end)) {\n          this.scrollRequestService.scrollTo({\n            column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0)\n          });\n        }\n      }\n    }\n    onFocusOut(args) {\n      if (isVisible(args.target)) {\n        this.mode = 0 /* NavigationMode.Standby */;\n      } else {\n        // Focused target is no longer visible,\n        // reset to cursor mode and recapture focus.\n        this.mode = 1 /* NavigationMode.Cursor */;\n      }\n\n      this.deactivateElements();\n      this.cursor.announce();\n    }\n    onWindowBlur() {\n      this.mode = 0 /* NavigationMode.Standby */;\n      this.deactivateElements();\n      this.cursor.announce();\n    }\n    onKeydown(args) {\n      if (this.mode === 1 /* NavigationMode.Cursor */) {\n        this.onCursorKeydown(args);\n      } else if (this.mode === 2 /* NavigationMode.Content */) {\n        this.onContentKeydown(args);\n      }\n    }\n    onTabout() {\n      // Tabbed out of the last focusable content element\n      // reset to cursor mode and recapture focus.\n      if (this.cursor.cell.focusGroup.isNavigable()) {\n        // Unless the cell has a single focusable element,\n        // otherwise we'd return to Content mode and enter an endless loop\n        return;\n      }\n      this.leaveCell();\n      this.cursor.reset();\n    }\n    handleVerticalArrowSelection(args) {\n      const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;\n      const rowSelectionEnabled = this.ctx.grid.selectionService.active && !this.ctx.grid.selectableSettings.checkboxOnly;\n      if (cellSelectionEnabled || rowSelectionEnabled) {\n        const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];\n        const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;\n        const rowIdx = this.activeRow.dataRowIndex - this.ctx.grid.skip;\n        const dataItem = selectionService.settings.view.at(rowIdx);\n        const item = {\n          index: this.activeRow.dataRowIndex,\n          data: dataItem,\n          column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]\n        };\n        if (selectionService.options.mode === 'multiple') {\n          cellSelectionEnabled ? this.handleMultipleArrowCellSelection(item) : this.handleMultipleArrowRowSelection(item);\n        } else {\n          selectionService.handleClick(item, args);\n        }\n      }\n    }\n    handleHorizontalArrowSelection(args) {\n      const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;\n      if (cellSelectionEnabled) {\n        const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];\n        const row = this.activeRow;\n        const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;\n        const dataItem = selectionService.settings.view.at(row.dataRowIndex - this.ctx.grid.skip);\n        const item = {\n          index: row.dataRowIndex,\n          data: dataItem,\n          column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]\n        };\n        if (!isPresent$1(dataItem) || !isPresent$1(item.column)) {\n          return;\n        }\n        if (selectionService.options.mode === 'multiple') {\n          this.handleMultipleArrowCellSelection(item);\n        } else {\n          selectionService.handleClick(item, args);\n        }\n      }\n    }\n    handleMultipleArrowCellSelection(item) {\n      const cellSelectionService = this.ctx.grid.cellSelectionService;\n      const startRowIndex = Math.min(cellSelectionService.lastSelectionItemRowIndex, item.index);\n      const startColIndex = Math.min(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);\n      const endRowIndex = Math.max(cellSelectionService.lastSelectionItemRowIndex, item.index);\n      const endColIndex = Math.max(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);\n      const ev = cellSelectionService.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);\n      cellSelectionService.changes.emit(ev);\n    }\n    handleMultipleArrowRowSelection(item) {\n      const rowSelectionService = this.ctx.grid.selectionService;\n      const startRowIndex = Math.min(rowSelectionService.lastSelectionStartIndex, item.index);\n      const endRowIndex = Math.max(rowSelectionService.lastSelectionStartIndex, item.index);\n      const ev = rowSelectionService.selectRange(startRowIndex, endRowIndex);\n      rowSelectionService.changes.emit(ev);\n    }\n    calculateRowspanOffset(direction, cellRowspan) {\n      if (!isPresent$1(this.lastCellRowIndex)) {\n        return 0;\n      }\n      const offset = direction === 'Up' ? Math.abs(this.lastCellRowIndex - this.activeRowIndex) : this.activeRowIndex + cellRowspan - this.lastCellRowIndex - 1;\n      return offset;\n    }\n  }\n  _class38 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class38_Factory(t) {\n    return new (t || _class38)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DomEventsService), i0.ɵɵinject(i44.PagerContextService), i0.ɵɵinject(ScrollRequestService), i0.ɵɵinject(GroupsService), i0.ɵɵinject(DetailsService), i0.ɵɵinject(FocusRoot), i0.ɵɵinject(EditService), i0.ɵɵinject(i0.ChangeDetectorRef), i0.ɵɵinject(ContextService), i0.ɵɵinject(ColumnResizingService), i0.ɵɵinject(FocusableDirective, 8));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class38,\n    factory: _class38.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\nconst hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);\nconst isDeleteButton = or(hasClass('k-i-x'), hasClass('k-svg-i-x'), hasClass('k-icon-button'));\nconst isSortIcon = or(hasClass('k-i-sort-asc-small'), hasClass('k-i-sort-desc-small'), hasClass('k-svg-i-sort-asc-small'), hasClass('k-svg-i-sort-desc-small'));\nconst skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName('label')));\nconst elementUnderCursor = ({\n  clientX,\n  clientY\n}) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);\nconst hideThenShow = (element, cont) => {\n  element.style.display = 'none';\n  const result = cont();\n  element.style.display = 'block';\n  return result;\n};\n/**\n * @hidden\n */\nlet DraggableColumnDirective = /*#__PURE__*/(() => {\n  var _class39;\n  class DraggableColumnDirective {\n    set enableDrag(enabled) {\n      this.enabled = enabled;\n      this.updateTouchAction();\n    }\n    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"hint\", void 0);\n      _defineProperty(this, \"cue\", void 0);\n      _defineProperty(this, \"nav\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"context\", {});\n      _defineProperty(this, \"drag\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"enabled\", void 0);\n      this.draggable = draggable;\n      this.element = element;\n      this.zone = zone;\n      this.service = service;\n      this.hint = hint;\n      this.cue = cue;\n      this.nav = nav;\n      this.renderer = renderer;\n    }\n    ngOnInit() {\n      this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(() => this.enabled), filter(({\n        originalEvent: {\n          target\n        }\n      }) => target === this.element.nativeElement || skipButtons(target)), tap(e => {\n        const originalEvent = e.originalEvent;\n        if (!e.isTouch) {\n          originalEvent.preventDefault();\n        }\n        this.nav.navigateTo(originalEvent.target);\n      }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(() => {\n        this.hint.create(this.context.hint);\n        this.cue.create();\n      }), switchMap(down => this.draggable.kendoDrag.pipe(tap(e => {\n        if (e.isTouch) {\n          e.originalEvent.preventDefault();\n        }\n      }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({\n        move,\n        down\n      })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    drop(upEvent) {\n      this.hint.remove();\n      this.cue.remove();\n      this.service.notifyDrop(this, upEvent);\n    }\n    performDrag({\n      move\n    }) {\n      this.hint.move(move);\n      const cursorElement = this.elementUnderCursor(move);\n      if (cursorElement) {\n        this.service.notifyDrag(this, cursorElement, move);\n      }\n      this.drag.emit({\n        draggable: this,\n        mouseEvent: move\n      });\n    }\n    elementUnderCursor(mouseEvent) {\n      this.hint.hide();\n      let target = elementUnderCursor(mouseEvent);\n      if (target && /k-grouping-dropclue/.test(target.className)) {\n        target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));\n      }\n      this.hint.show();\n      return target;\n    }\n    updateTouchAction() {\n      if (!this.element) {\n        return;\n      }\n      // eslint-disable-next-line no-unused-expressions\n      this.enabled ? this.renderer.addClass(this.element.nativeElement, 'k-touch-action-none') : this.renderer.removeClass(this.element.nativeElement, 'k-touch-action-none');\n    }\n  }\n  _class39 = DraggableColumnDirective;\n  _defineProperty(DraggableColumnDirective, \"\\u0275fac\", function _class39_Factory(t) {\n    return new (t || _class39)(i0.ɵɵdirectiveInject(i1$3.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DragAndDropService), i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(DraggableColumnDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class39,\n    selectors: [[\"\", \"kendoDraggableColumn\", \"\"]],\n    inputs: {\n      context: \"context\",\n      enableDrag: \"enableDrag\"\n    },\n    outputs: {\n      drag: \"drag\"\n    },\n    standalone: true\n  }));\n  return DraggableColumnDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DropTargetDirective = /*#__PURE__*/(() => {\n  var _class40;\n  class DropTargetDirective {\n    constructor(element, service) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"context\", {});\n      _defineProperty(this, \"enter\", new EventEmitter());\n      _defineProperty(this, \"leave\", new EventEmitter());\n      _defineProperty(this, \"drop\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.element = element;\n      this.service = service;\n    }\n    ngOnInit() {\n      this.service.add(this);\n      const changes = this.service.changes.pipe(filter(({\n        target\n      }) => target === this));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'leave')).subscribe(e => {\n        this.leave.next(this.eventArgs(e));\n      }));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'enter')).subscribe(e => {\n        this.enter.next(this.eventArgs(e));\n      }));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'drop')).subscribe(e => {\n        this.drop.next(this.eventArgs(e));\n      }));\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    eventArgs(e) {\n      return {\n        target: this,\n        mouseEvent: e.mouseEvent,\n        draggable: e.draggable\n      };\n    }\n  }\n  _class40 = DropTargetDirective;\n  _defineProperty(DropTargetDirective, \"\\u0275fac\", function _class40_Factory(t) {\n    return new (t || _class40)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DragAndDropService));\n  });\n  _defineProperty(DropTargetDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class40,\n    selectors: [[\"\", \"kendoDropTarget\", \"\"]],\n    inputs: {\n      context: \"context\"\n    },\n    outputs: {\n      enter: \"enter\",\n      leave: \"leave\",\n      drop: \"drop\"\n    },\n    standalone: true\n  }));\n  return DropTargetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction isColumnGroupComponent(column) {\n  return column.isColumnGroup;\n}\n/**\n * Represents the column group header of the Grid\n * ([more information and examples](slug:multicolumnheaders_columns_grid)).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *   <kendo-grid-column-group title=\"Product Info\">\n *     <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *     <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *   </kendo-grid-column-group>\n *   <kendo-grid-column field=\"UnitPrice\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ColumnGroupComponent = /*#__PURE__*/(() => {\n  var _class41;\n  class ColumnGroupComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      _defineProperty(this, \"parent\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"includeInChooser\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isColumnGroup\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"minResizableWidth\", 10);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"maxResizableWidth\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"children\", void 0);\n      this.parent = parent;\n      if (parent && parent.isSpanColumn) {\n        throw new Error(ColumnConfigurationErrorMessages.nestedInside('ColumnGroupComponent', 'SpanColumnComponent'));\n      }\n    }\n    /**\n     * @hidden\n     */\n    rowspan() {\n      return 1;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n      if (!this.children) {\n        return 1;\n      }\n      return columnsSpan(this.children.filter(child => child !== this && child.isVisible));\n    }\n    /**\n     * @hidden\n     */\n    get leafIndex() {\n      return this.children ? (this.firstChild || {}).leafIndex : -1;\n    }\n    get childrenArray() {\n      return this.children.filter(c => c !== this);\n    }\n    get hasChildren() {\n      return Boolean(this.firstChild);\n    }\n    get firstChild() {\n      return this.children.find(column => column !== this);\n    }\n  }\n  _class41 = ColumnGroupComponent;\n  _defineProperty(ColumnGroupComponent, \"\\u0275fac\", function _class41_Factory(t) {\n    return new (t || _class41)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(ColumnGroupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class41,\n    selectors: [[\"kendo-grid-column-group\"]],\n    contentQueries: function _class41_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class41)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class41_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ColumnGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).\n * To define the detail template, nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" selectable=\"true\" style=\"height: 160px\">\n *    <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *    <ng-template kendoGridDetailTemplate let-dataItem>\n *       <div *ngIf=\"dataItem.Category\">\n *          <header>{{dataItem.Category?.CategoryName}}</header>\n *          span>{{dataItem.Category?.Description}}</span>\n *       </div>\n *    </ng-template>\n * </kendo-grid>\n * ```\n *\n */\nlet DetailTemplateDirective = /*#__PURE__*/(() => {\n  var _class42;\n  class DetailTemplateDirective {\n    /**\n     * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.\n     */\n    set showIf(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('showIf', fn));\n      }\n      this._condition = fn;\n    }\n    get showIf() {\n      return this._condition;\n    }\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      _defineProperty(this, \"_condition\", () => true);\n      this.templateRef = templateRef;\n    }\n  }\n  _class42 = DetailTemplateDirective;\n  _defineProperty(DetailTemplateDirective, \"\\u0275fac\", function _class42_Factory(t) {\n    return new (t || _class42)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DetailTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class42,\n    selectors: [[\"\", \"kendoGridDetailTemplate\", \"\"]],\n    inputs: {\n      showIf: [\"kendoGridDetailTemplateShowIf\", \"showIf\"]\n    },\n    standalone: true\n  }));\n  return DetailTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColGroupComponent = /*#__PURE__*/(() => {\n  var _class43;\n  class ColGroupComponent {\n    constructor() {\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"sort\", new Array());\n    }\n    get columnsToRender() {\n      return columnsToRender(this.columns);\n    }\n    trackBy(index) {\n      return index;\n    }\n    isSorted(column) {\n      const state = this.sortDescriptor(column.field);\n      return this.isSortable(column) && (state.dir === 'asc' || state.dir === 'desc');\n    }\n    getColumnComponent(column) {\n      return column;\n    }\n    isSortable(column) {\n      return !isNullOrEmptyString(column.field) && isTruthy(column.sortable);\n    }\n    sortDescriptor(field) {\n      return this.sort.find(item => item.field === field) || {\n        field\n      };\n    }\n  }\n  _class43 = ColGroupComponent;\n  _defineProperty(ColGroupComponent, \"\\u0275fac\", function _class43_Factory(t) {\n    return new (t || _class43)();\n  });\n  _defineProperty(ColGroupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class43,\n    selectors: [[\"\", \"kendoGridColGroup\", \"\"]],\n    inputs: {\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      sort: \"sort\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c0,\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"k-group-col\", 4, \"ngFor\", \"ngForOf\"], [3, \"k-hierarchy-col\", 4, \"ngIf\"], [3, \"width\", \"k-sorted\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"]],\n    template: function _class43_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵtemplate(1, _class43_col_1_Template, 1, 2, \"col\", 0);\n        i0.ɵɵtemplate(2, _class43_col_2_Template, 1, 2, \"col\", 1);\n        i0.ɵɵtemplate(3, _class43_col_3_Template, 1, 4, \"col\", 2);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnsToRender)(\"ngForTrackBy\", ctx.trackBy);\n      }\n    },\n    dependencies: [NgFor, NgIf],\n    encapsulation: 2\n  }));\n  return ColGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Creates a loading template that overrides the default loading indicator of the Grid Component.\n * To define a loading template, nest an `<ng-template>` tag with the `kendoGridLoadingTemplate` directive inside the `<kendo-grid>` tag\n * ([see example](slug:loadingtemplate_grid)).\n */\nlet LoadingTemplateDirective = /*#__PURE__*/(() => {\n  var _class44;\n  class LoadingTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class44 = LoadingTemplateDirective;\n  _defineProperty(LoadingTemplateDirective, \"\\u0275fac\", function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(LoadingTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class44,\n    selectors: [[\"\", \"kendoGridLoadingTemplate\", \"\"]],\n    standalone: true\n  }));\n  return LoadingTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LoadingComponent = /*#__PURE__*/(() => {\n  var _class45;\n  class LoadingComponent {\n    get loadingText() {\n      return this.ctx.localization.get('loading');\n    }\n    constructor(ctx) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"loadingTemplate\", void 0);\n      this.ctx = ctx;\n    }\n  }\n  _class45 = LoadingComponent;\n  _defineProperty(LoadingComponent, \"\\u0275fac\", function _class45_Factory(t) {\n    return new (t || _class45)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(LoadingComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class45,\n    selectors: [[\"\", \"kendoGridLoading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class45_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-loading-mask\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      loadingTemplate: \"loadingTemplate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c1,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [1, \"k-loading-text\"], [1, \"k-loading-image\"], [1, \"k-loading-color\"], [3, \"ngTemplateOutlet\"]],\n    template: function _class45_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class45_ng_container_0_Template, 5, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class45_1_Template, 1, 1, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.loadingTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loadingTemplate);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return LoadingComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ResizeService = /*#__PURE__*/(() => {\n  var _class46;\n  class ResizeService {\n    constructor() {\n      _defineProperty(this, \"resizeSubscription\", new Subscription(() => {}));\n      _defineProperty(this, \"dispatcher\", new Subject());\n      _defineProperty(this, \"changes\", this.dispatcher.asObservable().pipe(throttleTime(100)));\n    }\n    connect(resizes) {\n      this.resizeSubscription.add(resizes.subscribe(this.dispatcher));\n    }\n    destroy() {\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n  }\n  _class46 = ResizeService;\n  _defineProperty(ResizeService, \"\\u0275fac\", function _class46_Factory(t) {\n    return new (t || _class46)();\n  });\n  _defineProperty(ResizeService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class46,\n    factory: _class46.ɵfac\n  }));\n  return ResizeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ResizableContainerDirective = /*#__PURE__*/(() => {\n  var _class47;\n  class ResizableContainerDirective {\n    set lockedWidth(value) {\n      this._lockedWidth = value;\n      if (this.enabled) {\n        this.attachResize();\n        this.resize();\n      }\n    }\n    set kendoGridResizableContainer(enabled) {\n      const refresh = enabled !== this.enabled;\n      this.enabled = enabled;\n      if (refresh) {\n        this.attachResize();\n        this.resize();\n      }\n    }\n    constructor(el, renderer, resizeService, ctx) {\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"resizeService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"_lockedWidth\", void 0);\n      _defineProperty(this, \"enabled\", false);\n      _defineProperty(this, \"resizeSubscription\", void 0);\n      this.el = el;\n      this.renderer = renderer;\n      this.resizeService = resizeService;\n      this.ctx = ctx;\n    }\n    ngOnDestroy() {\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n    attachResize() {\n      if (this.resizeSubscription && !this.enabled) {\n        this.resizeSubscription.unsubscribe();\n        this.resizeSubscription = null;\n      }\n      if (!this.resizeSubscription && this.enabled) {\n        this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));\n      }\n    }\n    resize() {\n      if (this.ctx.grid && this.ctx.grid.wrapper) {\n        const containerElement = this.ctx.grid.wrapper.nativeElement;\n        const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);\n        if (this.enabled && width > 0) {\n          this.renderer.setStyle(this.el.nativeElement, \"width\", width + \"px\");\n        } else {\n          this.renderer.setStyle(this.el.nativeElement, \"width\", \"\");\n        }\n      }\n    }\n  }\n  _class47 = ResizableContainerDirective;\n  _defineProperty(ResizableContainerDirective, \"\\u0275fac\", function _class47_Factory(t) {\n    return new (t || _class47)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ResizeService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(ResizableContainerDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class47,\n    selectors: [[\"\", \"kendoGridResizableContainer\", \"\"]],\n    inputs: {\n      lockedWidth: \"lockedWidth\",\n      kendoGridResizableContainer: \"kendoGridResizableContainer\"\n    },\n    standalone: true\n  }));\n  return ResizableContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FocusGroup = /*#__PURE__*/(() => {\n  var _class48;\n  class FocusGroup {\n    get focusableChildren() {\n      return this.children.filter(el => el.canFocus());\n    }\n    get isActive() {\n      return this.active;\n    }\n    constructor(root) {\n      _defineProperty(this, \"root\", void 0);\n      _defineProperty(this, \"active\", true);\n      _defineProperty(this, \"children\", []);\n      this.root = root;\n      this.root.registerGroup(this);\n    }\n    ngOnDestroy() {\n      this.root.unregisterGroup(this);\n      this.active = true;\n    }\n    registerElement(element) {\n      this.unregisterElement(element);\n      this.children.push(element);\n    }\n    unregisterElement(element) {\n      this.children = this.children.filter(f => f !== element);\n    }\n    /**\n     * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.\n     * Requires a single \"simple\" focusable element such as a button or a checkbox.\n     */\n    isNavigable() {\n      const focusable = this.focusableChildren;\n      return focusable.length === 1 && focusable[0].isNavigable();\n    }\n    canFocus() {\n      return this.focusableChildren.length > 0;\n    }\n    focus() {\n      if (this.canFocus() && !this.hasFocus()) {\n        this.focusableChildren[0].focus();\n      }\n    }\n    activate() {\n      this.toggleState(true);\n    }\n    deactivate() {\n      this.toggleState(false);\n    }\n    hasFocus() {\n      return this.children.reduce((focused, element) => focused || element.hasFocus(), false);\n    }\n    toggleState(active) {\n      if (this.active !== active) {\n        this.active = active;\n        this.children.forEach(f => f.toggle(active));\n      }\n    }\n  }\n  _class48 = FocusGroup;\n  _defineProperty(FocusGroup, \"\\u0275fac\", function _class48_Factory(t) {\n    return new (t || _class48)(i0.ɵɵinject(FocusRoot));\n  });\n  _defineProperty(FocusGroup, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class48,\n    factory: _class48.ɵfac\n  }));\n  return FocusGroup;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst reset = (...lists) => {\n  let diff = false;\n  for (let idx = 0; idx < lists.length; idx++) {\n    const [list, columns] = lists[idx];\n    diff = diff || list.length !== columns.length;\n    list.reset(columns);\n  }\n  return diff;\n};\n/**\n * @hidden\n */\nclass ColumnsContainer {\n  constructor(columns) {\n    _defineProperty(this, \"columns\", void 0);\n    _defineProperty(this, \"allColumns\", new QueryList());\n    _defineProperty(this, \"leafColumns\", new QueryList());\n    _defineProperty(this, \"lockedColumns\", new QueryList());\n    _defineProperty(this, \"nonLockedColumns\", new QueryList());\n    _defineProperty(this, \"lockedLeafColumns\", new QueryList());\n    _defineProperty(this, \"nonLockedLeafColumns\", new QueryList());\n    _defineProperty(this, \"totalLevels\", 0);\n    _defineProperty(this, \"changes\", new EventEmitter());\n    _defineProperty(this, \"leafColumnsToRender\", []);\n    _defineProperty(this, \"lockedColumnsToRender\", []);\n    _defineProperty(this, \"nonLockedColumnsToRender\", []);\n    _defineProperty(this, \"hasGroupHeaderColumn\", false);\n    _defineProperty(this, \"hasGroupFooter\", false);\n    _defineProperty(this, \"hasFooter\", false);\n    _defineProperty(this, \"unlockedWidth\", 0);\n    this.columns = columns;\n  }\n  refresh() {\n    const currentLevels = this.totalLevels;\n    const leafColumns = new Array();\n    const lockedLeafColumns = new Array();\n    const nonLockedLeafColumns = new Array();\n    const lockedColumns = new Array();\n    const nonLockedColumns = new Array();\n    const allColumns = new Array();\n    const leafColumnsToRender = new Array();\n    const lockedColumnsToRender = new Array();\n    const nonLockedColumnsToRender = new Array();\n    let hasGroupHeaderColumn = false;\n    let hasGroupFooter = false;\n    let hasFooter = false;\n    let unlockedWidth = 0;\n    let leafIndex = 0;\n    this.totalLevels = 0;\n    this.columns().forEach(column => {\n      const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;\n      const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;\n      const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;\n      if (!isColumnGroupComponent(column)) {\n        containerLeafColumns.push(column);\n        leafColumns.push(column);\n        leafColumnsToRender.push(...columnsToRender([column]));\n        toRenderContainer.push(...columnsToRender([column]));\n        hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);\n        hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);\n        hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);\n        if (!column.isLocked) {\n          unlockedWidth += column.width || 0;\n        }\n        if (column.isSpanColumn) {\n          column.childColumns.forEach(c => {\n            c.leafIndex = leafIndex++;\n          });\n        } else {\n          column.leafIndex = leafIndex++;\n        }\n      }\n      containerColumns.push(column);\n      allColumns.push(column);\n      this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;\n    });\n    this.hasGroupHeaderColumn = hasGroupHeaderColumn;\n    this.hasGroupFooter = hasGroupFooter;\n    this.hasFooter = hasFooter;\n    this.leafColumnsToRender = leafColumnsToRender;\n    this.lockedColumnsToRender = lockedColumnsToRender;\n    this.nonLockedColumnsToRender = nonLockedColumnsToRender;\n    this.unlockedWidth = unlockedWidth;\n    const changes = reset([this.leafColumns, leafColumns], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;\n    if (changes) {\n      this.changes.emit();\n    }\n    return changes;\n  }\n}\nconst NO_STICKY = {\n  left: '0px',\n  right: '0px'\n};\n/**\n * @hidden\n */\nlet ColumnInfoService = /*#__PURE__*/(() => {\n  var _class50;\n  class ColumnInfoService {\n    constructor() {\n      _defineProperty(this, \"visibilityChange\", new EventEmitter());\n      _defineProperty(this, \"lockedChange\", new EventEmitter());\n      _defineProperty(this, \"stickyChange\", new EventEmitter());\n      _defineProperty(this, \"columnRangeChange\", new EventEmitter());\n      _defineProperty(this, \"columnsContainer\", new ColumnsContainer(() => []));\n      _defineProperty(this, \"list\", void 0);\n      _defineProperty(this, \"stickyColumns\", void 0);\n    }\n    get lockedLeafColumns() {\n      return this.columnsContainer.lockedLeafColumns;\n    }\n    get nonLockedLeafColumns() {\n      return this.columnsContainer.nonLockedLeafColumns;\n    }\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n    get totalLevels() {\n      return this.columnsContainer.totalLevels;\n    }\n    get hiddenColumns() {\n      if (!this.list) {\n        return [];\n      }\n      return this.list().filter(column => !column.isVisible);\n    }\n    get leafNamedColumns() {\n      const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup)).filter(column => column.matchesMedia && column.displayTitle);\n      return orderBy(columns, [{\n        field: 'locked',\n        dir: 'desc'\n      }]);\n    }\n    get unlockedRootCount() {\n      return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;\n    }\n    stickyColumnsStyles(column) {\n      this.stickyColumns = this.list().rootColumns().filter(column => column.sticky && !column.locked && column.isVisible);\n      if (this.stickyColumns.length === 0) {\n        return NO_STICKY;\n      }\n      const result = this.stickyColumns.reduce((acc, curr) => {\n        if (curr.leafIndex < column.leafIndex) {\n          acc.left += curr.width;\n        } else if (curr.leafIndex > column.leafIndex) {\n          acc.right += curr.width;\n        }\n        return acc;\n      }, {\n        left: 0,\n        right: 0\n      });\n      return {\n        left: `${result.left}px`,\n        right: `${result.right}px`\n      };\n    }\n    init(columns, list) {\n      this.columnsContainer = columns;\n      this.list = list;\n      this.stickyColumns = null;\n    }\n    changeVisibility(columns) {\n      this.stickyColumns = null;\n      this.visibilityChange.emit(columns);\n    }\n    changeLocked(columns) {\n      this.stickyColumns = null;\n      this.lockedChange.emit(columns);\n    }\n    changeStuck(columns) {\n      this.stickyColumns = null;\n      this.stickyChange.emit(columns);\n    }\n  }\n  _class50 = ColumnInfoService;\n  _defineProperty(ColumnInfoService, \"\\u0275fac\", function _class50_Factory(t) {\n    return new (t || _class50)();\n  });\n  _defineProperty(ColumnInfoService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class50,\n    factory: _class50.ɵfac\n  }));\n  return ColumnInfoService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet id$3 = 0;\nfunction nextId$1() {\n  return id$3++;\n}\n/**\n * @hidden\n */\nlet LogicalCellDirective = /*#__PURE__*/(() => {\n  var _class51;\n  class LogicalCellDirective {\n    get id() {\n      if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {\n        return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);\n      }\n    }\n    get cellRowspan() {\n      return String(this.rowSpan);\n    }\n    get rowspanClass() {\n      return this.dataRowIndex > -1 && this.rowSpan > 1;\n    }\n    get ariaColIndex() {\n      if (this.logicalSlaveCell || this.logicalColIndex === -1) {\n        return undefined;\n      }\n      return this.logicalColIndex + 1;\n    }\n    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {\n      _defineProperty(this, \"focusGroup\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"idService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"logicalColIndex\", void 0);\n      _defineProperty(this, \"logicalRowIndex\", void 0);\n      _defineProperty(this, \"logicalSlaveCell\", false);\n      _defineProperty(this, \"colIndex\", void 0);\n      _defineProperty(this, \"colSpan\", 1);\n      _defineProperty(this, \"rowSpan\", 1);\n      _defineProperty(this, \"groupItem\", void 0);\n      _defineProperty(this, \"dataRowIndex\", -1);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"detailExpandCell\", false);\n      _defineProperty(this, \"headerLabelText\", void 0);\n      _defineProperty(this, \"uid\", nextId$1());\n      _defineProperty(this, \"navigationChange\", void 0);\n      this.focusGroup = focusGroup;\n      this.element = element;\n      this.columnInfoService = columnInfoService;\n      this.idService = idService;\n      this.navigationService = navigationService;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.cellContext = cellContext;\n    }\n    ngOnInit() {\n      if (!this.navigationService.tableEnabled) {\n        return;\n      }\n      this.navigationChange = this.navigationService.changes.subscribe(e => this.onNavigationChange(e));\n    }\n    ngDoCheck() {\n      if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {\n        return;\n      }\n      if (this.cellContext) {\n        this.cellContext.focusGroup = this.focusGroup;\n      }\n      this.registerNoChanges();\n    }\n    ngOnChanges(changes) {\n      if (!this.navigationService.tableEnabled) {\n        return;\n      }\n      const keys = Object.keys(changes);\n      if (keys.length === 1 && keys[0] === 'groupItem' || this.logicalColIndex === -1) {\n        // Ignore groupItem changes as the reference is not stable\n        return;\n      }\n      const indexChange = changes['logicalColIndex'];\n      const rowIndexChange = changes['logicalRowIndex'];\n      const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;\n      const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;\n      this.navigationService.unregisterCell(index, rowIndex, this);\n      this.registerChanges();\n      this.updateElement();\n    }\n    ngOnDestroy() {\n      if (this.navigationChange) {\n        this.navigationChange.unsubscribe();\n      }\n      this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);\n    }\n    onNavigationChange(e) {\n      const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;\n      const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;\n      if (active || wasActive) {\n        this.updateElement();\n      }\n    }\n    updateElement() {\n      const el = this.element.nativeElement;\n      this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');\n      if (this.isFocused()) {\n        if (this.focusGroup.isNavigable()) {\n          this.focusGroup.focus();\n        } else {\n          if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {\n            this.microtask(() => this.isFocused() && el.focus());\n          }\n          this.renderer.addClass(el, 'k-focus');\n        }\n        if (this.headerLabelText) {\n          el.removeAttribute('aria-label');\n        }\n      } else {\n        this.renderer.removeClass(el, 'k-focus');\n        if (this.headerLabelText) {\n          el.setAttribute('aria-label', this.headerLabelText);\n        }\n      }\n    }\n    microtask(callback) {\n      this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));\n    }\n    registerChanges() {\n      if (!this.logicalSlaveCell) {\n        this.navigationService.registerCell(this);\n      }\n    }\n    registerNoChanges() {\n      if (!this.logicalSlaveCell) {\n        this.navigationService.registerCellOnCurrentRow(this);\n      }\n    }\n    isFocusable() {\n      return this.navigationService.isCellFocusable(this);\n    }\n    isFocused() {\n      return this.navigationService.isCellFocused(this);\n    }\n  }\n  _class51 = LogicalCellDirective;\n  _defineProperty(LogicalCellDirective, \"\\u0275fac\", function _class51_Factory(t) {\n    return new (t || _class51)(i0.ɵɵdirectiveInject(FocusGroup), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(CELL_CONTEXT, 8));\n  });\n  _defineProperty(LogicalCellDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class51,\n    selectors: [[\"\", \"kendoGridLogicalCell\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class51_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"rowspan\", ctx.cellRowspan)(\"aria-colindex\", ctx.ariaColIndex);\n        i0.ɵɵclassProp(\"k-table-td-row-span\", ctx.rowspanClass);\n      }\n    },\n    inputs: {\n      logicalColIndex: \"logicalColIndex\",\n      logicalRowIndex: \"logicalRowIndex\",\n      logicalSlaveCell: \"logicalSlaveCell\",\n      colIndex: \"colIndex\",\n      colSpan: \"colSpan\",\n      rowSpan: \"rowSpan\",\n      groupItem: \"groupItem\",\n      dataRowIndex: \"dataRowIndex\",\n      dataItem: \"dataItem\",\n      detailExpandCell: \"detailExpandCell\",\n      headerLabelText: \"headerLabelText\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FocusGroup,\n      deps: [FocusRoot],\n      useClass: FocusGroup\n    }]), i0.ɵɵNgOnChangesFeature]\n  }));\n  return LogicalCellDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet id$2 = 0;\nfunction nextId() {\n  return id$2++;\n}\n/**\n * @hidden\n */\nlet LogicalRowDirective = /*#__PURE__*/(() => {\n  var _class52;\n  class LogicalRowDirective {\n    get hostRole() {\n      return this.logicalSlaveRow ? 'presentation' : 'row';\n    }\n    get ariaRowIndex() {\n      return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;\n    }\n    get rowIndex() {\n      return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;\n    }\n    get ariaOwns() {\n      if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {\n        return undefined;\n      }\n      const ids = [];\n      if (this.dataRowIndex < 0) {\n        let total = this.logicalCellsCount + this.logicalSlaveCellsCount;\n        this.columnsArray.forEach(column => {\n          if (column.isSpanColumn) {\n            total += column.colspan - 1;\n          }\n        });\n        for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {\n          ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));\n        }\n      } else {\n        let columnIndex = 0;\n        this.columnsArray.forEach(column => {\n          if (!column.isLocked) {\n            ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));\n          }\n          columnIndex += column.isSpanColumn ? column.colspan : 1;\n        });\n      }\n      return ids.join(' ');\n    }\n    constructor(idService, navigation) {\n      _defineProperty(this, \"idService\", void 0);\n      _defineProperty(this, \"navigation\", void 0);\n      _defineProperty(this, \"logicalRowIndex\", void 0);\n      _defineProperty(this, \"logicalSlaveRow\", false);\n      _defineProperty(this, \"logicalCellsCount\", void 0);\n      _defineProperty(this, \"logicalSlaveCellsCount\", 0);\n      _defineProperty(this, \"dataRowIndex\", -1);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"totalColumns\", void 0);\n      _defineProperty(this, \"uid\", nextId());\n      _defineProperty(this, \"tableRowClass\", true);\n      this.idService = idService;\n      this.navigation = navigation;\n    }\n    ngOnChanges(changes) {\n      if (!this.navigation.enabled || this.logicalSlaveRow) {\n        return;\n      }\n      const indexChange = changes.logicalRowIndex;\n      const logicalSlaveRowChange = changes.logicalSlaveRow;\n      if (indexChange || logicalSlaveRowChange) {\n        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;\n        this.navigation.unregisterRow(index, this);\n        this.navigation.registerRow(this);\n      } else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {\n        this.navigation.updateRow(this);\n      }\n    }\n    ngOnDestroy() {\n      this.navigation.unregisterRow(this.logicalRowIndex, this);\n    }\n    get columnsArray() {\n      return this.totalColumns?.allColumns.toArray() || [];\n    }\n  }\n  _class52 = LogicalRowDirective;\n  _defineProperty(LogicalRowDirective, \"\\u0275fac\", function _class52_Factory(t) {\n    return new (t || _class52)(i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(NavigationService));\n  });\n  _defineProperty(LogicalRowDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class52,\n    selectors: [[\"\", \"kendoGridLogicalRow\", \"\"]],\n    hostVars: 6,\n    hostBindings: function _class52_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole)(\"aria-rowindex\", ctx.ariaRowIndex)(\"data-kendo-grid-row-index\", ctx.rowIndex)(\"aria-owns\", ctx.ariaOwns);\n        i0.ɵɵclassProp(\"k-table-row\", ctx.tableRowClass);\n      }\n    },\n    inputs: {\n      logicalRowIndex: \"logicalRowIndex\",\n      logicalSlaveRow: \"logicalSlaveRow\",\n      logicalCellsCount: \"logicalCellsCount\",\n      logicalSlaveCellsCount: \"logicalSlaveCellsCount\",\n      dataRowIndex: \"dataRowIndex\",\n      dataItem: \"dataItem\",\n      totalColumns: \"totalColumns\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return LogicalRowDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FORMAT_REGEX = /\\{\\d+:?/;\n/**\n * @hidden\n */\nlet FieldAccessorPipe = /*#__PURE__*/(() => {\n  var _class53;\n  class FieldAccessorPipe {\n    constructor(intlService) {\n      _defineProperty(this, \"intlService\", void 0);\n      this.intlService = intlService;\n    }\n    transform(dataItem, fieldName, format) {\n      if (!isNullOrEmptyString(fieldName)) {\n        const value = getter(fieldName)(dataItem);\n        if (!isNullOrEmptyString(format)) {\n          return this.formatValue(format, value);\n        }\n        return value;\n      }\n      return dataItem;\n    }\n    formatValue(format, value) {\n      const intl = this.intlService;\n      if (isString(format) && format.match(FORMAT_REGEX)) {\n        return intl.format(format, value);\n      }\n      return intl.toString(value, format);\n    }\n  }\n  _class53 = FieldAccessorPipe;\n  _defineProperty(FieldAccessorPipe, \"\\u0275fac\", function _class53_Factory(t) {\n    return new (t || _class53)(i0.ɵɵdirectiveInject(i1$4.IntlService, 16));\n  });\n  _defineProperty(FieldAccessorPipe, \"\\u0275pipe\", /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"valueOf\",\n    type: _class53,\n    pure: false,\n    standalone: true\n  }));\n  return FieldAccessorPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet GridTableDirective = /*#__PURE__*/(() => {\n  var _class54;\n  class GridTableDirective {\n    get sizeSmallClass() {\n      return this.size === 'small';\n    }\n    get sizeMediumClass() {\n      return this.size === 'medium' || !this.size;\n    }\n    set size(size) {\n      this._size = size;\n      if (size === 'none') {\n        this.wrapper.nativeElement.classList.remove('k-table-sm', 'k-table-md');\n      }\n    }\n    get size() {\n      return this._size;\n    }\n    constructor(wrapper) {\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"_size\", 'medium');\n      this.wrapper = wrapper;\n    }\n  }\n  _class54 = GridTableDirective;\n  _defineProperty(GridTableDirective, \"\\u0275fac\", function _class54_Factory(t) {\n    return new (t || _class54)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(GridTableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class54,\n    selectors: [[\"\", \"kendoGridTable\", \"\"]],\n    hostVars: 6,\n    hostBindings: function _class54_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-table\", ctx.hostClass)(\"k-table-sm\", ctx.sizeSmallClass)(\"k-table-md\", ctx.sizeMediumClass);\n      }\n    },\n    inputs: {\n      size: \"size\"\n    },\n    standalone: true\n  }));\n  return GridTableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst forEachColumn = (list, callback) => {\n  list.forEach(column => {\n    callback(column);\n    if (column.isColumnGroup && column.hasChildren) {\n      forEachColumn(column.childrenArray, callback);\n    }\n  });\n};\nconst forEachLevel = (list, callback) => {\n  sortColumns(list).forEach(column => {\n    callback(column);\n    if (column.isColumnGroup && column.hasChildren) {\n      forEachLevel(column.childrenArray, callback);\n    }\n  });\n};\nconst filterHierarchy = (list, predicate) => {\n  const result = [];\n  sortColumns(list).forEach(column => {\n    if (predicate(column)) {\n      if (column.isColumnGroup) {\n        const children = filterHierarchy(column.childrenArray, predicate);\n        if (children.length) {\n          result.push(column, ...children);\n        }\n      } else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {\n        result.push(column);\n      }\n    }\n  });\n  return result.sort((a, b) => Number(b.locked) - Number(a.locked));\n};\n/**\n * @hidden\n */\nclass ColumnList {\n  static empty() {\n    return new ColumnList(new QueryList());\n  }\n  constructor(columns) {\n    _defineProperty(this, \"columns\", void 0);\n    this.columns = columns;\n  }\n  forEach(callback) {\n    forEachColumn(this.columns, callback);\n  }\n  filter(callback) {\n    const result = [];\n    forEachColumn(this.columns, column => {\n      if (callback(column)) {\n        result.push(column);\n      }\n    });\n    return result;\n  }\n  filterHierarchy(predicate) {\n    return filterHierarchy(this.columns.toArray(), predicate);\n  }\n  filterSort(callback) {\n    const result = [];\n    forEachLevel(this.columns.toArray(), column => {\n      if (callback(column)) {\n        result.push(column);\n      }\n    });\n    return result;\n  }\n  toArray() {\n    const result = [];\n    forEachColumn(this.columns, column => {\n      result.push(column);\n    });\n    return result;\n  }\n  rootColumns() {\n    return this.columns.toArray();\n  }\n  totalColumnLevels() {\n    let totalLevels = 0;\n    this.forEach(column => {\n      totalLevels = Math.max(column.level, totalLevels);\n    });\n    return totalLevels;\n  }\n}\n\n/**\n * @hidden\n */\nclass GroupInfoService {\n  constructor() {\n    _defineProperty(this, \"_columnList\", ColumnList.empty);\n  }\n  get columns() {\n    return expandColumns(this._columnList().toArray()).filter(isColumnComponent);\n  }\n  registerColumnsContainer(columns) {\n    this._columnList = columns;\n  }\n  formatForGroup(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.format : \"\";\n  }\n  isGroupable(groupField) {\n    const [column] = this.columns.filter(x => x.field === groupField);\n    return column ? column.groupable : true;\n  }\n  groupTitle(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.title || column.field : this.groupField(item);\n  }\n  groupHeaderTemplate(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;\n  }\n  groupField(group) {\n    return group.data ? group.data.field : group.field;\n  }\n  columnForGroup(group) {\n    const field = this.groupField(group);\n    const [column] = this.columns.filter(x => x.field === field);\n    return column;\n  }\n}\n\n/**\n * @hidden\n */\nlet GroupHeaderComponent = /*#__PURE__*/(() => {\n  var _class57;\n  class GroupHeaderComponent {\n    constructor(groupsService, groupInfoService, ctx) {\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"groupInfoService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"rowIndex\", void 0);\n      _defineProperty(this, \"logicalRowIndex\", void 0);\n      _defineProperty(this, \"item\", void 0);\n      _defineProperty(this, \"skipGroupDecoration\", false);\n      _defineProperty(this, \"hasDetails\", false);\n      _defineProperty(this, \"totalColumnsCount\", 0);\n      _defineProperty(this, \"hasGroupHeaderColumn\", void 0);\n      _defineProperty(this, \"groupHeaderColumns\", void 0);\n      _defineProperty(this, \"columns\", void 0);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"groupItemClass\", true);\n      _defineProperty(this, \"tableGroupRowClass\", true);\n      _defineProperty(this, \"isExpanded\", false);\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"caretAltRightIcon\", caretAltRightIcon);\n      _defineProperty(this, \"caretAltLeftIcon\", caretAltLeftIcon);\n      this.groupsService = groupsService;\n      this.groupInfoService = groupInfoService;\n      this.ctx = ctx;\n    }\n    ngDoCheck() {\n      const groupArgs = {\n        group: this.item.data,\n        groupIndex: this.item.index,\n        parentGroup: getGroupRowArgs(this.item.parentGroup)\n      };\n      this.isExpanded = this.groupsService.isExpanded(groupArgs);\n    }\n    prefixGroupCell(item) {\n      return new Array(item.level);\n    }\n    toggleGroup(item) {\n      this.groupsService.toggleRow(item);\n      return false;\n    }\n    groupSpan(item) {\n      const groupCount = (this.groups || []).length;\n      const detailOffset = this.hasDetails ? 1 : 0;\n      if (this.hasGroupHeaderColumn) {\n        return groupCount + 1 + detailOffset - item.level;\n      }\n      const columnCount = columnsSpan(this.columns);\n      if (this.skipGroupDecoration) {\n        return columnCount;\n      }\n      return groupCount + columnCount + detailOffset - item.level;\n    }\n    logicalColSpan() {\n      return this.skipGroupDecoration ? 1 : this.totalColumnsCount;\n    }\n    ariaRole() {\n      if (this.skipGroupDecoration) {\n        return 'presentation';\n      }\n      return 'gridcell';\n    }\n    formatForGroup(item) {\n      return this.groupInfoService.formatForGroup(item);\n    }\n    groupTitle(item) {\n      return this.groupInfoService.groupTitle(item);\n    }\n    groupHeaderTemplate(item) {\n      return this.groupInfoService.groupHeaderTemplate(item);\n    }\n    get groupButtonTitle() {\n      const messageKey = this.isExpanded ? 'groupCollapse' : 'groupExpand';\n      return this.ctx.localization.get(messageKey);\n    }\n    get arrowIcon() {\n      const icon = !this.isExpanded ? !this.ctx.localization.rtl ? 'caret-alt-right' : 'caret-alt-left' : 'caret-alt-down';\n      return icon;\n    }\n    get arrowSVGIcon() {\n      const icon = !this.isExpanded ? !this.ctx.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;\n      return icon;\n    }\n  }\n  _class57 = GroupHeaderComponent;\n  _defineProperty(GroupHeaderComponent, \"\\u0275fac\", function _class57_Factory(t) {\n    return new (t || _class57)(i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(GroupHeaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class57,\n    selectors: [[\"\", \"kendoGridGroupHeader\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class57_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grouping-row\", ctx.groupItemClass)(\"k-table-group-row\", ctx.tableGroupRowClass);\n      }\n    },\n    inputs: {\n      rowIndex: \"rowIndex\",\n      logicalRowIndex: \"logicalRowIndex\",\n      item: \"item\",\n      skipGroupDecoration: \"skipGroupDecoration\",\n      hasDetails: \"hasDetails\",\n      totalColumnsCount: \"totalColumnsCount\",\n      hasGroupHeaderColumn: \"hasGroupHeaderColumn\",\n      groupHeaderColumns: \"groupHeaderColumns\",\n      columns: \"columns\",\n      groups: \"groups\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c2,\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"aria-selected\", \"false\", \"class\", \"k-table-td\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\", 4, \"ngIf\"], [\"class\", \"k-group-cell k-table-td k-table-group-td\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-group-cell\", \"k-table-td\", \"k-table-group-td\"], [\"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\"], [1, \"k-reset\"], [\"href\", \"#\", \"tabindex\", \"-1\", \"role\", \"presentation\", 3, \"click\"], [3, \"name\", \"svgIcon\"], [3, \"templateContext\"], [\"role\", \"gridcell\", \"class\", \"k-table-td\", \"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"gridcell\", \"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class57_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class57_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class57_td_1_Template, 3, 9, \"td\", 1);\n        i0.ɵɵtemplate(2, _class57_ng_container_2_Template, 2, 1, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.skipGroupDecoration);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasGroupHeaderColumn);\n      }\n    },\n    dependencies: [NgIf, NgFor, LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe],\n    encapsulation: 2\n  }));\n  return GroupHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst withoutField = ({\n  field\n}) => isNullOrEmptyString(field);\nconst alreadyGrouped = ({\n  groups,\n  field\n}) => groups.some(group => group.field === field);\nconst overSameTarget = ({\n  target,\n  field\n}) => target.field === field;\nconst overLastTarget = ({\n  target\n}) => target.lastTarget;\nconst isLastGroup = ({\n  groups,\n  field\n}) => groups.map(group => group.field).indexOf(field) === groups.length - 1;\nconst isNotGroupable = groupsService => ({\n  field\n}) => !groupsService.isGroupable(field);\nconst columnRules = groupService => or(withoutField, alreadyGrouped, isNotGroupable(groupService));\nconst indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));\n/**\n * @hidden\n */\nlet GroupPanelComponent = /*#__PURE__*/(() => {\n  var _class58;\n  class GroupPanelComponent {\n    get groupHeaderClass() {\n      return true;\n    }\n    set text(value) {\n      this.emptyText = value;\n    }\n    get text() {\n      return this.emptyText ? this.emptyText : this.ctx.localization.get('groupPanelEmpty');\n    }\n    get gridId() {\n      return this.ctx.grid?.ariaRootId;\n    }\n    constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {\n      _defineProperty(this, \"hint\", void 0);\n      _defineProperty(this, \"cue\", void 0);\n      _defineProperty(this, \"groupInfoService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"change\", new EventEmitter());\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"dropTargets\", new QueryList());\n      _defineProperty(this, \"defaultTemplate\", void 0);\n      _defineProperty(this, \"groupTitles\", []);\n      _defineProperty(this, \"isChipMenuOpen\", false);\n      _defineProperty(this, \"rtl\", false);\n      _defineProperty(this, \"first\", void 0);\n      _defineProperty(this, \"last\", void 0);\n      _defineProperty(this, \"arrowLeftIcon\", arrowLeftIcon);\n      _defineProperty(this, \"arrowRightIcon\", arrowRightIcon);\n      _defineProperty(this, \"emptyText\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      _defineProperty(this, \"targetSubscription\", void 0);\n      _defineProperty(this, \"popupSubs\", void 0);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"activeItem\", void 0);\n      _defineProperty(this, \"handleKeyDown\", e => {\n        if (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowUp) {\n          e.preventDefault();\n          const relatedItemType = e.target.matches(':first-child') ? 'next' : 'previous';\n          this.activateMenuItem(e.target, relatedItemType);\n        } else if (e.keyCode === Keys.Escape) {\n          this.destroyMenu(true);\n        } else if (e.keyCode === Keys.Tab) {\n          this.destroyMenu(true);\n        } else if (e.keyCode === Keys.Space || e.keyCode === Keys.Enter) {\n          this.handleMenuClick(e);\n        }\n      });\n      _defineProperty(this, \"handleClick\", e => {\n        e.preventDefault();\n        const menuItemEl = e.target.closest('.k-menu-item');\n        if (!menuItemEl.matches('[aria-disabled=\"true\"]')) {\n          this.handleMenuClick(e);\n          return;\n        }\n        if (menuItemEl.getAttribute('tabindex') === '0') {\n          return;\n        }\n        const activeMenuItem = menuItemEl.closest('.k-menu-group').querySelector('[tabindex=\"0\"]');\n        const relatedItemType = activeMenuItem.matches(':first-child') ? 'next' : 'previous';\n        this.activateMenuItem(activeMenuItem, relatedItemType);\n      });\n      this.hint = hint;\n      this.cue = cue;\n      this.groupInfoService = groupInfoService;\n      this.ctx = ctx;\n      this.cd = cd;\n      this.popupService = popupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      this.subscription = this.ctx.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.cd.markForCheck();\n      });\n      this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));\n    }\n    ngDoCheck() {\n      const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));\n      if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {\n        this.groupTitles = currentTitles;\n        this.cd.markForCheck();\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n      this.destroyMenu();\n    }\n    messageFor(token) {\n      return this.ctx.localization.get(token);\n    }\n    getTitle(group) {\n      return this.messageFor(group.dir === 'desc' ? 'sortedDescending' : 'sortedAscending');\n    }\n    getDirectionIcon(group) {\n      return group.dir === 'desc' ? 'sort-desc-sm' : 'sort-asc-sm';\n    }\n    getDirectionSvgIcon(group) {\n      return group.dir === 'desc' ? sortDescSmallIcon : sortAscSmallIcon;\n    }\n    directionChange(group) {\n      group.dir = group.dir ? group.dir : \"asc\";\n      group.dir = group.dir === 'asc' ? 'desc' : 'asc';\n      const index = this.groups.findIndex(x => x.field === group.field);\n      const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];\n      this.change.emit(groups);\n    }\n    insert(field, index) {\n      const groups = this.groups.filter(x => x.field !== field);\n      if (groups.length || this.groups.length === 0) {\n        this.change.emit([...groups.slice(0, index), {\n          field: field\n        }, ...groups.slice(index)]);\n      }\n    }\n    remove(group) {\n      this.destroyMenu();\n      this.change.emit(this.groups.filter(x => x.field !== group.field));\n    }\n    toggleMenu(chip, first, last, field) {\n      const anchor = chip.element.nativeElement.querySelector('.k-chip-action');\n      if (this.popupRef) {\n        const popupAnchor = this.popupRef.popup.instance.anchor;\n        this.destroyMenu();\n        if (anchor === popupAnchor) {\n          return;\n        }\n      }\n      this.first = first;\n      this.last = last;\n      const direction = this.ctx.localization.rtl ? 'right' : 'left';\n      this.popupRef = this.popupService.open({\n        anchor: anchor,\n        content: this.defaultTemplate,\n        anchorAlign: {\n          vertical: 'bottom',\n          horizontal: direction\n        },\n        popupAlign: {\n          vertical: 'top',\n          horizontal: direction\n        },\n        positionMode: 'absolute'\n      });\n      this.activeItem = this.dropTargets.find(dt => dt.context.field === field);\n      this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');\n      const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll('.k-menu-item'));\n      this.activateMenuItem(menuItems[1], 'previous');\n      this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.destroyMenu(true);\n      });\n      if (isUniversal()) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.popupSubs.add(fromEvent(document, 'click').pipe(filter(event => !closest(event.target, node => node === this.popupRef.popupElement || node.matches && node.matches('.k-chip-action')))).subscribe(() => {\n          this.destroyMenu();\n        }));\n      });\n    }\n    canDrop(draggable, target) {\n      const isIndicator = draggable.type === 'groupIndicator';\n      const rules = isIndicator ? indicatorRules : columnRules(this.groupInfoService);\n      return !rules({\n        field: draggable.field,\n        groups: this.groups,\n        target\n      });\n    }\n    attachTargets() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n      this.targetSubscription = new Subscription();\n      const enterStream = this.dropTargets.reduce((acc, target) => merge(acc, target.enter), from([]));\n      const leaveStream = this.dropTargets.reduce((acc, target) => merge(acc, target.leave), from([]));\n      const dropStream = this.dropTargets.reduce((acc, target) => merge(acc, target.drop), from([]));\n      this.targetSubscription.add(enterStream.pipe(tap(() => {\n        this.hint.removeLock();\n        this.destroyMenu();\n      }), filter(({\n        draggable,\n        target\n      }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));\n    }\n    enter({\n      draggable,\n      target\n    }) {\n      this.hint.enable();\n      let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);\n      if (this.ctx.localization.rtl) {\n        before = !before;\n      }\n      this.cue.position(position(target.element.nativeElement, before));\n    }\n    leave() {\n      this.hint.disable();\n      this.cue.hide();\n    }\n    drop({\n      target,\n      draggable\n    }) {\n      const field = draggable.context.field;\n      const index = this.dropTargets.toArray().indexOf(target);\n      this.insert(field, index);\n    }\n    destroyMenu(focusAnchor) {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.popupSubs && this.popupSubs.unsubscribe();\n        focusAnchor && this.activeItem.context.target.focus();\n      }\n    }\n    activateMenuItem(item, relatedItemType) {\n      this.renderer.setAttribute(item, 'tabindex', '-1');\n      this.renderer.removeClass(item, 'k-focus');\n      const relatedItem = item[`${relatedItemType}ElementSibling`];\n      this.renderer.setAttribute(relatedItem, 'tabindex', '0');\n      this.renderer.addClass(relatedItem, 'k-focus');\n      this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));\n    }\n    handleMenuClick(e) {\n      e.preventDefault();\n      if (e.target.getAttribute('aria-disabled') !== 'true') {\n        const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);\n        let groupChip, groupChipIndex;\n        for (let i = 0; i < chips.length; i++) {\n          if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest('.k-chip')) {\n            groupChip = chips[i];\n            groupChipIndex = i;\n            break;\n          }\n        }\n        const isPrev = e.target.closest('.k-menu-item').matches(':first-child');\n        if (isPrev && groupChipIndex > 0) {\n          this.insert(groupChip.context.field, groupChipIndex - 1);\n        } else if (!isPrev && groupChipIndex < chips.length - 1) {\n          this.insert(groupChip.context.field, groupChipIndex + 1);\n        }\n        this.destroyMenu(true);\n      }\n    }\n  }\n  _class58 = GroupPanelComponent;\n  _defineProperty(GroupPanelComponent, \"\\u0275fac\", function _class58_Factory(t) {\n    return new (t || _class58)(i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i5.PopupService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(GroupPanelComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class58,\n    selectors: [[\"kendo-grid-group-panel\"]],\n    viewQuery: function _class58_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 7, TemplateRef);\n        i0.ɵɵviewQuery(DropTargetDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropTargets = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class58_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grouping-header\", ctx.groupHeaderClass);\n      }\n    },\n    inputs: {\n      text: \"text\",\n      navigable: \"navigable\",\n      groups: \"groups\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 5,\n    vars: 3,\n    consts: [[\"class\", \"k-grouping-drop-container\", \"kendoDropTarget\", \"\", 3, \"context\", 4, \"ngIf\"], [\"role\", \"none\", 3, \"navigable\", 4, \"ngIf\"], [\"defaultTemplate\", \"\"], [\"kendoDropTarget\", \"\", 1, \"k-grouping-drop-container\", 3, \"context\"], [\"role\", \"none\", 3, \"navigable\"], [\"kendoDropTarget\", \"\", \"kendoDraggableColumn\", \"\", \"kendoDraggable\", \"\", 3, \"title\", \"enableDrag\", \"context\", \"label\", \"removable\", \"hasMenu\", \"icon\", \"svgIcon\", \"contentClick\", \"remove\", \"menuToggle\", \"keydown.alt.arrowdown\", 4, \"ngFor\", \"ngForOf\"], [\"kendoDropTarget\", \"\", \"kendoDraggableColumn\", \"\", \"kendoDraggable\", \"\", 3, \"title\", \"enableDrag\", \"context\", \"label\", \"removable\", \"hasMenu\", \"icon\", \"svgIcon\", \"contentClick\", \"remove\", \"menuToggle\", \"keydown.alt.arrowdown\"], [\"chip\", \"\"], [\"unselectable\", \"on\", \"role\", \"menu\", 1, \"k-group\", \"k-menu-group\", \"k-reset\", \"k-menu-group-md\", 3, \"kendoEventsOutsideAngular\"], [\"role\", \"menuitem\", \"unselectable\", \"on\", 1, \"k-item\", \"k-menu-item\"], [1, \"k-link\", \"k-menu-link\"], [3, \"name\", \"svgIcon\"], [1, \"k-menu-link-text\"]],\n    template: function _class58_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class58_div_0_Template, 2, 3, \"div\", 0);\n        i0.ɵɵtemplate(1, _class58_kendo_chiplist_1_Template, 2, 2, \"kendo-chiplist\", 1);\n        i0.ɵɵtemplate(2, _class58_div_2_Template, 2, 2, \"div\", 0);\n        i0.ɵɵtemplate(3, _class58_ng_template_3_Template, 11, 16, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.groups.length === 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.groups.length !== 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.groups.length !== 0);\n      }\n    },\n    dependencies: [NgIf, DropTargetDirective, ChipListComponent, NgFor, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return GroupPanelComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst localizeOperators$1 = operators => localization => Object.keys(operators).reduce((acc, key) => {\n  acc[operators[key]] = localization.get(key);\n  return acc;\n}, {});\nconst operatorTexts = localizeOperators$1({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterGteOperator\": \"gte\",\n  \"filterGtOperator\": \"gt\",\n  \"filterLteOperator\": \"lte\",\n  \"filterLtOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\",\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterAfterOrEqualOperator\": \"after-eq\",\n  \"filterAfterOperator\": \"after\",\n  \"filterBeforeOrEqualOperator\": \"before-eq\",\n  \"filterBeforeOperator\": \"before\"\n});\n/**\n * @hidden\n */\nconst toJSON = xs => xs.map(x => x.toJSON());\n/**\n * @hidden\n */\nlet FilterOperatorBase = /*#__PURE__*/(() => {\n  var _class59;\n  class FilterOperatorBase {\n    /**\n     * The text that will be displayed in the drop-down list.\n     * @readonly\n     * @type {string}\n     * @memberOf FilterOperatorBase\n     */\n    get text() {\n      return this._text;\n    }\n    set text(value) {\n      this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;\n    }\n    constructor(operator, ctx) {\n      _defineProperty(this, \"operator\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      _defineProperty(this, \"messages\", void 0);\n      _defineProperty(this, \"_text\", void 0);\n      this.operator = operator;\n      this.ctx = ctx;\n      this.messages = operatorTexts(this.ctx.localization);\n      this._text = this.messages[this.operator];\n      this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n      return {\n        text: this.text,\n        value: this.operator\n      };\n    }\n    refreshText() {\n      const update = this._text === this.messages[this.operator];\n      this.messages = operatorTexts(this.ctx.localization);\n      if (update) {\n        this._text = this.messages[this.operator];\n      }\n    }\n  }\n  _class59 = FilterOperatorBase;\n  _defineProperty(FilterOperatorBase, \"\\u0275fac\", function _class59_Factory(t) {\n    return new (t || _class59)(i0.ɵɵdirectiveInject('filterOperator'), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(FilterOperatorBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class59,\n    selectors: [[\"kendo-grid-filter-operator-base\"]],\n    inputs: {\n      text: \"text\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function _class59_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return FilterOperatorBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Contains` (**Contains**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet ContainsFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class60;\n  class ContainsFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"contains\", ctx);\n    }\n  }\n  _class60 = ContainsFilterOperatorComponent;\n  _defineProperty(ContainsFilterOperatorComponent, \"\\u0275fac\", function _class60_Factory(t) {\n    return new (t || _class60)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(ContainsFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class60,\n    selectors: [[\"kendo-filter-contains-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class60)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class60_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ContainsFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `DoesNotContain` (**Does not contain**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet DoesNotContainFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class61;\n  class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"doesnotcontain\", ctx);\n    }\n  }\n  _class61 = DoesNotContainFilterOperatorComponent;\n  _defineProperty(DoesNotContainFilterOperatorComponent, \"\\u0275fac\", function _class61_Factory(t) {\n    return new (t || _class61)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(DoesNotContainFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class61,\n    selectors: [[\"kendo-filter-not-contains-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class61)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class61_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return DoesNotContainFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `EndsWith` (**Ends with**) string filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet EndsWithFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class62;\n  class EndsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"endswith\", ctx);\n    }\n  }\n  _class62 = EndsWithFilterOperatorComponent;\n  _defineProperty(EndsWithFilterOperatorComponent, \"\\u0275fac\", function _class62_Factory(t) {\n    return new (t || _class62)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(EndsWithFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class62,\n    selectors: [[\"kendo-filter-endswith-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class62)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class62_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return EndsWithFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Equal` (**Is equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet EqualFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class63;\n  class EqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"eq\", ctx);\n    }\n  }\n  _class63 = EqualFilterOperatorComponent;\n  _defineProperty(EqualFilterOperatorComponent, \"\\u0275fac\", function _class63_Factory(t) {\n    return new (t || _class63)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(EqualFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class63,\n    selectors: [[\"kendo-filter-eq-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class63)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class63_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return EqualFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `IsEmpty` (**Is empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet IsEmptyFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class64;\n  class IsEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"isempty\", ctx);\n    }\n  }\n  _class64 = IsEmptyFilterOperatorComponent;\n  _defineProperty(IsEmptyFilterOperatorComponent, \"\\u0275fac\", function _class64_Factory(t) {\n    return new (t || _class64)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(IsEmptyFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class64,\n    selectors: [[\"kendo-filter-isempty-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class64)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class64_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return IsEmptyFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `IsNotEmpty` (**Is not empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet IsNotEmptyFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class65;\n  class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"isnotempty\", ctx);\n    }\n  }\n  _class65 = IsNotEmptyFilterOperatorComponent;\n  _defineProperty(IsNotEmptyFilterOperatorComponent, \"\\u0275fac\", function _class65_Factory(t) {\n    return new (t || _class65)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(IsNotEmptyFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class65,\n    selectors: [[\"kendo-filter-isnotempty-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class65)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class65_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return IsNotEmptyFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `IsNotNull` (**Is not null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet IsNotNullFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class66;\n  class IsNotNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"isnotnull\", ctx);\n    }\n  }\n  _class66 = IsNotNullFilterOperatorComponent;\n  _defineProperty(IsNotNullFilterOperatorComponent, \"\\u0275fac\", function _class66_Factory(t) {\n    return new (t || _class66)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(IsNotNullFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class66,\n    selectors: [[\"kendo-filter-isnotnull-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class66)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class66_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return IsNotNullFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `IsNull` (**Is null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet IsNullFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class67;\n  class IsNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"isnull\", ctx);\n    }\n  }\n  _class67 = IsNullFilterOperatorComponent;\n  _defineProperty(IsNullFilterOperatorComponent, \"\\u0275fac\", function _class67_Factory(t) {\n    return new (t || _class67)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(IsNullFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class67,\n    selectors: [[\"kendo-filter-isnull-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class67)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class67_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return IsNullFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `NotEqual` (**Is not equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet NotEqualFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class68;\n  class NotEqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"neq\", ctx);\n    }\n  }\n  _class68 = NotEqualFilterOperatorComponent;\n  _defineProperty(NotEqualFilterOperatorComponent, \"\\u0275fac\", function _class68_Factory(t) {\n    return new (t || _class68)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(NotEqualFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class68,\n    selectors: [[\"kendo-filter-neq-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class68)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class68_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return NotEqualFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `StartsWith` (**Starts with**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).\n *\n * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).\n */\nlet StartsWithFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class69;\n  class StartsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"startswith\", ctx);\n    }\n  }\n  _class69 = StartsWithFilterOperatorComponent;\n  _defineProperty(StartsWithFilterOperatorComponent, \"\\u0275fac\", function _class69_Factory(t) {\n    return new (t || _class69)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(StartsWithFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class69,\n    selectors: [[\"kendo-filter-startswith-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class69)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class69_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return StartsWithFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Greater` (**Is greater than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet GreaterFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class70;\n  class GreaterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"gt\", ctx);\n    }\n  }\n  _class70 = GreaterFilterOperatorComponent;\n  _defineProperty(GreaterFilterOperatorComponent, \"\\u0275fac\", function _class70_Factory(t) {\n    return new (t || _class70)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(GreaterFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class70,\n    selectors: [[\"kendo-filter-gt-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class70)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class70_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return GreaterFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet GreaterOrEqualToFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class71;\n  class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"gte\", ctx);\n    }\n  }\n  _class71 = GreaterOrEqualToFilterOperatorComponent;\n  _defineProperty(GreaterOrEqualToFilterOperatorComponent, \"\\u0275fac\", function _class71_Factory(t) {\n    return new (t || _class71)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(GreaterOrEqualToFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class71,\n    selectors: [[\"kendo-filter-gte-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class71)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class71_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return GreaterOrEqualToFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Less` (**Is less than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.\n *\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet LessFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class72;\n  class LessFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"lt\", ctx);\n    }\n  }\n  _class72 = LessFilterOperatorComponent;\n  _defineProperty(LessFilterOperatorComponent, \"\\u0275fac\", function _class72_Factory(t) {\n    return new (t || _class72)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(LessFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class72,\n    selectors: [[\"kendo-filter-lt-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class72)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class72_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return LessFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `LessOrEqualTo` (**Is less than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.\n *\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet LessOrEqualToFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class73;\n  class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"lte\", ctx);\n    }\n  }\n  _class73 = LessOrEqualToFilterOperatorComponent;\n  _defineProperty(LessOrEqualToFilterOperatorComponent, \"\\u0275fac\", function _class73_Factory(t) {\n    return new (t || _class73)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(LessOrEqualToFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class73,\n    selectors: [[\"kendo-filter-lte-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class73)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class73_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return LessOrEqualToFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Greater` (**Is after**) [date filter](slug:filtering_grid#toc-date-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet AfterFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class74;\n  class AfterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"after\", ctx);\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"gt\"\n      };\n    }\n  }\n  _class74 = AfterFilterOperatorComponent;\n  _defineProperty(AfterFilterOperatorComponent, \"\\u0275fac\", function _class74_Factory(t) {\n    return new (t || _class74)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(AfterFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class74,\n    selectors: [[\"kendo-filter-after-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class74)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class74_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return AfterFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `GreaterOrEqualTo` (**Is after or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet AfterEqFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class75;\n  class AfterEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"after-eq\", ctx);\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"gte\"\n      };\n    }\n  }\n  _class75 = AfterEqFilterOperatorComponent;\n  _defineProperty(AfterEqFilterOperatorComponent, \"\\u0275fac\", function _class75_Factory(t) {\n    return new (t || _class75)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(AfterEqFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class75,\n    selectors: [[\"kendo-filter-after-eq-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class75)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class75_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return AfterEqFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `LessOrEqualTo` (**Is before or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet BeforeEqFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class76;\n  class BeforeEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"before-eq\", ctx);\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"lte\"\n      };\n    }\n  }\n  _class76 = BeforeEqFilterOperatorComponent;\n  _defineProperty(BeforeEqFilterOperatorComponent, \"\\u0275fac\", function _class76_Factory(t) {\n    return new (t || _class76)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(BeforeEqFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class76,\n    selectors: [[\"kendo-filter-before-eq-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class76)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class76_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return BeforeEqFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `Less than` (**Is before**) [date filter](slug:filtering_grid#toc-date-filter) operator.\n * [See example](slug:filter_row#toc-default-filter-operator).\n */\nlet BeforeFilterOperatorComponent = /*#__PURE__*/(() => {\n  var _class77;\n  class BeforeFilterOperatorComponent extends FilterOperatorBase {\n    constructor(ctx) {\n      super(\"before\", ctx);\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"lt\"\n      };\n    }\n  }\n  _class77 = BeforeFilterOperatorComponent;\n  _defineProperty(BeforeFilterOperatorComponent, \"\\u0275fac\", function _class77_Factory(t) {\n    return new (t || _class77)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(BeforeFilterOperatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class77,\n    selectors: [[\"kendo-filter-before-operator\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => _class77)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class77_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return BeforeFilterOperatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n*/\nlet SizingOptionsService = /*#__PURE__*/(() => {\n  var _class78;\n  class SizingOptionsService {\n    constructor() {\n      _defineProperty(this, \"changes\", new Subject());\n    }\n  }\n  _class78 = SizingOptionsService;\n  _defineProperty(SizingOptionsService, \"\\u0275fac\", function _class78_Factory(t) {\n    return new (t || _class78)();\n  });\n  _defineProperty(SizingOptionsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class78,\n    factory: _class78.ɵfac\n  }));\n  return SizingOptionsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a component which accommodates the filter operators.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *   <kendo-grid-column field=\"ProductName\">\n *     <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *       <input />\n *       <kendo-grid-filter-cell-operators\n *         [operators]=\"[{text: 'Equals', value: 'eq'}]\">\n *       </kendo-grid-filter-cell-operators>\n *     </ng-template>\n *   </kendo-grid-column>\n * <kendo-grid>\n * ```\n */\nlet FilterCellOperatorsComponent = /*#__PURE__*/(() => {\n  var _class79;\n  class FilterCellOperatorsComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return true;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(ctx, sizing) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"sizing\", void 0);\n      _defineProperty(this, \"clearText\", 'Clear');\n      _defineProperty(this, \"filterClearIcon\", filterClearIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"filterSVGIcon\", filterIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"dropdown\", void 0);\n      /**\n       * The filter operators that will be displayed.\n       */\n      _defineProperty(this, \"operators\", []);\n      /**\n       * Determines if the **Clear** button will be displayed.\n       * @type {boolean}\n       */\n      _defineProperty(this, \"showButton\", void 0);\n      /**\n       * Determines if the list of operators will be displayed.\n       * @type {boolean}\n       * @default true\n       */\n      _defineProperty(this, \"showOperators\", true);\n      /**\n       * The selected operator.\n       * @type {string}\n       */\n      _defineProperty(this, \"value\", void 0);\n      /**\n       * The Grid column which the filter operators are associated with.\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * Fires when the operator is selected.\n       * @type {EventEmitter<string>}\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires when the **Clear** button is clicked.\n       * @type {EventEmitter<undefined>}\n       */\n      _defineProperty(this, \"clear\", new EventEmitter());\n      _defineProperty(this, \"subs\", void 0);\n      this.ctx = ctx;\n      this.sizing = sizing;\n    }\n    /**\n     * @hidden\n     */\n    onChange(dataItem) {\n      this.valueChange.emit(dataItem);\n    }\n    /**\n     * @hidden\n     */\n    clearClick() {\n      this.clear.emit();\n      return false;\n    }\n    /**\n     * @hidden\n     */\n    clearKeydown(args) {\n      if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {\n        this.clear.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n    dropdownKeydown(args) {\n      if (args.defaultPrevented) {\n        return;\n      }\n      if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {\n        this.dropdown.toggle(true);\n        args.preventDefault();\n      }\n    }\n    ngOnInit() {\n      this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get('filterClearButton'));\n      this.subs.add(this.sizing.changes.subscribe(size => this.size = size));\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterCellOperatorLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class79 = FilterCellOperatorsComponent;\n  _defineProperty(FilterCellOperatorsComponent, \"\\u0275fac\", function _class79_Factory(t) {\n    return new (t || _class79)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(FilterCellOperatorsComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class79,\n    selectors: [[\"kendo-grid-filter-cell-operators\"]],\n    viewQuery: function _class79_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c9, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class79_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell-operator\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      operators: \"operators\",\n      showButton: \"showButton\",\n      showOperators: \"showOperators\",\n      value: \"value\",\n      column: \"column\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      clear: \"clear\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"kendoGridFocusable\", \"\", \"class\", \"k-dropdown-operator\", \"icon\", \"filter\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"data\", \"value\", \"svgIcon\", \"valuePrimitive\", \"popupSettings\", \"size\", \"valueChange\", \"keydown\", 4, \"ngIf\"], [\"type\", \"button\", \"kendoButton\", \"\", \"kendoGridFocusable\", \"\", \"icon\", \"filter-clear\", 3, \"svgIcon\", \"title\", \"size\", \"click\", \"keydown\", 4, \"ngIf\"], [\"kendoGridFocusable\", \"\", \"icon\", \"filter\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-dropdown-operator\", 3, \"data\", \"value\", \"svgIcon\", \"valuePrimitive\", \"popupSettings\", \"size\", \"valueChange\", \"keydown\"], [\"dropdown\", \"\"], [\"type\", \"button\", \"kendoButton\", \"\", \"kendoGridFocusable\", \"\", \"icon\", \"filter-clear\", 3, \"svgIcon\", \"title\", \"size\", \"click\", \"keydown\"]],\n    template: function _class79_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class79_kendo_dropdownlist_0_Template, 2, 8, \"kendo-dropdownlist\", 0);\n        i0.ɵɵtemplate(1, _class79_button_1_Template, 1, 3, \"button\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButton);\n      }\n    },\n    dependencies: [NgIf, DropDownListComponent, FocusableDirective, ButtonComponent],\n    encapsulation: 2\n  }));\n  return FilterCellOperatorsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterInputDirective = /*#__PURE__*/(() => {\n  var _class80;\n  class FilterInputDirective {\n    set value(value) {\n      this.accessor.writeValue(value);\n    }\n    set disabled(value) {\n      this.accessor.setDisabledState(value);\n    }\n    constructor(valueAccessors, ngZone, element, renderer) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"change\", new EventEmitter());\n      _defineProperty(this, \"composing\", false);\n      _defineProperty(this, \"kendoInput\", void 0);\n      _defineProperty(this, \"filterDelay\", 500);\n      _defineProperty(this, \"columnLabel\", void 0);\n      _defineProperty(this, \"accessor\", void 0);\n      _defineProperty(this, \"changeRequests\", new Subject());\n      _defineProperty(this, \"changeRequestsSubscription\", void 0);\n      _defineProperty(this, \"unsubscribeEvents\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.accessor = valueAccessors[0];\n      ngZone.runOutsideAngular(() => {\n        const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);\n        const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);\n        this.unsubscribeEvents = () => {\n          unsubscribeStart();\n          unsubscribeEnd();\n        };\n      });\n    }\n    ngAfterViewInit() {\n      this.addAriaAttributes();\n      this.accessor.registerOnChange(x => this.filterDelay > 0 ? this.changeRequests.next(x) : this.change.emit(x));\n      this.subscribeChanges();\n    }\n    ngOnChanges(changes) {\n      if (isChanged$1('filterDelay', changes)) {\n        this.unsubscribeChanges();\n        this.subscribeChanges();\n      }\n    }\n    ngOnDestroy() {\n      this.unsubscribeChanges();\n      this.unsubscribeEvents();\n    }\n    subscribeChanges() {\n      this.changeRequestsSubscription = this.changeRequests.pipe(debounceTime(this.filterDelay), filter(() => !this.composing)).subscribe(x => this.change.emit(x));\n    }\n    unsubscribeChanges() {\n      if (this.changeRequestsSubscription) {\n        this.changeRequestsSubscription.unsubscribe();\n      }\n    }\n    addAriaAttributes() {\n      const ariaValue = this.columnLabel;\n      if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {\n        const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) || this.element.nativeElement;\n        this.renderer.setAttribute(focusableElement, 'aria-label', ariaValue);\n      } else {\n        const inputElement = this.element.nativeElement.querySelector('.k-input-inner');\n        const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;\n        if (ariaValue) {\n          this.renderer.setAttribute(elementToSetLabel, 'aria-label', ariaValue);\n        }\n      }\n    }\n  }\n  _class80 = FilterInputDirective;\n  _defineProperty(FilterInputDirective, \"\\u0275fac\", function _class80_Factory(t) {\n    return new (t || _class80)(i0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(FilterInputDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class80,\n    selectors: [[\"\", \"kendoFilterInput\", \"\"]],\n    contentQueries: function _class80_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KendoInput, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);\n      }\n    },\n    inputs: {\n      filterDelay: \"filterDelay\",\n      columnLabel: \"columnLabel\",\n      value: \"value\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return FilterInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet MenuTabbingService = /*#__PURE__*/(() => {\n  var _class81;\n  class MenuTabbingService {\n    constructor() {\n      _defineProperty(this, \"firstFocusable\", void 0);\n      _defineProperty(this, \"lastFocusable\", void 0);\n      _defineProperty(this, \"isColumnMenu\", false);\n      _defineProperty(this, \"isPopupOpen\", false);\n      _defineProperty(this, \"lastMenuItem\", void 0);\n      _defineProperty(this, \"isTabbedInterface\", false);\n    }\n  }\n  _class81 = MenuTabbingService;\n  _defineProperty(MenuTabbingService, \"\\u0275fac\", function _class81_Factory(t) {\n    return new (t || _class81)();\n  });\n  _defineProperty(MenuTabbingService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class81,\n    factory: _class81.ɵfac\n  }));\n  return MenuTabbingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a service to set the filter descriptor\n * ([see example]({% slug filter_row %}#toc-custom-filter-row-components)).\n */\nlet FilterService = /*#__PURE__*/(() => {\n  var _class82;\n  class FilterService {\n    /**\n     * Sets the filter descriptor.\n     *\n     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.\n     */\n    filter(value) {\n      this.changes.next(value);\n    }\n    /**\n     * @hidden\n     */\n    constructor(menuTabbingService) {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      /**\n       * Fires when the filter descriptors is set.\n       */\n      _defineProperty(this, \"changes\", new Subject());\n      this.menuTabbingService = menuTabbingService;\n    }\n  }\n  _class82 = FilterService;\n  _defineProperty(FilterService, \"\\u0275fac\", function _class82_Factory(t) {\n    return new (t || _class82)(i0.ɵɵinject(MenuTabbingService, 8));\n  });\n  _defineProperty(FilterService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class82,\n    factory: _class82.ɵfac\n  }));\n  return FilterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ScrollSyncService = /*#__PURE__*/(() => {\n  var _class83;\n  class ScrollSyncService {\n    constructor(ngZone) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changes\", new Subject());\n      _defineProperty(this, \"elements\", []);\n      _defineProperty(this, \"source\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"headerSubscription\", new Subscription());\n      _defineProperty(this, \"bodySubscription\", new Subscription());\n      this.ngZone = ngZone;\n      this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));\n    }\n    registerEmitter(el, sourceType) {\n      this.unregister(sourceType);\n      this.elements.push({\n        element: el,\n        sourceType\n      });\n      if (sourceType === \"body\" || sourceType === \"header\") {\n        this.ngZone.runOutsideAngular(() => {\n          const obs = fromEvent(el, \"scroll\").pipe(map(({\n            target: {\n              scrollLeft\n            }\n          }) => ({\n            scrollLeft,\n            sourceType\n          })));\n          const subscription = obs.pipe(distinctUntilChanged((x, y) => x.scrollLeft === y.scrollLeft), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType)).subscribe(x => this.changes.next(x));\n          subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType)).subscribe(() => this.source = undefined));\n          if (sourceType === \"body\") {\n            this.bodySubscription.add(subscription);\n          } else {\n            this.headerSubscription.add(subscription);\n          }\n        });\n      }\n    }\n    /**\n     * destroy\n     */\n    destroy() {\n      this.subscriptions.unsubscribe();\n      this.headerSubscription.unsubscribe();\n      this.bodySubscription.unsubscribe();\n    }\n    scrollLeft({\n      scrollLeft,\n      sourceType\n    }) {\n      this.ngZone.runOutsideAngular(() => {\n        this.elements.filter(x => sourceType !== x.sourceType).forEach(({\n          element\n        }) => element.scrollLeft = scrollLeft);\n      });\n    }\n    unregister(sourceType) {\n      const index = this.elements.findIndex(x => x.sourceType === sourceType);\n      if (index > -1) {\n        if (sourceType === \"header\") {\n          this.headerSubscription.unsubscribe();\n          this.headerSubscription = new Subscription();\n        } else if (sourceType === \"body\") {\n          this.bodySubscription.unsubscribe();\n          this.bodySubscription = new Subscription();\n        }\n        this.elements.splice(index, 1);\n      }\n    }\n  }\n  _class83 = ScrollSyncService;\n  _defineProperty(ScrollSyncService, \"\\u0275fac\", function _class83_Factory(t) {\n    return new (t || _class83)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(ScrollSyncService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class83,\n    factory: _class83.ɵfac\n  }));\n  return ScrollSyncService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst contains = (node, predicate) => {\n  while (node) {\n    if (predicate(node)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n};\n/**\n * Arguments for the `close` event of the filter and column-menu popup.\n */\nclass PopupCloseEvent extends PreventableEvent {\n  constructor(e) {\n    super();\n    /**\n     * The original DOM event that causes the popup to close.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    this.originalEvent = e;\n  }\n}\nconst DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';\n/**\n * The service that is used for the popups of the filter and column menus\n * ([see example]({% slug filter_menu %}#toc-filter-menu-with-popup)).\n */\nlet SinglePopupService = /*#__PURE__*/(() => {\n  var _class85;\n  class SinglePopupService {\n    /**\n     * @hidden\n     */\n    constructor(popupService, renderer, ngZone, scrollSyncService, ctx) {\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * Fires when the filter or column menus are about to close because the user clicked outside their popups.\n       * Used to prevent the popup from closing.\n       */\n      _defineProperty(this, \"onClose\", new Subject());\n      _defineProperty(this, \"removeClick\", void 0);\n      _defineProperty(this, \"pointerEventsSub\", new Subscription());\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"scrollSubscription\", void 0);\n      _defineProperty(this, \"canClosePopup\", true);\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.ctx = ctx;\n      this.scrollSubscription = scrollSyncService.changes.pipe(skip(1)).subscribe(() => this.destroy());\n    }\n    /**\n     * @hidden\n     */\n    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {\n      const toggle = isPresent(popupRef) && this.popupRef === popupRef;\n      this.destroy();\n      if (!toggle) {\n        const direction = this.ctx.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          },\n          anchor: anchor,\n          popupClass: popupClass,\n          content: template,\n          positionMode: \"absolute\"\n        });\n        this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');\n        this.attachClose(anchor);\n      }\n      const popupEl = this.popupRef?.popupElement;\n      if (popupEl) {\n        this.attachMouseListeners(popupEl);\n      }\n      return this.popupRef;\n    }\n    /**\n     * @hidden\n     */\n    destroy() {\n      if (this.popupRef) {\n        this.detachClose();\n        this.pointerEventsSub.unsubscribe();\n        this.pointerEventsSub = null;\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    ngOnDestroy() {\n      this.destroy();\n      this.scrollSubscription.unsubscribe();\n    }\n    detachClose() {\n      if (this.removeClick) {\n        this.removeClick();\n      }\n    }\n    attachClose(skipElement) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.detachClose();\n      this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen('document', 'click', e => {\n        if (!contains(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {\n          const args = new PopupCloseEvent(e);\n          this.onClose.next(args);\n          if (!args.isDefaultPrevented() && this.canClosePopup) {\n            this.destroy();\n          }\n          this.canClosePopup = true;\n        }\n      }));\n    }\n    attachMouseListeners(el) {\n      this.pointerEventsSub = new Subscription();\n      this.ngZone.runOutsideAngular(() => {\n        this.pointerEventsSub.add(this.renderer.listen(el, 'pointerdown', e => {\n          e.stopImmediatePropagation();\n          this.canClosePopup = false;\n        }));\n        this.pointerEventsSub.add(this.renderer.listen(el, 'pointerup', () => {\n          this.canClosePopup = true;\n        }));\n      });\n    }\n  }\n  _class85 = SinglePopupService;\n  _defineProperty(SinglePopupService, \"\\u0275fac\", function _class85_Factory(t) {\n    return new (t || _class85)(i0.ɵɵinject(i5.PopupService), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(ScrollSyncService), i0.ɵɵinject(ContextService));\n  });\n  _defineProperty(SinglePopupService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class85,\n    factory: _class85.ɵfac\n  }));\n  return SinglePopupService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst insertDefaultFilter = (index, rootFilter, filter) => {\n  rootFilter = rootFilter || {\n    filters: [],\n    logic: \"and\"\n  };\n  rootFilter.filters[index] = filter;\n  return filter;\n};\n/**\n * @hidden\n */\nconst setFilter = (index, filter, field, defaultOperator) => {\n  if (isPresent(filter) && isPresent(filter.filters) && filter.filters.length > index) {\n    return filter.filters[index];\n  } else {\n    return insertDefaultFilter(index, filter, {\n      field,\n      operator: defaultOperator\n    });\n  }\n};\n/**\n * @hidden\n */\nconst logicOperators = localization => [{\n  text: localization.get(\"filterAndLogic\"),\n  value: \"and\"\n}, {\n  text: localization.get(\"filterOrLogic\"),\n  value: \"or\"\n}];\n/**\n * @hidden\n */\nconst flatten = filter => {\n  if (isPresent(filter.filters)) {\n    return filter.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);\n  }\n  return [];\n};\nconst trimFilterByField = (filter, field) => {\n  if (isPresent(filter) && isPresent(filter.filters)) {\n    filter.filters = filter.filters.filter(x => {\n      if (isCompositeFilterDescriptor(x)) {\n        trimFilterByField(x, field);\n        return x.filters.length;\n      } else {\n        return x.field !== field;\n      }\n    });\n  }\n};\n/**\n * @hidden\n */\nconst filtersByField = (filter, field) => flatten(filter || {}).filter(x => x.field === field);\n/**\n * @hidden\n */\nconst filterByField = (filter, field) => {\n  const [currentFilter] = filtersByField(filter, field);\n  return currentFilter;\n};\n/**\n * @hidden\n */\nconst removeFilter = (filter, field) => {\n  trimFilterByField(filter, field);\n  return filter;\n};\n/**\n * @hidden\n */\nconst localizeOperators = operators => localization => Object.keys(operators).map(key => ({\n  text: localization.get(key),\n  value: operators[key]\n}));\n/**\n * An abstract base class for the filter-cell component ([see example]({% slug filter_row %}#toc-custom-filter-row-components)).\n */\nlet BaseFilterCellComponent = /*#__PURE__*/(() => {\n  var _class86;\n  class BaseFilterCellComponent {\n    get hostClasses() {\n      return true;\n    }\n    get operators() {\n      return this._operators?.length ? this._operators : this.defaultOperators;\n    }\n    set operators(values) {\n      this._operators = values;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(filterService) {\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"operatorList\", new QueryList());\n      _defineProperty(this, \"size\", 'medium');\n      /**\n       * The current root filter.\n       * @type {CompositeFilterDescriptor}\n       */\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"defaultOperators\", void 0);\n      _defineProperty(this, \"_operators\", void 0);\n      _defineProperty(this, \"operationListSubscription\", void 0);\n      this.filterService = filterService;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n      this.operationListSubscription = observe(this.operatorList).pipe(map(q => q.toArray()), map(toJSON)).subscribe(x => {\n        this.operators = x;\n      });\n    }\n    ngOnDestroy() {\n      if (this.operationListSubscription) {\n        this.operationListSubscription.unsubscribe();\n      }\n    }\n    filterByField(field) {\n      return filterByField(this.filter, field);\n    }\n    filtersByField(field) {\n      return filtersByField(this.filter, field);\n    }\n    removeFilter(field) {\n      return removeFilter(this.filter, field);\n    }\n    updateFilter(filter) {\n      const root = this.filter || {\n        filters: [],\n        logic: \"and\"\n      };\n      const [currentFilter] = flatten(root).filter(x => x.field === filter.field);\n      if (!isPresent(currentFilter)) {\n        root.filters.push(filter);\n      } else {\n        Object.assign(currentFilter, filter);\n      }\n      return root;\n    }\n    applyFilter(filter) {\n      this.filterService.filter(filter);\n    }\n  }\n  _class86 = BaseFilterCellComponent;\n  _defineProperty(BaseFilterCellComponent, \"\\u0275fac\", function _class86_Factory(t) {\n    return new (t || _class86)(i0.ɵɵdirectiveInject(FilterService));\n  });\n  _defineProperty(BaseFilterCellComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class86,\n    contentQueries: function _class86_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.operatorList = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class86_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      operators: \"operators\",\n      filter: \"filter\"\n    }\n  }));\n  return BaseFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;\nconst isChanged = (a, b) => {\n  if (a.length !== b.length) {\n    return true;\n  }\n  for (let idx = 0, len = a.length; idx < len; idx++) {\n    const prev = a[idx];\n    const curr = b[idx];\n    if (isCompositeFilterDescriptor(prev)) {\n      if (diffFilters(prev, curr[idx])) {\n        return true;\n      }\n    } else if (areDifferent(prev, curr)) {\n      return true;\n    }\n  }\n  return false;\n};\nconst copyObject = obj => {\n  const result = {};\n  Object.assign(result, obj);\n  if (obj.constructor !== Object) {\n    const proto = obj.constructor.prototype;\n    Object.getOwnPropertyNames(proto).forEach(property => {\n      if (property !== 'constructor' && property !== '__proto__' && property !== 'prototype' && proto.hasOwnProperty(property)) {\n        result[property] = obj[property];\n      }\n    });\n  }\n  return result;\n};\nconst cloneFilter = filter => copyObject(filter);\n/**\n * @hidden\n */\nconst cloneFilters = filter => {\n  if (!filter) {\n    return;\n  }\n  if (isCompositeFilterDescriptor(filter)) {\n    return {\n      filters: cloneFilters(filter.filters),\n      logic: filter.logic\n    };\n  } else if (Array.isArray(filter)) {\n    return filter.map(cloneFilters);\n  }\n  return cloneFilter(filter);\n};\n/**\n * @hidden\n */\nconst diffFilters = (a, b) => {\n  if (isPresent(a) && !isPresent(b)) {\n    return true;\n  }\n  if (!isPresent(a) && isPresent(b)) {\n    return true;\n  }\n  return isPresent(a) && isPresent(b) && isChanged(a.filters, b.filters);\n};\n\n/**\n * @hidden\n */\nlet FilterHostDirective = /*#__PURE__*/(() => {\n  var _class87;\n  class FilterHostDirective {\n    constructor(host, resolver) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"resolver\", void 0);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"component\", void 0);\n      this.host = host;\n      this.resolver = resolver;\n    }\n    ngOnInit() {\n      this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));\n      this.initComponent({\n        column: this.column,\n        filter: this.filter\n      });\n    }\n    ngOnDestroy() {\n      if (this.component) {\n        this.component.destroy();\n        this.component = null;\n      }\n    }\n    ngOnChanges(changes) {\n      if (anyChanged([\"column\", \"filter\"], changes)) {\n        this.initComponent({\n          column: this.column,\n          filter: this.filter\n        });\n      }\n    }\n    initComponent({\n      column,\n      filter\n    }) {\n      const instance = this.component.instance;\n      instance.column = column;\n      instance.filter = filter;\n    }\n  }\n  _class87 = FilterHostDirective;\n  _defineProperty(FilterHostDirective, \"\\u0275fac\", function _class87_Factory(t) {\n    return new (t || _class87)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(FilterHostDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class87,\n    selectors: [[\"\", \"kendoGridFilterHostBase\", \"\"]],\n    inputs: {\n      column: \"column\",\n      filter: \"filter\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return FilterHostDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-access-missing-member\nconst stringOperators$1 = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * Represents a base string filter component.\n */\nlet StringFilterComponent = /*#__PURE__*/(() => {\n  var _class88;\n  class StringFilterComponent extends BaseFilterCellComponent {\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n      return this.filterByField((this.column || {}).field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    constructor(filterService, ctx) {\n      super(filterService);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * The default filter operator.\n       * @type {string}\n       * @default 'contains'\n       */\n      _defineProperty(this, \"operator\", \"contains\");\n      _defineProperty(this, \"subscription\", void 0);\n      this.ctx = ctx;\n    }\n    ngOnInit() {\n      this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      super.ngOnDestroy();\n    }\n    localizationChange() {\n      this.defaultOperators = stringOperators$1(this.ctx.localization);\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n  }\n  _class88 = StringFilterComponent;\n  _defineProperty(StringFilterComponent, \"\\u0275fac\", function _class88_Factory(t) {\n    return new (t || _class88)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(StringFilterComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class88,\n    inputs: {\n      column: \"column\",\n      operator: \"operator\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return StringFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterMenuDropDownListDirective = /*#__PURE__*/(() => {\n  var _class89;\n  class FilterMenuDropDownListDirective {\n    constructor(host) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"filterMenuDropDownLabel\", void 0);\n      _defineProperty(this, \"keydownHandler\", e => {\n        if (e.keyCode === Keys.Escape && this.host.isOpen) {\n          e.stopPropagation();\n          this.host.toggle(false);\n        }\n      });\n      this.host = host;\n    }\n    ngAfterViewInit() {\n      const wrapperElement = this.host.wrapper.nativeElement;\n      wrapperElement.setAttribute('aria-label', this.filterMenuDropDownLabel);\n      wrapperElement.addEventListener('keydown', this.keydownHandler, true);\n    }\n    ngOnDestroy() {\n      this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);\n    }\n  }\n  _class89 = FilterMenuDropDownListDirective;\n  _defineProperty(FilterMenuDropDownListDirective, \"\\u0275fac\", function _class89_Factory(t) {\n    return new (t || _class89)(i0.ɵɵdirectiveInject(i1$5.DropDownListComponent));\n  });\n  _defineProperty(FilterMenuDropDownListDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class89,\n    selectors: [[\"\", \"kendoFilterMenuDropDown\", \"\"]],\n    inputs: {\n      filterMenuDropDownLabel: \"filterMenuDropDownLabel\"\n    },\n    standalone: true\n  }));\n  return FilterMenuDropDownListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);\nconst isEmptyValueOperator = operator => EMPTY_VALUE_OPERATORS.has(operator);\n/**\n * @hidden\n */\nlet FilterInputWrapperComponent = /*#__PURE__*/(() => {\n  var _class90;\n  class FilterInputWrapperComponent extends BaseFilterCellComponent {\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    get currentOperator() {\n      const filter = this.currentFilter;\n      if (!this._operator) {\n        this._operator = filter ? filter.operator : this.defaultOperator;\n      }\n      return this._operator;\n    }\n    set currentOperator(value) {\n      this._operator = value;\n      const emptyValueOperator = isEmptyValueOperator(value);\n      this.filterInputDisabled = emptyValueOperator;\n      if (emptyValueOperator) {\n        this.applyNoValueFilter(value);\n      } else if (!isBlank(value) && isPresent(this.currentFilter)) {\n        this.onChange(this.currentFilter.value);\n      }\n    }\n    get defaultOperator() {\n      if (!isNullOrEmptyString(this._defaultOperator)) {\n        return this._defaultOperator;\n      } else if (this.operators && this.operators.length) {\n        return this.operators[0].value;\n      }\n      return \"eq\";\n    }\n    set defaultOperator(value) {\n      this._defaultOperator = value;\n    }\n    set filterInputDisabled(disabled) {\n      if (!this.input) {\n        return;\n      }\n      this.input.disabled = disabled;\n    }\n    constructor(filterService) {\n      super(filterService);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"input\", void 0);\n      _defineProperty(this, \"_defaultOperator\", void 0);\n      _defineProperty(this, \"_operator\", void 0);\n      _defineProperty(this, \"changeSubscription\", void 0);\n    }\n    ngAfterContentInit() {\n      if (isPresent(this.input)) {\n        this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));\n        this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n      }\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      if (this.changeSubscription) {\n        this.changeSubscription.unsubscribe();\n      }\n    }\n    onChange(value) {\n      if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {\n        this.filterChange(isNullOrEmptyString(value) ? this.removeFilter(this.column.field) : this.updateFilter({\n          field: this.column.field,\n          operator: this.currentOperator,\n          value: value\n        }));\n      }\n    }\n    onClear() {\n      this.onChange(null);\n      this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);\n    }\n    applyNoValueFilter(operator) {\n      this.filterChange(this.updateFilter({\n        field: this.column.field,\n        operator: operator,\n        value: null\n      }));\n    }\n    ngOnChanges(changes) {\n      if (isChanged$1(\"filter\", changes, false)) {\n        this._operator = null;\n        this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n      }\n    }\n  }\n  _class90 = FilterInputWrapperComponent;\n  _defineProperty(FilterInputWrapperComponent, \"\\u0275fac\", function _class90_Factory(t) {\n    return new (t || _class90)(i0.ɵɵdirectiveInject(FilterService));\n  });\n  _defineProperty(FilterInputWrapperComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class90,\n    contentQueries: function _class90_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      defaultOperator: \"defaultOperator\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return FilterInputWrapperComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterMenuInputWrapperComponent = /*#__PURE__*/(() => {\n  var _class91;\n  class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return false;\n    }\n    constructor(ctx) {\n      super(null);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"isFirstDropDown\", void 0);\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      _defineProperty(this, \"firstOperatorDropDown\", void 0);\n      _defineProperty(this, \"_currentFilter\", void 0);\n      this.ctx = ctx;\n    }\n    ngAfterViewInit() {\n      const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService && this.filterService.menuTabbingService;\n      const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;\n      if (shouldFocusFirstFocusable && !isTabbedInterface) {\n        this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;\n        this.firstOperatorDropDown.focus();\n      }\n    }\n    operatorChange(dataItem) {\n      this.currentOperator = dataItem;\n    }\n    filterChange(filter) {\n      this.applyFilter(filter);\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n      return this._currentFilter;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    set currentFilter(value) {\n      this._currentFilter = value;\n    }\n    updateFilter(filter) {\n      Object.assign(this.currentFilter, filter);\n      return this.filter;\n    }\n    onChange(value) {\n      this.filterChange(this.updateFilter({\n        field: this.column.field,\n        operator: this.currentOperator,\n        value: value\n      }));\n    }\n    onShiftTab(e) {\n      e.stopImmediatePropagation();\n      if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {\n        e.preventDefault();\n        this.filterService.menuTabbingService.lastFocusable.focus();\n      }\n    }\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.ctx.localization.get('filterMenuOperatorsDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class91 = FilterMenuInputWrapperComponent;\n  _defineProperty(FilterMenuInputWrapperComponent, \"\\u0275fac\", function _class91_Factory(t) {\n    return new (t || _class91)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(FilterMenuInputWrapperComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class91,\n    selectors: [[\"kendo-grid-filter-menu-input-wrapper\"]],\n    viewQuery: function _class91_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DropDownListComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);\n      }\n    },\n    inputs: {\n      filterService: \"filterService\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\",\n      currentFilter: \"currentFilter\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c11,\n    decls: 2,\n    vars: 4,\n    consts: [[\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"value\", \"valuePrimitive\", \"valueChange\", \"keydown.shift.tab\"]],\n    template: function _class91_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 0);\n        i0.ɵɵlistener(\"valueChange\", function _class91_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n          return ctx.operatorChange($event);\n        })(\"keydown.shift.tab\", function _class91_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) {\n          return ctx.onShiftTab($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx.filterMenuDropDownLabel)(\"data\", ctx.operators)(\"value\", ctx.currentOperator)(\"valuePrimitive\", true);\n      }\n    },\n    dependencies: [DropDownListComponent, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  }));\n  return FilterMenuInputWrapperComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet StringFilterMenuInputComponent = /*#__PURE__*/(() => {\n  var _class92;\n  class StringFilterMenuInputComponent {\n    constructor(ctx) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"operators\", []);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"operator\", void 0);\n      _defineProperty(this, \"currentFilter\", void 0);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"isFirstDropDown\", void 0);\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      _defineProperty(this, \"placeholder\", void 0);\n      this.ctx = ctx;\n    }\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class92 = StringFilterMenuInputComponent;\n  _defineProperty(StringFilterMenuInputComponent, \"\\u0275fac\", function _class92_Factory(t) {\n    return new (t || _class92)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(StringFilterMenuInputComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class92,\n    selectors: [[\"kendo-grid-string-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\",\n      placeholder: \"placeholder\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 12,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"placeholder\", \"ngModel\"]],\n    template: function _class92_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0);\n        i0.ɵɵelement(1, \"kendo-textbox\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        let tmp_11_0;\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", 0)(\"placeholder\", ctx.placeholder)(\"ngModel\", (tmp_11_0 = ctx.currentFilter == null ? null : ctx.currentFilter.value) !== null && tmp_11_0 !== undefined ? tmp_11_0 : null);\n      }\n    },\n    dependencies: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule, i4.NgControlStatus, i4.NgModel],\n    encapsulation: 2\n  }));\n  return StringFilterMenuInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a string-filter menu component\n * ([see example](slug:filter_menu#toc-built-in-filter-menu-components)).\n *\n * ```html\n * <kendo-grid-column field=\"ProductName\">\n *   <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *     <kendo-grid-string-filter-menu\n *       [column]=\"column\"\n *       [filter]=\"filter\"\n *       [filterService]=\"filterService\">\n *     </kendo-grid-string-filter-menu>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet StringFilterMenuComponent = /*#__PURE__*/(() => {\n  var _class93;\n  class StringFilterMenuComponent extends StringFilterComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return false;\n    }\n    /**\n     * The current menu filter.\n     * @type {CompositeFilterDescriptor}\n     */\n\n    constructor(ctx) {\n      super(null, ctx);\n      _defineProperty(this, \"logicOperators\", logicOperators(this.ctx.localization));\n      _defineProperty(this, \"filter\", {\n        filters: [],\n        logic: \"and\"\n      });\n      /**\n       * Determines if the inputs of second criteria will displayed.\n       * @default true\n       */\n      _defineProperty(this, \"extra\", true);\n      /**\n       * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.\n       */\n      _defineProperty(this, \"filterService\", void 0);\n      /**\n       * The placeholder text for the filter input.\n       * @type {string}\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      /**\n       * The placeholder text for the second filter input. Applies when `extra` is set to `true`.\n       * @type {string}\n       */\n      _defineProperty(this, \"extraPlaceholder\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n    }\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    localizationChange() {\n      this.logicOperators = logicOperators(this.ctx.localization);\n      super.localizationChange();\n    }\n  }\n  _class93 = StringFilterMenuComponent;\n  _defineProperty(StringFilterMenuComponent, \"\\u0275fac\", function _class93_Factory(t) {\n    return new (t || _class93)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(StringFilterMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class93,\n    selectors: [[\"kendo-grid-string-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function _class93_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      placeholder: \"placeholder\",\n      extraPlaceholder: \"extraPlaceholder\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 10,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"isFirstDropDown\", \"placeholder\", \"menuTabbingService\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"placeholder\", \"menuTabbingService\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"placeholder\", \"menuTabbingService\"]],\n    template: function _class93_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-string-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, _class93_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, _class93_kendo_grid_string_filter_menu_input_2_Template, 1, 7, \"kendo-grid-string-filter-menu-input\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"isFirstDropDown\", true)(\"placeholder\", ctx.placeholder)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    dependencies: [StringFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  }));\n  return StringFilterMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-access-missing-member\nconst numericOperators = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterGteOperator\": \"gte\",\n  \"filterGtOperator\": \"gt\",\n  \"filterLteOperator\": \"lte\",\n  \"filterLtOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * Represents a base numeric filter component.\n */\nlet NumericFilterComponent = /*#__PURE__*/(() => {\n  var _class94;\n  class NumericFilterComponent extends BaseFilterCellComponent {\n    /**\n     * Specifies the number format used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n    get format() {\n      return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    get columnFormat() {\n      return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : \"n2\";\n    }\n    constructor(filterService, ctx) {\n      super(filterService);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * The default filter operator.\n       * @type {string}\n       * @default 'eq'\n       */\n      _defineProperty(this, \"operator\", \"eq\");\n      /**\n       * Specifies the value that is used to increment or decrement the component value.\n       * @type {numeric}\n       * @default 1\n       */\n      _defineProperty(this, \"step\", 1);\n      /**\n       * Specifies the smallest value that is valid.\n       * @type {number}\n       */\n      _defineProperty(this, \"min\", void 0);\n      /**\n       * Specifies the greatest value that is valid.\n       * @type {number}\n       */\n      _defineProperty(this, \"max\", void 0);\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n       * @type {boolean}\n       * @default true\n       */\n      _defineProperty(this, \"spinners\", true);\n      /**\n       * Specifies the number precision applied to the component value when it is focused.\n       * If the user enters a number with a greater precision than is currently configured, the component value is rounded.\n       *\n       * @type {number}\n       */\n      _defineProperty(this, \"decimals\", void 0);\n      _defineProperty(this, \"_format\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this.ctx = ctx;\n      this.defaultOperators = numericOperators(this.ctx.localization);\n    }\n    ngOnInit() {\n      this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      super.ngOnDestroy();\n    }\n    localizationChange() {\n      this.defaultOperators = numericOperators(this.ctx.localization);\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n  }\n  _class94 = NumericFilterComponent;\n  _defineProperty(NumericFilterComponent, \"\\u0275fac\", function _class94_Factory(t) {\n    return new (t || _class94)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(NumericFilterComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class94,\n    inputs: {\n      column: \"column\",\n      operator: \"operator\",\n      step: \"step\",\n      min: \"min\",\n      max: \"max\",\n      spinners: \"spinners\",\n      decimals: \"decimals\",\n      format: \"format\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return NumericFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet NumericFilterMenuInputComponent = /*#__PURE__*/(() => {\n  var _class95;\n  class NumericFilterMenuInputComponent {\n    constructor(ctx) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"operators\", []);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"operator\", void 0);\n      _defineProperty(this, \"currentFilter\", void 0);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"filterDelay\", void 0);\n      _defineProperty(this, \"isFirstDropDown\", void 0);\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      /**\n       * Specifies the value which is used to increment or decrement the component value.\n       * @type {numeric}\n       */\n      _defineProperty(this, \"step\", 1);\n      /**\n       * Specifies the smallest value that is valid.\n       * @type {number}\n       */\n      _defineProperty(this, \"min\", void 0);\n      /**\n       * Specifies the greatest value that is valid.\n       * @type {number}\n       */\n      _defineProperty(this, \"max\", void 0);\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n       * @type {boolean}\n       */\n      _defineProperty(this, \"spinners\", true);\n      /**\n       * Specifies the number precision tat is applied to the component value when it is focused.\n       * If the user enters a number with a greater precision than is currently configured, the component value is rounded.\n       *\n       * @type {number}\n       */\n      _defineProperty(this, \"decimals\", void 0);\n      /**\n       * Specifies the number format that is used when the component is not focused.\n       * By default, the `column.format` value is used (if set).\n       */\n      _defineProperty(this, \"format\", void 0);\n      /**\n       * The placeholder text for the filter input.\n       * @type {string}\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      this.ctx = ctx;\n    }\n    messageFor(key) {\n      return this.ctx.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class95 = NumericFilterMenuInputComponent;\n  _defineProperty(NumericFilterMenuInputComponent, \"\\u0275fac\", function _class95_Factory(t) {\n    return new (t || _class95)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(NumericFilterMenuInputComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class95,\n    selectors: [[\"kendo-grid-numeric-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      filterDelay: \"filterDelay\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\",\n      step: \"step\",\n      min: \"min\",\n      max: \"max\",\n      spinners: \"spinners\",\n      decimals: \"decimals\",\n      format: \"format\",\n      placeholder: \"placeholder\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 21,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"autoCorrect\", \"value\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"placeholder\"], [3, \"increment\", \"decrement\"]],\n    template: function _class95_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0)(1, \"kendo-numerictextbox\", 1);\n        i0.ɵɵelement(2, \"kendo-numerictextbox-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", ctx.filterDelay)(\"autoCorrect\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"increment\", ctx.messageFor(\"filterNumericIncrement\"))(\"decrement\", ctx.messageFor(\"filterNumericDecrement\"));\n      }\n    },\n    dependencies: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent],\n    encapsulation: 2\n  }));\n  return NumericFilterMenuInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a numeric filter-menu component.\n *\n * @example\n * ```html\n * <kendo-grid-column field=\"UnitPrice\">\n *   <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *     <kendo-grid-numeric-filter-menu\n *       [column]=\"column\"\n *       [filter]=\"filter\"\n *       [filterService]=\"filterService\">\n *     </kendo-grid-numeric-filter-menu>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet NumericFilterMenuComponent = /*#__PURE__*/(() => {\n  var _class96;\n  class NumericFilterMenuComponent extends NumericFilterComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return false;\n    }\n    /**\n     * The current menu filter.\n     * @type {CompositeFilterDescriptor}\n     */\n\n    constructor(ctx) {\n      super(null, ctx);\n      _defineProperty(this, \"logicOperators\", logicOperators(this.ctx.localization));\n      _defineProperty(this, \"filter\", {\n        filters: [],\n        logic: \"and\"\n      });\n      /**\n       * Determines if the inputs of second criteria will displayed.\n       * @default true\n       */\n      _defineProperty(this, \"extra\", true);\n      /**\n       * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.\n       */\n      _defineProperty(this, \"filterService\", void 0);\n      /**\n       * Determines the delay (in milliseconds) before creating a filter descriptor based on the value. A value of 0 indicates no delay. The default value is 500.\n       *\n       * @default 500\n       */\n      _defineProperty(this, \"filterDelay\", 500);\n      /**\n       * The placeholder text for the filter input.\n       * @type {string}\n       */\n      _defineProperty(this, \"placeholder\", '');\n      /**\n       * The placeholder text for the extra filter input. Applies when `extra` is set to `true`.\n       * @type {string}\n       */\n      _defineProperty(this, \"extraPlaceholder\", '');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n    }\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    localizationChange() {\n      this.logicOperators = logicOperators(this.ctx.localization);\n      super.localizationChange();\n    }\n  }\n  _class96 = NumericFilterMenuComponent;\n  _defineProperty(NumericFilterMenuComponent, \"\\u0275fac\", function _class96_Factory(t) {\n    return new (t || _class96)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(NumericFilterMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class96,\n    selectors: [[\"kendo-grid-numeric-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function _class96_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      filterDelay: \"filterDelay\",\n      placeholder: \"placeholder\",\n      extraPlaceholder: \"extraPlaceholder\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 17,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"filterDelay\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\", \"isFirstDropDown\", \"placeholder\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\", \"placeholder\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\", \"placeholder\"]],\n    template: function _class96_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-numeric-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, _class96_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, _class96_kendo_grid_numeric_filter_menu_input_2_Template, 1, 13, \"kendo-grid-numeric-filter-menu-input\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"filterDelay\", ctx.filterDelay)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step)(\"menuTabbingService\", ctx.menuTabbingService)(\"isFirstDropDown\", true)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    dependencies: [NumericFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  }));\n  return NumericFilterMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-access-missing-member\nconst dateOperators = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterAfterOrEqualOperator\": \"gte\",\n  \"filterAfterOperator\": \"gt\",\n  \"filterBeforeOrEqualOperator\": \"lte\",\n  \"filterBeforeOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * @hidden\n */\nlet DateFilterComponent = /*#__PURE__*/(() => {\n  var _class97;\n  class DateFilterComponent extends BaseFilterCellComponent {\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     *\n     * @readonly\n     * @type {string}\n     */\n    get format() {\n      return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n    /**\n     * Specifies the smallest value that is valid.\n     * @type {Date}\n     */\n\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    get columnFormat() {\n      return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : \"d\";\n    }\n    constructor(filterService, ctx) {\n      super(filterService);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * The default filter operator. Defaults to `contains`.\n       * @type {string}\n       * @default 'gte'\n       */\n      _defineProperty(this, \"operator\", \"gte\");\n      _defineProperty(this, \"min\", void 0);\n      /**\n       * Specifies the greatest value that is valid.\n       * @type {Date}\n       */\n      _defineProperty(this, \"max\", void 0);\n      /**\n       * Defines the descriptions of the format sections in the input field.\n       * [See example](slug:placeholders_datepicker#toc-format-sections-description).\n       */\n      _defineProperty(this, \"formatPlaceholder\", void 0);\n      /**\n       * Specifies the hint that the component displays when its value is `null`.\n       * [See example](slug:placeholders_datepicker#toc-text-hints).\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      /**\n       * Defines the active view that the calendar initially renders.\n       * By default, the active view is `month`.\n       * You have to set `activeView` within the `topView`-`bottomView` range.\n       * @default 'month'\n       */\n      _defineProperty(this, \"activeView\", \"month\");\n      /**\n       * Defines the bottommost calendar view, to which the user can navigate.\n       * @default 'month'\n       */\n      _defineProperty(this, \"bottomView\", \"month\");\n      /**\n       * Defines the topmost calendar view, to which the user can navigate.\n       * @default 'century'\n       */\n      _defineProperty(this, \"topView\", \"century\");\n      /**\n       * Determines whether to display a week number column in the `month` view of the Calendar.\n       * @default false\n       */\n      _defineProperty(this, \"weekNumber\", false);\n      _defineProperty(this, \"_format\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this.ctx = ctx;\n      this.defaultOperators = dateOperators(this.ctx.localization);\n    }\n    ngOnInit() {\n      this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      super.ngOnDestroy();\n    }\n    localizationChange() {\n      this.defaultOperators = dateOperators(this.ctx.localization);\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n  }\n  _class97 = DateFilterComponent;\n  _defineProperty(DateFilterComponent, \"\\u0275fac\", function _class97_Factory(t) {\n    return new (t || _class97)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(DateFilterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class97,\n    selectors: [[\"kendo-grid-date-filter-base\"]],\n    inputs: {\n      column: \"column\",\n      operator: \"operator\",\n      format: \"format\",\n      min: \"min\",\n      max: \"max\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      weekNumber: \"weekNumber\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class97_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return DateFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DateFilterMenuInputComponent = /*#__PURE__*/(() => {\n  var _class98;\n  class DateFilterMenuInputComponent {\n    constructor(popupService, ctx) {\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"operators\", []);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"operator\", void 0);\n      _defineProperty(this, \"currentFilter\", void 0);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      _defineProperty(this, \"format\", void 0);\n      _defineProperty(this, \"formatPlaceholder\", void 0);\n      _defineProperty(this, \"placeholder\", void 0);\n      _defineProperty(this, \"min\", void 0);\n      _defineProperty(this, \"max\", void 0);\n      _defineProperty(this, \"activeView\", void 0);\n      _defineProperty(this, \"bottomView\", void 0);\n      _defineProperty(this, \"topView\", void 0);\n      _defineProperty(this, \"weekNumber\", void 0);\n      _defineProperty(this, \"isFirstDropDown\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this.popupService = popupService;\n      this.ctx = ctx;\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    open(picker) {\n      this.subscription = this.popupService.onClose.pipe(filter(() => picker.isActive)).subscribe(e => e.preventDefault());\n    }\n    messageFor(key) {\n      return this.ctx.localization.get(key);\n    }\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class98 = DateFilterMenuInputComponent;\n  _defineProperty(DateFilterMenuInputComponent, \"\\u0275fac\", function _class98_Factory(t) {\n    return new (t || _class98)(i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(DateFilterMenuInputComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class98,\n    selectors: [[\"kendo-grid-date-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\",\n      format: \"format\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      min: \"min\",\n      max: \"max\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      weekNumber: \"weekNumber\",\n      isFirstDropDown: \"isFirstDropDown\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 4,\n    vars: 22,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"value\", \"placeholder\", \"formatPlaceholder\", \"format\", \"min\", \"max\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"open\"], [\"picker\", \"\"], [3, \"toggle\", \"today\"]],\n    template: function _class98_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r1 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0)(1, \"kendo-datepicker\", 1, 2);\n        i0.ɵɵlistener(\"open\", function _class98_Template_kendo_datepicker_open_1_listener() {\n          i0.ɵɵrestoreView(_r1);\n          const _r0 = i0.ɵɵreference(2);\n          return i0.ɵɵresetView(ctx.open(_r0));\n        });\n        i0.ɵɵelement(3, \"kendo-datepicker-messages\", 3);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", 0)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"placeholder\", ctx.placeholder)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"format\", ctx.format)(\"min\", ctx.min)(\"max\", ctx.max)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"weekNumber\", ctx.weekNumber);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"toggle\", ctx.messageFor(\"filterDateToggle\"))(\"today\", ctx.messageFor(\"filterDateToday\"));\n      }\n    },\n    dependencies: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent],\n    encapsulation: 2\n  }));\n  return DateFilterMenuInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a date filter-menu component.\n *\n * @example\n * ```html\n * <kendo-grid-column field=\"FirstOrderedOn\">\n *   <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *     <kendo-grid-date-filter-menu\n *       [column]=\"column\"\n *       [filter]=\"filter\"\n *       [filterService]=\"filterService\">\n *     </kendo-grid-date-filter-menu>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet DateFilterMenuComponent = /*#__PURE__*/(() => {\n  var _class99;\n  class DateFilterMenuComponent extends DateFilterComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return false;\n    }\n    /**\n     * The current menu filter.\n     * @type {CompositeFilterDescriptor}\n     */\n\n    constructor(ctx) {\n      super(null, ctx);\n      _defineProperty(this, \"logicOperators\", logicOperators(this.ctx.localization));\n      _defineProperty(this, \"filter\", {\n        filters: [],\n        logic: \"and\"\n      });\n      /**\n       * Determines if the inputs of second criteria will be displayed.\n       * @default true\n       */\n      _defineProperty(this, \"extra\", true);\n      /**\n       * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.\n       */\n      _defineProperty(this, \"filterService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n    }\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    localizationChange() {\n      this.logicOperators = logicOperators(this.ctx.localization);\n      super.localizationChange();\n    }\n  }\n  _class99 = DateFilterMenuComponent;\n  _defineProperty(DateFilterMenuComponent, \"\\u0275fac\", function _class99_Factory(t) {\n    return new (t || _class99)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(DateFilterMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class99,\n    selectors: [[\"kendo-grid-date-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function _class99_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 18,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"menuTabbingService\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"menuTabbingService\"]],\n    template: function _class99_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-date-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, _class99_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, _class99_kendo_grid_date_filter_menu_input_2_Template, 1, 15, \"kendo-grid-date-filter-menu-input\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"format\", ctx.format)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.min)(\"max\", ctx.max)(\"weekNumber\", ctx.weekNumber)(\"isFirstDropDown\", true)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    dependencies: [DateFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  }));\n  return DateFilterMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-access-missing-member\n/**\n * @hidden\n */\nlet BooleanFilterComponent = /*#__PURE__*/(() => {\n  var _class100;\n  class BooleanFilterComponent extends BaseFilterCellComponent {\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    constructor(filterService, ctx) {\n      super(filterService);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"operator\", \"eq\");\n      _defineProperty(this, \"items\", void 0);\n      _defineProperty(this, \"defaultItem\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      this.ctx = ctx;\n      this.items = [{\n        text: this.ctx.localization.get(\"filterIsTrue\"),\n        value: true\n      }, {\n        text: this.ctx.localization.get(\"filterIsFalse\"),\n        value: false\n      }];\n      this.defaultItem = {\n        text: this.ctx.localization.get(\"filterBooleanAll\"),\n        value: null\n      };\n    }\n    ngOnInit() {\n      this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      super.ngOnDestroy();\n    }\n    localizationChange() {\n      this.items = [{\n        text: this.ctx.localization.get(\"filterIsTrue\"),\n        value: true\n      }, {\n        text: this.ctx.localization.get(\"filterIsFalse\"),\n        value: false\n      }];\n      this.defaultItem = {\n        text: this.ctx.localization.get(\"filterBooleanAll\"),\n        value: null\n      };\n    }\n  }\n  _class100 = BooleanFilterComponent;\n  _defineProperty(BooleanFilterComponent, \"\\u0275fac\", function _class100_Factory(t) {\n    return new (t || _class100)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(BooleanFilterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class100,\n    selectors: [[\"kendo-grid-boolean-filter-base\"]],\n    inputs: {\n      column: \"column\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class100_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return BooleanFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet BooleanFilterRadioButtonDirective = /*#__PURE__*/(() => {\n  var _class101;\n  class BooleanFilterRadioButtonDirective {\n    constructor(hostElement, renderer) {\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"columnLabel\", void 0);\n      _defineProperty(this, \"radioButtonEl\", void 0);\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      this.radioButtonEl = this.hostElement.nativeElement;\n      this.renderer.setAttribute(this.hostElement.nativeElement, 'aria-label', this.columnLabel);\n    }\n  }\n  _class101 = BooleanFilterRadioButtonDirective;\n  _defineProperty(BooleanFilterRadioButtonDirective, \"\\u0275fac\", function _class101_Factory(t) {\n    return new (t || _class101)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(BooleanFilterRadioButtonDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class101,\n    selectors: [[\"\", \"kendoFilterMenuRadioButton\", \"\"]],\n    inputs: {\n      columnLabel: \"columnLabel\"\n    },\n    standalone: true\n  }));\n  return BooleanFilterRadioButtonDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a Boolean-filter menu component. [See example](slug:filter_menu#toc-built-in-filter-menu-components)\n *\n * @example\n *\n * ```html\n * <kendo-grid-column field=\"Discontinued\" title=\"Discontinued\">\n *   <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *     <kendo-grid-boolean-filter-menu\n *       [column]=\"column\"\n *       [filter]=\"filter\"\n *       [filterService]=\"filterService\">\n *     </kendo-grid-boolean-filter-menu>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet BooleanFilterMenuComponent = /*#__PURE__*/(() => {\n  var _class102;\n  class BooleanFilterMenuComponent extends BooleanFilterComponent {\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n      return false;\n    }\n    /**\n     * The current menu filter.\n     * @type {CompositeFilterDescriptor}\n     */\n\n    constructor(ctx) {\n      super(null, ctx);\n      _defineProperty(this, \"filter\", {\n        filters: [],\n        logic: \"and\"\n      });\n      /**\n       * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.\n       */\n      _defineProperty(this, \"filterService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      _defineProperty(this, \"idPrefix\", guid());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"radioButtons\", void 0);\n    }\n    ngAfterViewInit() {\n      this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;\n      if (!this.menuTabbingService?.isTabbedInterface) {\n        this.radioButtons.first.radioButtonEl.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    radioId(value) {\n      return `${this.idPrefix}_${value}`;\n    }\n    /**\n     * @hidden\n     */\n    onChange(value, input) {\n      this.applyFilter(this.updateFilter({\n        field: this.column.field,\n        operator: \"eq\",\n        value: value\n      }));\n      this.filterService.menuTabbingService.firstFocusable = input.hostElement.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    isSelected(radioValue) {\n      return this.filtersByField(this.column.field).some(({\n        value\n      }) => value === radioValue);\n    }\n    /**\n     * @hidden\n     */\n    onShiftTab(e) {\n      if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.filterService.menuTabbingService.lastFocusable) {\n        e.preventDefault();\n        this.filterService.menuTabbingService.lastFocusable.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class102 = BooleanFilterMenuComponent;\n  _defineProperty(BooleanFilterMenuComponent, \"\\u0275fac\", function _class102_Factory(t) {\n    return new (t || _class102)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(BooleanFilterMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class102,\n    selectors: [[\"kendo-grid-boolean-filter-menu\"]],\n    viewQuery: function _class102_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.radioButtons = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class102_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      filter: \"filter\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"k-radio-list\", \"k-reset\"], [4, \"ngFor\", \"ngForOf\"], [\"kendoFilterMenuRadioButton\", \"\", 3, \"columnLabel\", \"name\", \"checked\", \"change\", \"keydown.shift.tab\"], [\"input\", \"\"], [1, \"k-radio-label\"]],\n    template: function _class102_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, _class102_li_1_Template, 5, 6, \"li\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    dependencies: [NgFor, RadioButtonComponent, BooleanFilterRadioButtonDirective],\n    encapsulation: 2\n  }));\n  return BooleanFilterMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * > List the following components as `entryComponents` in the GridModule.\n */\nconst filterMenuComponentFactory = type => ({\n  \"boolean\": BooleanFilterMenuComponent,\n  \"date\": DateFilterMenuComponent,\n  \"numeric\": NumericFilterMenuComponent,\n  \"text\": StringFilterMenuComponent\n})[type];\n\n/**\n * @hidden\n */\nlet FilterMenuHostDirective = /*#__PURE__*/(() => {\n  var _class103;\n  class FilterMenuHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n      super(host, resolver);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"menuTabbingService\", void 0);\n    }\n    componentType() {\n      if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {\n        return filterMenuComponentFactory(this.column.filter);\n      }\n      return StringFilterMenuComponent;\n    }\n    initComponent(ctx) {\n      super.initComponent(ctx);\n      this.component.instance.filterService = this.filterService;\n      this.component.instance.menuTabbingService = this.menuTabbingService;\n    }\n  }\n  _class103 = FilterMenuHostDirective;\n  _defineProperty(FilterMenuHostDirective, \"\\u0275fac\", function _class103_Factory(t) {\n    return new (t || _class103)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(FilterMenuHostDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class103,\n    selectors: [[\"\", \"kendoFilterMenuHost\", \"\"]],\n    inputs: {\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return FilterMenuHostDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isNoValueOperator = operator => operator === \"isnull\" || operator === \"isnotnull\" || operator === \"isempty\" || operator === \"isnotempty\";\nconst validFilters = ({\n  value,\n  operator\n}) => !isNullOrEmptyString(value) || isNoValueOperator(operator);\nconst trimFilters = filter => {\n  filter.filters = filter.filters.filter(validFilters);\n  return filter;\n};\nconst findParent = (filters, field, parent) => {\n  return filters.reduce((acc, filter) => {\n    if (acc) {\n      return acc;\n    }\n    if (filter.filters) {\n      return findParent(filter.filters, field, filter);\n    } else if (filter.field === field) {\n      return parent;\n    }\n    return acc;\n  }, undefined);\n};\nconst parentLogicOfDefault = (filter, field, def = \"and\") => {\n  const parent = findParent((filter || {}).filters || [], field);\n  return isPresent(parent) ? parent.logic : def;\n};\n/**\n * @hidden\n */\nlet FilterMenuContainerComponent = /*#__PURE__*/(() => {\n  var _class104;\n  class FilterMenuContainerComponent {\n    /**\n     * The current root filter.\n     * @type {CompositeFilterDescriptor}\n     */\n    set filter(value) {\n      this._filter = cloneFilters(value);\n    }\n    get filter() {\n      return this._filter;\n    }\n    /**\n     * @hidden\n     */\n\n    get childFilter() {\n      if (!isPresent(this._childFilter)) {\n        this._childFilter = {\n          filters: filtersByField(this.filter, (this.column || {}).field),\n          logic: parentLogicOfDefault(this.filter, (this.column || {}).field)\n        };\n      }\n      return this._childFilter;\n    }\n    constructor(parentService, childService, ctx, cd, menuTabbingService) {\n      _defineProperty(this, \"parentService\", void 0);\n      _defineProperty(this, \"childService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isLast\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isExpanded\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      _defineProperty(this, \"actionsClass\", 'k-actions k-actions-stretched k-actions-horizontal');\n      _defineProperty(this, \"resetButton\", void 0);\n      _defineProperty(this, \"filterButton\", void 0);\n      _defineProperty(this, \"_childFilter\", void 0);\n      _defineProperty(this, \"subscription\", void 0);\n      _defineProperty(this, \"_templateContext\", {});\n      _defineProperty(this, \"_filter\", void 0);\n      this.parentService = parentService;\n      this.childService = childService;\n      this.ctx = ctx;\n      this.cd = cd;\n      this.menuTabbingService = menuTabbingService;\n    }\n    ngOnInit() {\n      this.subscription = this.childService.changes.subscribe(filter => this._childFilter = filter);\n      this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n    ngAfterViewChecked() {\n      if (!this.menuTabbingService.isColumnMenu || this.isLast && this.isExpanded) {\n        this.menuTabbingService.lastFocusable = this.disabled ? this.resetButton.nativeElement : this.filterButton.nativeElement;\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      this.menuTabbingService.lastFocusable = undefined;\n    }\n    get disabled() {\n      return !this.childFilter.filters.some(validFilters);\n    }\n    get templateContext() {\n      this._templateContext.column = this.column;\n      this._templateContext.filter = this.childFilter;\n      this._templateContext.filterService = this.childService;\n      this._templateContext[\"$implicit\"] = this.childFilter;\n      return this._templateContext;\n    }\n    get hasTemplate() {\n      return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);\n    }\n    submit() {\n      const filter = trimFilters(this.childFilter);\n      if (filter.filters.length) {\n        const root = this.filter || {\n          filters: [],\n          logic: \"and\"\n        };\n        removeFilter(root, this.column.field);\n        root.filters.push(filter);\n        this.parentService.filter(root);\n      }\n      this.close.emit();\n      return false;\n    }\n    reset() {\n      const root = this.filter || {\n        filters: [],\n        logic: \"and\"\n      };\n      removeFilter(root, this.column.field);\n      this.parentService.filter(root);\n      this.close.emit();\n    }\n    onTab(e, buttonType) {\n      if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {\n        e.preventDefault();\n        if (buttonType === 'reset') {\n          // eslint-disable-next-line no-unused-expressions\n          this.menuTabbingService.firstFocusable.focus();\n        } else {\n          this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();\n        }\n      }\n    }\n    get clearText() {\n      return this.ctx.localization.get(\"filterClearButton\");\n    }\n    get filterText() {\n      return this.ctx.localization.get(\"filterFilterButton\");\n    }\n  }\n  _class104 = FilterMenuContainerComponent;\n  _defineProperty(FilterMenuContainerComponent, \"\\u0275fac\", function _class104_Factory(t) {\n    return new (t || _class104)(i0.ɵɵdirectiveInject(FilterService, 4), i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MenuTabbingService));\n  });\n  _defineProperty(FilterMenuContainerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class104,\n    selectors: [[\"kendo-grid-filter-menu-container\"]],\n    viewQuery: function _class104_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c12, 5);\n        i0.ɵɵviewQuery(_c13, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resetButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterButton = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      isLast: \"isLast\",\n      isExpanded: \"isExpanded\",\n      menuTabbingService: \"menuTabbingService\",\n      filter: \"filter\",\n      actionsClass: \"actionsClass\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([FilterService, MenuTabbingService]), i0.ɵɵStandaloneFeature],\n    decls: 12,\n    vars: 7,\n    consts: [[1, \"k-filter-menu\", 3, \"submit\", \"reset\"], [1, \"k-filter-menu-container\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [3, \"ngClass\"], [\"type\", \"submit\", 1, \"k-button\", \"k-button-solid-primary\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"disabled\", \"keydown.tab\"], [\"filterButton\", \"\"], [\"type\", \"reset\", 1, \"k-button\", \"k-button-solid-base\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"keydown.tab\"], [\"resetButton\", \"\"], [\"kendoFilterMenuHost\", \"\", 3, \"filterService\", \"column\", \"filter\", \"menuTabbingService\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class104_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"form\", 0);\n        i0.ɵɵlistener(\"submit\", function _class104_Template_form_submit_0_listener() {\n          return ctx.submit();\n        })(\"reset\", function _class104_Template_form_reset_0_listener() {\n          return ctx.reset();\n        });\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵtemplate(3, _class104_ng_container_3_Template, 2, 4, \"ng-container\", 3);\n        i0.ɵɵtemplate(4, _class104_ng_container_4_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(5, \"div\", 4)(6, \"button\", 5, 6);\n        i0.ɵɵlistener(\"keydown.tab\", function _class104_Template_button_keydown_tab_6_listener($event) {\n          return ctx.onTab($event, \"filter\");\n        });\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"button\", 7, 8);\n        i0.ɵɵlistener(\"keydown.tab\", function _class104_Template_button_keydown_tab_9_listener($event) {\n          return ctx.onTab($event, \"reset\");\n        });\n        i0.ɵɵtext(11);\n        i0.ɵɵelementEnd()()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitch\", ctx.hasTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.actionsClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"disabled\", ctx.disabled);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.filterText);\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate(ctx.clearText);\n      }\n    },\n    dependencies: [FormsModule, i4.ɵNgNoValidate, i4.NgControlStatusGroup, i4.NgForm, NgSwitch, NgSwitchCase, FilterMenuHostDirective, NgIf, NgTemplateOutlet, NgClass],\n    encapsulation: 2\n  }));\n  return FilterMenuContainerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet id$1 = 0;\nconst getId$1 = gridId => `${gridId}-filter-menu-${id$1++}`;\n/**\n * @hidden\n */\nlet FilterMenuComponent = /*#__PURE__*/(() => {\n  var _class105;\n  class FilterMenuComponent {\n    constructor(filterService, popupService, ctx, navigationService, renderer, cdr, idService) {\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"idService\", void 0);\n      _defineProperty(this, \"filterIcon\", filterIcon);\n      /**\n       * The column with which the filter is associated.\n       * @type {ColumnComponent}\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * The current root filter.\n       * @type {CompositeFilterDescriptor}\n       */\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"anchor\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"tabIndex\", '-1');\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"popupSubs\", void 0);\n      this.filterService = filterService;\n      this.popupService = popupService;\n      this.ctx = ctx;\n      this.navigationService = navigationService;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.idService = idService;\n    }\n    ngOnDestroy() {\n      this.cleanUp();\n    }\n    get hasFilters() {\n      return filtersByField(this.filter, (this.column || {}).field).length > 0;\n    }\n    /**\n     * @hidden\n     */\n    get filterLabel() {\n      const localizationMsg = this.ctx.localization.get('filterMenuTitle') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    /**\n     * @hidden\n     */\n    get isNavigable() {\n      return this.navigationService.tableEnabled;\n    }\n    toggle(anchor, template) {\n      this.popupRef = this.popupService.open(anchor, template, this.popupRef);\n      // Needed as changes to 'popupRef' are not reflected\n      // automatically when the Popup is closed by clicking outside the anchor\n      const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;\n      if (this.popupRef) {\n        this.popupSubs?.unsubscribe();\n        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {\n          this.close();\n          this.updateAria(ariaRoot);\n        });\n        this.popupSubs.add(this.popupRef.popup.instance.close.subscribe(() => {\n          this.popupRef = null;\n          this.updateAria(ariaRoot);\n        }));\n        const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-filter-popup');\n        if (popupAriaElement) {\n          const popupId = getId$1(this.idService?.gridId());\n          this.renderer.setAttribute(popupAriaElement, 'id', popupId);\n          this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');\n          this.renderer.setAttribute(popupAriaElement, 'aria-label', this.filterLabel);\n          ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);\n          ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');\n        }\n      } else {\n        if (this.navigationService.tableEnabled) {\n          this.navigationService.focusCell(0, this.column.leafIndex);\n        } else {\n          this.anchor.nativeElement.focus();\n        }\n      }\n      return false;\n    }\n    close() {\n      this.cleanUp();\n      if (this.navigationService.tableEnabled) {\n        this.navigationService.focusCell(0, this.column.leafIndex);\n      } else {\n        this.anchor.nativeElement.focus();\n      }\n    }\n    updateAria(ariaRoot) {\n      ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');\n      ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');\n    }\n    cleanUp() {\n      this.popupService.destroy();\n      this.popupRef = null;\n      this.popupSubs?.unsubscribe();\n      this.popupSubs = null;\n      this.cdr.markForCheck();\n    }\n  }\n  _class105 = FilterMenuComponent;\n  _defineProperty(FilterMenuComponent, \"\\u0275fac\", function _class105_Factory(t) {\n    return new (t || _class105)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(FilterMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class105,\n    selectors: [[\"kendo-grid-filter-menu\"]],\n    viewQuery: function _class105_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c14, 7);\n        i0.ɵɵviewQuery(_c15, 7, TemplateRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.anchor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      tabIndex: \"tabIndex\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 5,\n    vars: 7,\n    consts: [[\"href\", \"#\", 1, \"k-grid-filter-menu\", \"k-grid-header-menu\", 3, \"tabindex\", \"click\", \"keydown.enter\"], [\"anchor\", \"\"], [\"name\", \"filter\", 3, \"svgIcon\"], [\"template\", \"\"], [3, \"column\", \"filter\", \"close\", \"keydown.escape\", \"keydown.enter\"]],\n    template: function _class105_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r7 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class105_Template_a_click_0_listener() {\n          i0.ɵɵrestoreView(_r7);\n          const _r0 = i0.ɵɵreference(1);\n          const _r1 = i0.ɵɵreference(4);\n          return i0.ɵɵresetView(ctx.toggle(_r0, _r1));\n        })(\"keydown.enter\", function _class105_Template_a_keydown_enter_0_listener($event) {\n          return $event.stopImmediatePropagation();\n        });\n        i0.ɵɵelement(2, \"kendo-icon-wrapper\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class105_ng_template_3_Template, 1, 2, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-active\", ctx.hasFilters);\n        i0.ɵɵproperty(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵattribute(\"title\", ctx.filterLabel)(\"aria-haspopup\", ctx.isNavigable ? undefined : \"dialog\")(\"aria-expanded\", ctx.isNavigable ? undefined : false);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"svgIcon\", ctx.filterIcon);\n      }\n    },\n    dependencies: [IconWrapperComponent, FilterMenuContainerComponent],\n    encapsulation: 2\n  }));\n  return FilterMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];\n/**\n * @hidden\n */\nlet FilterCellWrapperComponent = /*#__PURE__*/(() => {\n  var _class106;\n  class FilterCellWrapperComponent extends FilterInputWrapperComponent {\n    get hostClasses() {\n      return true;\n    }\n    get overrideBaseClasses() {\n      return false;\n    }\n    get showButton() {\n      const filter = this.currentFilter;\n      return isPresent(filter) && (!isNullOrEmptyString(filter.value) || EMPTY_FILTER_OPERATORS.indexOf(String(filter.operator)) >= 0);\n    }\n    constructor(filterService) {\n      super(filterService);\n      _defineProperty(this, \"showOperators\", true);\n    }\n    filterChange(filter) {\n      this.applyFilter(filter);\n    }\n  }\n  _class106 = FilterCellWrapperComponent;\n  _defineProperty(FilterCellWrapperComponent, \"\\u0275fac\", function _class106_Factory(t) {\n    return new (t || _class106)(i0.ɵɵdirectiveInject(FilterService));\n  });\n  _defineProperty(FilterCellWrapperComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class106,\n    selectors: [[\"kendo-grid-filter-wrapper-cell\"]],\n    hostVars: 4,\n    hostBindings: function _class106_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell-wrapper\", ctx.hostClasses)(\"k-filtercell\", ctx.overrideBaseClasses);\n      }\n    },\n    inputs: {\n      showOperators: \"showOperators\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c11,\n    decls: 2,\n    vars: 5,\n    consts: [[3, \"showOperators\", \"column\", \"operators\", \"showButton\", \"value\", \"clear\", \"valueChange\"]],\n    template: function _class106_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"kendo-grid-filter-cell-operators\", 0);\n        i0.ɵɵlistener(\"clear\", function _class106_Template_kendo_grid_filter_cell_operators_clear_1_listener() {\n          return ctx.onClear();\n        })(\"valueChange\", function _class106_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) {\n          return ctx.currentOperator = $event;\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"showOperators\", ctx.showOperators)(\"column\", ctx.column)(\"operators\", ctx.operators)(\"showButton\", ctx.showButton)(\"value\", ctx.currentOperator);\n      }\n    },\n    dependencies: [FilterCellOperatorsComponent],\n    encapsulation: 2\n  }));\n  return FilterCellWrapperComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable no-access-missing-member\nconst stringOperators = localizeOperators({\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * @hidden\n */\nlet AutoCompleteFilterCellComponent = /*#__PURE__*/(() => {\n  var _class107;\n  class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {\n    set valueField(value) {\n      this._valueField = value;\n    }\n    get valueField() {\n      return this._valueField ? this._valueField : this.column.field;\n    }\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : \"contains\";\n    }\n    constructor(filterService, column, ctx, sizingOptionsService) {\n      super(filterService);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"showOperators\", true);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"_valueField\", void 0);\n      _defineProperty(this, \"subs\", void 0);\n      this.ctx = ctx;\n      this.defaultOperators = stringOperators(this.ctx.localization);\n      this.column = column;\n      this.subs = sizingOptionsService.changes.subscribe(size => this.size = size);\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n  }\n  _class107 = AutoCompleteFilterCellComponent;\n  _defineProperty(AutoCompleteFilterCellComponent, \"\\u0275fac\", function _class107_Factory(t) {\n    return new (t || _class107)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ColumnComponent), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(AutoCompleteFilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class107,\n    selectors: [[\"kendo-grid-autocomplete-filter-cell\"]],\n    inputs: {\n      showOperators: \"showOperators\",\n      column: \"column\",\n      data: \"data\",\n      valueField: \"valueField\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 8,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"showOperators\"], [\"kendoFilterInput\", \"\", 3, \"data\", \"size\", \"valueField\", \"value\"]],\n    template: function _class107_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"kendo-autocomplete\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"data\", ctx.data)(\"size\", ctx.size)(\"valueField\", ctx.valueField)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    dependencies: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective],\n    encapsulation: 2\n  }));\n  return AutoCompleteFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a Boolean filter-cell component.\n * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).\n *\n * @example\n *\n * ```html\n * <kendo-grid-column field=\"Discontinued\">\n *   <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *     <kendo-grid-boolean-filter-cell\n *       [column]=\"column\"\n *       [filter]=\"filter\">\n *     </kendo-grid-boolean-filter-cell>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet BooleanFilterCellComponent = /*#__PURE__*/(() => {\n  var _class108;\n  class BooleanFilterCellComponent extends BooleanFilterComponent {\n    constructor(filterService, ctx, cd, sizingService) {\n      super(filterService, ctx);\n      _defineProperty(this, \"cd\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"subs\", void 0);\n      this.cd = cd;\n      this.subs = sizingService.changes.subscribe(size => this.size = size);\n    }\n    ngOnDestroy() {\n      this.subs && this.subs.unsubscribe();\n    }\n    localizationChange() {\n      super.localizationChange();\n      this.cd.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('booleanFilterCellLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class108 = BooleanFilterCellComponent;\n  _defineProperty(BooleanFilterCellComponent, \"\\u0275fac\", function _class108_Factory(t) {\n    return new (t || _class108)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(BooleanFilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class108,\n    selectors: [[\"kendo-grid-boolean-filter-cell\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 12,\n    consts: [[3, \"column\", \"filter\", \"showOperators\", \"defaultOperator\"], [\"kendoFilterInput\", \"\", \"kendoGridFocusable\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"size\", \"columnLabel\", \"defaultItem\", \"data\", \"popupSettings\", \"valuePrimitive\", \"value\"]],\n    template: function _class108_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"kendo-dropdownlist\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"showOperators\", false)(\"defaultOperator\", ctx.operator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"columnLabel\", ctx.columnLabel)(\"defaultItem\", ctx.defaultItem)(\"data\", ctx.items)(\"popupSettings\", i0.ɵɵpureFunction0(11, _c10))(\"valuePrimitive\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    dependencies: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective],\n    encapsulation: 2\n  }));\n  return BooleanFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a [DatePicker](slug:overview_datepicker) filter-cell component.\n * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).\n *\n * @example\n *\n * ```html\n * <kendo-grid-column field=\"FirstOrderedOn\">\n *   <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *     <kendo-grid-date-filter-cell\n *       [column]=\"column\"\n *       [filter]=\"filter\">\n *     </kendo-grid-date-filter-cell>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet DateFilterCellComponent = /*#__PURE__*/(() => {\n  var _class109;\n  class DateFilterCellComponent extends DateFilterComponent {\n    constructor(filterService, ctx, sizingService) {\n      super(filterService, ctx);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       *  Represents a [DatePicker](slug:overview_datepicker) filter-cell component.\n       * [See example](slug:filter_row#toc-built-in-filter-row-components).\n       * @example\n       *\n       * ```html\n       * <kendo-grid-column field=\"Discontinued\">\n       *   <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n       *     <kendo-grid-date-filter-cell\n       *       [column]=\"column\"\n       *       [filter]=\"filter\">\n       *     </kendo-grid-date-filter-cell>\n       *   </ng-template>\n       * </kendo-grid-column>\n       * ```\n       * @type {boolean}\n       * @default true\n       */\n      _defineProperty(this, \"showOperators\", true);\n      _defineProperty(this, \"subs\", void 0);\n      this.ctx = ctx;\n      this.subs = sizingService.changes.subscribe(size => this.size = size);\n    }\n    ngOnDestroy() {\n      this.subs && this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.ctx.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class109 = DateFilterCellComponent;\n  _defineProperty(DateFilterCellComponent, \"\\u0275fac\", function _class109_Factory(t) {\n    return new (t || _class109)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(DateFilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class109,\n    selectors: [[\"kendo-grid-date-filter-cell\"]],\n    inputs: {\n      showOperators: \"showOperators\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 19,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoFilterInput\", \"\", \"kendoGridFocusable\", \"\", 3, \"columnLabel\", \"value\", \"format\", \"size\", \"formatPlaceholder\", \"placeholder\", \"activeView\", \"bottomView\", \"topView\", \"min\", \"max\", \"weekNumber\"], [3, \"toggle\", \"today\"]],\n    template: function _class109_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0)(1, \"kendo-datepicker\", 1);\n        i0.ɵɵelement(2, \"kendo-datepicker-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"size\", ctx.size)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"min\", ctx.min)(\"max\", ctx.max)(\"weekNumber\", ctx.weekNumber);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"toggle\", ctx.messageFor(\"filterDateToggle\"))(\"today\", ctx.messageFor(\"filterDateToday\"));\n      }\n    },\n    dependencies: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent],\n    encapsulation: 2\n  }));\n  return DateFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a string filter-cell component\n * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).\n *\n * @example\n * ```html\n * <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *   <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *     <kendo-grid-string-filter-cell\n *       [column]=\"column\"\n *       [filter]=\"filter\">\n *     </kendo-grid-string-filter-cell>\n *  </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet StringFilterCellComponent = /*#__PURE__*/(() => {\n  var _class110;\n  class StringFilterCellComponent extends StringFilterComponent {\n    constructor(filterService, ctx, sizingService) {\n      super(filterService, ctx);\n      /**\n       * Determines the delay time (in milliseconds) before the filter value is submitted.\n       * A value of `0` indicates no delay.\n       * @type {boolean}\n       * @default 500\n       */\n      _defineProperty(this, \"filterDelay\", 500);\n      /**\n       * Determines if the drop-down filter operators will be displayed.\n       * @type {boolean}\n       * @default true\n       */\n      _defineProperty(this, \"showOperators\", true);\n      /**\n       * The placeholder text for the filter input.\n       * @type {string}\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      _defineProperty(this, \"subs\", void 0);\n      this.subs = sizingService.changes.subscribe(size => this.size = size);\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class110 = StringFilterCellComponent;\n  _defineProperty(StringFilterCellComponent, \"\\u0275fac\", function _class110_Factory(t) {\n    return new (t || _class110)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(StringFilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class110,\n    selectors: [[\"kendo-grid-string-filter-cell\"]],\n    inputs: {\n      filterDelay: \"filterDelay\",\n      showOperators: \"showOperators\",\n      placeholder: \"placeholder\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 10,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoTextBox\", \"\", \"kendoGridFocusable\", \"\", \"kendoFilterInput\", \"\", 3, \"size\", \"columnLabel\", \"filterDelay\", \"placeholder\", \"ngModel\"]],\n    template: function _class110_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"kendo-textbox\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        let tmp_9_0;\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", ctx.filterDelay)(\"placeholder\", ctx.placeholder)(\"ngModel\", (tmp_9_0 = ctx.currentFilter == null ? null : ctx.currentFilter.value) !== null && tmp_9_0 !== undefined ? tmp_9_0 : null);\n      }\n    },\n    dependencies: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule, i4.NgControlStatus, i4.NgModel],\n    encapsulation: 2\n  }));\n  return StringFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a numeric filter-cell component.\n * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).\n *\n * @example\n * ```html\n * <kendo-grid-column field=\"UnitPrice\">\n *   <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *     <kendo-grid-numeric-filter-cell\n *       [column]=\"column\"\n *       [filter]=\"filter\">\n *     </kendo-grid-numeric-filter-cell>\n *   </ng-template>\n * </kendo-grid-column>\n * ```\n */\nlet NumericFilterCellComponent = /*#__PURE__*/(() => {\n  var _class111;\n  class NumericFilterCellComponent extends NumericFilterComponent {\n    constructor(filterService, ctx, sizingService) {\n      super(filterService, ctx);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * Determines the delay time (in milliseconds) before the filter value is submitted.\n       * A value of `0` indicates no delay. The default value is `500`.\n       * @type {boolean}\\\n       * @default 500\n       */\n      _defineProperty(this, \"filterDelay\", 500);\n      /**\n       * Determines if the drop-down filter operators will be displayed.\n       * The default value is `true`.\n       * @type {boolean}\n       * @default true\n       */\n      _defineProperty(this, \"showOperators\", true);\n      /**\n      * The placeholder text for the filter input.\n      * @type {string}\n      */\n      _defineProperty(this, \"placeholder\", void 0);\n      _defineProperty(this, \"subs\", void 0);\n      this.ctx = ctx;\n      this.subs = sizingService.changes.subscribe(size => this.size = size);\n    }\n    ngOnDestroy() {\n      this.subs && this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.ctx.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get columnLabel() {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n  }\n  _class111 = NumericFilterCellComponent;\n  _defineProperty(NumericFilterCellComponent, \"\\u0275fac\", function _class111_Factory(t) {\n    return new (t || _class111)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService));\n  });\n  _defineProperty(NumericFilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class111,\n    selectors: [[\"kendo-grid-numeric-filter-cell\"]],\n    inputs: {\n      filterDelay: \"filterDelay\",\n      showOperators: \"showOperators\",\n      placeholder: \"placeholder\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 19,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoGridFocusable\", \"\", \"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"autoCorrect\", \"value\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"size\", \"step\", \"placeholder\"], [3, \"increment\", \"decrement\"]],\n    template: function _class111_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0)(1, \"kendo-numerictextbox\", 1);\n        i0.ɵɵelement(2, \"kendo-numerictextbox-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", ctx.filterDelay)(\"autoCorrect\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"size\", ctx.size)(\"step\", ctx.step)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"increment\", ctx.messageFor(\"filterNumericIncrement\"))(\"decrement\", ctx.messageFor(\"filterNumericDecrement\"));\n      }\n    },\n    dependencies: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent],\n    encapsulation: 2\n  }));\n  return NumericFilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * > List the following components in the GridModule as `entryComponents`.\n */\nconst filterComponentFactory = type => ({\n  \"boolean\": BooleanFilterCellComponent,\n  \"date\": DateFilterCellComponent,\n  \"numeric\": NumericFilterCellComponent,\n  \"text\": StringFilterCellComponent\n})[type];\n\n/**\n * @hidden\n */\nlet FilterCellHostDirective = /*#__PURE__*/(() => {\n  var _class112;\n  class FilterCellHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n      super(host, resolver);\n    }\n    componentType() {\n      if (!isNullOrEmptyString(this.column.filter)) {\n        return filterComponentFactory(this.column.filter);\n      }\n      return StringFilterCellComponent;\n    }\n  }\n  _class112 = FilterCellHostDirective;\n  _defineProperty(FilterCellHostDirective, \"\\u0275fac\", function _class112_Factory(t) {\n    return new (t || _class112)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(FilterCellHostDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class112,\n    selectors: [[\"\", \"kendoFilterCellHost\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return FilterCellHostDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterCellComponent = /*#__PURE__*/(() => {\n  var _class113;\n  class FilterCellComponent {\n    constructor() {\n      _defineProperty(this, \"hostRole\", 'gridcell');\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"_templateContext\", {});\n      _defineProperty(this, \"_filter\", void 0);\n    }\n    get filter() {\n      return this._filter;\n    }\n    set filter(value) {\n      this._filter = cloneFilters(value);\n    }\n    get templateContext() {\n      this._templateContext.column = this.column;\n      this._templateContext.filter = this.filter;\n      this._templateContext['$implicit'] = this.filter;\n      return this._templateContext;\n    }\n    get hasTemplate() {\n      return isPresent(this.column.filterCellTemplateRef);\n    }\n    get isFilterable() {\n      return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;\n    }\n  }\n  _class113 = FilterCellComponent;\n  _defineProperty(FilterCellComponent, \"\\u0275fac\", function _class113_Factory(t) {\n    return new (t || _class113)();\n  });\n  _defineProperty(FilterCellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class113,\n    selectors: [[\"\", \"kendoGridFilterCell\", \"\"]],\n    hostVars: 1,\n    hostBindings: function _class113_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      size: \"size\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c16,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [\"kendoFilterCellHost\", \"\", 3, \"column\", \"filter\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class113_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class113_ng_container_0_Template, 4, 3, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isFilterable);\n      }\n    },\n    dependencies: [NgIf, NgSwitch, NgSwitchCase, FilterCellHostDirective, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return FilterCellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterRowComponent = /*#__PURE__*/(() => {\n  var _class114;\n  class FilterRowComponent {\n    constructor(ctx, columnInfoService) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"logicalRowIndex\", void 0);\n      _defineProperty(this, \"lockedColumnsCount\", void 0);\n      _defineProperty(this, \"filterRowClass\", true);\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n    }\n    addStickyStyles(column) {\n      const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;\n      return {\n        ...sticky,\n        ...column.filterStyle\n      };\n    }\n    filterLabel(column) {\n      const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';\n      const columnName = column.title || column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    getLogicalColIndex(columnIndex) {\n      const colIndex = this.lockedColumnsCount + columnIndex;\n      return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;\n    }\n  }\n  _class114 = FilterRowComponent;\n  _defineProperty(FilterRowComponent, \"\\u0275fac\", function _class114_Factory(t) {\n    return new (t || _class114)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService));\n  });\n  _defineProperty(FilterRowComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class114,\n    selectors: [[\"\", \"kendoGridFilterRow\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class114_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filter-row\", ctx.filterRowClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      filter: \"filter\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      logicalRowIndex: \"logicalRowIndex\",\n      lockedColumnsCount: \"lockedColumnsCount\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c17,\n    decls: 3,\n    vars: 3,\n    consts: [[\"class\", \"k-table-td k-group-cell k-table-group-td\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-table-td k-hierarchy-cell\", \"role\", \"presentation\", 4, \"ngIf\"], [\"class\", \"k-table-td\", \"kendoGridFilterCell\", \"\", \"kendoGridLogicalCell\", \"\", 3, \"k-grid-header-sticky\", \"ngStyle\", \"ngClass\", \"column\", \"filter\", \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-table-td\", \"k-group-cell\", \"k-table-group-td\"], [\"role\", \"presentation\", 1, \"k-table-td\", \"k-hierarchy-cell\"], [\"kendoGridFilterCell\", \"\", \"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"ngStyle\", \"ngClass\", \"column\", \"filter\", \"logicalRowIndex\", \"logicalColIndex\"]],\n    template: function _class114_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class114_td_0_Template, 1, 0, \"td\", 0);\n        i0.ɵɵtemplate(1, _class114_td_1_Template, 1, 0, \"td\", 1);\n        i0.ɵɵtemplate(2, _class114_td_2_Template, 1, 9, \"td\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columns);\n      }\n    },\n    dependencies: [NgFor, NgIf, FilterCellComponent, LogicalCellDirective, NgStyle, NgClass],\n    encapsulation: 2\n  }));\n  return FilterRowComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColumnMenuChooserItemCheckedDirective = /*#__PURE__*/(() => {\n  var _class115;\n  class ColumnMenuChooserItemCheckedDirective {\n    constructor(host) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"kendoColumnMenuChooserItemChecked\", void 0);\n      _defineProperty(this, \"checkbox\", void 0);\n      _defineProperty(this, \"checkedChangeSub\", new Subscription());\n      this.host = host;\n    }\n    ngAfterViewInit() {\n      this.checkedChangeSub.add(this.checkbox.checkedStateChange.subscribe(() => {\n        this.kendoColumnMenuChooserItemChecked = this.checkbox.checkedState === true;\n      }));\n    }\n    ngOnDestroy() {\n      this.checkedChangeSub.unsubscribe();\n    }\n  }\n  _class115 = ColumnMenuChooserItemCheckedDirective;\n  _defineProperty(ColumnMenuChooserItemCheckedDirective, \"\\u0275fac\", function _class115_Factory(t) {\n    return new (t || _class115)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ColumnMenuChooserItemCheckedDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class115,\n    selectors: [[\"\", \"kendoColumnMenuChooserItemChecked\", \"\"]],\n    contentQueries: function _class115_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CheckBoxComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.checkbox = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function _class115_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-checked\", ctx.kendoColumnMenuChooserItemChecked);\n      }\n    },\n    inputs: {\n      kendoColumnMenuChooserItemChecked: \"kendoColumnMenuChooserItemChecked\"\n    },\n    standalone: true\n  }));\n  return ColumnMenuChooserItemCheckedDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the service that is passed to the\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *    <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *       <span class=\"k-icon k-font-icon k-i-x\" (click)=\"service.close()\" </span>\n *       <kendo-grid-columnmenu-sort [service]=\"service\">\n *       </kendo-grid-columnmenu-sort>\n *    </ng-template>\n *    <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n * </kendo-grid>\n *\n * ```\n */\nlet ColumnMenuService = /*#__PURE__*/(() => {\n  var _class116;\n  class ColumnMenuService {\n    /**\n     * Closes the column menu.\n     */\n    close() {\n      this.closeMenu.emit();\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    constructor(menuTabbingService) {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"menuTabbingService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"closeMenu\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"sort\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"filter\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"sortable\", void 0);\n      _defineProperty(this, \"columnMenuContainer\", void 0);\n      this.menuTabbingService = menuTabbingService;\n    }\n  }\n  _class116 = ColumnMenuService;\n  _defineProperty(ColumnMenuService, \"\\u0275fac\", function _class116_Factory(t) {\n    return new (t || _class116)(i0.ɵɵinject(MenuTabbingService));\n  });\n  _defineProperty(ColumnMenuService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class116,\n    factory: _class116.ɵfac\n  }));\n  return ColumnMenuService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColumnListKeyboardNavigation = /*#__PURE__*/(() => {\n  var _class117;\n  class ColumnListKeyboardNavigation {\n    constructor(renderer) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"items\", void 0);\n      _defineProperty(this, \"activeIndex\", 0);\n      this.renderer = renderer;\n    }\n    next() {\n      this.toggle(this.activeIndex, false);\n      this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);\n      this.toggle(this.activeIndex, true);\n    }\n    prev() {\n      this.toggle(this.activeIndex, false);\n      this.activeIndex = Math.max(this.activeIndex - 1, 0);\n      this.toggle(this.activeIndex, true);\n    }\n    toggle(index, active) {\n      const element = this.items[index]?.host.nativeElement;\n      element && this.renderer.setAttribute(this.items[index].host.nativeElement, 'tabindex', active ? '0' : '-1');\n      active && element && element.focus();\n    }\n    toggleCheckedState() {\n      this.items[this.activeIndex].host.nativeElement.firstElementChild.click();\n    }\n  }\n  _class117 = ColumnListKeyboardNavigation;\n  _defineProperty(ColumnListKeyboardNavigation, \"\\u0275fac\", function _class117_Factory(t) {\n    return new (t || _class117)(i0.ɵɵinject(i0.Renderer2));\n  });\n  _defineProperty(ColumnListKeyboardNavigation, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class117,\n    factory: _class117.ɵfac\n  }));\n  return ColumnListKeyboardNavigation;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColumnListComponent = /*#__PURE__*/(() => {\n  var _class118;\n  class ColumnListComponent {\n    get className() {\n      return true;\n    }\n    isChecked(checkbox) {\n      return checkbox.checked;\n    }\n    set columns(value) {\n      this._columns = value.filter(column => column.includeInChooser !== false);\n      this.allColumns = value;\n      this.updateColumnState();\n    }\n    get columns() {\n      return this._columns;\n    }\n    constructor(element, ngZone, renderer, listNavigationService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"listNavigationService\", void 0);\n      _defineProperty(this, \"reset\", new EventEmitter());\n      _defineProperty(this, \"apply\", new EventEmitter());\n      _defineProperty(this, \"columnChange\", new EventEmitter());\n      _defineProperty(this, \"autoSync\", true);\n      _defineProperty(this, \"ariaLabel\", void 0);\n      _defineProperty(this, \"allowHideAll\", false);\n      _defineProperty(this, \"applyText\", void 0);\n      _defineProperty(this, \"resetText\", void 0);\n      _defineProperty(this, \"actionsClass\", 'k-actions k-actions-stretched k-actions-horizontal');\n      _defineProperty(this, \"isLast\", void 0);\n      _defineProperty(this, \"isExpanded\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"resetButton\", void 0);\n      _defineProperty(this, \"applyButton\", void 0);\n      _defineProperty(this, \"options\", void 0);\n      _defineProperty(this, \"checkboxes\", void 0);\n      _defineProperty(this, \"hasLocked\", void 0);\n      _defineProperty(this, \"hasVisibleLocked\", void 0);\n      _defineProperty(this, \"unlockedCount\", 0);\n      _defineProperty(this, \"hasUnlockedFiltered\", void 0);\n      _defineProperty(this, \"hasFiltered\", void 0);\n      _defineProperty(this, \"_columns\", void 0);\n      _defineProperty(this, \"allColumns\", void 0);\n      _defineProperty(this, \"domSubscriptions\", new Subscription());\n      _defineProperty(this, \"onKeydown\", e => {\n        if (e.keyCode !== Keys.Tab) {\n          e.preventDefault();\n        }\n        if (e.keyCode === Keys.ArrowDown) {\n          this.listNavigationService.next();\n        } else if (e.keyCode === Keys.ArrowUp) {\n          this.listNavigationService.prev();\n        } else if (e.keyCode === Keys.Space && e.target.classList.contains('k-column-list-item')) {\n          this.listNavigationService.toggleCheckedState();\n        }\n      });\n      _defineProperty(this, \"handleCheckBoxClick\", e => {\n        const closestItem = e.target.closest('.k-column-list-item');\n        if (closestItem) {\n          const checkboxElement = closestItem.querySelector('.k-checkbox-wrap');\n          const checkbox = this.checkboxes.find(checkBox => checkBox.hostElement.nativeElement === checkboxElement);\n          const index = parseInt(checkboxElement.firstElementChild.getAttribute('data-index'), 10);\n          if (this.autoSync) {\n            if (!this.columns[index]) {\n              return;\n            }\n            const column = this.columns[index];\n            const hidden = !checkbox.checkedState;\n            if (Boolean(column.hidden) !== hidden) {\n              this.ngZone.run(() => {\n                column.hidden = hidden;\n                this.columnChange.emit([column]);\n              });\n            }\n          } else {\n            this.updateDisabled();\n          }\n          if (index !== this.listNavigationService.activeIndex) {\n            this.listNavigationService.toggle(this.listNavigationService.activeIndex, false);\n            this.listNavigationService.activeIndex = index;\n            this.listNavigationService.toggle(index, true);\n          }\n        }\n      });\n      this.element = element;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.listNavigationService = listNavigationService;\n    }\n    ngOnInit() {\n      if (!this.element) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'click', e => {\n          this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n            this.handleCheckBoxClick(e);\n          });\n        }));\n        this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'keydown', this.onKeydown));\n      });\n    }\n    ngAfterViewInit() {\n      this.listNavigationService.items = this.options.toArray();\n      this.listNavigationService.toggle(0, true);\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.updateDisabled());\n    }\n    ngOnChanges(changes) {\n      if (!this.service) {\n        return;\n      }\n      if (changes['isLast'] && this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;\n      }\n      if (changes['isExpanded'] && this.isExpanded && this.isLast && this.applyButton) {\n        this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;\n      }\n    }\n    ngOnDestroy() {\n      this.domSubscriptions.unsubscribe();\n    }\n    isDisabled(column) {\n      return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) || this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden;\n    }\n    cancelChanges() {\n      this.checkboxes.forEach((element, index) => {\n        element.checkedState = !this.columns[index].hidden;\n      });\n      this.updateDisabled();\n      this.reset.emit();\n    }\n    applyChanges() {\n      const changed = [];\n      this.checkboxes.forEach((item, index) => {\n        const column = this.columns[index];\n        const hidden = !item.checkedState;\n        if (Boolean(column.hidden) !== hidden) {\n          column.hidden = hidden;\n          changed.push(column);\n        }\n      });\n      this.updateDisabled();\n      this.apply.emit(changed);\n    }\n    onTab(e) {\n      if (this.isLast) {\n        e.preventDefault();\n        if (this.service) {\n          this.service.menuTabbingService.firstFocusable.focus();\n        } else {\n          this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);\n        }\n      }\n    }\n    updateDisabled() {\n      if (this.allowHideAll && !this.hasLocked) {\n        return;\n      }\n      const checkedItems = [];\n      this.checkboxes.forEach((checkbox, index) => {\n        if (checkbox.checkedState) {\n          checkedItems.push({\n            checkbox,\n            index\n          });\n        }\n        this.setDisabledState(checkbox, false);\n      });\n      if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {\n        this.setDisabledState(checkedItems[0].checkbox, true);\n      } else if (this.hasLocked && !this.hasUnlockedFiltered) {\n        const columns = this.columns;\n        const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);\n        if (checkedUnlocked.length === 1) {\n          this.setDisabledState(checkedUnlocked[0].checkbox, true);\n        }\n      }\n    }\n    updateColumnState() {\n      this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;\n      this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;\n      this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;\n      const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);\n      if (filteredColumns.length) {\n        this.hasFiltered = filteredColumns.length > 0;\n        this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;\n      } else {\n        this.hasFiltered = false;\n        this.hasUnlockedFiltered = false;\n      }\n    }\n    setDisabledState(checkbox, disabled) {\n      this.ngZone.run(() => checkbox.disabled = disabled);\n      const checkboxElement = checkbox.hostElement.nativeElement;\n      const parentElement = checkboxElement.parentElement;\n      const classCommand = disabled ? 'addClass' : 'removeClass';\n      const attributeCommand = disabled ? 'setAttribute' : 'removeAttribute';\n      this.renderer[classCommand](parentElement, 'k-disabled');\n      this.renderer[attributeCommand](parentElement, 'aria-disabled', disabled ? 'true' : undefined);\n    }\n  }\n  _class118 = ColumnListComponent;\n  _defineProperty(ColumnListComponent, \"\\u0275fac\", function _class118_Factory(t) {\n    return new (t || _class118)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ColumnListKeyboardNavigation));\n  });\n  _defineProperty(ColumnListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class118,\n    selectors: [[\"kendo-grid-columnlist\"]],\n    viewQuery: function _class118_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c12, 5);\n        i0.ɵɵviewQuery(_c18, 5);\n        i0.ɵɵviewQuery(ColumnMenuChooserItemCheckedDirective, 5);\n        i0.ɵɵviewQuery(CheckBoxComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resetButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.applyButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.options = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.checkboxes = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class118_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-column-list-wrapper\", ctx.className);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      autoSync: \"autoSync\",\n      ariaLabel: \"ariaLabel\",\n      allowHideAll: \"allowHideAll\",\n      applyText: \"applyText\",\n      resetText: \"resetText\",\n      actionsClass: \"actionsClass\",\n      isLast: \"isLast\",\n      isExpanded: \"isExpanded\",\n      service: \"service\"\n    },\n    outputs: {\n      reset: \"reset\",\n      apply: \"apply\",\n      columnChange: \"columnChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([ColumnListKeyboardNavigation]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 3,\n    consts: [[\"role\", \"listbox\", \"aria-multiselectable\", \"true\", 1, \"k-column-list\"], [\"class\", \"k-column-list-item\", \"role\", \"option\", 3, \"kendoColumnMenuChooserItemChecked\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\", 4, \"ngIf\"], [\"role\", \"option\", 1, \"k-column-list-item\", 3, \"kendoColumnMenuChooserItemChecked\"], [3, \"inputAttributes\", \"checkedState\", \"disabled\"], [1, \"k-checkbox-label\"], [3, \"ngClass\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-solid-primary\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"click\", \"keydown.enter\", \"keydown.space\"], [\"applyButton\", \"\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-solid-base\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"keydown.tab\", \"click\", \"keydown.enter\", \"keydown.space\"], [\"resetButton\", \"\"]],\n    template: function _class118_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, _class118_label_1_Template, 4, 7, \"label\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, _class118_div_2_Template, 7, 3, \"div\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columns);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.autoSync);\n      }\n    },\n    dependencies: [NgFor, ColumnMenuChooserItemCheckedDirective, NgIf, NgClass, CheckBoxComponent],\n    encapsulation: 2\n  }));\n  return ColumnListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the component for toggling visibility of the Grid columns visibility. [See example](slug:columnmenu_grid#toc-using-standalone-column-chooser).\n * To show and hide the columns without including the column chooser item in the [Column Menu](slug:columnmenu_grid),\n * add the component inside the [ToolbarTemplate](slug:toolbartemplate_grid) directive.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\">\n *   <ng-template kendoGridToolbarTemplate>\n *     <kendo-grid-column-chooser></kendo-grid-column-chooser>\n *   </ng-template>\n *   <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ColumnChooserComponent = /*#__PURE__*/(() => {\n  var _class119;\n  class ColumnChooserComponent {\n    get columns() {\n      return this.columnInfoService.leafNamedColumns;\n    }\n    constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"columnsIcon\", columnsIcon);\n      /**\n       * Specifies if the changes in the visibility of the column will be immediately applied.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"autoSync\", false);\n      /**\n       * Specifies if all columns can be hidden.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"allowHideAll\", true);\n      _defineProperty(this, \"anchor\", void 0);\n      _defineProperty(this, \"columnList\", void 0);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"popupId\", void 0);\n      _defineProperty(this, \"closeClick\", void 0);\n      _defineProperty(this, \"escapeListener\", void 0);\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n      this.popupService = popupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.changeDetector = changeDetector;\n    }\n    ngOnDestroy() {\n      this.close();\n    }\n    /**\n     * @hidden\n     */\n    toggle(anchor, template) {\n      if (!this.popupRef) {\n        const direction = this.ctx.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: anchor.element,\n          content: template,\n          positionMode: 'absolute',\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          }\n        });\n        const popupElement = this.popupRef?.popupElement;\n        if (popupElement) {\n          const popupId = `k-${guid()}`;\n          const popupAriaElement = popupElement.querySelector('.k-popup');\n          this.ngZone.runOutsideAngular(() => {\n            this.escapeListener = this.renderer.listen(popupAriaElement, 'keydown', e => {\n              if (e.keyCode === Keys.Escape) {\n                this.close(true);\n              }\n            });\n          });\n          this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');\n          this.renderer.setAttribute(popupAriaElement, 'id', popupId);\n          this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');\n          this.popupId = popupId;\n        }\n        if (!isDocumentAvailable()) {\n          return;\n        }\n        this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen('document', 'click', ({\n          target\n        }) => {\n          if (!closest(target, node => node === this.popupRef.popupElement || node === anchor.element)) {\n            this.ngZone.run(() => {\n              this.close();\n            });\n          }\n        }));\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onApply(changed) {\n      this.close(true);\n      if (changed.length) {\n        this.changeDetector.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onChange(changed) {\n      this.changeDetector.markForCheck();\n      this.columnInfoService.changeVisibility(changed);\n    }\n    /**\n     * @hidden\n     */\n    onShiftTab(e) {\n      if (e.target.matches('.k-column-list-item')) {\n        e.preventDefault();\n        this.columnList.resetButton.nativeElement.focus();\n      }\n    }\n    close(focusAnchor = false) {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.changeDetector.markForCheck();\n        this.escapeListener && this.escapeListener();\n      }\n      this.detachClose();\n      focusAnchor && this.anchor.element.focus();\n    }\n    detachClose() {\n      if (this.closeClick) {\n        this.closeClick();\n        this.closeClick = null;\n      }\n    }\n  }\n  _class119 = ColumnChooserComponent;\n  _defineProperty(ColumnChooserComponent, \"\\u0275fac\", function _class119_Factory(t) {\n    return new (t || _class119)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i5.PopupService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(ColumnChooserComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class119,\n    selectors: [[\"kendo-grid-column-chooser\"]],\n    viewQuery: function _class119_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c14, 5);\n        i0.ɵɵviewQuery(_c20, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.anchor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnList = _t.first);\n      }\n    },\n    inputs: {\n      autoSync: \"autoSync\",\n      allowHideAll: \"allowHideAll\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 4,\n    vars: 5,\n    consts: [[\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", \"icon\", \"columns\", 3, \"svgIcon\", \"click\"], [\"anchor\", \"\"], [\"template\", \"\"], [1, \"k-column-chooser-title\"], [3, \"columns\", \"ariaLabel\", \"isLast\", \"applyText\", \"resetText\", \"autoSync\", \"allowHideAll\", \"apply\", \"columnChange\", \"keydown.shift.tab\"], [\"columnList\", \"\"]],\n    template: function _class119_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r8 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class119_Template_button_click_0_listener() {\n          i0.ɵɵrestoreView(_r8);\n          const _r0 = i0.ɵɵreference(1);\n          const _r1 = i0.ɵɵreference(3);\n          return i0.ɵɵresetView(ctx.toggle(_r0, _r1));\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, _class119_ng_template_2_Template, 4, 8, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"svgIcon\", ctx.columnsIcon);\n        i0.ɵɵattribute(\"title\", ctx.ctx.localization.get(\"columns\"))(\"aria-haspopup\", \"dialog\")(\"aria-expanded\", !!ctx.popupRef)(\"aria-controls\", !!ctx.popupRef ? ctx.popupId : undefined);\n      }\n    },\n    dependencies: [ButtonComponent, ColumnListComponent],\n    encapsulation: 2\n  }));\n  return ColumnChooserComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColumnMenuItemBase = /*#__PURE__*/(() => {\n  var _class120;\n  class ColumnMenuItemBase {\n    constructor() {\n      /**\n       * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.\n       * Requires a mandatory input.\n       */\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n    }\n    ngOnInit() {\n      if (isDevMode() && !this.service) {\n        throw new Error(ColumnMenuErrorMessages.serviceInput);\n      }\n    }\n    /**\n     * @hidden\n     */\n    close() {\n      this.service.close();\n    }\n  }\n  _class120 = ColumnMenuItemBase;\n  _defineProperty(ColumnMenuItemBase, \"\\u0275fac\", function _class120_Factory(t) {\n    return new (t || _class120)();\n  });\n  _defineProperty(ColumnMenuItemBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class120,\n    selectors: [[\"kendo-grid-column-menu-item-base\"]],\n    hostVars: 2,\n    hostBindings: function _class120_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-columnmenu-item-wrapper\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      service: \"service\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function _class120_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ColumnMenuItemBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;\n/**\n * @hidden\n */\nconst hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;\n/**\n * @hidden\n */\nconst hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\nconst hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\nconst hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\nconst hasColumnChooser = settings => settings.columnChooser !== false;\n/**\n * @hidden\n */\nconst hasAutoSizeColumn = settings => settings.autoSizeColumn;\n/**\n* @hidden\n*/\nconst hasAutoSizeAllColumns = settings => settings.autoSizeAllColumns;\n/**\n * @hidden\n */\nconst autoSizeColumn = (grid, service, column) => {\n  // eslint-disable-next-line no-unused-expressions\n  column ? grid.autoFitColumn(column) : grid.autoFitColumns();\n  service.close();\n};\n/**\n * @hidden\n */\nconst hasItems = (settings, column) => hasAutoSizeAllColumns(settings) || hasColumnChooser(settings) || hasFilter(settings, column) || hasAutoSizeColumn(settings) || hasLock(settings, column) || hasSort(settings, column);\n\n/**\n * Represents the content template of the\n * [`ColumnMenuItemComponent`]({% slug api_grid_columnmenuitemcomponent %}) component.\n * Provides an option for specifying the content of a column item.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate>\n *     <kendo-grid-columnmenu-item text=\"Item Text\" [expanded]=\"true\">\n *       <ng-template kendoGridColumnMenuItemContentTemplate>\n *         Item Content\n *       </ng-template>\n *     </kendo-grid-columnmenu-item>\n *   </ng-template>\n *   <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *   ...\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuItemContentTemplateDirective = /*#__PURE__*/(() => {\n  var _class121;\n  class ColumnMenuItemContentTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class121 = ColumnMenuItemContentTemplateDirective;\n  _defineProperty(ColumnMenuItemContentTemplateDirective, \"\\u0275fac\", function _class121_Factory(t) {\n    return new (t || _class121)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(ColumnMenuItemContentTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class121,\n    selectors: [[\"\", \"kendoGridColumnMenuItemContentTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ColumnMenuItemContentTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents an item that can be placed inside a\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```html\n * <kendo-grid [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\" let-column=\"column\">\n *     <kendo-grid-columnmenu-item text=\"Fit column\"></kendo-grid-columnmenu-item>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuItemComponent = /*#__PURE__*/(() => {\n  var _class122;\n  class ColumnMenuItemComponent {\n    constructor() {\n      /**\n       * Fires when the item is clicked.\n       */\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      /**\n       * Fires when the content is expanded.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the content is collapsed.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Specifies the name of the [font icon](slug:icons#icons-list)\n       * that will be rendered for the item.\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * Specifies the name of the [SVG icon]({% slug svgicon_list %})\n       * that will be rendered for the item.\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Specifies the item text.\n       */\n      _defineProperty(this, \"text\", void 0);\n      /**\n       * Specifies if the item is selected.\n       */\n      _defineProperty(this, \"selected\", void 0);\n      /**\n       * Specifies if the item is disabled.\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      /**\n       * Specifies if the item is expanded.\n       */\n      _defineProperty(this, \"expanded\", void 0);\n      /**\n       * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.\n       * Required to include the item in the column menu keyboard navigation sequence.\n       */\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"contentTemplate\", void 0);\n      _defineProperty(this, \"contentState\", 'collapsed');\n      _defineProperty(this, \"contentId\", void 0);\n      _defineProperty(this, \"chevronUpIcon\", chevronUpIcon);\n      _defineProperty(this, \"chevronDownIcon\", chevronDownIcon);\n    }\n    get expandedIcon() {\n      return this.expanded ? 'arrow-chevron-up' : 'arrow-chevron-down';\n    }\n    get expandedSvgIcon() {\n      return this.expanded ? this.chevronUpIcon : this.chevronDownIcon;\n    }\n    ngAfterViewInit() {\n      this.contentTemplate && (this.contentId = `k-${guid()}`);\n    }\n    ngOnChanges(changes) {\n      if (changes.expanded) {\n        this.updateContentState();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      this.itemClick.emit(e);\n      if (this.contentTemplate) {\n        this.expanded = !this.expanded;\n        this.updateContentState();\n        if (this.expanded) {\n          this.expand.emit();\n        } else {\n          this.collapse.emit();\n        }\n      }\n    }\n    updateContentState() {\n      this.contentState = this.expanded ? 'expanded' : 'collapsed';\n    }\n  }\n  _class122 = ColumnMenuItemComponent;\n  _defineProperty(ColumnMenuItemComponent, \"\\u0275fac\", function _class122_Factory(t) {\n    return new (t || _class122)();\n  });\n  _defineProperty(ColumnMenuItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class122,\n    selectors: [[\"kendo-grid-columnmenu-item\"]],\n    contentQueries: function _class122_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      text: \"text\",\n      selected: \"selected\",\n      disabled: \"disabled\",\n      expanded: \"expanded\",\n      service: \"service\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 2,\n    consts: [[\"class\", \"k-expander\", 4, \"ngIf\", \"ngIfElse\"], [\"content\", \"\"], [1, \"k-expander\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", 1, \"k-columnmenu-item\", 3, \"click\", \"keydown.enter\"], [3, \"name\", \"svgIcon\"], [\"class\", \"k-spacer\", 4, \"ngIf\"], [\"class\", \"k-expander-indicator\", 4, \"ngIf\"], [\"class\", \"k-columnmenu-item-content\", 3, \"overflow\", 4, \"ngIf\"], [1, \"k-spacer\"], [1, \"k-expander-indicator\"], [1, \"k-columnmenu-item-content\"]],\n    template: function _class122_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class122_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(1, _class122_ng_template_1_Template, 6, 12, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.contentTemplate)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [IconWrapperComponent, NgIf, NgTemplateOutlet],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('state', [state('collapsed', style({\n        display: 'none'\n      })), state('expanded', style({\n        display: 'block'\n      })), transition('collapsed => expanded', [style({\n        height: '0px',\n        display: 'block'\n      }), animate('100ms ease-in', style({\n        height: '*'\n      }))]), transition('expanded => collapsed', [style({\n        height: '*'\n      }), animate('100ms ease-in', style({\n        height: '0px'\n      }))])])]\n    }\n  }));\n  return ColumnMenuItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item for resizing all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.\n * [See example](slug:columnmenu_grid#toc-autosize-all-columns-item).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the `service` input of the `kendo-grid-columnmenu-autosize-all-columns` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * @example\n * ```html\n * <kendo-grid [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-autosize-all-columns [service]=\"service\">\n *     </kendo-grid-columnmenu-autosize-all-columns>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuAutoSizeAllColumnsComponent = /*#__PURE__*/(() => {\n  var _class123;\n  class ColumnMenuAutoSizeAllColumnsComponent extends ColumnMenuItemBase {\n    constructor(ctx) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"displayInlineFlexIcon\", displayInlineFlexIcon);\n      this.ctx = ctx;\n    }\n    ngOnInit() {\n      const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;\n      if (isVirtualColumns && isDevMode()) {\n        console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);\n      }\n    }\n    /**\n     * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.\n     */\n    autoSizeAllColumns() {\n      autoSizeColumn(this.ctx.grid, this.service);\n    }\n  }\n  _class123 = ColumnMenuAutoSizeAllColumnsComponent;\n  _defineProperty(ColumnMenuAutoSizeAllColumnsComponent, \"\\u0275fac\", function _class123_Factory(t) {\n    return new (t || _class123)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(ColumnMenuAutoSizeAllColumnsComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class123,\n    selectors: [[\"kendo-grid-columnmenu-autosize-all-columns\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"icon\", \"display-inline-flex\", 3, \"text\", \"svgIcon\", \"itemClick\", 4, \"ngIf\"], [\"icon\", \"display-inline-flex\", 3, \"text\", \"svgIcon\", \"itemClick\"]],\n    template: function _class123_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class123_kendo_grid_columnmenu_item_0_Template, 1, 2, \"kendo-grid-columnmenu-item\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.ctx.grid.virtualColumns);\n      }\n    },\n    dependencies: [NgIf, ColumnMenuItemComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuAutoSizeAllColumnsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item for resizing the specified column to the minimum possible width so that it fits the header or cell content without wrapping.\n * [See example](slug:columnmenu_grid#toc-autosize-column-item).\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) and `column` that are passed by\n * the template to the `service` and `column` input of the `kendo-grid-columnmenu-autosize-column` component.\n *\n * @example\n * ```html\n * <kendo-grid [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\" let-column=\"column\">\n *     <kendo-grid-columnmenu-autosize-column [column]=\"column\" [service]=\"service\">\n *     </kendo-grid-columnmenu-autosize-column>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuAutoSizeColumnComponent = /*#__PURE__*/(() => {\n  var _class124;\n  class ColumnMenuAutoSizeColumnComponent extends ColumnMenuItemBase {\n    constructor(ctx) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * The Grid column instance which will be resized through the auto size column option.\n       */\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"maxWidthIcon\", maxWidthIcon);\n      this.ctx = ctx;\n    }\n    ngOnInit() {\n      const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;\n      if (isVirtualColumns && isDevMode()) {\n        console.warn(ColumnMenuErrorMessages.autoSizeColumn);\n      }\n    }\n    /**\n     * Resizes a specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.\n     */\n    autoSizeColumn() {\n      autoSizeColumn(this.ctx.grid, this.service, this.column);\n    }\n  }\n  _class124 = ColumnMenuAutoSizeColumnComponent;\n  _defineProperty(ColumnMenuAutoSizeColumnComponent, \"\\u0275fac\", function _class124_Factory(t) {\n    return new (t || _class124)(i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(ColumnMenuAutoSizeColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class124,\n    selectors: [[\"kendo-grid-columnmenu-autosize-column\"]],\n    inputs: {\n      column: \"column\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"k-grid-columnmenu-autosize-column\", \"icon\", \"max-width\", 3, \"text\", \"svgIcon\", \"itemClick\", 4, \"ngIf\"], [\"icon\", \"max-width\", 1, \"k-grid-columnmenu-autosize-column\", 3, \"text\", \"svgIcon\", \"itemClick\"]],\n    template: function _class124_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class124_kendo_grid_columnmenu_item_0_Template, 1, 2, \"kendo-grid-columnmenu-item\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.ctx.grid.virtualColumns);\n      }\n    },\n    dependencies: [NgIf, ColumnMenuItemComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuAutoSizeColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item for selecting columns in the Grid. [See example](slug:columnmenu_grid#toc-column-chooser-item).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-chooser` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * @example\n * ```html\n * <kendo-grid [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-chooser [service]=\"service\"> </kendo-grid-columnmenu-chooser>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuChooserComponent = /*#__PURE__*/(() => {\n  var _class125;\n  class ColumnMenuChooserComponent extends ColumnMenuItemBase {\n    get columns() {\n      return this.columnInfoService.leafNamedColumns;\n    }\n    constructor(ctx, columnInfoService, changeDetector, hostElement) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Fires when the content is expanded.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the content is collapsed.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Specifies if the content is expanded.\n       * @default false\n       */\n      _defineProperty(this, \"expanded\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isLast\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsClass\", 'k-actions k-actions-stretched k-actions-horizontal');\n      _defineProperty(this, \"columnsIcon\", columnsIcon);\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n    }\n    /**\n     * @hidden\n     */\n    onApply(changed) {\n      this.close();\n      if (changed.length) {\n        this.changeDetector.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onCollapse() {\n      this.expanded = false;\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');\n      }\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n    onExpand() {\n      this.expanded = true;\n      this.expand.emit();\n    }\n  }\n  _class125 = ColumnMenuChooserComponent;\n  _defineProperty(ColumnMenuChooserComponent, \"\\u0275fac\", function _class125_Factory(t) {\n    return new (t || _class125)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ColumnMenuChooserComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class125,\n    selectors: [[\"kendo-grid-columnmenu-chooser\"]],\n    inputs: {\n      expanded: \"expanded\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[\"icon\", \"columns\", 3, \"text\", \"svgIcon\", \"expanded\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"applyText\", \"resetText\", \"ariaLabel\", \"columns\", \"autoSync\", \"allowHideAll\", \"actionsClass\", \"isLast\", \"isExpanded\", \"service\", \"apply\"]],\n    template: function _class125_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"collapse\", function _class125_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function _class125_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, _class125_ng_template_1_Template, 1, 10, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.ctx.localization.get(\"columns\"))(\"svgIcon\", ctx.columnsIcon)(\"expanded\", ctx.expanded);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnListComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuChooserComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item that sticks or unsticks columns in the Grid.\n * [See example](slug:columnmenu_grid#toc-stick-and-unstick-items).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-lock` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *      <kendo-grid-columnmenu-stick [service]=\"service\">\n *      </kendo-grid-columnmenu-stick>\n *   </ng-template>\n * </kendo-grid>\n *\n * ```\n */\nlet ColumnMenuStickComponent = /*#__PURE__*/(() => {\n  var _class126;\n  class ColumnMenuStickComponent extends ColumnMenuItemBase {\n    constructor(ctx, columnInfoService, changeDetector) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"stickIcon\", stickIcon);\n      _defineProperty(this, \"unstickIcon\", unstickIcon);\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n    }\n    get text() {\n      return this.ctx.localization.get(this.sticky ? 'unstick' : 'stick');\n    }\n    get icon() {\n      return this.sticky ? 'unstick' : 'stick';\n    }\n    get svgIcon() {\n      return this.sticky ? this.unstickIcon : this.stickIcon;\n    }\n    get disabled() {\n      return !this.sticky && this.columnInfoService.unlockedRootCount < 2;\n    }\n    /**\n     * @hidden\n     */\n    toggleColumn() {\n      this.toggleHierarchy(!this.sticky);\n      this.close();\n      this.changeDetector.markForCheck();\n    }\n    toggleHierarchy(sticky) {\n      let root = this.service.column;\n      while (root.parent) {\n        root = root.parent;\n      }\n      const columns = [root];\n      const allChanged = [];\n      while (columns.length) {\n        const column = columns.shift();\n        column.sticky = sticky;\n        allChanged.push(column);\n        if (column.hasChildren) {\n          columns.push(...column.childrenArray);\n        }\n      }\n      this.columnInfoService.changeStuck(allChanged);\n    }\n    get sticky() {\n      return this.service.column.sticky;\n    }\n  }\n  _class126 = ColumnMenuStickComponent;\n  _defineProperty(ColumnMenuStickComponent, \"\\u0275fac\", function _class126_Factory(t) {\n    return new (t || _class126)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(ColumnMenuStickComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class126,\n    selectors: [[\"kendo-grid-columnmenu-stick\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 4,\n    consts: [[3, \"text\", \"icon\", \"svgIcon\", \"disabled\", \"itemClick\"]],\n    template: function _class126_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function _class126_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleColumn();\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.text)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"disabled\", ctx.disabled);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuStickComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item for locking and unlocking columns in the Grid. [See example](slug:columnmenu_grid#toc-lock-and-unlock-items).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-lock` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-lock [service]=\"service\">\n *     </kendo-grid-columnmenu-lock>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuLockComponent = /*#__PURE__*/(() => {\n  var _class127;\n  class ColumnMenuLockComponent extends ColumnMenuItemBase {\n    constructor(ctx, columnInfoService, changeDetector) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"unlockIcon\", unlockIcon);\n      _defineProperty(this, \"lockIcon\", lockIcon);\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n    }\n    get text() {\n      return this.ctx.localization.get(this.locked ? 'unlock' : 'lock');\n    }\n    get icon() {\n      return this.locked ? 'unlock' : 'lock';\n    }\n    get svgIcon() {\n      return this.locked ? this.unlockIcon : this.lockIcon;\n    }\n    get disabled() {\n      return !this.locked && this.columnInfoService.unlockedRootCount < 2;\n    }\n    /**\n     * @hidden\n     */\n    toggleColumn() {\n      this.toggleHierarchy(!this.locked);\n      this.close();\n      this.changeDetector.markForCheck();\n    }\n    toggleHierarchy(locked) {\n      let root = this.service.column;\n      while (root.parent) {\n        root = root.parent;\n      }\n      const columns = [root];\n      const allChanged = [];\n      while (columns.length) {\n        const column = columns.shift();\n        column.locked = locked;\n        allChanged.push(column);\n        if (column.hasChildren) {\n          columns.push(...column.childrenArray);\n        }\n      }\n      this.columnInfoService.changeLocked(allChanged);\n    }\n    get locked() {\n      return this.service.column.locked;\n    }\n  }\n  _class127 = ColumnMenuLockComponent;\n  _defineProperty(ColumnMenuLockComponent, \"\\u0275fac\", function _class127_Factory(t) {\n    return new (t || _class127)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(ColumnMenuLockComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class127,\n    selectors: [[\"kendo-grid-columnmenu-lock\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 4,\n    consts: [[3, \"text\", \"icon\", \"svgIcon\", \"disabled\", \"itemClick\"]],\n    template: function _class127_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function _class127_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleColumn();\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.text)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"disabled\", ctx.disabled);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuLockComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item which combines the lock and sticky column functionalities.\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-position` component. [See example](slug:columnmenu_grid#toc-set-column-position-item).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\" [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\" let-column=\"column\">\n *     <kendo-grid-columnmenu-position [service]=\"service\" [showLock]=\"true\" [showStick]=\"true\">\n *     </kendo-grid-columnmenu-position>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuPositionComponent = /*#__PURE__*/(() => {\n  var _class128;\n  class ColumnMenuPositionComponent extends ColumnMenuItemBase {\n    /**\n     * @hidden\n     */\n    set isLast(value) {\n      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      this._isLast = value;\n    }\n    /**\n     * @hidden\n     */\n    get isLast() {\n      return this._isLast;\n    }\n    constructor(ctx, hostElement) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Fires when the content is expanded.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the content is collapsed.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Specifies if the content is expanded.\n       * @default false\n       */\n      _defineProperty(this, \"expanded\", false);\n      /**\n       * Specifies if the lock column item is displayed.\n       */\n      _defineProperty(this, \"showLock\", void 0);\n      /**\n       * Specifies if the stick column item is displayed.\n       */\n      _defineProperty(this, \"showStick\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsClass\", 'k-actions');\n      _defineProperty(this, \"setColumnPositionIcon\", setColumnPositionIcon);\n      _defineProperty(this, \"_isLast\", false);\n      this.ctx = ctx;\n      this.hostElement = hostElement;\n    }\n    /**\n     * @hidden\n     */\n    onTab(e, isLastItem) {\n      if (this.isLast && isLastItem) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        if (this.service) {\n          this.service.menuTabbingService.firstFocusable.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onCollapse() {\n      this.expanded = false;\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      }\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n    onExpand() {\n      this.expanded = true;\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      }\n      this.expand.emit();\n    }\n    getLastFocusableItem() {\n      const menuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');\n      const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;\n      return menuItems[lastFocusableIndex];\n    }\n  }\n  _class128 = ColumnMenuPositionComponent;\n  _defineProperty(ColumnMenuPositionComponent, \"\\u0275fac\", function _class128_Factory(t) {\n    return new (t || _class128)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ColumnMenuPositionComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class128,\n    selectors: [[\"kendo-grid-columnmenu-position\"]],\n    inputs: {\n      expanded: \"expanded\",\n      showLock: \"showLock\",\n      showStick: \"showStick\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[\"icon\", \"set-column-position\", 3, \"text\", \"svgIcon\", \"expanded\", \"keydown.tab\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"service\", \"keydown.tab\", 4, \"ngIf\"], [3, \"service\", \"keydown.tab\"]],\n    template: function _class128_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"keydown.tab\", function _class128_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) {\n          return ctx.onTab($event, !ctx.expanded);\n        })(\"collapse\", function _class128_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function _class128_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, _class128_ng_template_1_Template, 2, 2, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.ctx.localization.get(\"setColumnPosition\"))(\"svgIcon\", ctx.setColumnPositionIcon)(\"expanded\", ctx.expanded);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, NgIf, ColumnMenuLockComponent, ColumnMenuStickComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuPositionComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column-menu item for editing column filters in the Grid. [See example](slug:columnmenu_grid#toc-filter-item).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-filter` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * @example\n * ```html\n * <kendo-grid [columnMenu]=\"true\" ...>\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-filter [service]=\"service\">\n *     </kendo-grid-columnmenu-filter>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuFilterComponent = /*#__PURE__*/(() => {\n  var _class129;\n  class ColumnMenuFilterComponent extends ColumnMenuItemBase {\n    constructor(ctx, hostElement) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Fires when the content is expanded.\n       */\n      _defineProperty(this, \"expand\", new EventEmitter());\n      /**\n       * Fires when the content is collapsed.\n       */\n      _defineProperty(this, \"collapse\", new EventEmitter());\n      /**\n       * Specifies if the content is expanded.\n       * @default false\n       */\n      _defineProperty(this, \"expanded\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isLast\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsClass\", 'k-actions k-actions-stretched k-actions-horizontal');\n      _defineProperty(this, \"filterIcon\", filterIcon);\n      this.ctx = ctx;\n      this.hostElement = hostElement;\n    }\n    /**\n     * @hidden\n     */\n    onCollapse() {\n      this.expanded = false;\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');\n      }\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n    onExpand() {\n      this.expanded = true;\n      this.expand.emit();\n    }\n  }\n  _class129 = ColumnMenuFilterComponent;\n  _defineProperty(ColumnMenuFilterComponent, \"\\u0275fac\", function _class129_Factory(t) {\n    return new (t || _class129)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ColumnMenuFilterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class129,\n    selectors: [[\"kendo-grid-columnmenu-filter\"]],\n    inputs: {\n      expanded: \"expanded\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[\"icon\", \"filter\", 3, \"text\", \"svgIcon\", \"expanded\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"column\", \"menuTabbingService\", \"filter\", \"actionsClass\", \"isLast\", \"isExpanded\", \"keydown.shift.tab\", \"close\"]],\n    template: function _class129_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"collapse\", function _class129_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function _class129_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, _class129_ng_template_1_Template, 1, 6, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.ctx.localization.get(\"filter\"))(\"svgIcon\", ctx.filterIcon)(\"expanded\", ctx.expanded);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ColumnMenuItemDirective = /*#__PURE__*/(() => {\n  var _class130;\n  class ColumnMenuItemDirective {\n    /**\n     * @hidden\n     */\n    set isFirst(value) {\n      if (value) {\n        const focusableElement = this.columnMenuItems[0];\n        this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;\n        this.ngZone.runOutsideAngular(() => {\n          const firstItemKeydownSub = this.renderer.listen(focusableElement, 'keydown', this.onTab);\n          this.subs.add(firstItemKeydownSub);\n        });\n      }\n      this._isFirst = value;\n    }\n    /**\n     * @hidden\n     */\n    get isFirst() {\n      return this._isFirst;\n    }\n    /**\n     * @hidden\n     */\n    set isLast(value) {\n      if (!this.columnMenuItems) {\n        return;\n      }\n      if (value) {\n        const lastFocusableElement = this.getLastColumnMenuItem();\n        this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;\n        this.ngZone.runOutsideAngular(() => {\n          const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, 'keydown', this.onTab);\n          this.subs.add(lastItemKeydownSub);\n        });\n        if (this.isExpandableItem()) {\n          this.menuItemComponent.isLast = true;\n        }\n      }\n      this._isLast = value;\n    }\n    /**\n     * @hidden\n     */\n    get isLast() {\n      return this._isLast;\n    }\n    constructor(hostElement, renderer, ngZone) {\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      /**\n       * The reference to the Grid column menu item. Required to include the item in the built-in keyboard navigation.\n       */\n      _defineProperty(this, \"menuItemComponent\", void 0);\n      _defineProperty(this, \"firstFocusableElement\", void 0);\n      _defineProperty(this, \"lastFocusableElement\", void 0);\n      _defineProperty(this, \"_isFirst\", false);\n      _defineProperty(this, \"_isLast\", false);\n      _defineProperty(this, \"columnMenuItems\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"onTab\", e => {\n        if (e.keyCode !== Keys.Tab) {\n          return;\n        }\n        if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {\n          e.preventDefault();\n          this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();\n        }\n        if (this.isLast && !e.shiftKey) {\n          const lastColumnMenuItem = this.getLastColumnMenuItem();\n          const isExpanded = this.menuItemComponent.expanded;\n          if (lastColumnMenuItem === e.target && !isExpanded) {\n            e.preventDefault();\n            this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();\n          }\n        }\n      });\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n    }\n    ngAfterViewInit() {\n      this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');\n      [].slice.apply(this.columnMenuItems).forEach(el => this.renderer.setAttribute(el, 'tabindex', '0'));\n      if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {\n        this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;\n      }\n      this.menuItemComponent.service?.columnMenuContainer.templateMenuItems.push(this);\n    }\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n    getLastColumnMenuItem() {\n      return this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1];\n    }\n    isExpandableItem() {\n      return this.menuItemComponent instanceof ColumnMenuFilterComponent || this.menuItemComponent instanceof ColumnMenuChooserComponent || this.menuItemComponent instanceof ColumnMenuPositionComponent;\n    }\n  }\n  _class130 = ColumnMenuItemDirective;\n  _defineProperty(ColumnMenuItemDirective, \"\\u0275fac\", function _class130_Factory(t) {\n    return new (t || _class130)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ColumnMenuItemDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class130,\n    selectors: [[\"\", \"kendoGridColumnMenuItem\", \"\"]],\n    inputs: {\n      menuItemComponent: [\"kendoGridColumnMenuItem\", \"menuItemComponent\"]\n    },\n    standalone: true\n  }));\n  return ColumnMenuItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColumnMenuContainerComponent = /*#__PURE__*/(() => {\n  var _class131;\n  class ColumnMenuContainerComponent {\n    constructor(service, ngZone) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"columnMenuItems\", void 0);\n      _defineProperty(this, \"templateMenuItems\", []);\n      this.service = service;\n      this.ngZone = ngZone;\n      service.columnMenuContainer = this;\n    }\n    ngAfterViewInit() {\n      if (this.columnMenuItems.length) {\n        this.columnMenuItems.first.isFirst = true;\n        this.columnMenuItems.last.isLast = true;\n      } else if (this.templateMenuItems.length) {\n        this.templateMenuItems[0].isFirst = true;\n        this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;\n      } else {\n        return;\n      }\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable.focus());\n    }\n  }\n  _class131 = ColumnMenuContainerComponent;\n  _defineProperty(ColumnMenuContainerComponent, \"\\u0275fac\", function _class131_Factory(t) {\n    return new (t || _class131)(i0.ɵɵdirectiveInject(ColumnMenuService), i0.ɵɵdirectiveInject(NgZone));\n  });\n  _defineProperty(ColumnMenuContainerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class131,\n    selectors: [[\"kendo-grid-columnmenu-container\"]],\n    contentQueries: function _class131_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuItems = _t);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c11,\n    decls: 1,\n    vars: 0,\n    template: function _class131_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ColumnMenuContainerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass SortService {\n  constructor() {\n    _defineProperty(this, \"changes\", new Subject());\n  }\n  sort(value) {\n    this.changes.next(value);\n  }\n}\n\n/**\n * @hidden\n */\nconst DEFAULTS = {\n  allowUnsort: true,\n  mode: 'single',\n  showIndexes: true,\n  initialDirection: 'asc',\n  multiSortKey: 'none'\n};\n/**\n * @hidden\n */\nconst normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);\n\n/**\n * Represents the column-menu item for sorting Grid columns.\n * [See example](slug:columnmenu_grid#toc-sort-item).\n *\n * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-sort` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).\n *\n * You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * the template to the service input of the `kendo-grid-columnmenu-sort` component.\n *\n * @example\n * ```html\n * <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *   <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *     <kendo-grid-columnmenu-sort [service]=\"service\">\n *     </kendo-grid-columnmenu-sort>\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuSortComponent = /*#__PURE__*/(() => {\n  var _class133;\n  class ColumnMenuSortComponent extends ColumnMenuItemBase {\n    constructor(ctx, sortService, renderer) {\n      super();\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"sortService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"sortAscSmallIcon\", sortAscSmallIcon);\n      _defineProperty(this, \"sortDescSmallIcon\", sortDescSmallIcon);\n      this.ctx = ctx;\n      this.sortService = sortService;\n      this.renderer = renderer;\n    }\n    get sortedAsc() {\n      const descriptor = this.descriptor;\n      return descriptor && (!descriptor.dir || descriptor.dir === 'asc');\n    }\n    get sortedDesc() {\n      const descriptor = this.descriptor;\n      return descriptor && descriptor.dir === 'desc';\n    }\n    /**\n     * @hidden\n     */\n    toggleSort(dir) {\n      const field = this.service.column.field;\n      const {\n        mode,\n        allowUnsort\n      } = normalize$1(this.service.sortable);\n      const descriptor = this.descriptor;\n      const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];\n      if (descriptor && descriptor.dir === dir) {\n        if (!allowUnsort) {\n          return;\n        }\n      } else {\n        sort.push({\n          field,\n          dir\n        });\n      }\n      this.sortService.sort(sort);\n      this.close();\n    }\n    get descriptor() {\n      return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);\n    }\n  }\n  _class133 = ColumnMenuSortComponent;\n  _defineProperty(ColumnMenuSortComponent, \"\\u0275fac\", function _class133_Factory(t) {\n    return new (t || _class133)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(ColumnMenuSortComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class133,\n    selectors: [[\"kendo-grid-columnmenu-sort\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 6,\n    consts: [[\"icon\", \"sort-asc-small\", 3, \"text\", \"svgIcon\", \"selected\", \"itemClick\"], [\"icon\", \"sort-desc-small\", 3, \"text\", \"svgIcon\", \"selected\", \"itemClick\"]],\n    template: function _class133_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function _class133_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleSort(\"asc\");\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(1, \"kendo-grid-columnmenu-item\", 1);\n        i0.ɵɵlistener(\"itemClick\", function _class133_Template_kendo_grid_columnmenu_item_itemClick_1_listener() {\n          return ctx.toggleSort(\"desc\");\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.ctx.localization.get(\"sortAscending\"))(\"svgIcon\", ctx.sortAscSmallIcon)(\"selected\", ctx.sortedAsc);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"text\", ctx.ctx.localization.get(\"sortDescending\"))(\"svgIcon\", ctx.sortDescSmallIcon)(\"selected\", ctx.sortedDesc);\n      }\n    },\n    dependencies: [ColumnMenuItemComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuSortComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst POPUP_CLASSES = 'k-grid-columnmenu-popup k-column-menu';\nlet id = 0;\nconst getId = gridId => `${gridId}-column-menu-${id++}`;\n/**\n * Represents the [column menu](slug:columnmenu_grid#toc-customizing-the-position) component.\n * ```html\n * <kendo-grid ...>\n *   <kendo-grid-column field=\"ProductName\" [columnMenu]=\"false\">\n *     <ng-template kendoGridHeaderTemplate let-column>\n *        <kendo-grid-column-menu [column]=\"column\"> </kendo-grid-column-menu>\n *     </ng-template>\n *   </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ColumnMenuComponent = /*#__PURE__*/(() => {\n  var _class134;\n  class ColumnMenuComponent {\n    /**\n     * @hidden\n     */\n    get showGeneralTab() {\n      return this.hasSort || this.hasLock || this.hasStick || this.hasPosition || this.hasAutoSizeColumn || this.hasAutoSizeAllColumns;\n    }\n    constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService) {\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"idService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"standalone\", true);\n      /**\n       * The Grid column instance to control with the menu.\n       */\n      _defineProperty(this, \"column\", void 0);\n      /**\n       * The settings for the Column Menu.\n       */\n      _defineProperty(this, \"settings\", {});\n      /**\n       * The descriptors by which the data will be sorted.\n       * Typically bound to the same value as [GridComponent.sort]({% slug api_grid_gridcomponent %}#toc-sort).\n       */\n      _defineProperty(this, \"sort\", void 0);\n      /**\n       * The descriptor by which the data will be filtered.\n       * Typically bound to the same value as [GridComponent.filter]({% slug api_grid_gridcomponent %}#toc-filter).\n       */\n      _defineProperty(this, \"filter\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"sortable\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"columnMenuTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"tabIndex\", '-1');\n      _defineProperty(this, \"anchor\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"defaultTemplate\", void 0);\n      _defineProperty(this, \"tabbedInterfaceTemplate\", void 0);\n      _defineProperty(this, \"tabStrip\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"columnsIcon\", columnsIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsClass\", 'k-actions');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"slidersIcon\", slidersIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"filterIcon\", filterIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"expandedFilter\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"expandedColumns\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"expandedPosition\", false);\n      _defineProperty(this, \"moreVerticalIcon\", moreVerticalIcon);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"closeSubscription\", void 0);\n      _defineProperty(this, \"popupSubs\", void 0);\n      this.navigationService = navigationService;\n      this.popupService = popupService;\n      this.service = service;\n      this.ctx = ctx;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.columnInfoService = columnInfoService;\n      this.idService = idService;\n      this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));\n    }\n    /**\n     * @hidden\n     */\n    get isActive() {\n      return this.hasFilter && filtersByField(this.filter, this.column.field).length > 0 || !this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field);\n    }\n    /**\n     * @hidden\n     */\n    get hasFilter() {\n      return hasFilter(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get isNavigable() {\n      return this.navigationService.tableEnabled;\n    }\n    /**\n     * @hidden\n     */\n    get hasSort() {\n      return hasSort(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get hasColumnChooser() {\n      return hasColumnChooser(this.settings);\n    }\n    /**\n     * @hidden\n     */\n    onApply(changed) {\n      this.close(true);\n      if (changed.length) {\n        this.cdr.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n      }\n    }\n    /**\n     * @hidden\n     */\n    get hasAutoSizeColumn() {\n      return hasAutoSizeColumn(this.settings);\n    }\n    /**\n     * @hidden\n     */\n    get hasAutoSizeAllColumns() {\n      return hasAutoSizeAllColumns(this.settings);\n    }\n    /**\n     * @hidden\n     */\n    get hasLock() {\n      return hasLock(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get hasStick() {\n      return hasStick(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get hasPosition() {\n      return hasPosition(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get columns() {\n      return this.columnInfoService.leafNamedColumns;\n    }\n    ngAfterViewInit() {\n      if (this.ctx.grid.virtualColumns && isDevMode()) {\n        if (this.settings.autoSizeAllColumns) {\n          this.settings.autoSizeAllColumns = false;\n          console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);\n        }\n        if (this.settings.autoSizeColumn) {\n          this.settings.autoSizeColumn = false;\n          console.warn(ColumnMenuErrorMessages.autoSizeColumn);\n        }\n      }\n      this.service.menuTabbingService.isTabbedInterface = this.settings.view === 'tabbed' ? true : false;\n    }\n    ngOnChanges() {\n      this.service.column = this.column;\n      this.service.sort = this.sort;\n      this.service.filter = this.filter;\n      this.service.sortable = this.sortable;\n    }\n    ngOnDestroy() {\n      this.close();\n      this.closeSubscription.unsubscribe();\n      this.popupSubs?.unsubscribe();\n      this.closeSubscription = this.popupSubs = null;\n    }\n    /**\n     * @hidden\n     */\n    toggle(e, anchor, template) {\n      if (e) {\n        e.preventDefault();\n        e instanceof KeyboardEvent && e.stopImmediatePropagation();\n      }\n      this.expandedFilter = this.getExpandedState(this.settings.filter);\n      this.expandedColumns = this.getExpandedState(this.settings.columnChooser);\n      this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);\n      this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASSES);\n      // Needed as changes to 'popupRef' and 'popupId' are not reflected\n      // automatically when the Popup is closed by clicking outside the anchor\n      const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;\n      if (this.popupRef) {\n        this.popupSubs?.unsubscribe();\n        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {\n          this.popupSubs?.unsubscribe();\n          this.popupSubs = null;\n          this.close(true);\n          this.updateAria(ariaRoot);\n        });\n        this.popupSubs.add(this.popupRef.popup.instance.close.subscribe(() => {\n          this.popupSubs?.unsubscribe();\n          this.popupSubs = this.popupRef = null;\n          this.updateAria(ariaRoot);\n        }));\n        const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-columnmenu-popup');\n        if (popupAriaElement) {\n          const popupId = getId(this.idService?.gridId());\n          this.renderer.setAttribute(popupAriaElement, 'id', popupId);\n          this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');\n          this.renderer.setAttribute(popupAriaElement, 'aria-label', this.columnMenuTitle);\n          ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);\n          ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');\n        }\n        if (this.settings.view === 'tabbed') {\n          this.renderer.addClass(popupAriaElement, 'k-column-menu-tabbed');\n          this.renderer.addClass(popupAriaElement, 'k-column-menu');\n          this.cdr.detectChanges();\n          this.tabStrip?.selectTab(0);\n        }\n      } else {\n        if (this.navigationService.tableEnabled) {\n          this.navigationService.focusCell(0, this.column.leafIndex);\n        } else {\n          this.anchor.nativeElement.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    close(triggerFocus = false) {\n      this.popupService.destroy();\n      this.popupRef = null;\n      this.cdr.markForCheck();\n      if (!triggerFocus) {\n        return;\n      }\n      if (this.navigationService.tableEnabled) {\n        this.navigationService.focusCell(0, this.column.leafIndex);\n      } else {\n        this.anchor.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get columnMenuTitle() {\n      const localizationMsg = this.ctx.localization.get('columnMenu') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n    getExpandedState(menuItemSettings) {\n      return typeof menuItemSettings === 'object' ? menuItemSettings.expanded : false;\n    }\n    updateAria(ariaRoot) {\n      ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');\n      ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');\n    }\n  }\n  _class134 = ColumnMenuComponent;\n  _defineProperty(ColumnMenuComponent, \"\\u0275fac\", function _class134_Factory(t) {\n    return new (t || _class134)(i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(ColumnMenuService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(ColumnMenuComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class134,\n    selectors: [[\"kendo-grid-column-menu\"]],\n    viewQuery: function _class134_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c14, 7);\n        i0.ɵɵviewQuery(_c15, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c5, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c21, 7, TemplateRef);\n        i0.ɵɵviewQuery(TabStripComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.anchor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabbedInterfaceTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabStrip = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class134_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-column-menu-standalone\", ctx.standalone);\n      }\n    },\n    inputs: {\n      standalone: \"standalone\",\n      column: \"column\",\n      settings: \"settings\",\n      sort: \"sort\",\n      filter: \"filter\",\n      sortable: \"sortable\",\n      columnMenuTemplate: \"columnMenuTemplate\",\n      tabIndex: \"tabIndex\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([ColumnMenuService, MenuTabbingService]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 9,\n    vars: 8,\n    consts: [[\"href\", \"#\", 1, \"k-grid-header-menu\", \"k-grid-column-menu\", 3, \"ngClass\", \"tabindex\", \"click\", \"keydown.enter\"], [\"anchor\", \"\"], [\"name\", \"more-vertical\", 3, \"svgIcon\"], [\"template\", \"\"], [\"defaultTemplate\", \"\"], [\"tabbedInterfaceTemplate\", \"\"], [3, \"keydown.escape\", \"keydown.enter\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"kendoGridColumnMenuItem\", \"service\", 4, \"ngIf\"], [3, \"showLock\", \"showStick\", \"kendoGridColumnMenuItem\", \"service\", \"expanded\", 4, \"ngIf\"], [\"class\", \"k-separator\", 3, \"borderColor\", 4, \"ngIf\"], [3, \"kendoGridColumnMenuItem\", \"service\", \"expanded\", 4, \"ngIf\"], [3, \"service\", \"kendoGridColumnMenuItem\", \"column\", 4, \"ngIf\"], [3, \"service\", \"kendoGridColumnMenuItem\", 4, \"ngIf\"], [3, \"kendoGridColumnMenuItem\", \"service\"], [\"sortItem\", \"\"], [\"lockItem\", \"\"], [\"stickItem\", \"\"], [3, \"showLock\", \"showStick\", \"kendoGridColumnMenuItem\", \"service\", \"expanded\"], [\"positionItem\", \"\"], [1, \"k-separator\"], [3, \"kendoGridColumnMenuItem\", \"service\", \"expanded\"], [\"chooserItem\", \"\"], [3, \"service\", \"kendoGridColumnMenuItem\", \"column\"], [\"autoSizeColumnItem\", \"\"], [3, \"service\", \"kendoGridColumnMenuItem\"], [\"autoSizeAllColumnsItem\", \"\"], [\"filterItem\", \"\"], [3, \"keydown.escape\"], [\"tabstrip\", \"\"], [4, \"ngIf\"], [\"kendoTabTitle\", \"\"], [\"kendoTabContent\", \"\"], [\"name\", \"filter\", 3, \"svgIcon\"], [3, \"column\", \"menuTabbingService\", \"filter\", \"actionsClass\", \"keydown.shift.tab\", \"close\"], [\"name\", \"sliders\", 3, \"svgIcon\"], [\"name\", \"columns\", 3, \"svgIcon\"], [3, \"applyText\", \"resetText\", \"columns\", \"autoSync\", \"allowHideAll\", \"actionsClass\", \"service\", \"apply\"]],\n    template: function _class134_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r63 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class134_Template_a_click_0_listener($event) {\n          i0.ɵɵrestoreView(_r63);\n          const _r0 = i0.ɵɵreference(1);\n          const _r1 = i0.ɵɵreference(4);\n          return i0.ɵɵresetView(ctx.toggle($event, _r0, _r1));\n        })(\"keydown.enter\", function _class134_Template_a_keydown_enter_0_listener($event) {\n          return $event.stopImmediatePropagation();\n        });\n        i0.ɵɵelement(2, \"kendo-icon-wrapper\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class134_ng_template_3_Template, 2, 5, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, _class134_ng_template_5_Template, 11, 10, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, _class134_ng_template_7_Template, 5, 3, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(6, _c23, ctx.isActive))(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵattribute(\"title\", ctx.columnMenuTitle)(\"aria-expanded\", ctx.isNavigable ? undefined : false)(\"aria-haspopup\", ctx.isNavigable ? undefined : \"dialog\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"svgIcon\", ctx.moreVerticalIcon);\n      }\n    },\n    dependencies: [NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, NgIf, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnListComponent],\n    encapsulation: 2\n  }));\n  return ColumnMenuComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ExcelService = /*#__PURE__*/(() => {\n  var _class135;\n  class ExcelService {\n    constructor() {\n      _defineProperty(this, \"saveToExcel\", new EventEmitter());\n      _defineProperty(this, \"exportClick\", new EventEmitter());\n    }\n    save(component) {\n      if (this.saveToExcel.observers.length === 0) {\n        if (isDevMode()) {\n          throw new Error(GridConfigurationErrorMessages.requiredModule('excel', 'ExcelModule', '<kendo-grid-excel>'));\n        }\n      } else {\n        this.saveToExcel.emit(component);\n      }\n    }\n  }\n  _class135 = ExcelService;\n  _defineProperty(ExcelService, \"\\u0275fac\", function _class135_Factory(t) {\n    return new (t || _class135)();\n  });\n  _defineProperty(ExcelService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class135,\n    factory: _class135.ɵfac\n  }));\n  return ExcelService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `excelExport` event.\n */\nclass ExcelExportEvent extends PreventableEvent {\n  constructor(workbook) {\n    super();\n    _defineProperty(this, \"workbook\", void 0);\n    this.workbook = workbook;\n  }\n}\nconst fetchComponentData = component => {\n  return {\n    data: component.view.map(item => item),\n    group: component.group\n  };\n};\nconst toExcelColumn = column => {\n  return {\n    title: column.title,\n    field: column.field,\n    locked: Boolean(column.locked),\n    width: column.width,\n    level: column.level,\n    hidden: !column.isVisible,\n    groupHeaderTemplate: column.groupHeaderTemplate,\n    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,\n    groupFooterTemplate: column.groupFooterTemplate,\n    footerTemplate: column.footerTemplate\n  };\n};\nconst toExcelColumns = columns => {\n  const result = [];\n  sortColumns(columns).forEach(column => {\n    if (column.isSpanColumn) {\n      result.push(...toExcelColumns(column.childrenArray));\n    } else {\n      const excelColumn = toExcelColumn(column);\n      if (column.isColumnGroup) {\n        excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));\n      }\n      result.push(excelColumn);\n    }\n  });\n  return result;\n};\nconst componentColumns = component => {\n  const columns = toExcelColumns(component.columns.toArray());\n  return orderBy(columns, [{\n    field: 'locked',\n    dir: 'desc'\n  }]);\n};\n/**\n * Configures the settings for the export of Grid in Excel ([see example]({% slug excelexport_grid %})).\n */\nlet ExcelComponent = /*#__PURE__*/(() => {\n  var _class137;\n  class ExcelComponent {\n    constructor(excelService, ctx, zone) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      /**\n       * Specifies the file name of the exported Excel file.\n       * @default \"Export.xlsx\"\n       */\n      _defineProperty(this, \"fileName\", 'Export.xlsx');\n      /**\n       * Enables or disables column filtering in the Excel file. This behavior is different from the filtering feature of the Grid.\n       */\n      _defineProperty(this, \"filterable\", void 0);\n      /**\n       * The author of the workbook.\n       */\n      _defineProperty(this, \"creator\", void 0);\n      /**\n       * The date on which the workbook was created. Defaults to `new Date()`.\n       */\n      _defineProperty(this, \"date\", void 0);\n      /**\n       * If set to `true`, the content is forwarded to [proxyURL](#toc-proxyurl) even if the browser supports the saving of files locally.\n       */\n      _defineProperty(this, \"forceProxy\", void 0);\n      /**\n       * The URL of the server-side proxy which streams the file to the end user.\n       *\n       * Using a proxy is required if the browser is not capable of saving files locally.\n       *\n       * Optionally, set up a proxy to reduce memory usage. This avoids copying the file contents in memory,\n       * but transmits it over the network instead. For this use case, set [forceProxy](#toc-forceproxy) to `true`\n       * to skip client-side saving even in browser that support it.\n       *\n       * In the request body, the proxy receives a POST request with the specific parameters. [See example](slug:server_proxy#toc-implementations).\n       * The proxy returns the decoded file with the `\"Content-Disposition\"` header set to `attachment; filename=\"<fileName.xslx>\"`.\n       *\n       * For details on the server-side proxy usage and implementation, see the [File Saver]({% slug overview_filesaver %}) documentation.\n       */\n      _defineProperty(this, \"proxyURL\", void 0);\n      /**\n       * The function that is used to get the exported data options. By default, uses the current data and group of the Grid.\n       * To export data that is different from the current Grid data, provide a custom function.\n       */\n      _defineProperty(this, \"fetchData\", void 0);\n      /**\n       * If the data is grouped, the options of the cells that are inserted before the data,\n       * group, and footer cells to indicate the group hierarchy.\n       */\n      _defineProperty(this, \"paddingCellOptions\", void 0);\n      /**\n       * If the data is grouped, the options of the cells that are inserted before the\n       * header cells to align the headers and the column values.\n       */\n      _defineProperty(this, \"headerPaddingCellOptions\", void 0);\n      /**\n       * Specifies if the groups in the Excel file are collapsible.\n       */\n      _defineProperty(this, \"collapsible\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"columns\", new QueryList());\n      _defineProperty(this, \"saveSubscription\", void 0);\n      _defineProperty(this, \"dataSubscription\", void 0);\n      this.ctx = ctx;\n      this.zone = zone;\n      this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));\n    }\n    ngOnDestroy() {\n      this.saveSubscription.unsubscribe();\n      if (this.dataSubscription) {\n        this.dataSubscription.unsubscribe();\n      }\n    }\n    save(component) {\n      const data = (this.fetchData || fetchComponentData)(component);\n      const exportData = result => {\n        delete this.dataSubscription;\n        this.exportData(component, result);\n      };\n      if (data instanceof Promise) {\n        data.then(exportData);\n      } else if (data instanceof Observable) {\n        this.dataSubscription = data.pipe(take(1)).subscribe(exportData);\n      } else {\n        exportData(data);\n      }\n    }\n    exportData(component, result) {\n      const options = workbookOptions({\n        columns: this.columns.length ? this.columns : componentColumns(component),\n        data: result.data,\n        group: result.group,\n        filterable: this.filterable,\n        creator: this.creator,\n        date: this.date,\n        paddingCellOptions: this.paddingCellOptions,\n        headerPaddingCellOptions: this.headerPaddingCellOptions,\n        rtl: this.ctx.localization.rtl,\n        collapsible: this.collapsible\n      });\n      const args = new ExcelExportEvent(options);\n      component.excelExport.emit(args);\n      if (!args.isDefaultPrevented()) {\n        this.zone.runOutsideAngular(() => this.saveFile(options));\n      }\n    }\n    saveFile(options) {\n      toDataURL(options).then(dataURL => {\n        saveAs(dataURL, this.fileName, {\n          forceProxy: this.forceProxy,\n          proxyURL: this.proxyURL\n        });\n      });\n    }\n  }\n  _class137 = ExcelComponent;\n  _defineProperty(ExcelComponent, \"\\u0275fac\", function _class137_Factory(t) {\n    return new (t || _class137)(i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ExcelComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class137,\n    selectors: [[\"kendo-grid-excel\"]],\n    contentQueries: function _class137_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase$1, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    inputs: {\n      fileName: \"fileName\",\n      filterable: \"filterable\",\n      creator: \"creator\",\n      date: \"date\",\n      forceProxy: \"forceProxy\",\n      proxyURL: \"proxyURL\",\n      fetchData: \"fetchData\",\n      paddingCellOptions: \"paddingCellOptions\",\n      headerPaddingCellOptions: \"headerPaddingCellOptions\",\n      collapsible: \"collapsible\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class137_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ExcelComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `export-to-Excel` command of the Grid. You can apply this\n * directive to any `button` element inside a\n * [ToolbarTemplate]({% slug api_grid_toolbartemplatedirective %}).\n * When the user clicks a button associated with the directive, the\n * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event\n * fires ([see example]({% slug excelexport_grid %})).\n *\n * @example\n * ```html\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridExcelCommand>Export to Excel</button>\n *      </ng-template>\n *      <kendo-grid-excel fileName=\"Grid.xlsx\">\n *      </kendo-grid-excel>\n * </kendo-grid>\n * ```\n */\nlet ExcelCommandDirective = /*#__PURE__*/(() => {\n  var _class138;\n  class ExcelCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.excelService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    get excelClass() {\n      return true;\n    }\n    constructor(excelService, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"excelService\", void 0);\n      this.excelService = excelService;\n      this.ngZone = ngZone;\n    }\n  }\n  _class138 = ExcelCommandDirective;\n  _defineProperty(ExcelCommandDirective, \"\\u0275fac\", function _class138_Factory(t) {\n    return new (t || _class138)(i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ExcelCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class138,\n    selectors: [[\"\", \"kendoGridExcelCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class138_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class138_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-excel\", ctx.excelClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c24,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class138_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class138_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class138_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class138_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return ExcelCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SuspendService = /*#__PURE__*/(() => {\n  var _class139;\n  class SuspendService {\n    constructor() {\n      _defineProperty(this, \"scroll\", false);\n    }\n  }\n  _class139 = SuspendService;\n  _defineProperty(SuspendService, \"\\u0275fac\", function _class139_Factory(t) {\n    return new (t || _class139)();\n  });\n  _defineProperty(SuspendService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class139,\n    factory: _class139.ɵfac\n  }));\n  return SuspendService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet PDFService = /*#__PURE__*/(() => {\n  var _class140;\n  class PDFService {\n    constructor() {\n      _defineProperty(this, \"savePDF\", new EventEmitter());\n      _defineProperty(this, \"drawPDF\", new EventEmitter());\n      _defineProperty(this, \"exportClick\", new EventEmitter());\n      _defineProperty(this, \"dataChanged\", new EventEmitter());\n      _defineProperty(this, \"exporting\", void 0);\n    }\n    save(component) {\n      this.emitEvent(this.savePDF, component);\n    }\n    draw(component, promise) {\n      this.emitEvent(this.drawPDF, {\n        component,\n        promise\n      });\n    }\n    /**\n     * @hidden\n     */\n    emitEvent(emitter, args) {\n      if (emitter.observers.length === 0) {\n        if (isDevMode()) {\n          throw new Error(GridConfigurationErrorMessages.requiredModule('PDF', 'PDFModule', '<kendo-grid-pdf>'));\n        }\n      } else {\n        emitter.emit(args);\n      }\n    }\n  }\n  _class140 = PDFService;\n  _defineProperty(PDFService, \"\\u0275fac\", function _class140_Factory(t) {\n    return new (t || _class140)();\n  });\n  _defineProperty(PDFService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class140,\n    factory: _class140.ɵfac\n  }));\n  return PDFService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the Kendo UI PDFMargin component for Angular.\n * The supported units are:\n * `\"mm\"`\n * `\"cm\"`\n * `\"in\"`\n * `\"pt\"` (default).\n * Numbers are considered to be points (`\"pt\"`).\n */\nlet PDFMarginComponent = /*#__PURE__*/(() => {\n  var _class141;\n  class PDFMarginComponent extends PDFExportMarginComponent {}\n  _class141 = PDFMarginComponent;\n  _defineProperty(PDFMarginComponent, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class141_BaseFactory;\n    return function _class141_Factory(t) {\n      return (ɵ_class141_BaseFactory || (ɵ_class141_BaseFactory = i0.ɵɵgetInheritedFactory(_class141)))(t || _class141);\n    };\n  }());\n  _defineProperty(PDFMarginComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class141,\n    selectors: [[\"kendo-grid-pdf-margin\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class141_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return PDFMarginComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the PDF page template of the Grid that helps to customize the PDF pages. To define a page template,\n * nest an `<ng-template>` tag with the `kendoGridPDFTemplate` directive inside `<kendo-grid-pdf>` tag.\n *\n * The template context provides the following fields:\n * - `pageNumber`&mdash;Defines PDF page number.\n * - `totalPages`&mdash;Defines the total number of PDF pages.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *   ...\n *   <kendo-grid-pdf fileName=\"Products.pdf\" paperSize=\"A4\">\n *     <ng-template kendoGridPDFTemplate let-pageNumber=\"pageNumber\" let-totalPages=\"totalPages\">\n *         Page {{ pageNumber }} of {{ totalPages }}\n *     </ng-template>\n *   </kendo-grid-pdf>\n * </kendo-grid>\n * ```\n */\nlet PDFTemplateDirective = /*#__PURE__*/(() => {\n  var _class142;\n  class PDFTemplateDirective extends PDFExportTemplateDirective {\n    constructor(templateRef) {\n      super(templateRef);\n    }\n  }\n  _class142 = PDFTemplateDirective;\n  _defineProperty(PDFTemplateDirective, \"\\u0275fac\", function _class142_Factory(t) {\n    return new (t || _class142)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(PDFTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class142,\n    selectors: [[\"\", \"kendoGridPDFTemplate\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return PDFTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst HEADER_CLASS = 'k-grid-header';\n/**\n * @hidden\n */\nconst FOOTER_CLASS = 'k-grid-footer';\nconst GRID_LIST = 'KENDO-GRID-LIST';\nconst TABLE = 'TABLE';\nconst matchesList = matchesNodeName(GRID_LIST);\nconst matchesTable = matchesNodeName(TABLE);\nconst suffix = locked => locked ? 'locked' : 'wrap';\n/**\n * @hidden\n */\nclass GridQuery {\n  constructor(element) {\n    _defineProperty(this, \"element\", void 0);\n    _defineProperty(this, \"headerWrap\", void 0);\n    _defineProperty(this, \"list\", void 0);\n    _defineProperty(this, \"footerWrap\", void 0);\n    this.element = element;\n    this.list = findElement(element, matchesList);\n  }\n  content(locked) {\n    return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));\n  }\n  header(locked) {\n    this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));\n    return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));\n  }\n  footer(locked) {\n    this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));\n    return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));\n  }\n  table() {\n    return findElement(this.element, matchesTable);\n  }\n}\nconst FIRST_CLASS = 'k-first';\nconst INPUTS = ['input', 'select', 'textarea', 'option'];\n/** @hidden */\nconst cloneNode = node => {\n  const clone = node.cloneNode(false);\n  if (node._kendoExportVisual) {\n    clone._kendoExportVisual = node._kendoExportVisual;\n  }\n  if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {\n    clone.removeAttribute(\"id\");\n    clone.removeAttribute(\"name\");\n    clone.value = node.value;\n    clone.checked = node.checked;\n    clone.selected = node.selected;\n  }\n  let child = node.firstChild;\n  while (child) {\n    clone.appendChild(cloneNode(child));\n    child = child.nextSibling;\n  }\n  return clone;\n};\nconst appendNodes = (element, nodes) => {\n  const length = nodes.length;\n  for (let idx = 0; idx < length; idx++) {\n    element.appendChild(cloneNode(nodes[idx]));\n  }\n};\nconst wrapTable = (table, size) => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  const wrapper = document.createElement('div');\n  const classes = ['k-grid'];\n  if (size && size !== 'none') {\n    classes.push(`k-grid-${size === 'medium' ? 'md' : 'sm'}`);\n  }\n  wrapper.classList.add(...classes);\n  wrapper.appendChild(table);\n  return wrapper;\n};\nconst createTableElement = sources => {\n  const sourceCount = sources.length;\n  const element = cloneNode(sources[0]);\n  const rowsCount = element.rows.length;\n  if (sourceCount > 1) {\n    for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n      for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {\n        appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);\n      }\n    }\n  }\n  return element;\n};\nconst setFirstCellClass = (header, headers) => {\n  if (headers.length > 1 && header.rows.length > 1) {\n    for (let idx = 1; idx < header.rows.length; idx++) {\n      const firstCellIndex = headers[0].rows[idx].cells.length;\n      const cell = header.rows[idx].cells[firstCellIndex];\n      if (String(cell.className).indexOf(FIRST_CLASS) === -1) {\n        cell.className += ` ${FIRST_CLASS}`;\n      }\n    }\n  }\n};\nconst createTable = (colGroups, headers, bodies, footers, size) => {\n  const table = document.createElement('table');\n  const classes = ['k-table'];\n  if (size && size !== 'none') {\n    classes.push(`k-table-${size === 'medium' ? 'md' : 'sm'}`);\n  }\n  table.classList.add(...classes);\n  const colGroup = colGroups[0].cloneNode(true);\n  for (let idx = 1; idx < colGroups.length; idx++) {\n    appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));\n  }\n  const header = createTableElement(headers);\n  const body = createTableElement(bodies);\n  setFirstCellClass(header, headers);\n  table.appendChild(colGroup);\n  table.appendChild(header);\n  table.appendChild(body);\n  if (footers.length) {\n    const footer = createTableElement(footers);\n    table.appendChild(footer);\n  }\n  return wrapTable(table, size);\n};\n/**\n * @hidden\n */\nconst exportElement = (wrapper, size) => {\n  const query = new GridQuery(wrapper);\n  const content = query.content();\n  let result;\n  if (content) {\n    const colGroups = [content.querySelector('colgroup')];\n    const headers = [query.header().querySelector('thead')];\n    const bodies = [content.querySelector('tbody')];\n    const footer = query.footer();\n    const footers = [];\n    if (footer) {\n      footers.push(footer.querySelector('tfoot'));\n    }\n    const lockedContent = query.content(true);\n    if (lockedContent) {\n      colGroups.unshift(lockedContent.querySelector('colgroup'));\n      headers.unshift(query.header(true).querySelector('thead'));\n      bodies.unshift(lockedContent.querySelector('tbody'));\n      if (footer) {\n        footers.unshift(query.footer(true).querySelector('tfoot'));\n      }\n    }\n    result = createTable(colGroups, headers, bodies, footers, size);\n  } else {\n    result = wrapTable(query.table().cloneNode(true), size);\n  }\n  return result;\n};\nconst createElement$1 = (tagName, className) => {\n  const element = document.createElement(tagName);\n  if (className) {\n    element.className = className;\n  }\n  return element;\n};\nconst createDiv = className => {\n  return createElement$1('div', className);\n};\n/**\n * Configures the settings for the export of Grid in PDF ([see example]({% slug pdfexport_grid %})).\n */\nlet PDFComponent = /*#__PURE__*/(() => {\n  var _class144;\n  class PDFComponent extends PDFExportComponent {\n    constructor(pdfService, suspendService, ngZone, element, ctx) {\n      super(element);\n      _defineProperty(this, \"pdfService\", void 0);\n      _defineProperty(this, \"suspendService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      /**\n       * Exports all Grid pages, starting from the first one.\n       */\n      _defineProperty(this, \"allPages\", void 0);\n      /**\n       * The delay in milliseconds before exporting the Grid content.\n       * Useful for scenarios which involve exporting complex components used in the Grid\n       * templates such as charts or data-bound components with asynchronous data retrieval ([see example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"delay\", 0);\n      _defineProperty(this, \"columns\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"marginComponent\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"pageTemplateDirective\", void 0);\n      _defineProperty(this, \"progress\", void 0);\n      _defineProperty(this, \"component\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"skip\", void 0);\n      _defineProperty(this, \"pageSize\", void 0);\n      _defineProperty(this, \"originalHeight\", void 0);\n      _defineProperty(this, \"originalOverflow\", void 0);\n      _defineProperty(this, \"saveSubscription\", void 0);\n      _defineProperty(this, \"drawSubscription\", void 0);\n      _defineProperty(this, \"renderAllPages\", void 0);\n      _defineProperty(this, \"originalColumns\", void 0);\n      this.pdfService = pdfService;\n      this.suspendService = suspendService;\n      this.ngZone = ngZone;\n      this.ctx = ctx;\n      this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));\n      this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));\n      this.reset = this.reset.bind(this);\n      this.draw = this.draw.bind(this);\n    }\n    ngOnDestroy() {\n      this.saveSubscription.unsubscribe();\n      this.drawSubscription.unsubscribe();\n      this.reset();\n    }\n    /**\n     * @hidden\n     */\n    saveAs() {\n      throw new Error(GridConfigurationErrorMessages.unsupportedMethod('saveAs', 'GridComponent.saveAsPDF'));\n    }\n    /**\n     * @hidden\n     */\n    export() {\n      throw new Error(GridConfigurationErrorMessages.unsupportedMethod('export', 'GridComponent.drawPDF'));\n    }\n    savePDF(component) {\n      this.createPDF(component, this.draw);\n    }\n    drawPDF({\n      component,\n      promise\n    }) {\n      this.createPDF(component, () => {\n        this.createExportGroup(promise);\n      });\n    }\n    createPDF(component, callback) {\n      const pageSize = component.pageSize;\n      const total = component.view.total;\n      const columns = this.columns.toArray();\n      if (columns.length) {\n        this.originalColumns = component.columns.toArray();\n      }\n      this.component = component;\n      this.suspendService.scroll = true;\n      this.pdfService.exporting = true;\n      this.initProgress();\n      this.renderAllPages = this.allPages && pageSize < total;\n      if (this.renderAllPages) {\n        this.skip = component.skip;\n        this.pageSize = pageSize;\n        this.changePage(0, total, callback, columns);\n      } else if (columns.length || component.virtualColumns) {\n        this.changeColumns(columns, callback);\n      } else {\n        callback();\n      }\n    }\n    initProgress() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const wrapperElement = this.component.wrapper.nativeElement;\n      const progress = this.progress = createDiv('k-loading-pdf-mask');\n      const overlay = cloneNode(wrapperElement);\n      progress.appendChild(overlay);\n      progress.appendChild(createDiv('k-loading-color'));\n      progress.appendChild(createElement$1('span', 'k-i-loading k-icon'));\n      this.originalHeight = wrapperElement.style.height;\n      this.originalOverflow = wrapperElement.style.overflow;\n      wrapperElement.style.height = wrapperElement.offsetHeight + 'px';\n      wrapperElement.style.overflow = 'hidden';\n      wrapperElement.appendChild(progress);\n      this.applyScroll(overlay);\n    }\n    applyScroll(overlay) {\n      const query = new GridQuery(this.component.wrapper.nativeElement);\n      const content = query.content();\n      if (content) {\n        const overlayQuery = new GridQuery(overlay);\n        const overlayContent = overlayQuery.content();\n        overlayContent.scrollTop = content.scrollTop;\n        overlayContent.scrollLeft = content.scrollLeft;\n        overlayQuery.header().scrollLeft = query.header().scrollLeft;\n        const footer = query.footer();\n        if (footer) {\n          overlayQuery.footer().scrollLeft = footer.scrollLeft;\n        }\n        const lockedContent = query.content(true);\n        if (lockedContent) {\n          const overlayLockedContent = overlayQuery.content(true);\n          overlayLockedContent.scrollTop = lockedContent.scrollTop;\n          overlayLockedContent.scrollLeft = lockedContent.scrollLeft;\n        }\n      }\n    }\n    draw() {\n      this.createExportElement(element => {\n        this.save(element, this.fileName);\n      });\n    }\n    createExportGroup(promise) {\n      this.createExportElement(element => {\n        this.exportElement(element).then(group => promise.resolve(group));\n      });\n    }\n    createExportElement(callback) {\n      this.ngZone.runOutsideAngular(() => {\n        const container = this.container = createDiv('k-grid-pdf-export-element');\n        const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || 'medium');\n        container.appendChild(element);\n        document.body.appendChild(container);\n        callback(element);\n      });\n    }\n    drawOptions() {\n      const options = super.drawOptions();\n      options._destructive = true;\n      return options;\n    }\n    cleanup() {\n      super.cleanup();\n      this.pdfService.exporting = false;\n      if (this.component) {\n        const originalColumns = this.originalColumns;\n        delete this.originalColumns;\n        if (this.renderAllPages) {\n          this.changePage(this.skip, this.pageSize, this.reset, originalColumns);\n        } else if (originalColumns || this.component.virtualColumns) {\n          this.changeColumns(originalColumns, this.reset);\n        } else {\n          this.reset();\n        }\n      } else {\n        this.reset();\n      }\n      this.removeContainer();\n    }\n    removeContainer() {\n      if (this.container) {\n        document.body.removeChild(this.container);\n        delete this.container;\n      }\n    }\n    changePage(skip, _take, callback, columns) {\n      this.ngZone.run(() => {\n        this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {\n          if (columns && columns.length || this.component.virtualColumns) {\n            this.changeColumns(columns, callback);\n          } else {\n            this.onStable(callback);\n          }\n        });\n        this.component.notifyPageChange('pdf', {\n          skip: skip,\n          take: _take\n        });\n      });\n    }\n    changeColumns(columns, callback) {\n      this.ngZone.run(() => {\n        this.onStable(callback);\n        if (columns && columns.length) {\n          this.component.columns.reset(columns);\n        }\n      });\n    }\n    reset() {\n      this.suspendService.scroll = false;\n      this.renderAllPages = false;\n      if (!this.component) {\n        return;\n      }\n      const wrapperElement = this.component.wrapper.nativeElement;\n      wrapperElement.removeChild(this.progress);\n      wrapperElement.style.height = this.originalHeight;\n      wrapperElement.style.overflow = this.originalOverflow;\n      delete this.progress;\n      delete this.component;\n    }\n    onStable(callback) {\n      // not sure if it is an actual scenario. occurs in the tests.\n      // onStable is triggered in the same pass without the change detection.\n      // thus, the callback is called before the changes are applied without the timeout.\n      setTimeout(() => {\n        let onStable = this.ngZone.onStable.asObservable().pipe(take(1));\n        if (this.delay > 0) {\n          onStable = onStable.pipe(delay(this.delay));\n        }\n        onStable.subscribe(callback);\n      }, 0);\n    }\n  }\n  _class144 = PDFComponent;\n  _defineProperty(PDFComponent, \"\\u0275fac\", function _class144_Factory(t) {\n    return new (t || _class144)(i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(SuspendService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ContextService, 8));\n  });\n  _defineProperty(PDFComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class144,\n    selectors: [[\"kendo-grid-pdf\"]],\n    contentQueries: function _class144_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, PDFTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.marginComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    inputs: {\n      allPages: \"allPages\",\n      delay: \"delay\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class144_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return PDFComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `export-to-PDF` command of the Grid.\n * You can apply this directive to any `button` element inside a\n * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).\n * When the user clicks a button that is associated with the directive, the\n * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event\n * fires ([see example]({% slug pdfexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridPDFCommand>Export to PDF</button>\n *      </ng-template>\n *      <kendo-grid-pdf fileName=\"Grid.pdf\">\n *      </kendo-grid-pdf>\n * </kendo-grid>\n * ```\n */\nlet PDFCommandDirective = /*#__PURE__*/(() => {\n  var _class145;\n  class PDFCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.pdfService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    get pdfClass() {\n      return true;\n    }\n    constructor(pdfService, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"pdfService\", void 0);\n      this.pdfService = pdfService;\n      this.ngZone = ngZone;\n    }\n  }\n  _class145 = PDFCommandDirective;\n  _defineProperty(PDFCommandDirective, \"\\u0275fac\", function _class145_Factory(t) {\n    return new (t || _class145)(i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(PDFCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class145,\n    selectors: [[\"\", \"kendoGridPDFCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class145_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class145_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-pdf\", ctx.pdfClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c25,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class145_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class145_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class145_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class145_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return PDFCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst isFilterable = settings => settings !== false;\n/**\n * @hidden\n */\nconst hasFilterMenu = settings => typeof settings === 'string' && settings.indexOf('menu') > -1;\n/**\n * @hidden\n */\nconst hasFilterRow = settings => settings === true || typeof settings === 'string' && settings.indexOf('row') > -1;\n\n/**\n * @hidden\n */\nlet ColumnReorderService = /*#__PURE__*/(() => {\n  var _class146;\n  class ColumnReorderService {\n    constructor() {\n      _defineProperty(this, \"changes\", new EventEmitter());\n    }\n    reorder(e) {\n      this.changes.emit(e);\n    }\n  }\n  _class146 = ColumnReorderService;\n  _defineProperty(ColumnReorderService, \"\\u0275fac\", function _class146_Factory(t) {\n    return new (t || _class146)();\n  });\n  _defineProperty(ColumnReorderService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class146,\n    factory: _class146.ɵfac\n  }));\n  return ColumnReorderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `columnReorder` event.\n */\nclass ColumnReorderEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor({\n    column,\n    newIndex,\n    oldIndex\n  }) {\n    super();\n    /**\n     * The reordered column.\n     */\n    _defineProperty(this, \"column\", void 0);\n    /**\n     * The new index of the column.\n     * Relative to the collection of columns.\n     */\n    _defineProperty(this, \"newIndex\", void 0);\n    /**\n     * The original index of the column before reordering.\n     * Relative to the collection of columns.\n     */\n    _defineProperty(this, \"oldIndex\", void 0);\n    this.column = column;\n    this.newIndex = newIndex;\n    this.oldIndex = oldIndex;\n  }\n}\n\n/**\n * @hidden\n */\nconst fromPercentage = (value, percent) => {\n  const sign = percent < 0 ? -1 : 1;\n  return Math.ceil(Math.abs(percent) / 100 * value) * sign;\n};\n/**\n * @hidden\n */\nconst toPercentage = (value, whole) => value / whole * 100;\n/**\n * @hidden\n */\nconst headerWidth = handle => handle.nativeElement.parentElement.getBoundingClientRect().width;\n/**\n * @hidden\n */\nconst adjacentColumnWidth = handle => handle.nativeElement.parentElement.nextElementSibling?.getBoundingClientRect().width;\n/**\n * @hidden\n */\nconst adjacentColumnInGroupWidth = (handle, rowIndex, colIndex) => {\n  const tableElement = handle.nativeElement.closest('.k-grid-header-table');\n  const selector = rowAttribute => `tr[${rowAttribute}=\"${rowIndex}\"] th[aria-colindex=\"${colIndex}\"]`;\n  const thElement = tableElement.querySelector([selector('aria-rowindex'), selector('data-kendo-grid-row-index')]);\n  return thElement.getBoundingClientRect().width;\n};\n/**\n * @hidden\n */\nconst allLeafColumns = columns => expandColumns(columns).filter(c => !c.isColumnGroup);\n/**\n * @hidden\n */\nconst createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({\n  pageX\n}) => ({\n  originalX: mouseDown.pageX,\n  pageX\n})));\n/**\n * @hidden\n */\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n/**\n * @hidden\n */\nconst isInSpanColumn = column => !!(column.parent && column.parent.isSpanColumn);\n/**\n * @hidden\n *\n * Calculates the column index. If the column is stated in `SpanColumn`,\n * the index for all child columns equals the index of the first child.\n */\nconst indexOf = (target, list) => {\n  let index = 0;\n  let ignore = 0;\n  let skip = 0;\n  while (index < list.length) {\n    const current = list[index];\n    const isParentSpanColumn = isInSpanColumn(current);\n    if (current === target) {\n      break;\n    }\n    if (ignore-- <= 0 && isParentSpanColumn) {\n      ignore = current.parent.childColumns.length - 1;\n      skip += ignore;\n    }\n    index++;\n  }\n  return index - skip;\n};\n/**\n * @hidden\n */\nlet ColumnHandleDirective = /*#__PURE__*/(() => {\n  var _class148;\n  class ColumnHandleDirective {\n    get visible() {\n      if (this.isConstrainedMode && (this.isLast || this.isLastInGroup(this.column))) {\n        return 'none';\n      }\n      return this.column.resizable ? 'block' : 'none';\n    }\n    get leftStyle() {\n      return isTruthy(this.rtl) ? 0 : null;\n    }\n    get rightStyle() {\n      return isTruthy(this.rtl) ? null : 0;\n    }\n    get isConstrainedMode() {\n      const isConstrainedMode = this.ctx.grid?.resizable === 'constrained';\n      const isUnconstrainedMode = this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === 'unconstrained';\n      const constrainedNoShift = isConstrainedMode && !this.service.isShiftPressed;\n      const unconstrainedWithShift = isUnconstrainedMode && this.service.isShiftPressed;\n      return constrainedNoShift || unconstrainedWithShift;\n    }\n    autoFit() {\n      this.service.autoFitResize = true;\n      const allLeafs = allLeafColumns(this.columns);\n      const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));\n      const columnInfo = currentLeafs.map(column => {\n        const isParentSpan = isInSpanColumn(column);\n        const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;\n        const index = indexOf(column, allLeafs);\n        return {\n          column,\n          headerIndex: this.columnsForLevel(column.level).indexOf(column),\n          index,\n          isLastInSpan,\n          isParentSpan,\n          level: column.level\n        };\n      });\n      currentLeafs.forEach(column => column.width = 0);\n      this.service.measureColumns(columnInfo);\n    }\n    constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"isLast\", void 0);\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"rtl\", false);\n      _defineProperty(this, \"totalChildrenSum\", 0);\n      _defineProperty(this, \"childrenColumns\", []);\n      _defineProperty(this, \"minWidthTotal\", 0);\n      _defineProperty(this, \"foundColumn\", void 0);\n      _defineProperty(this, \"stopPropagation\", ({\n        originalEvent: event\n      }) => {\n        this.service.isShiftPressed = event.shiftKey;\n        event.stopPropagation();\n        event.preventDefault();\n      });\n      this.draggable = draggable;\n      this.element = element;\n      this.service = service;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.ctx = ctx;\n      this.columnInfoService = columnInfoService;\n    }\n    ngOnInit() {\n      if (isBlank(this.column.width)) {\n        this.column.implicitWidth = headerWidth(this.element);\n      }\n      const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'start')).subscribe(this.initState.bind(this)));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn')).subscribe(this.resize.bind(this)));\n      this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only\n      ).subscribe(this.initColumnWidth.bind(this)));\n      this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(this.stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable))).subscribe(({\n        pageX,\n        originalX\n      }) => {\n        const delta = pageX - originalX;\n        const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);\n        this.service.resizeColumns(percent);\n      })));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete')).subscribe(this.sizeToFit.bind(this)));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit')).subscribe(this.autoFit.bind(this)));\n      this.subscriptions.add(this.ctx.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl));\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    shouldUpdate() {\n      return !allLeafColumns(this.columns).map(column => column.width || this.isConstrainedMode && !column.width && column.implicitWidth).some(isBlank);\n    }\n    initColumnWidth() {\n      this.column.width = headerWidth(this.element);\n      if (this.isConstrainedMode) {\n        this.column.resizeStartWidth = this.column.width;\n      }\n    }\n    initState() {\n      this.column.resizeStartWidth = headerWidth(this.element);\n      if (this.isConstrainedMode && !this.service.adjacentColumn) {\n        this.setAdjacentColumn();\n      }\n      this.service.resizedColumn({\n        column: this.column,\n        oldWidth: this.column.resizeStartWidth\n      });\n    }\n    resize({\n      deltaPercent\n    }) {\n      let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);\n      if (isTruthy(this.rtl)) {\n        delta *= -1;\n      }\n      let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);\n      if (isPresent(this.column.maxResizableWidth)) {\n        newWidth = Math.min(newWidth, this.column.maxResizableWidth);\n      }\n      if (this.isConstrainedMode) {\n        newWidth = this.calcNewColumnWidth(newWidth);\n      }\n      const tableDelta = this.getTableDelta(newWidth, delta);\n      this.updateWidth(this.column, newWidth);\n      this.service.resizeTable(this.column, tableDelta);\n    }\n    sizeToFit({\n      columns,\n      widths\n    }) {\n      const index = columns.indexOf(this.column);\n      const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE\n      const tableDelta = width - this.column.resizeStartWidth;\n      this.updateWidth(this.column, width);\n      this.service.resizeTable(this.column, tableDelta);\n    }\n    updateWidth(column, width) {\n      if (this.isConstrainedMode && this.service.adjacentColumn && !this.service.autoFitResize) {\n        this.updateWidthsOfResizedColumns(column, width);\n      }\n      column.width = width;\n      this.columnInfoService.hiddenColumns.forEach(col => {\n        if (isBlank(col.width) && isPresent(col.implicitWidth)) {\n          // Resize hidden columns to their implicit width so they\n          // can be displayed with the same width if made visible.\n          col.width = col.implicitWidth;\n        }\n      });\n      this.cdr.markForCheck(); //force CD cycle\n    }\n\n    updateWidthsOfResizedColumns(column, width) {\n      let adjacentColumnNewWidth = column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - width;\n      if (this.service.draggedGroupColumn && column.parent) {\n        this.updateWidthOfDraggedColumn(column, width);\n        this.setGroupWidths(this.service.draggedGroupColumn);\n      } else if (!this.service.draggedGroupColumn && !column.parent && this.service.adjacentColumn.parent) {\n        this.service.adjacentColumn.parent.width = column.width + this.service.adjacentColumn.parent.width - width;\n        this.service.adjacentColumn.width = adjacentColumnNewWidth;\n      } else if (!this.service.draggedGroupColumn && column.parent && this.service.adjacentColumn.parent) {\n        adjacentColumnNewWidth = column.width + this.service.adjacentColumn.width - width;\n        this.service.adjacentColumn.width = adjacentColumnNewWidth;\n        const filteredColumns = this.service.adjacentColumn.parent.children.filter(c => c !== this.service.adjacentColumn);\n        const filteredColumnsWidth = filteredColumns.reduce((acc, c) => acc + c.width, 0);\n        this.service.adjacentColumn.parent.width = adjacentColumnNewWidth + filteredColumnsWidth;\n        this.setGroupWidths(this.service.adjacentColumn.parent);\n      } else if (adjacentColumnNewWidth > this.service.adjacentColumn.minResizableWidth) {\n        this.service.adjacentColumn.width = adjacentColumnNewWidth;\n      }\n    }\n    calcNewColumnWidth(newWidth) {\n      let maxAllowedResizableWidth;\n      if (!this.service.adjacentColumn.parent) {\n        maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width - this.service.adjacentColumn.minResizableWidth;\n        if (!this.column.parent) {\n          maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;\n          if (this.service.adjacentColumn.maxResizableWidth) {\n            const minResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.maxResizableWidth;\n            maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;\n            this.column.minResizableWidth = minResizableWidth;\n            this.column.maxResizableWidth = maxAllowedResizableWidth;\n          }\n        }\n      } else {\n        maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width;\n        newWidth = Math.min(newWidth, maxAllowedResizableWidth);\n        this.minWidthTotal = 0;\n        const minResizableWidth = this.minAdjacentColumnWidth(this.service.adjacentColumn);\n        maxAllowedResizableWidth -= minResizableWidth;\n      }\n      return Math.min(newWidth, maxAllowedResizableWidth - 1);\n    }\n    setAdjacentColumn() {\n      const columnsForLevel = this.columnsForLevel(this.column.level);\n      if (this.column.parent) {\n        if (this.column.isReordered) {\n          this.service.adjacentColumn = columnsForLevel.find(c => c.orderIndex === this.column.orderIndex + 1);\n          this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;\n        } else {\n          const columnIndex = columnsForLevel.indexOf(this.column);\n          this.service.adjacentColumn = columnsForLevel[columnIndex + 1];\n          this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);\n          const parentColumnChildren = Array.from(this.column.parent.children);\n          const indexOfCurrentColumn = parentColumnChildren.indexOf(this.column);\n          let adjacentColumn;\n          if (indexOfCurrentColumn + 1 <= parentColumnChildren.length - 1) {\n            adjacentColumn = parentColumnChildren[indexOfCurrentColumn + 1];\n            if (adjacentColumn?.isColumnGroup) {\n              this.service.adjacentColumn = adjacentColumn;\n            }\n          }\n        }\n        if (this.service.adjacentColumn.isColumnGroup) {\n          this.foundColumn = null;\n          this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);\n        }\n        if (this.column.isColumnGroup) {\n          this.service.draggedGroupColumn = this.column;\n        }\n      } else if (this.column.isColumnGroup) {\n        if (this.column.isReordered) {\n          this.service.adjacentColumn = columnsForLevel.find(c => c.orderIndex === this.column.orderIndex + 1);\n        } else {\n          this.service.adjacentColumn = columnsForLevel[columnsForLevel.indexOf(this.column) + 1];\n        }\n        this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);\n        if (this.service.adjacentColumn.isColumnGroup) {\n          this.foundColumn = null;\n          this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);\n        }\n        this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;\n        this.service.draggedGroupColumn = this.column;\n      } else {\n        if (this.column.isReordered) {\n          this.service.adjacentColumn = columnsForLevel.find(col => col.orderIndex === this.column.orderIndex + 1);\n        } else {\n          let adjacentColumn = columnsForLevel.find(c => c.leafIndex === this.column.leafIndex + 1);\n          if (!adjacentColumn) {\n            const indexOfCurrentColumn = columnsForLevel.indexOf(this.column);\n            adjacentColumn = columnsForLevel[indexOfCurrentColumn + 1];\n          }\n          this.service.adjacentColumn = adjacentColumn;\n        }\n        if (!this.service.adjacentColumn.parent) {\n          this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);\n        }\n        if (this.service.adjacentColumn.isColumnGroup) {\n          this.foundColumn = null;\n          this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);\n          const rowIndex = this.service.adjacentColumn.level + 1;\n          const colIndex = this.service.adjacentColumn.leafIndex + 1;\n          this.service.adjacentColumn.resizeStartWidth = adjacentColumnInGroupWidth(this.element, rowIndex, colIndex);\n        }\n      }\n      this.service.resizedColumn({\n        column: this.service.adjacentColumn,\n        oldWidth: this.service.adjacentColumn.resizeStartWidth\n      });\n    }\n    firstGroupChild(column) {\n      Array.from(column.children).sort((a, b) => a.orderIndex - b.orderIndex).forEach((c, idx) => {\n        if (idx === 0 && !c.isColumnGroup) {\n          if (!this.foundColumn) {\n            this.foundColumn = c;\n          }\n        } else if (c.isColumnGroup) {\n          this.firstGroupChild(c);\n        }\n      });\n      return this.foundColumn;\n    }\n    setGroupWidths(column) {\n      const childrenWidths = column.children.reduce((acc, c) => acc + c.width, 0);\n      column.width = childrenWidths;\n      column.children.forEach(c => {\n        if (c.isColumnGroup) {\n          this.setGroupWidths(c);\n        }\n      });\n    }\n    updateWidthOfDraggedColumn(column, width) {\n      this.totalChildrenSum = 0;\n      this.childrenColumns = [];\n      this.calcChildrenWidth(this.service.draggedGroupColumn);\n      const childrenWidthNotIncludingColumn = this.childrenColumns.reduce((acc, col) => {\n        return col !== column ? acc + col.width : acc;\n      }, 0);\n      this.service.draggedGroupColumn.width = childrenWidthNotIncludingColumn + width;\n      if (this.service.adjacentColumn.minResizableWidth <= this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width - childrenWidthNotIncludingColumn) {\n        this.service.adjacentColumn.width = this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width - childrenWidthNotIncludingColumn;\n      }\n    }\n    calcChildrenWidth(column) {\n      const columnChildren = Array.from(column.children);\n      const childrenNoGroups = columnChildren.filter(c => !c.isColumnGroup);\n      const childrenGroups = columnChildren.filter(c => c.isColumnGroup);\n      childrenNoGroups.forEach(col => {\n        if (this.childrenColumns.indexOf(col) === -1) {\n          this.childrenColumns.push(col);\n        }\n      });\n      this.totalChildrenSum += childrenNoGroups.reduce((acc, col) => acc + col.resizeStartWidth, 0);\n      childrenGroups.forEach(col => {\n        this.calcChildrenWidth(col);\n      });\n    }\n    columnsForLevel(level) {\n      return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);\n    }\n    minAdjacentColumnWidth(column) {\n      if (column.isColumnGroup) {\n        Array.from(column.children).forEach(c => {\n          this.minAdjacentColumnWidth(c);\n        });\n      } else {\n        this.minWidthTotal += column.minResizableWidth;\n        if (column.width < column.minResizableWidth) {\n          column.width = column.minResizableWidth;\n        }\n      }\n      return this.minWidthTotal;\n    }\n    getTableDelta(newWidth, delta) {\n      const minWidth = this.column.minResizableWidth;\n      const maxWidth = this.column.maxResizableWidth;\n      const startWidth = this.column.resizeStartWidth;\n      const isAboveMin = newWidth > minWidth;\n      const isBelowMax = newWidth < maxWidth;\n      const isInBoundaries = isPresent(maxWidth) ? isAboveMin && isBelowMax : isAboveMin;\n      if (isInBoundaries) {\n        return delta;\n      } else if (newWidth <= minWidth) {\n        return minWidth - startWidth;\n      } else {\n        return startWidth - maxWidth;\n      }\n    }\n    isLastInGroup(column) {\n      if (column.parent) {\n        const groupChildren = Array.from(column.parent.children);\n        const indexOfCurrentColumn = groupChildren.indexOf(column);\n        if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {\n          return column.orderIndex - groupChildren[0].orderIndex === groupChildren.length - 1;\n        } else {\n          return indexOfCurrentColumn === groupChildren.length - 1;\n        }\n      }\n    }\n  }\n  _class148 = ColumnHandleDirective;\n  _defineProperty(ColumnHandleDirective, \"\\u0275fac\", function _class148_Factory(t) {\n    return new (t || _class148)(i0.ɵɵdirectiveInject(i1$3.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnInfoService));\n  });\n  _defineProperty(ColumnHandleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class148,\n    selectors: [[\"\", \"kendoGridColumnHandle\", \"\"]],\n    hostVars: 6,\n    hostBindings: function _class148_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function _class148_dblclick_HostBindingHandler() {\n          return ctx.autoFit();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible)(\"left\", ctx.leftStyle)(\"right\", ctx.rightStyle);\n      }\n    },\n    inputs: {\n      isLast: \"isLast\",\n      columns: \"columns\",\n      column: \"column\"\n    },\n    standalone: true\n  }));\n  return ColumnHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalDataChangesService = /*#__PURE__*/(() => {\n  var _class149;\n  class LocalDataChangesService {\n    constructor() {\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"data\", void 0);\n    }\n  }\n  _class149 = LocalDataChangesService;\n  _defineProperty(LocalDataChangesService, \"\\u0275fac\", function _class149_Factory(t) {\n    return new (t || _class149)();\n  });\n  _defineProperty(LocalDataChangesService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class149,\n    factory: _class149.ɵfac\n  }));\n  return LocalDataChangesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet CellSelectionAggregateService = /*#__PURE__*/(() => {\n  var _class150;\n  class CellSelectionAggregateService {\n    constructor(ctx, dataChanges, columnInfoService) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"dataChanges\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"selectedItems\", []);\n      _defineProperty(this, \"groupedAggregates\", {\n        dates: [],\n        numbers: [],\n        booleans: []\n      });\n      _defineProperty(this, \"aggregates\", {\n        sum: null,\n        average: null,\n        min: null,\n        max: null,\n        count: null,\n        isTrue: null,\n        isFalse: null,\n        earliest: null,\n        latest: null\n      });\n      _defineProperty(this, \"sub\", new Subscription());\n      this.ctx = ctx;\n      this.dataChanges = dataChanges;\n      this.columnInfoService = columnInfoService;\n    }\n    ngOnDestroy() {\n      this.sub.unsubscribe();\n    }\n    isAggregateIncluded(aggregate) {\n      const {\n        cellAggregates\n      } = this.ctx.grid.selectable;\n      if (typeof cellAggregates !== 'boolean') {\n        return cellAggregates?.includes(aggregate);\n      }\n      return true;\n    }\n    init() {\n      this.sub.add(this.ctx.grid.dataStateChange.subscribe(() => {\n        // nullifies aggregates and sets default count to avoid mismatching state -\n        // https://github.com/telerik/kendo-angular-private/issues/2964\n        this.nullifyAggregates();\n        if (this.isAggregateIncluded('count')) {\n          this.aggregates['count'] = 0;\n        }\n      }));\n      if (this.ctx.grid.selectable.cellAggregates) {\n        if (this.isAggregateIncluded('count')) {\n          this.aggregates['count'] = 0;\n        }\n        const selectionDirective = this.ctx.grid.selectionDirective;\n        if (selectionDirective && !this.isRowSelection) {\n          this.selectedItems = selectionDirective.selectedKeys;\n        }\n      }\n    }\n    onSelectionChange(selectionArgs) {\n      this.handleSelectedItems(selectionArgs);\n      this.nullifyAggregates();\n      this.handleAggregateChanges();\n      return this.aggregates;\n    }\n    get isRowSelection() {\n      return typeof this.ctx.grid.selectable === 'boolean' || !this.ctx.grid.selectable.cell;\n    }\n    handleAggregateChanges() {\n      const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();\n      const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();\n      const selectedItemsLength = this.selectedItems.length;\n      const columns = [...lockedColumns, ...nonLockedColumns];\n      const fields = columns.map(col => col.field);\n      if (this.isAggregateIncluded('count')) {\n        this.aggregates['count'] = this.isRowSelection ? selectedItemsLength * columns.length : selectedItemsLength;\n      }\n      this.selectedItems.forEach(item => {\n        if (this.isRowSelection) {\n          fields.forEach(field => {\n            const cellValue = item.dataItem;\n            if (cellValue && cellValue.hasOwnProperty(field)) {\n              const cellValue = item.dataItem[field];\n              this.groupAggregates(cellValue);\n            }\n          });\n        } else if (!this.isRowSelection) {\n          // Enables working with the current Grid data regardless of its form (array, GridDataResult, GroupedResult).\n          // Currently gets the item by index only - https://github.com/telerik/kendo-angular-private/issues/2964\n          const selectedItem = this.ctx.grid.flatData.flatMap(recursiveFlatMap)[item.itemKey];\n          const field = fields[item.columnKey];\n          if (selectedItem && selectedItem.hasOwnProperty(field)) {\n            const cellValue = selectedItem[fields[item.columnKey]];\n            this.groupAggregates(cellValue);\n          }\n        }\n      });\n      this.calculateAggregates();\n    }\n    groupAggregates(aggregate) {\n      if (typeof aggregate === 'number') {\n        this.groupedAggregates.numbers.push(aggregate);\n      } else if (typeof aggregate === 'boolean') {\n        this.groupedAggregates.booleans.push(aggregate);\n      } else if (aggregate instanceof Date) {\n        this.groupedAggregates.dates.push(aggregate);\n      }\n    }\n    calculateAggregates() {\n      if (this.groupedAggregates.numbers.length > 0) {\n        if (this.isAggregateIncluded('min')) {\n          this.aggregates['min'] = Math.min(...this.groupedAggregates.numbers);\n        }\n        if (this.isAggregateIncluded('max')) {\n          this.aggregates['max'] = Math.max(...this.groupedAggregates.numbers);\n        }\n        if (this.isAggregateIncluded('sum')) {\n          this.aggregates['sum'] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);\n        }\n        if (this.isAggregateIncluded('average')) {\n          this.aggregates['average'] = this.aggregates['sum'] / this.groupedAggregates.numbers.length;\n        }\n      }\n      if (this.groupedAggregates.booleans.length > 0) {\n        if (this.isAggregateIncluded('isTrue')) {\n          const isTrueCount = this.groupedAggregates.booleans.filter(bool => bool).length;\n          this.aggregates['isTrue'] = isTrueCount > 0 ? isTrueCount : null;\n        }\n        if (this.isAggregateIncluded('isFalse')) {\n          const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates['isTrue'];\n          this.aggregates['isFalse'] = isFalseCount > 0 ? isFalseCount : null;\n        }\n      }\n      if (this.groupedAggregates.dates.length > 0) {\n        if (this.isAggregateIncluded('earliest')) {\n          this.aggregates['earliest'] = new Date(Math.min(...this.groupedAggregates.dates));\n        }\n        if (this.isAggregateIncluded('latest')) {\n          this.aggregates['latest'] = new Date(Math.max(...this.groupedAggregates.dates));\n        }\n      }\n    }\n    handleSelectedItems(selectionArgs) {\n      const rowOrCellSelect = `${this.isRowSelection ? 'selectedRows' : 'selectedCells'}`;\n      const rowOrCellDeselect = `${this.isRowSelection ? 'deselectedRows' : 'deselectedCells'}`;\n      const selectedItems = selectionArgs[rowOrCellSelect];\n      const deselectedItems = selectionArgs[rowOrCellDeselect];\n      if (!this.isRowSelection) {\n        // Needed when we have column groups with cell selection, the deselected items are duplicated\n        deselectedItems.forEach((item, index) => {\n          if (index + 1 < deselectedItems.length) {\n            if (item.itemKey === deselectedItems[index + 1].itemKey && item.columnKey === deselectedItems[index + 1].columnKey) {\n              deselectedItems.splice(index, 1);\n            }\n          }\n        });\n      }\n      if (selectedItems.length > 0) {\n        selectedItems.forEach(item => {\n          this.selectedItems = [...this.selectedItems, item];\n        });\n      }\n      if (deselectedItems.length > 0) {\n        if (this.isRowSelection) {\n          deselectedItems.forEach(row => {\n            this.selectedItems = this.selectedItems.filter(elem => elem.dataItem !== row.dataItem);\n          });\n        } else {\n          deselectedItems.forEach(cell => {\n            const index = this.selectedItems.findIndex(elem => elem.itemKey === cell.itemKey && elem.columnKey === cell.columnKey);\n            this.selectedItems.splice(index, 1);\n          });\n        }\n      }\n    }\n    nullifyAggregates() {\n      this.groupedAggregates = {\n        dates: [],\n        numbers: [],\n        booleans: []\n      };\n      this.aggregates['count'] = null;\n      this.aggregates['sum'] = this.aggregates['average'] = null;\n      this.aggregates['max'] = this.aggregates['min'] = null;\n      this.aggregates['isFalse'] = this.aggregates['isTrue'] = null;\n      this.aggregates['earliest'] = this.aggregates['latest'] = null;\n    }\n  }\n  _class150 = CellSelectionAggregateService;\n  _defineProperty(CellSelectionAggregateService, \"\\u0275fac\", function _class150_Factory(t) {\n    return new (t || _class150)(i0.ɵɵinject(ContextService), i0.ɵɵinject(LocalDataChangesService), i0.ɵɵinject(ColumnInfoService));\n  });\n  _defineProperty(CellSelectionAggregateService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class150,\n    factory: _class150.ɵfac\n  }));\n  return CellSelectionAggregateService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SelectionService = /*#__PURE__*/(() => {\n  var _class151;\n  class SelectionService {\n    get enableMarquee() {\n      const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;\n      if (!this.settings || checkboxOnly) {\n        return false;\n      }\n      const selectableSettings = this.settings.selectable;\n      const dragAndMultiple = typeof selectableSettings === 'object' && isPresent(selectableSettings) && selectableSettings.mode === 'multiple' && selectableSettings.enabled !== false && !selectableSettings.checkboxOnly && selectableSettings.drag;\n      return this.active && dragAndMultiple;\n    }\n    get hasNonSelectable() {\n      return this.nonSelectableRows.size > 0;\n    }\n    constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"aggregateService\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"ctxService\", void 0);\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"lastSelectionStartIndex\", void 0);\n      _defineProperty(this, \"currentSelection\", []);\n      _defineProperty(this, \"nonSelectableRows\", new Map());\n      _defineProperty(this, \"selectAllChecked\", false);\n      _defineProperty(this, \"settings\", void 0);\n      _defineProperty(this, \"active\", false);\n      _defineProperty(this, \"aggregates\", void 0);\n      _defineProperty(this, \"mouseDownEventArgs\", void 0);\n      _defineProperty(this, \"dragging\", false);\n      _defineProperty(this, \"cellClickSubscription\", void 0);\n      _defineProperty(this, \"mousedownSubscription\", void 0);\n      _defineProperty(this, \"dataChangedSubscription\", void 0);\n      _defineProperty(this, \"lastSelectionData\", {});\n      _defineProperty(this, \"_selectAllState\", void 0);\n      this.domEvents = domEvents;\n      this.aggregateService = aggregateService;\n      this.localDataChangesService = localDataChangesService;\n      this.navigationService = navigationService;\n      this.ctxService = ctxService;\n      this.addSubscriptions();\n    }\n    init(settings) {\n      this.settings = settings;\n      if (!isPresent(this.lastSelectionStartIndex)) {\n        this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;\n        this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};\n      }\n      this.currentSelection = [];\n      this.nonSelectableRows = new Map();\n      if (settings.selectable && settings.selectable.enabled !== false) {\n        const iterator = this.getIterator();\n        this._selectAllState = true;\n        let item = iterator.next();\n        while (!item.done) {\n          if (item.value && item.value.type === \"data\") {\n            const rowArgs = {\n              dataItem: item.value.data,\n              index: item.value.index\n            };\n            if (settings.rowSelected(rowArgs)) {\n              this.currentSelection[item.value.index] = rowArgs;\n            } else {\n              this._selectAllState = undefined;\n            }\n            if (!settings.isRowSelectable(rowArgs)) {\n              this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);\n              this._selectAllState = undefined;\n            }\n          }\n          item = iterator.next();\n        }\n        if (this.currentSelection.length === 0) {\n          this._selectAllState = false;\n        }\n      }\n    }\n    isSelected(index) {\n      if (this.settings && this.active) {\n        return this.options.enabled && isPresent(this.currentSelection[index]) && !this.nonSelectableRows.has(index);\n      }\n    }\n    handleClick(item, event) {\n      if (this.dragging) {\n        this.dragging = false;\n        return;\n      }\n      let ev;\n      const ctrlKey = event.ctrlKey || event.metaKey;\n      if (this.options.mode === \"single\" && ctrlKey && this.isSelected(item.index)) {\n        ev = this.toggle(item);\n      } else if (this.options.mode === \"multiple\") {\n        if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {\n          ev = this.toggle(item);\n        } else if (event.shiftKey) {\n          ev = this.addAllTo(item, ctrlKey);\n        }\n      }\n      if (!isPresent(ev)) {\n        ev = this.select(item);\n        this.currentSelection[item.index] = {\n          dataItem: item.data,\n          index: item.index\n        };\n      }\n      if (!ev.selectedRows.length && !ev.deselectedRows.length) {\n        return;\n      }\n      ev.ctrlKey = ctrlKey;\n      ev.shiftKey = event.shiftKey;\n      if (this.options.cellAggregates) {\n        ev.cellAggregates = this.aggregateService.onSelectionChange(ev);\n      }\n      if (ev.shiftKey) {\n        ev.rangeStartRow = {\n          dataItem: this.lastSelectionData,\n          index: this.lastSelectionStartIndex\n        };\n        ev.rangeEndRow = {\n          dataItem: item.data,\n          index: item.index\n        };\n      }\n      this.changes.emit(ev);\n    }\n    toggle(item) {\n      const selectedRows = [];\n      const deselectedRows = [];\n      this.lastSelectionStartIndex = item.index;\n      this.lastSelectionData = item.data;\n      const rowArgs = {\n        dataItem: item.data,\n        index: item.index\n      };\n      if (this.isSelected(item.index)) {\n        deselectedRows.push(rowArgs);\n      } else if (!this.nonSelectableRows.has(item.index)) {\n        selectedRows.push(rowArgs);\n      }\n      if (this.hasNonSelectable) {\n        const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));\n        deselectedRows.push(...nonSelectableRows);\n      }\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n    toggleByIndex(index) {\n      const iterator = this.getIterator();\n      if (this.selectAllChecked && this.isSelected(index)) {\n        this.selectAllChecked = false;\n      }\n      let item = iterator.next();\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.index === index) {\n          const itemToToggle = {\n            data: item.value.data,\n            index: item.value.index\n          };\n          if (this.isSelected(index) || this.options.mode === \"multiple\") {\n            return this.toggle(itemToToggle);\n          } else {\n            return this.select(itemToToggle);\n          }\n        }\n        item = iterator.next();\n      }\n    }\n    select(item) {\n      const deselectedRows = [];\n      const selectedRows = [];\n      this.lastSelectionStartIndex = item.index;\n      this.lastSelectionData = item.data;\n      if (!this.isSelected(item.index) && !this.nonSelectableRows.has(item.index)) {\n        selectedRows.push({\n          dataItem: item.data,\n          index: item.index\n        });\n      }\n      this.currentSelection.forEach(row => {\n        if (row.index !== item.index) {\n          deselectedRows.push(row);\n        }\n      });\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n    //Used to manually deselect removed items\n    deselect(removedItem) {\n      const iterator = this.getIterator();\n      let item = iterator.next();\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.data === removedItem) {\n          const rowArgs = {\n            dataItem: item.value.data,\n            index: item.value.index\n          };\n          if (this.isSelected(rowArgs.index) || this.nonSelectableRows.has(rowArgs.index)) {\n            const ev = {\n              ctrlKey: false,\n              deselectedRows: [rowArgs],\n              selectedRows: []\n            };\n            this.changes.emit(ev);\n          }\n        }\n        item = iterator.next();\n      }\n    }\n    addAllTo(item, ctrlKey) {\n      const selectedRows = [];\n      const deselectedRows = [];\n      const start = Math.min(this.lastSelectionStartIndex, item.index);\n      const end = Math.max(this.lastSelectionStartIndex, item.index);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n          if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey) {\n            deselectedRows.push(rowArgs);\n          }\n          if (idx >= start && idx <= end && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {\n            selectedRows.push(rowArgs);\n          }\n        }\n        next = iterator.next();\n      }\n      if (this.hasNonSelectable) {\n        const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));\n        deselectedRows.push(...nonSelectableRows);\n      }\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n    updateAll(selectAllChecked) {\n      this.selectAllChecked = selectAllChecked;\n      const selectedRows = [];\n      const deselectedRows = [];\n      const iterator = this.getIterator();\n      let next = iterator.next();\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n          if (!this.nonSelectableRows.has(idx)) {\n            if (this.isSelected(idx) && !selectAllChecked) {\n              deselectedRows.push(rowArgs);\n            }\n            if (!this.isSelected(idx) && selectAllChecked) {\n              selectedRows.push(rowArgs);\n            }\n          }\n        }\n        next = iterator.next();\n      }\n      if (!selectedRows.length && !deselectedRows.length) {\n        return;\n      }\n      if (this.hasNonSelectable) {\n        const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));\n        deselectedRows.push(...nonSelectableRows);\n      }\n      const ev = {\n        ctrlKey: true,\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows,\n        shiftKey: true\n      };\n      if (this.options.cellAggregates) {\n        ev.cellAggregates = this.aggregateService.onSelectionChange(ev);\n      }\n      this.changes.emit(ev);\n    }\n    selectRange(startIndex, endIndex) {\n      const selectedRows = [];\n      const deselectedRows = [];\n      const start = Math.min(startIndex, endIndex);\n      const end = Math.max(startIndex, endIndex);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n          if ((idx < start || idx > end) && this.isSelected(idx)) {\n            deselectedRows.push(rowArgs);\n          }\n          if (idx >= start && idx <= end && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {\n            selectedRows.push(rowArgs);\n          }\n        }\n        next = iterator.next();\n      }\n      let cellAggregates;\n      if (this.options.cellAggregates) {\n        cellAggregates = this.aggregateService.onSelectionChange({\n          selectedRows,\n          deselectedRows\n        });\n      }\n      if (this.hasNonSelectable) {\n        const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));\n        deselectedRows.push(...nonSelectableRows);\n      }\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows,\n        cellAggregates\n      };\n    }\n    get selectAllState() {\n      return this._selectAllState;\n    }\n    get selected() {\n      return this.currentSelection.map(item => {\n        return item.index;\n      }).filter(n => typeof n === \"number\");\n    }\n    get options() {\n      const defaultOptions = {\n        cellAggregates: false,\n        checkboxOnly: false,\n        enabled: true,\n        mode: \"multiple\",\n        metaKeyMultiSelect: true\n      };\n      if (!isPresent(this.settings)) {\n        return defaultOptions;\n      }\n      if (typeof this.settings.selectable === 'boolean') {\n        return {\n          cellAggregates: false,\n          checkboxOnly: false,\n          enabled: this.settings.selectable,\n          mode: \"multiple\",\n          metaKeyMultiSelect: true\n        };\n      } else {\n        return Object.assign(defaultOptions, this.settings.selectable);\n      }\n    }\n    ngOnDestroy() {\n      this.removeSubscriptions();\n    }\n    targetArgs() {\n      return {\n        index: this.mouseDownEventArgs.rowIndex,\n        dataItem: this.mouseDownEventArgs.dataItem\n      };\n    }\n    addSubscriptions() {\n      if (!this.cellClickSubscription) {\n        this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n          if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {\n            if (this.active) {\n              this.handleClick({\n                index: args.rowIndex,\n                data: args.dataItem\n              }, args.originalEvent);\n            }\n          }\n        });\n      }\n      if (!this.mousedownSubscription) {\n        this.mousedownSubscription = this.domEvents.cellMousedown.subscribe(args => {\n          this.mouseDownEventArgs = args;\n          if (this.options.enabled && (!this.options.mode || this.options.mode === \"multiple\") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {\n            if (this.active) {\n              args.originalEvent.preventDefault();\n              this.navigationService.focusCellByElement(args.originalEvent.target);\n            }\n          }\n        });\n      }\n      if (this.localDataChangesService && !this.dataChangedSubscription) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(args => {\n          if (this.active) {\n            if (isPresent(args.action) && args.action === 'remove') {\n              this.deselect(args.item);\n            }\n          }\n        });\n      }\n    }\n    getIterator() {\n      const accessor = this.settings.view.accessor();\n      if (!accessor) {\n        return;\n      }\n      return accessor[iterator]();\n    }\n    removeSubscriptions() {\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n        this.cellClickSubscription = null;\n      }\n      if (this.mousedownSubscription) {\n        this.mousedownSubscription.unsubscribe();\n        this.mousedownSubscription = null;\n      }\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n        this.dataChangedSubscription = null;\n      }\n    }\n  }\n  _class151 = SelectionService;\n  _defineProperty(SelectionService, \"\\u0275fac\", function _class151_Factory(t) {\n    return new (t || _class151)(i0.ɵɵinject(DomEventsService), i0.ɵɵinject(CellSelectionAggregateService), i0.ɵɵinject(LocalDataChangesService), i0.ɵɵinject(NavigationService), i0.ɵɵinject(ContextService));\n  });\n  _defineProperty(SelectionService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class151,\n    factory: _class151.ɵfac\n  }));\n  return SelectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet CellSelectionService = /*#__PURE__*/(() => {\n  var _class152;\n  class CellSelectionService {\n    get enableMarquee() {\n      const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;\n      if (!this.settings || checkboxOnly) {\n        return false;\n      }\n      const selectableSettings = this.settings.selectable;\n      const dragAndMultiple = typeof selectableSettings === 'object' && isPresent(selectableSettings) && selectableSettings.mode === 'multiple' && selectableSettings.cell && selectableSettings.enabled !== false && selectableSettings.drag;\n      return this.active && dragAndMultiple;\n    }\n    get hasNonSelectable() {\n      return this.nonSelectableRows.size > 0;\n    }\n    constructor(domEvents, aggregateService, localDataChangesService, navigationService) {\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"aggregateService\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"mouseUpEvent\", new EventEmitter());\n      _defineProperty(this, \"currentSelection\", []);\n      _defineProperty(this, \"settings\", void 0);\n      _defineProperty(this, \"active\", false);\n      _defineProperty(this, \"aggregates\", void 0);\n      _defineProperty(this, \"nonSelectableRows\", new Map());\n      _defineProperty(this, \"mouseDownEventArgs\", void 0);\n      _defineProperty(this, \"mouseUpEventArgs\", void 0);\n      _defineProperty(this, \"dragging\", false);\n      _defineProperty(this, \"dragSelectDeselect\", false);\n      _defineProperty(this, \"lastSelectionItem\", {\n        itemKey: 0,\n        columnKey: 0\n      });\n      _defineProperty(this, \"lastSelectionItemRowIndex\", 0);\n      _defineProperty(this, \"lastSelectionItemColIndex\", 0);\n      _defineProperty(this, \"cellClickSubscription\", void 0);\n      _defineProperty(this, \"dataChangedSubscription\", void 0);\n      _defineProperty(this, \"mousedownSubscription\", void 0);\n      this.domEvents = domEvents;\n      this.aggregateService = aggregateService;\n      this.localDataChangesService = localDataChangesService;\n      this.navigationService = navigationService;\n      this.addSubscriptions();\n    }\n    init(settings) {\n      this.settings = settings;\n      this.currentSelection = [];\n      this.nonSelectableRows = new Map();\n      if (settings.selectable && settings.selectable.enabled !== false) {\n        const iterator = this.getIterator();\n        let item = iterator.next();\n        while (!item.done) {\n          if (item.value && item.value.type === \"data\") {\n            const rowArgs = {\n              dataItem: item.value.data,\n              index: item.value.index\n            };\n            settings.columns.forEach(col => {\n              const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);\n              if (selectedCellArgs.selected) {\n                this.currentSelection.push(selectedCellArgs.item);\n              }\n              if (!settings.isRowSelectable(rowArgs)) {\n                this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);\n              }\n            });\n          }\n          item = iterator.next();\n        }\n      }\n    }\n    isCellSelected(item, col) {\n      if (this.settings && this.active) {\n        const selectedCellArgs = this.settings.cellSelected({\n          dataItem: item.data,\n          index: item.index\n        }, col, col.leafIndex);\n        return this.options.enabled && selectedCellArgs.selected && !this.nonSelectableRows.has(item.index);\n      }\n      return false;\n    }\n    handleClick(item, event) {\n      if (this.dragging) {\n        this.dragging = false;\n        return;\n      }\n      let ev;\n      const ctrlKey = event.ctrlKey || event.metaKey;\n      if (this.options.mode === \"single\" && ctrlKey && this.isCellSelected(item, item.column)) {\n        ev = this.toggle(item);\n      } else if (this.options.mode === \"multiple\") {\n        if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {\n          ev = this.toggle(item);\n        } else if (event.shiftKey) {\n          const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);\n          const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);\n          const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);\n          const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);\n          ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);\n        }\n      }\n      if (!isPresent(ev)) {\n        ev = this.select(item);\n        this.currentSelection = [this.lastSelectionItem];\n      }\n      if (!ev.selectedCells.length && !ev.deselectedCells.length) {\n        return;\n      }\n      ev.ctrlKey = ctrlKey;\n      ev.shiftKey = event.shiftKey;\n      if (this.options.cellAggregates && !event.shiftKey) {\n        ev.cellAggregates = this.aggregateService.onSelectionChange(ev);\n      }\n      if (ev.shiftKey) {\n        ev.rangeStartCell = this.lastSelectionItem;\n        ev.rangeEndCell = {\n          ...this.settings.cellSelected({\n            dataItem: item.data,\n            index: item.index\n          }, item.column, item.column.leafIndex).item\n        };\n      }\n      this.changes.emit(ev);\n    }\n    toggle(item) {\n      const selectedCells = [];\n      const deselectedCells = [];\n      this.lastSelectionItem = this.settings.cellSelected({\n        dataItem: item.data,\n        index: item.index\n      }, item.column, item.column.leafIndex).item;\n      this.lastSelectionItemRowIndex = item.index;\n      this.lastSelectionItemColIndex = item.column.leafIndex;\n      if (this.isCellSelected(item, item.column)) {\n        deselectedCells.push(this.lastSelectionItem);\n      } else if (!this.nonSelectableRows.has(item.index)) {\n        selectedCells.push(this.lastSelectionItem);\n      }\n      return {\n        deselectedCells,\n        selectedCells\n      };\n    }\n    select(item) {\n      const selectedCells = [];\n      const deselectedCells = [];\n      this.lastSelectionItem = this.settings.cellSelected({\n        dataItem: item.data,\n        index: item.index\n      }, item.column, item.column.leafIndex).item;\n      this.lastSelectionItemRowIndex = item.index;\n      this.lastSelectionItemColIndex = item.column.leafIndex;\n      if (!this.isCellSelected(item, item.column) && !this.nonSelectableRows.has(item.index)) {\n        selectedCells.push(this.lastSelectionItem);\n      }\n      this.currentSelection.forEach(selectedItem => {\n        if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {\n          deselectedCells.push(selectedItem);\n        }\n      });\n      return {\n        deselectedCells,\n        selectedCells\n      };\n    }\n    //Used to manually deselect removed items\n    deselect(removedItem) {\n      const iterator = this.getIterator();\n      let item = iterator.next();\n      let rowArgs;\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.data === removedItem) {\n          rowArgs = {\n            dataItem: item.value.data,\n            index: item.value.index\n          };\n          break;\n        }\n        item = iterator.next();\n      }\n      if (rowArgs) {\n        const cellsToRemove = this.currentSelection.filter(selectedItem => {\n          const contender = this.settings.cellSelected(rowArgs, null, null).item;\n          return selectedItem.itemKey === contender.itemKey || this.nonSelectableRows.has(rowArgs.index);\n        });\n        if (cellsToRemove.length) {\n          const ev = {\n            ctrlKey: false,\n            deselectedCells: cellsToRemove,\n            selectedCells: []\n          };\n          this.changes.emit(ev);\n        }\n      }\n    }\n    selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex) {\n      const selectedCells = [];\n      const deselectedCells = [];\n      const selectionStartRow = Math.min(startRowIndex, endRowIndex);\n      const selectionStartCol = Math.min(startColIndex, endColIndex);\n      const selectionEndRow = Math.max(startRowIndex, endRowIndex);\n      const selectionEndCol = Math.max(startColIndex, endColIndex);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const data = next.value.data;\n          const rowArgs = {\n            dataItem: data,\n            index: idx\n          };\n          this.settings.columns.forEach(col => {\n            const {\n              item\n            } = this.settings.cellSelected(rowArgs, col, col.leafIndex);\n            const selected = this.isCellSelected(next.value, col);\n            const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;\n            const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;\n            const isInSelectionRect = isInRowRange && isInColRange;\n            if (!isInSelectionRect && selected) {\n              deselectedCells.push(item);\n            }\n            if (isInSelectionRect && !selected && !this.nonSelectableRows.has(idx)) {\n              selectedCells.push(item);\n            }\n          });\n        }\n        next = iterator.next();\n      }\n      let cellAggregates;\n      if (this.options.cellAggregates) {\n        cellAggregates = this.aggregateService.onSelectionChange({\n          selectedCells,\n          deselectedCells\n        });\n      }\n      return {\n        deselectedCells,\n        selectedCells,\n        cellAggregates\n      };\n    }\n    get options() {\n      const defaultOptions = {\n        cellAggregates: false,\n        checkboxOnly: false,\n        enabled: true,\n        mode: \"multiple\",\n        metaKeyMultiSelect: true\n      };\n      if (!isPresent(this.settings)) {\n        return defaultOptions;\n      }\n      if (typeof this.settings.selectable === 'boolean') {\n        return {\n          cellAggregates: false,\n          checkboxOnly: false,\n          enabled: this.settings.selectable,\n          mode: \"multiple\",\n          metaKeyMultiSelect: true\n        };\n      } else {\n        return Object.assign(defaultOptions, this.settings.selectable);\n      }\n    }\n    ngOnDestroy() {\n      this.removeSubscriptions();\n    }\n    addSubscriptions() {\n      if (!this.cellClickSubscription) {\n        this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n          if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {\n            if (this.active) {\n              this.handleClick({\n                index: args.rowIndex,\n                data: args.dataItem,\n                column: args.column\n              }, args.originalEvent);\n            }\n          }\n        });\n      }\n      if (!this.mousedownSubscription) {\n        this.mousedownSubscription = this.domEvents.cellMousedown.subscribe(args => {\n          this.mouseDownEventArgs = args;\n          if (this.options.enabled && (!this.options.mode || this.options.mode === \"multiple\") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {\n            if (this.active) {\n              args.originalEvent.preventDefault();\n              this.navigationService.focusCellByElement(args.originalEvent.target);\n            }\n          }\n        });\n      }\n      if (this.localDataChangesService && !this.dataChangedSubscription) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(args => {\n          if (this.active) {\n            if (isPresent(args.action) && args.action === 'remove') {\n              this.deselect(args.item);\n            }\n          }\n        });\n      }\n    }\n    getIterator() {\n      const accessor = this.settings.view.accessor();\n      if (!accessor) {\n        return;\n      }\n      return accessor[iterator]();\n    }\n    removeSubscriptions() {\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n        this.cellClickSubscription = null;\n      }\n      if (this.mousedownSubscription) {\n        this.mousedownSubscription.unsubscribe();\n        this.mousedownSubscription = null;\n      }\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n        this.dataChangedSubscription = null;\n      }\n    }\n  }\n  _class152 = CellSelectionService;\n  _defineProperty(CellSelectionService, \"\\u0275fac\", function _class152_Factory(t) {\n    return new (t || _class152)(i0.ɵɵinject(DomEventsService), i0.ɵɵinject(CellSelectionAggregateService), i0.ɵɵinject(LocalDataChangesService), i0.ɵɵinject(NavigationService));\n  });\n  _defineProperty(CellSelectionService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class152,\n    factory: _class152.ɵfac\n  }));\n  return CellSelectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the select-all checkbox feature of the Grid ([see example](slug:grid_selection_persistence#toc-selecting-all-items)).\n *\n * @example\n * ```html\n * <input\n *   type=\"checkbox\"\n *   kendoCheckBox\n *   kendoGridSelectAllCheckbox\n *   [state]=\"selectAllState\"\n *   (selectAllChange)=\"onSelectAllChange($event)\"\n * />\n * ```\n */\nlet SelectAllCheckboxDirective = /*#__PURE__*/(() => {\n  var _class153;\n  class SelectAllCheckboxDirective {\n    ngAfterContentChecked() {\n      this.setState();\n    }\n    ngOnChanges() {\n      this.stateSet = true;\n    }\n    constructor(selectionService, cellSelectionService, ngZone, element, renderer, checkbox) {\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"cellSelectionService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"checkbox\", void 0);\n      /**\n       * Explicitly overrides the state of the select-all checkbox.\n       */\n      _defineProperty(this, \"state\", void 0);\n      /**\n       * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox\n       * ([see example](slug:grid_row_selection#toc-select-all-checkbox)).\n       */\n      _defineProperty(this, \"selectAllChange\", new EventEmitter());\n      _defineProperty(this, \"destroyClick\", void 0);\n      _defineProperty(this, \"checkboxChange\", void 0);\n      _defineProperty(this, \"stateSet\", false);\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.ngZone = ngZone;\n      this.element = element;\n      this.renderer = renderer;\n      this.checkbox = checkbox;\n      this.ngZone.runOutsideAngular(() => {\n        if (this.checkbox) {\n          this.checkboxChange = this.checkbox.checkedStateChange.subscribe(this.onClick.bind(this));\n        } else {\n          this.destroyClick = this.renderer.listen(this.element.nativeElement, 'click', this.onClick.bind(this));\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.checkboxChange) {\n        this.checkboxChange.unsubscribe();\n      }\n      if (this.destroyClick) {\n        this.destroyClick();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n      const isIndeterminateState = this.checkbox?.checkedState === 'indeterminate' || this.element.nativeElement.indeterminate;\n      const isCheckedState = this.checkbox?.checkedState === true || this.element.nativeElement.checked;\n      const checkboxState = isCheckedState ? 'checked' : isIndeterminateState ? 'indeterminate' : 'unchecked';\n      const isChecked = this.selectionService.hasNonSelectable ? !this.selectionService.selectAllChecked : isCheckedState;\n      const options = this.selectionService.options;\n      const enabledAndMultiple = options.enabled && options.mode === 'multiple' && !this.cellSelectionService.active;\n      const shouldEmitSelectAll = hasObservers(this.selectAllChange);\n      if (enabledAndMultiple || shouldEmitSelectAll) {\n        this.ngZone.run(() => {\n          if (enabledAndMultiple) {\n            this.selectionService.updateAll(isChecked);\n          }\n          if (shouldEmitSelectAll) {\n            this.selectAllChange.emit(checkboxState);\n          }\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    setState() {\n      const state = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;\n      if (this.checkbox) {\n        this.checkbox.checkedState = isPresent(state) ? state : 'indeterminate';\n      } else {\n        const elem = this.element.nativeElement;\n        this.renderer.setProperty(elem, 'indeterminate', !isPresent(state));\n        this.renderer.setProperty(elem, 'checked', isPresent(state) ? state : false);\n      }\n    }\n    /**\n     * @hidden\n     */\n    stateToBool() {\n      switch (this.state) {\n        case 'checked':\n          return true;\n        case 'unchecked':\n          return false;\n        default:\n          return undefined;\n      }\n    }\n  }\n  _class153 = SelectAllCheckboxDirective;\n  _defineProperty(SelectAllCheckboxDirective, \"\\u0275fac\", function _class153_Factory(t) {\n    return new (t || _class153)(i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i3.CheckBoxComponent, 9));\n  });\n  _defineProperty(SelectAllCheckboxDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class153,\n    selectors: [[\"\", \"kendoGridSelectAllCheckbox\", \"\"]],\n    inputs: {\n      state: \"state\"\n    },\n    outputs: {\n      selectAllChange: \"selectAllChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return SelectAllCheckboxDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));\nconst directions = initialDirection => initialDirection === \"asc\" ? [\"asc\", \"desc\"] : [\"desc\", \"asc\"];\n/**\n * @hidden\n */\nconst isRootLevel = ({\n  parent\n}) => !isTruthy(parent);\nconst ofColumnType = ({\n  draggable\n}) => ['column', 'columnGroup'].indexOf(draggable.context.type) >= 0;\nconst notSameElement = ({\n  draggable,\n  target\n}) => draggable.element.nativeElement !== target.element.nativeElement;\nconst inSameParent = (x, y) => x.parent === y.parent || isInSpanColumn$1(y) && inSameParent(x, y.parent);\nconst sameParent = ({\n  draggable,\n  target\n}) => inSameParent(draggable.context.column, target.context.column);\nconst lastNonLocked = ({\n  draggable\n}) => !isTruthy(draggable.context.column.locked) && isRootLevel(draggable.context.column) && draggable.context.lastColumn;\nconst notInSpanColumn = ({\n  draggable\n}) => !isInSpanColumn$1(draggable.context.column);\nconst reorderable = ({\n  draggable\n}) => draggable.context.column.reorderable;\nconst lockable = ({\n  draggable,\n  target\n}) => draggable.context.column.lockable !== false || draggable.context.column.isLocked === target.context.column.isLocked;\nconst rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);\nconst modifierKeys = ['alt', 'ctrl', 'shift', 'meta'];\n/**\n * @hidden\n */\nlet HeaderComponent = /*#__PURE__*/(() => {\n  var _class154;\n  class HeaderComponent {\n    get sortableLabel() {\n      return this.contextService.localization.get('sortable');\n    }\n    get columnMenuSettings() {\n      return this.columnMenu;\n    }\n    // Number of unlocked columns in the next table, if any\n    get unlockedColumnsCount() {\n      return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;\n    }\n    constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService, zone) {\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"hint\", void 0);\n      _defineProperty(this, \"cue\", void 0);\n      _defineProperty(this, \"reorderService\", void 0);\n      _defineProperty(this, \"idService\", void 0);\n      _defineProperty(this, \"sortService\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"contextService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"totalColumnLevels\", void 0);\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"scrollable\", void 0);\n      _defineProperty(this, \"filterable\", void 0);\n      _defineProperty(this, \"sort\", new Array());\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"sortable\", false);\n      _defineProperty(this, \"groupable\", false);\n      _defineProperty(this, \"lockedColumnsCount\", 0);\n      _defineProperty(this, \"resizable\", false);\n      _defineProperty(this, \"reorderable\", false);\n      _defineProperty(this, \"columnMenu\", false);\n      _defineProperty(this, \"columnMenuTemplate\", void 0);\n      _defineProperty(this, \"totalColumnsCount\", 0);\n      _defineProperty(this, \"totalColumns\", void 0);\n      _defineProperty(this, \"tabIndex\", void 0);\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"sortedFields\", {});\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"dropTargets\", new QueryList());\n      _defineProperty(this, \"filterMenus\", void 0);\n      _defineProperty(this, \"columnMenus\", void 0);\n      _defineProperty(this, \"sortAscSmallIcon\", sortAscSmallIcon);\n      _defineProperty(this, \"sortDescSmallIcon\", sortDescSmallIcon);\n      _defineProperty(this, \"subscription\", new Subscription());\n      _defineProperty(this, \"targetSubscription\", void 0);\n      _defineProperty(this, \"stopSorting\", false);\n      _defineProperty(this, \"_leafColumns\", void 0);\n      this.popupService = popupService;\n      this.hint = hint;\n      this.cue = cue;\n      this.reorderService = reorderService;\n      this.idService = idService;\n      this.sortService = sortService;\n      this.columnInfoService = columnInfoService;\n      this.cd = cd;\n      this.contextService = contextService;\n      this.navigationService = navigationService;\n      this.zone = zone;\n    }\n    sortColumn(descriptor) {\n      this.sortService.sort(descriptor);\n    }\n    getColumnComponent(column) {\n      return column;\n    }\n    onSortClick(column, event, link) {\n      if (this.stopSorting) {\n        this.stopSorting = false;\n        return;\n      }\n      const target = event.target;\n      if (column.headerTemplateRef && target !== link) {\n        const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));\n        if (hasFocusableParent) {\n          // Do not sort when clicking focusable template elements.\n          return;\n        }\n      }\n      const modifier = this.matchModifier(event);\n      const toggledColumn = this.toggleSort(column, modifier);\n      this.sortColumn(toggledColumn);\n    }\n    onHeaderKeydown(column, args) {\n      if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {\n        args.preventDefault();\n        args.stopImmediatePropagation();\n        const filterMenu = this.filterMenus.find(fm => fm.column === column);\n        filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);\n        return;\n      }\n      if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {\n        args.preventDefault();\n        args.stopImmediatePropagation();\n        const columnMenu = this.columnMenus.find(cm => cm.column === column);\n        columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);\n        return;\n      }\n      const isCtrlOrMeta = args.ctrlKey || args.metaKey;\n      const isGroupingKeyShortcut = (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) && isCtrlOrMeta;\n      if (isGroupingKeyShortcut && this.isGroupable(column)) {\n        args.preventDefault();\n        args.stopImmediatePropagation();\n        const isGroupedByField = this.groups.some(gr => gr.field === column.field);\n        if (isGroupedByField) {\n          this.groups = this.groups.filter(gr => gr.field !== column.field);\n        } else {\n          this.groups.push({\n            field: column.field\n          });\n        }\n        this.contextService.grid.groupChange.emit(this.groups);\n        return;\n      }\n      const isLeftOrRightArrow = args.keyCode === Keys.ArrowLeft || args.keyCode === Keys.ArrowRight;\n      const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;\n      if (isReorderingKeyShortcut && this.isReorderable(column)) {\n        args.preventDefault();\n        const columnsCount = this.columnInfoService.leafNamedColumns.length;\n        const reorderDirection = args.keyCode === Keys.ArrowLeft ? -1 : 1;\n        const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;\n        const reorderDirectionOffset = reorderDirection * rtlMultiplier;\n        const newIndex = column.leafIndex + reorderDirectionOffset;\n        const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);\n        const gridInstance = this.contextService.grid;\n        gridInstance.reorderColumn(column, normalizedNewIndex, {\n          before: reorderDirectionOffset < 0\n        });\n        gridInstance.columnReorder.emit(new ColumnReorderEvent({\n          column,\n          newIndex: normalizedNewIndex,\n          oldIndex: column.leafIndex\n        }));\n        return;\n      }\n      if (!this.sortable || args.defaultPrevented || column.sortable === false) {\n        return;\n      }\n      if (args.keyCode === Keys.Enter && isPresent(column.field)) {\n        const modifier = this.matchModifier(args);\n        this.sortService.sort(this.toggleSort(column, modifier));\n      }\n    }\n    showSortNumbering(column) {\n      const {\n        showIndexes\n      } = normalize$1(this.sortable);\n      return showIndexes && this.sort && this.sort.filter(({\n        dir\n      }) => isPresent(dir)).length > 1 && this.sortOrder(column.field) > 0;\n    }\n    sortOrder(field) {\n      return this.sort.filter(({\n        dir\n      }) => isPresent(dir)).findIndex(x => x.field === field) + 1;\n    }\n    sortState(column) {\n      if (!this.isInteractive(column, 'sortable')) {\n        return;\n      }\n      const state = this.sortDescriptor(column.field);\n      if (state.dir === 'asc') {\n        return 'ascending';\n      }\n      if (state.dir === 'desc') {\n        return 'descending';\n      }\n    }\n    get isNavigable() {\n      return this.navigationService.tableEnabled;\n    }\n    /**\n     *\n     * @param column\n     * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.\n     * @returns - SortDescriptor[]\n     */\n    toggleSort(column, modifier = true) {\n      const {\n        allowUnsort,\n        mode,\n        initialDirection\n      } = normalize$1(this.sortable, column.sortable);\n      const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);\n      if (mode === 'single' || !modifier) {\n        return [descriptor];\n      }\n      return [...this.sort.filter(desc => desc.field !== column.field), descriptor];\n    }\n    /**\n     *\n     * Determines whether the modifier key (if any) passed\n     * with a click/keyboard event matches the user-defined multiSortKey.\n     */\n    matchModifier(event) {\n      const {\n        multiSortKey\n      } = normalize$1(this.sortable);\n      if (multiSortKey === 'none') {\n        return modifierKeys.every(key => !event[`${key}Key`]);\n      }\n      return multiSortKey === 'ctrl' ? event.ctrlKey || event.metaKey : event[`${multiSortKey}Key`];\n    }\n    ngAfterViewInit() {\n      this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));\n    }\n    ngDoCheck() {\n      this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));\n    }\n    ngOnChanges(changes) {\n      const sortChange = changes.sort;\n      if (sortChange && !sortChange.isFirstChange()) {\n        sortChange.currentValue.forEach(change => {\n          this.sortedFields[change.field] = true;\n        });\n      }\n    }\n    ngOnInit() {\n      this.subscription.add(this.contextService.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n    ngOnDestroy() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n      if (this.popupService) {\n        this.popupService.destroy();\n      }\n      this.subscription.unsubscribe();\n    }\n    selectAllCheckboxId() {\n      return this.idService.selectAllCheckboxId();\n    }\n    get selectAllCheckboxLabel() {\n      return this.contextService.localization.get('selectAllCheckboxLabel');\n    }\n    isFirstOnRow(column, index) {\n      const isTailing = c => c && (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));\n      return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);\n    }\n    logicalColumnIndex(column) {\n      const index = column.leafIndex;\n      if (isPresent(index)) {\n        return index + (isPresent(this.detailTemplate) ? 1 : 0);\n      }\n      return -1;\n    }\n    get showFilterMenu() {\n      return !this.columnMenu && hasFilterMenu(this.filterable);\n    }\n    get showFilterRow() {\n      return hasFilterRow(this.filterable);\n    }\n    showColumnMenu(column) {\n      return this.columnMenu && column.columnMenu && (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));\n    }\n    isFilterable(column) {\n      return !isNullOrEmptyString(column.field) && column.filterable === true;\n    }\n    canDrop(draggable, target) {\n      isDocumentAvailable() && this.zone.runOutsideAngular(() => {\n        document.addEventListener('pointerup', () => {\n          this.stopSorting = true;\n          setTimeout(() => this.stopSorting = false);\n        }, {\n          once: true,\n          capture: true\n        });\n      });\n      return this.reorderable && rules({\n        draggable,\n        target\n      });\n    }\n    shouldActivate(column) {\n      const canReorder = this.isReorderable(column);\n      if (!canReorder && !isColumnComponent(column)) {\n        return false;\n      }\n      const groupable = this.isGroupable(column);\n      return groupable || canReorder;\n    }\n    isInteractive(column, prop) {\n      return !isNullOrEmptyString(column.field) && isTruthy(this[prop]) && isTruthy(column[prop]);\n    }\n    isCheckboxColumn(column) {\n      return isCheckboxColumn(column) && !column.templateRef;\n    }\n    addStickyStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return {\n        ...column.headerStyle,\n        ...stickyStyles\n      };\n    }\n    toggleDirection(field, allowUnsort, initialDirection) {\n      const descriptor = this.sortDescriptor(field);\n      const [first, second] = directions(initialDirection);\n      let dir = first;\n      if (descriptor.dir === first) {\n        dir = second;\n      } else if (descriptor.dir === second && allowUnsort) {\n        dir = undefined;\n      }\n      return {\n        dir,\n        field\n      };\n    }\n    columnsForLevel(level) {\n      const columns = this.columns ? this.columns.filter(column => column.level === level) : [];\n      return sortColumns(columnsToRender(columns));\n    }\n    isColumnGroupComponent(column) {\n      return isColumnGroupComponent(column);\n    }\n    sortDescriptor(field) {\n      return this.sort.find(item => item.field === field) || {\n        field\n      };\n    }\n    get columnLevels() {\n      return new Array((this.totalColumnLevels || 0) + 1);\n    }\n    get leafColumns() {\n      return this._leafColumns;\n    }\n    isReorderable(column) {\n      return this.reorderable && column.reorderable;\n    }\n    isGroupable(column) {\n      return this.groupable && isColumnComponent(column) && column.groupable !== false;\n    }\n    attachTargets() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n      this.targetSubscription = new Subscription();\n      const enterStream = merge(...this.dropTargets.map(target => target.enter));\n      const leaveStream = merge(...this.dropTargets.map(target => target.leave));\n      const dropStream = merge(...this.dropTargets.map(target => target.drop));\n      this.targetSubscription.add(enterStream.pipe(tap(({\n        target,\n        draggable\n      }) => {\n        if (draggable.context.type === 'groupIndicator') {\n          return;\n        }\n        const targetLocked = isTruthy(target.context.column.isLocked);\n        const draggableLocked = isTruthy(draggable.context.column.isLocked);\n        if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {\n          this.hint.toggleLock(targetLocked);\n        }\n      }), filter(({\n        draggable,\n        target\n      }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map(e => mergeObjects(e, {\n        before: this.calculateBefore(e),\n        changeContainer: e.changeContainer\n      })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap(args => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));\n    }\n    normalizeTarget(e) {\n      let target = e.target;\n      const parent = target.context.column.parent;\n      if (parent && parent.isSpanColumn) {\n        const arr = this.dropTargets.toArray();\n        const firstSpan = arr.find(t => t.context.column.parent === parent);\n        const index = arr.indexOf(firstSpan);\n        const adjust = e.before ? 0 : parent.childColumns.length - 1;\n        target = arr[index + adjust];\n      }\n      return mergeObjects(e, {\n        target\n      });\n    }\n    trackMove(leaveStream, dropStream, e) {\n      const column = e.target.context.column;\n      const levelColumns = this.columnsForLevel(column.level);\n      const index = levelColumns.indexOf(column);\n      const isFirst = column.locked ? index === levelColumns.length - 1 : index === 0;\n      const changed = e.draggable.context.column.isLocked !== column.isLocked;\n      if (changed && isFirst) {\n        return e.draggable.drag.pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({\n          mouseEvent\n        }) => mergeObjects({\n          changeContainer: true\n        }, e, {\n          mouseEvent\n        })));\n      }\n      return of(mergeObjects({\n        changeContainer: changed\n      }, e));\n    }\n    calculateBefore({\n      draggable,\n      target,\n      mouseEvent,\n      changeContainer = false\n    }) {\n      const targetElement = target.element.nativeElement;\n      let before = false;\n      if (changeContainer) {\n        const {\n          left\n        } = offset(targetElement);\n        const halfWidth = targetElement.offsetWidth / 2;\n        const middle = left + halfWidth;\n        before = middle > mouseEvent.pageX;\n        if (this.contextService.localization.rtl) {\n          before = !before;\n        }\n      } else {\n        before = isTargetBefore(draggable.element.nativeElement, targetElement);\n      }\n      return before;\n    }\n    enter({\n      target,\n      before\n    }) {\n      this.hint.enable();\n      if (this.contextService.localization.rtl) {\n        before = !before;\n      }\n      this.cue.position(position(target.element.nativeElement, before));\n    }\n    leave() {\n      this.hint.disable();\n      this.cue.hide();\n    }\n    drop({\n      draggable,\n      target,\n      before,\n      changeContainer\n    }) {\n      this.reorderService.reorder({\n        before,\n        changeContainer,\n        source: draggable.context.column,\n        target: target.context.column\n      });\n    }\n  }\n  _class154 = HeaderComponent;\n  _defineProperty(HeaderComponent, \"\\u0275fac\", function _class154_Factory(t) {\n    return new (t || _class154)(i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(ColumnReorderService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(HeaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class154,\n    selectors: [[\"\", \"kendoGridHeader\", \"\"]],\n    viewQuery: function _class154_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DropTargetDirective, 5);\n        i0.ɵɵviewQuery(FilterMenuComponent, 5);\n        i0.ɵɵviewQuery(ColumnMenuComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropTargets = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterMenus = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenus = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class154_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-table-thead\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      totalColumnLevels: \"totalColumnLevels\",\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      scrollable: \"scrollable\",\n      filterable: \"filterable\",\n      sort: \"sort\",\n      filter: \"filter\",\n      sortable: \"sortable\",\n      groupable: \"groupable\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      columnMenu: \"columnMenu\",\n      columnMenuTemplate: \"columnMenuTemplate\",\n      totalColumnsCount: \"totalColumnsCount\",\n      totalColumns: \"totalColumns\",\n      tabIndex: \"tabIndex\",\n      size: \"size\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c26,\n    decls: 3,\n    vars: 2,\n    consts: [[\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\", 4, \"ngFor\", \"ngForOf\"], [\"kendoGridFilterRow\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"filter\", \"groups\", \"detailTemplate\", \"lockedColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\"], [\"class\", \"k-group-cell k-header k-table-th\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-hierarchy-cell k-header k-table-th\", \"role\", \"presentation\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-group-cell\", \"k-header\", \"k-table-th\"], [\"role\", \"presentation\", 1, \"k-hierarchy-cell\", \"k-header\", \"k-table-th\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnheader\", \"aria-selected\", \"false\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", \"class\", \"k-header k-table-th\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"headerLabelText\", \"colSpan\", \"rowSpan\", \"k-sorted\", \"enableDrag\", \"context\", \"k-filterable\", \"k-first\", \"k-grid-header-sticky\", \"ngClass\", \"ngStyle\", \"keydown\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", \"class\", \"k-header k-table-th\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"rowSpan\", \"colSpan\", \"headerLabelText\", \"enableDrag\", \"context\", \"k-first\", \"k-filterable\", \"k-grid-content-sticky\", \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnheader\", \"aria-selected\", \"false\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", 1, \"k-header\", \"k-table-th\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"headerLabelText\", \"colSpan\", \"rowSpan\", \"enableDrag\", \"context\", \"ngClass\", \"ngStyle\", \"keydown\"], [4, \"ngIf\"], [\"kendoGridColumnHandle\", \"\", \"kendoDraggable\", \"\", \"class\", \"k-column-resizer\", 3, \"isLast\", \"column\", \"columns\", 4, \"ngIf\"], [1, \"k-cell-inner\"], [1, \"k-link\"], [3, \"templateContext\"], [3, \"column\", \"filter\", \"tabIndex\", 4, \"ngIf\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", \"sort\", \"filter\", \"sortable\", \"tabIndex\", 4, \"ngIf\"], [1, \"k-column-title\"], [3, \"column\", \"filter\", \"tabIndex\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", \"sort\", \"filter\", \"sortable\", \"tabIndex\"], [1, \"k-link\", 3, \"click\"], [\"link\", \"\"], [\"role\", \"note\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-sort-order\", 4, \"ngIf\"], [\"role\", \"note\", 3, \"name\", \"svgIcon\"], [1, \"k-sort-order\"], [\"kendoGridSelectAllCheckbox\", \"\", \"kendoGridFocusable\", \"\", 3, \"inputAttributes\"], [\"kendoGridColumnHandle\", \"\", \"kendoDraggable\", \"\", 1, \"k-column-resizer\", 3, \"isLast\", \"column\", \"columns\"], [\"kendoGridLogicalCell\", \"\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", 1, \"k-header\", \"k-table-th\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"rowSpan\", \"colSpan\", \"headerLabelText\", \"enableDrag\", \"context\", \"ngClass\", \"ngStyle\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", 4, \"ngIf\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\"], [\"kendoGridFilterRow\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"filter\", \"groups\", \"detailTemplate\", \"lockedColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\"]],\n    template: function _class154_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵtemplate(1, _class154_tr_1_Template, 4, 8, \"tr\", 0);\n        i0.ɵɵtemplate(2, _class154_tr_2_Template, 1, 10, \"tr\", 1);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnLevels);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showFilterRow);\n      }\n    },\n    dependencies: [NgFor, LogicalRowDirective, NgIf, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective, NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent],\n    encapsulation: 2\n  }));\n  return HeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FooterComponent = /*#__PURE__*/(() => {\n  var _class155;\n  class FooterComponent {\n    get footerClass() {\n      return !this.scrollable;\n    }\n    constructor(columnInfoService) {\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"scrollable\", void 0);\n      _defineProperty(this, \"lockedColumnsCount\", 0);\n      _defineProperty(this, \"logicalRowIndex\", 0);\n      _defineProperty(this, \"totalColumns\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"hostRole\", 'rowgroup');\n      this.columnInfoService = columnInfoService;\n    }\n    get columnsToRender() {\n      return columnsToRender(this.columns || []);\n    }\n    trackByIndex(index) {\n      return index;\n    }\n    logicalColumnIndex(column) {\n      const index = column.leafIndex;\n      if (isPresent(index)) {\n        return index + (isPresent(this.detailTemplate) ? 1 : 0);\n      }\n      return -1;\n    }\n    addStickyStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return {\n        ...column.footerStyle,\n        ...stickyStyles\n      };\n    }\n    isColumnGroupComponent(column) {\n      return isColumnGroupComponent(column);\n    }\n  }\n  _class155 = FooterComponent;\n  _defineProperty(FooterComponent, \"\\u0275fac\", function _class155_Factory(t) {\n    return new (t || _class155)(i0.ɵɵdirectiveInject(ColumnInfoService));\n  });\n  _defineProperty(FooterComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class155,\n    selectors: [[\"\", \"kendoGridFooter\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class155_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole);\n        i0.ɵɵclassProp(\"k-grid-footer\", ctx.footerClass)(\"k-table-tfoot\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      scrollable: \"scrollable\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      logicalRowIndex: \"logicalRowIndex\",\n      totalColumns: \"totalColumns\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c31,\n    decls: 5,\n    vars: 11,\n    consts: [[\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\"], [\"class\", \"k-table-td k-group-cell k-table-group-td\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", \"class\", \"k-table-td k-hierarchy-cell\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"role\", \"presentation\", 1, \"k-table-td\", \"k-group-cell\", \"k-table-group-td\"], [\"role\", \"presentation\", 1, \"k-table-td\", \"k-hierarchy-cell\"], [\"kendoGridLogicalCell\", \"\", \"class\", \"k-table-td\", \"role\", \"gridcell\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"k-grid-footer-sticky\", \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", \"aria-selected\", \"false\", 1, \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"ngClass\", \"ngStyle\"], [3, \"templateContext\"]],\n    template: function _class155_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelementStart(1, \"tr\", 0);\n        i0.ɵɵtemplate(2, _class155_td_2_Template, 1, 0, \"td\", 1);\n        i0.ɵɵtemplate(3, _class155_td_3_Template, 1, 0, \"td\", 2);\n        i0.ɵɵtemplate(4, _class155_ng_container_4_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-footer-template\", true);\n        i0.ɵɵproperty(\"logicalRowIndex\", ctx.logicalRowIndex)(\"logicalSlaveRow\", ctx.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx.columns.length)(\"logicalSlaveCellsCount\", ctx.columns.length - ctx.lockedColumnsCount)(\"totalColumns\", ctx.totalColumns);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnsToRender)(\"ngForTrackBy\", ctx.trackByIndex);\n      }\n    },\n    dependencies: [LogicalRowDirective, NgFor, NgIf, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective],\n    encapsulation: 2\n  }));\n  return FooterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the command columns of the Grid. You have to define the content of the\n * column inside an `<ng-template>` tag.\n * For more information and examples, refer to the [Command Column Directives](slug:editing_directives_grid#toc-command-column-directives) article.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\">\n *   <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *   <kendo-grid-command-column title=\"command\" [width]=\"220\">\n *      <ng-template kendoGridCellTemplate>\n *         <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *         <button kendoGridRemoveCommand>Remove</button>\n *      </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nlet CommandColumnComponent = /*#__PURE__*/(() => {\n  var _class156;\n  class CommandColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      _defineProperty(this, \"parent\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      this.parent = parent;\n    }\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n  }\n  _class156 = CommandColumnComponent;\n  _defineProperty(CommandColumnComponent, \"\\u0275fac\", function _class156_Factory(t) {\n    return new (t || _class156)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(CommandColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class156,\n    selectors: [[\"kendo-grid-command-column\"]],\n    contentQueries: function _class156_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class156)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class156_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return CommandColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the checkbox column for selecting rows in the Grid. [See example](slug:grid_row_selection#toc-select-all-checkbox).\n *\n * @example\n * ```html\n * <kendo-grid [selectable]=\"{enabled: true, checkboxOnly: true}\">\n *   <kendo-grid-checkbox-column title=\"Default checkbox\"></kendo-grid-checkbox-column>\n *   <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet CheckboxColumnComponent = /*#__PURE__*/(() => {\n  var _class157;\n  class CheckboxColumnComponent extends ColumnBase {\n    constructor(selectionService, cellSelectionService, parent, idService) {\n      super(parent, idService);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"cellSelectionService\", void 0);\n      _defineProperty(this, \"parent\", void 0);\n      /**\n       * Determines whether a select-all `kendoGridSelectAllCheckbox` checkbox will be displayed in the header.\n       */\n      _defineProperty(this, \"showSelectAll\", void 0);\n      /**\n       * Determines whether checkboxes will be rendered for rows which are marked as non-selectable. By default, such checkboxes are visible and disabled.\n       */\n      _defineProperty(this, \"showDisabledCheckbox\", true);\n      /*\n       * @hidden\n       */\n      _defineProperty(this, \"isCheckboxColumn\", true);\n      _defineProperty(this, \"template\", void 0);\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.parent = parent;\n    }\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    rowSelectable(rowIdx) {\n      return !this.selectionService.nonSelectableRows.has(rowIdx) && !this.cellSelectionService.nonSelectableRows.has(rowIdx);\n    }\n  }\n  _class157 = CheckboxColumnComponent;\n  _defineProperty(CheckboxColumnComponent, \"\\u0275fac\", function _class157_Factory(t) {\n    return new (t || _class157)(i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(CheckboxColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class157,\n    selectors: [[\"kendo-grid-checkbox-column\"]],\n    contentQueries: function _class157_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      showSelectAll: \"showSelectAll\",\n      showDisabledCheckbox: \"showDisabledCheckbox\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class157)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class157_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return CheckboxColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the row-selection checkbox of the Grid. The directive expects the\n * index of the current row as an input parameter. Inside the [`CellTemplateDirective`](slug:api_grid_celltemplatedirective), apply the\n * `kendoGridSelectionCheckbox` to a `<kendo-checkbox></kendo-checkbox>` or an `<input type=\"checkbox\"/>` element. When the user clicks the checkbox that is associated\n * with the directive, a [selectionChange](slug:api_grid_gridcomponent#toc-selectionChange)\n * event is triggered.\n *\n * @example\n * ```html\n * <kendo-grid ... >\n *   <kendo-grid-column>\n *     <ng-template kendoGridCellTemplate let-rowIndex=\"rowIndex\">\n *       <input ... [kendoGridSelectionCheckbox]=\"rowIndex\"/>\n *     </ng-template>\n *   </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet SelectionCheckboxDirective = /*#__PURE__*/(() => {\n  var _class158;\n  class SelectionCheckboxDirective {\n    ngAfterContentChecked() {\n      this.setCheckedState();\n    }\n    constructor(selectionService, cellSelectionService, aggregateService, el, renderer, ngZone, checkbox) {\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"cellSelectionService\", void 0);\n      _defineProperty(this, \"aggregateService\", void 0);\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"checkbox\", void 0);\n      /**\n       * The current index of the `dataItem` that will be selected.\n       */\n      _defineProperty(this, \"itemIndex\", void 0);\n      _defineProperty(this, \"destroyClick\", void 0);\n      _defineProperty(this, \"destroyKeyDown\", void 0);\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.aggregateService = aggregateService;\n      this.el = el;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.checkbox = checkbox;\n      this.ngZone.runOutsideAngular(() => {\n        this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));\n        this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, 'keydown', this.onKeyDown.bind(this));\n      });\n    }\n    ngOnDestroy() {\n      if (this.destroyClick) {\n        this.destroyClick();\n      }\n      if (this.destroyKeyDown) {\n        this.destroyKeyDown();\n      }\n    }\n    onClick(event) {\n      const nonSelectableRow = this.selectionService.nonSelectableRows.has(this.itemIndex) || this.cellSelectionService.nonSelectableRows.has(this.itemIndex);\n      if (nonSelectableRow || this.cellSelectionService.options.cell) {\n        event.preventDefault();\n        return;\n      }\n      if (this.selectionService.options.enabled) {\n        this.ngZone.run(() => {\n          let ev;\n          const ctrlKey = event.ctrlKey || event.metaKey;\n          if (event.shiftKey) {\n            const item = {\n              index: this.itemIndex\n            };\n            ev = this.selectionService.addAllTo(item, ctrlKey);\n          } else {\n            ev = this.selectionService.toggleByIndex(this.itemIndex);\n          }\n          ev.ctrlKey = event.ctrlKey;\n          ev.shiftKey = event.shiftKey;\n          if (this.selectionService.options.cellAggregates) {\n            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);\n          }\n          this.selectionService.changes.emit(ev);\n        });\n      }\n    }\n    onKeyDown(e) {\n      if (e.keyCode === Keys.Enter) {\n        this.onClick(e);\n      }\n    }\n    /*\n     * @hidden\n     */\n    setCheckedState() {\n      const isSelected = this.selectionService.nonSelectableRows.has(this.itemIndex) ? false : this.selectionService.isSelected(this.itemIndex);\n      if (this.checkbox) {\n        this.checkbox.checkedState = isSelected;\n      } else {\n        this.renderer.setProperty(this.el.nativeElement, 'checked', isSelected);\n      }\n    }\n  }\n  _class158 = SelectionCheckboxDirective;\n  _defineProperty(SelectionCheckboxDirective, \"\\u0275fac\", function _class158_Factory(t) {\n    return new (t || _class158)(i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(CellSelectionAggregateService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.CheckBoxComponent, 9));\n  });\n  _defineProperty(SelectionCheckboxDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class158,\n    selectors: [[\"\", \"kendoGridSelectionCheckbox\", \"\"]],\n    inputs: {\n      itemIndex: [\"kendoGridSelectionCheckbox\", \"itemIndex\"]\n    },\n    standalone: true\n  }));\n  return SelectionCheckboxDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ChangeNotificationService = /*#__PURE__*/(() => {\n  var _class159;\n  class ChangeNotificationService {\n    constructor(ngZone) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"subscription\", void 0);\n      this.ngZone = ngZone;\n    }\n    notify() {\n      if (!this.subscription || this.subscription.closed) {\n        this.subscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this.changes.emit());\n      }\n    }\n  }\n  _class159 = ChangeNotificationService;\n  _defineProperty(ChangeNotificationService, \"\\u0275fac\", function _class159_Factory(t) {\n    return new (t || _class159)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(ChangeNotificationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class159,\n    factory: _class159.ɵfac\n  }));\n  return ChangeNotificationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the no-records template of the Grid. Provides an option to customize the\n * appearance of the item that is displayed when no data is present.\n * To define the no-records template, nest an `<ng-template>` tag with the `kendoGridNoRecordsTemplate`\n * directive inside `<kendo-grid>` [see example](slug:norecordtemplate_grid).\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"data\">\n *   <ng-template kendoGridNoRecordsTemplate>\n *     There are not products. <a href=\"#\" (click)=\"refresh()\">Click here to refresh</a>.\n *   </ng-template>\n *   <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *   <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet NoRecordsTemplateDirective = /*#__PURE__*/(() => {\n  var _class160;\n  class NoRecordsTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class160 = NoRecordsTemplateDirective;\n  _defineProperty(NoRecordsTemplateDirective, \"\\u0275fac\", function _class160_Factory(t) {\n    return new (t || _class160)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(NoRecordsTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class160,\n    selectors: [[\"\", \"kendoGridNoRecordsTemplate\", \"\"]],\n    standalone: true\n  }));\n  return NoRecordsTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction defaultTrackBy(index, item) {\n  if (item.type === 'data' && item.isEditing) {\n    return item.data;\n  }\n  return index;\n}\n\n/**\n * @hidden\n */\nconst NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';\n/**\n * @hidden\n */\nconst NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';\n/**\n * @hidden\n */\nconst IGNORE_TARGET_CLASSSES = 'k-icon k-svg-icon';\n/**\n * @hidden\n */\nconst IGNORE_CONTAINER_CLASSES = 'k-grid k-grid-ignore-click';\n\n/**\n * @hidden\n */\nlet CellComponent = /*#__PURE__*/(() => {\n  var _class161;\n  class CellComponent {\n    get commandCellClass() {\n      return this.isCommand(this.column);\n    }\n    get dragHandleCellClass() {\n      return isRowReorderColumn(this.column);\n    }\n    get dragRowHandleLabel() {\n      return isRowReorderColumn(this.column) ? this.ctx.localization.get('dragRowHandleLabel') : undefined;\n    }\n    set rowIndex(index) {\n      this._rowIndex = index;\n      this.updateCellContext();\n    }\n    get rowIndex() {\n      return this._rowIndex;\n    }\n    get isEdited() {\n      if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {\n        return false;\n      }\n      const editContext = this.editService.columnContext(this.rowIndex, this.column);\n      return this.isFieldEditable(editContext, this.column);\n    }\n    get showLoading() {\n      return this.isVirtual && this.isLoading;\n    }\n    get formGroup() {\n      return this.editService.context(this.rowIndex).group;\n    }\n    get templateContext() {\n      return this._templateContext;\n    }\n    get editTemplateContext() {\n      this._editTemplateContext.$implicit = this.formGroup;\n      this._editTemplateContext.isNew = this.isNew;\n      this._editTemplateContext.column = this.column;\n      this._editTemplateContext.dataItem = this.dataItem;\n      this._editTemplateContext.formGroup = this.formGroup;\n      this._editTemplateContext.rowIndex = this.rowIndex;\n      return this._editTemplateContext;\n    }\n    get rowReorderTemplateContext() {\n      this._rowReorderTemplateContext.$implicit = this.dataItem;\n      this._rowReorderTemplateContext.columnIndex = this.columnIndex;\n      this._rowReorderTemplateContext.rowIndex = this.rowIndex;\n      return this._rowReorderTemplateContext;\n    }\n    get format() {\n      if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {\n        return extractFormat(this.column.format);\n      }\n      return undefined;\n    }\n    get isBoundColumn() {\n      return this.column.field && !this.column.templateRef;\n    }\n    get isCheckboxColumn() {\n      return isCheckboxColumn(this.column) && !this.column.templateRef;\n    }\n    get selectionCheckboxId() {\n      return this.idService.selectionCheckboxId(this.rowIndex);\n    }\n    get selectionCheckboxLabel() {\n      return this.ctx.localization.get('selectionCheckboxLabel');\n    }\n    get isSpanColumn() {\n      return isSpanColumn(this.column) && !this.column.templateRef;\n    }\n    get childColumns() {\n      return columnsToRender([this.column]);\n    }\n    get isRowReorderColumn() {\n      return isRowReorderColumn(this.column) && !this.column.templateRef;\n    }\n    get isRowSelectable() {\n      return this.column.rowSelectable(this._rowIndex);\n    }\n    get isColumnEditable() {\n      if (!this.column || this.isCommand(this.column)) {\n        return false;\n      }\n      return this.column.editable !== false;\n    }\n    constructor(editService, idService, ctx, cellContext) {\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"idService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"column\", void 0);\n      _defineProperty(this, \"columnIndex\", void 0);\n      _defineProperty(this, \"isNew\", false);\n      _defineProperty(this, \"isLoading\", false);\n      _defineProperty(this, \"isVirtual\", false);\n      _defineProperty(this, \"loadingTemplate\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"reorderIcon\", reorderIcon);\n      _defineProperty(this, \"_rowIndex\", void 0);\n      _defineProperty(this, \"_templateContext\", {});\n      _defineProperty(this, \"_editTemplateContext\", {});\n      _defineProperty(this, \"_rowReorderTemplateContext\", {});\n      this.editService = editService;\n      this.idService = idService;\n      this.ctx = ctx;\n      this.cellContext = cellContext;\n    }\n    ngDoCheck() {\n      this.updateCellContext();\n    }\n    ngOnChanges() {\n      this.updateTemplateContext();\n    }\n    ngAfterContentChecked() {\n      this.updateTemplateContext();\n    }\n    isCommand(column) {\n      return column instanceof CommandColumnComponent;\n    }\n    isFieldEditable(editContext, column) {\n      if (!isPresent(editContext)) {\n        return false;\n      }\n      if (isPresent(column.editTemplate)) {\n        return true;\n      }\n      return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));\n    }\n    updateCellContext() {\n      if (this.cellContext) {\n        this.cellContext.rowIndex = this._rowIndex;\n      }\n    }\n    updateTemplateContext() {\n      if (!this.column.templateRef) {\n        return;\n      }\n      const context = this._templateContext;\n      context.isNew = this.isNew;\n      context.column = this.column;\n      context.dataItem = this.dataItem;\n      context.rowIndex = this.rowIndex;\n      context.columnIndex = this.columnIndex;\n      context.$implicit = this.dataItem;\n    }\n  }\n  _class161 = CellComponent;\n  _defineProperty(CellComponent, \"\\u0275fac\", function _class161_Factory(t) {\n    return new (t || _class161)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(CELL_CONTEXT, 8));\n  });\n  _defineProperty(CellComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class161,\n    selectors: [[\"\", \"kendoGridCell\", \"\"]],\n    hostVars: 7,\n    hostBindings: function _class161_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.dragRowHandleLabel);\n        i0.ɵɵclassProp(\"k-command-cell\", ctx.commandCellClass)(\"k-drag-cell\", ctx.dragHandleCellClass)(\"k-touch-action-none\", ctx.dragHandleCellClass);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      columnIndex: \"columnIndex\",\n      isNew: \"isNew\",\n      isLoading: \"isLoading\",\n      isVirtual: \"isVirtual\",\n      loadingTemplate: \"loadingTemplate\",\n      rowIndex: \"rowIndex\",\n      dataItem: \"dataItem\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c32,\n    decls: 3,\n    vars: 3,\n    consts: [[3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngIf\", \"ngIfElse\"], [\"loading\", \"\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngFor\", \"ngForOf\"], [\"nonSelectableRow\", \"\"], [3, \"kendoGridSelectionCheckbox\", \"inputAttributes\"], [3, \"kendoGridSelectionCheckbox\", \"inputAttributes\", \"disabled\", 4, \"ngIf\"], [3, \"kendoGridSelectionCheckbox\", \"inputAttributes\", \"disabled\"], [\"name\", \"reorder\", 3, \"svgIcon\", 4, \"ngIf\"], [\"name\", \"reorder\", 3, \"svgIcon\"], [\"class\", \"k-skeleton-text k-skeleton\", 4, \"ngIf\"], [1, \"k-skeleton-text\", \"k-skeleton\"], [3, \"ngSwitch\", 4, \"ngIf\"], [\"kendoGridFocusable\", \"\", 3, \"format\", \"formControl\", 4, \"ngSwitchCase\"], [\"kendoGridFocusable\", \"\", 3, \"formControl\", 4, \"ngSwitchCase\"], [\"kendoGridFocusable\", \"\", 3, \"formControl\", 4, \"ngSwitchDefault\"], [\"kendoGridFocusable\", \"\", 3, \"format\", \"formControl\"], [\"kendoGridFocusable\", \"\", 3, \"formControl\"]],\n    template: function _class161_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵtemplate(1, _class161_ng_container_1_Template, 4, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, _class161_ng_container_2_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngSwitch\", ctx.isEdited);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n      }\n    },\n    dependencies: [NgSwitch, NgSwitchCase, NgIf, NgTemplateOutlet, NgFor, FocusableDirective, SelectionCheckboxDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, NgSwitchDefault, FieldAccessorPipe, ReactiveFormsModule, i4.NgControlStatus, i4.FormControlDirective, CheckBoxComponent, TextBoxComponent],\n    encapsulation: 2\n  }));\n  return CellComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass RowspanService {\n  constructor() {\n    _defineProperty(this, \"skipCells\", []);\n    _defineProperty(this, \"cellExists\", (rowIndex, colIndex) => cell => cell.rowIndex === rowIndex && cell.colIndex === colIndex);\n  }\n  addCells(rowIndex, colIndex, rowspan) {\n    for (let i = 1; i < rowspan; i++) {\n      if (!this.skipCells.some(this.cellExists(rowIndex + i, colIndex))) {\n        this.skipCells.push({\n          rowIndex: rowIndex + i,\n          colIndex\n        });\n      }\n    }\n  }\n  reset() {\n    this.skipCells = [];\n  }\n  shouldSkip(rowIndex, colIndex) {\n    return !!this.skipCells.find(this.cellExists(rowIndex, colIndex));\n  }\n}\nconst columnCellIndex = (cell, cells) => {\n  let cellIndex = 0;\n  for (let idx = 0; idx < cells.length; idx++) {\n    if (cells[idx] === cell) {\n      return cellIndex;\n    }\n    if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {\n      cellIndex++;\n    }\n  }\n};\n/**\n * @hidden\n */\nlet TableBodyComponent = /*#__PURE__*/(() => {\n  var _class163;\n  class TableBodyComponent {\n    constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService, rowspanService) {\n      _defineProperty(this, \"detailsService\", void 0);\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"changeNotification\", void 0);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"cellSelectionService\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"rowspanService\", void 0);\n      _defineProperty(this, \"columns\", []);\n      _defineProperty(this, \"allColumns\", void 0);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"noRecordsTemplate\", void 0);\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"skip\", 0);\n      _defineProperty(this, \"selectable\", void 0);\n      _defineProperty(this, \"filterable\", void 0);\n      _defineProperty(this, \"noRecordsText\", void 0);\n      _defineProperty(this, \"isLocked\", false);\n      _defineProperty(this, \"isLoading\", void 0);\n      _defineProperty(this, \"isVirtual\", void 0);\n      _defineProperty(this, \"cellLoadingTemplate\", void 0);\n      _defineProperty(this, \"skipGroupDecoration\", false);\n      _defineProperty(this, \"showGroupFooters\", false);\n      _defineProperty(this, \"lockedColumnsCount\", 0);\n      _defineProperty(this, \"totalColumnsCount\", 0);\n      _defineProperty(this, \"virtualColumns\", void 0);\n      _defineProperty(this, \"trackBy\", defaultTrackBy);\n      _defineProperty(this, \"rowSticky\", void 0);\n      _defineProperty(this, \"totalColumns\", void 0);\n      _defineProperty(this, \"rowClass\", () => null);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"groupHeaderSlaveCellsCount\", void 0);\n      _defineProperty(this, \"groupHeaderColumns\", void 0);\n      _defineProperty(this, \"clickSubscription\", void 0);\n      _defineProperty(this, \"touchSubscription\", void 0);\n      _defineProperty(this, \"l10nSubscription\", void 0);\n      _defineProperty(this, \"cellKeydownSubscription\", void 0);\n      _defineProperty(this, \"clickTimeout\", void 0);\n      _defineProperty(this, \"minusIcon\", minusIcon);\n      _defineProperty(this, \"plusIcon\", plusIcon);\n      _defineProperty(this, \"dataArray\", void 0);\n      _defineProperty(this, \"rerender\", false);\n      this.detailsService = detailsService;\n      this.groupsService = groupsService;\n      this.changeNotification = changeNotification;\n      this.editService = editService;\n      this.ctx = ctx;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.element = element;\n      this.domEvents = domEvents;\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.columnInfoService = columnInfoService;\n      this.navigationService = navigationService;\n      this.rowspanService = rowspanService;\n      this.noRecordsText = this.ctx.localization.get('noRecords');\n      this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe(args => this.cellKeydownHandler(args));\n      this.trackByWrapper = this.trackByWrapper.bind(this);\n      this.trackByColumns = this.trackByColumns.bind(this);\n    }\n    get newDataItem() {\n      return this.editService.newDataItem;\n    }\n    get cachedDataArray() {\n      if (!this.dataArray) {\n        this.dataArray = this.data.map(item => item);\n      }\n      return this.dataArray;\n    }\n    // Number of unlocked columns in the next table, if any\n    unlockedColumnsCount(item) {\n      const allColumns = this.allColumns || this.columns;\n      let allColumnsCount = allColumns.length;\n      allColumns.forEach(column => {\n        if (column.isSpanColumn) {\n          allColumnsCount += column.colspan - 1;\n        }\n      });\n      const contentColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - allColumnsCount;\n      const headerFooterColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;\n      return item && this.isDataItem(item) ? contentColumnsCount : headerFooterColumnsCount;\n    }\n    shouldSkipCell(rowIndex, colIndex) {\n      return this.rowspanService.shouldSkip(rowIndex, colIndex);\n    }\n    getRowspan(row, column, colIndex) {\n      if (this.rerender) {\n        this.dataArray = null;\n        this.rerender = false;\n      }\n      const rowspan = column.cellRowspan(row, column, this.cachedDataArray);\n      if (rowspan > 1) {\n        this.rowspanService.addCells(row.index, colIndex, rowspan);\n      }\n      this.ngZone.runOutsideAngular(() => setTimeout(() => {\n        this.rerender = true;\n        this.rowspanService.reset();\n      }));\n      return rowspan;\n    }\n    isAriaSelected(item, column) {\n      return this.cellSelectionService.isCellSelected(item, column) || this.isRowSelected(item) ? 'true' : 'false';\n    }\n    toggleRow(index, dataItem) {\n      this.detailsService.toggleRow(index, dataItem);\n      return false;\n    }\n    isExpanded(viewItem) {\n      return this.detailsService.isExpanded(viewItem.index, viewItem.data);\n    }\n    detailButtonIconName(viewItem) {\n      const expanded = this.isExpanded(viewItem);\n      return expanded ? 'minus' : 'plus';\n    }\n    detailButtonSvgIcon(viewItem) {\n      const expanded = this.isExpanded(viewItem);\n      return expanded ? this.minusIcon : this.plusIcon;\n    }\n    detailButtonTitle(viewItem) {\n      const messageKey = this.isExpanded(viewItem) ? 'detailCollapse' : 'detailExpand';\n      return this.ctx.localization.get(messageKey);\n    }\n    isGroup(item) {\n      return item.type === 'group';\n    }\n    isDataItem(item) {\n      return !this.isGroup(item) && !this.isFooter(item);\n    }\n    isFooter(item) {\n      return item.type === 'footer';\n    }\n    isFooterItemInExpandedGroup(item) {\n      const footerItem = {\n        data: item.data,\n        index: item.groupIndex,\n        parentGroup: item.group.parentGroup\n      };\n      return this.isInExpandedGroup(footerItem);\n    }\n    isDataItemInExpandedGroup(item) {\n      const dataItem = {\n        data: item.group.data,\n        index: item.groupIndex,\n        parentGroup: item.group.parentGroup\n      };\n      return this.isInExpandedGroup(dataItem);\n    }\n    isInExpandedGroup(item) {\n      return this.groupsService.isInExpandedGroup(item);\n    }\n    isParentGroupExpanded(item) {\n      return this.groupsService.isInExpandedGroup(item.parentGroup);\n    }\n    isOdd(item) {\n      return item.index % 2 !== 0;\n    }\n    isSelectable(args) {\n      const rowSelectable = this.isRowSelectable(args);\n      const selectionEnabled = this.selectable && this.selectable.enabled !== false;\n      return selectionEnabled && rowSelectable;\n    }\n    isRowSelected(item) {\n      return this.selectionService.isSelected(item.index);\n    }\n    isRowSelectable(args) {\n      return this.selectionService.settings?.isRowSelectable(args) || this.cellSelectionService.settings?.isRowSelectable(args);\n    }\n    trackByWrapper(index, item) {\n      if (item.type === 'data') {\n        item.isEditing = this.editService.hasEdited(item.index);\n      }\n      return this.trackBy(index, item);\n    }\n    trackByColumns(index, item) {\n      return this.virtualColumns ? index : item;\n    }\n    ngDoCheck() {\n      if (this.hasGroupHeaderColumn) {\n        this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));\n      } else {\n        this.groupHeaderColumns = [];\n      }\n      if (this.isLocked) {\n        this.groupHeaderSlaveCellsCount = this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;\n      } else {\n        this.groupHeaderSlaveCellsCount = 0;\n      }\n    }\n    ngAfterViewChecked() {\n      if (this.rowSticky) {\n        this.applyStickyRowsStyling();\n      }\n    }\n    ngOnChanges(changes) {\n      if (isChanged$1('columns', changes, false)) {\n        this.changeNotification.notify();\n      }\n    }\n    logicalRowIndex(rowIndex) {\n      let pos = this.skip + rowIndex;\n      if (this.hasDetailTemplate) {\n        pos *= 2;\n      }\n      const absoluteRowIndex = 1 + pos;\n      const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n      const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n      const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;\n      return absoluteRowIndex + headerRowCount;\n    }\n    addRowLogicalIndex() {\n      return this.columnInfoService.totalLevels + 1 + (hasFilterRow(this.filterable) ? 1 : 0);\n    }\n    logicalColIndex(column) {\n      if (!isPresent(column.leafIndex)) {\n        return -1;\n      }\n      return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);\n    }\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        const clickHandler = this.clickHandler.bind(this);\n        const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);\n        const mouseupSubscription = this.renderer.listen(this.element.nativeElement, 'mouseup', clickHandler);\n        const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);\n        const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);\n        const touchstartSubscription = this.renderer.listen(this.element.nativeElement, 'touchstart', clickHandler);\n        const touchendSubscription = this.renderer.listen(this.element.nativeElement, 'touchend', clickHandler);\n        this.clickSubscription = () => {\n          mousedownSubscription();\n          mouseupSubscription();\n          clickSubscription();\n          contextmenuSubscription();\n        };\n        this.touchSubscription = () => {\n          touchstartSubscription();\n          touchendSubscription();\n        };\n      });\n      let originalNoRecordText = this.ctx.localization.get('noRecords');\n      this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {\n        if (this.noRecordsText === originalNoRecordText) {\n          this.noRecordsText = this.ctx.localization.get('noRecords');\n          originalNoRecordText = this.noRecordsText;\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.clickSubscription) {\n        this.clickSubscription();\n      }\n      if (this.touchSubscription) {\n        this.touchSubscription();\n      }\n      if (this.l10nSubscription) {\n        this.l10nSubscription.unsubscribe();\n      }\n      this.cellKeydownSubscription.unsubscribe();\n      clearTimeout(this.clickTimeout);\n    }\n    isEditingCell(index, column) {\n      return this.editService.isEditing() && this.editService.isEditedColumn(index, column);\n    }\n    isEditingRow(index) {\n      return this.editService.isEditing() && this.editService.hasEdited(index);\n    }\n    get hasGroupHeaderColumn() {\n      return this.columnsContainer.hasGroupHeaderColumn;\n    }\n    get columnsContainer() {\n      return this.columnInfoService.columnsContainer;\n    }\n    get columnsSpan() {\n      return columnsSpan(this.columns);\n    }\n    get allColumnsSpan() {\n      return columnsSpan(this.allColumns || this.columns);\n    }\n    get colSpan() {\n      return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);\n    }\n    get footerColumns() {\n      const colsToRender = Array.from(this.columns).reduce((cols, col) => {\n        const newCols = col instanceof SpanColumnComponent ? Array.from(col.childColumns) : [col];\n        return [...cols, ...newCols];\n      }, []);\n      return colsToRender;\n    }\n    showGroupHeader(item) {\n      return !item.data.skipHeader;\n    }\n    addStickyColumnStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return {\n        ...column.style,\n        ...stickyStyles\n      };\n    }\n    resizeHandler() {\n      this.applyStickyRowsStyling();\n    }\n    get hasDetailTemplate() {\n      return isPresent(this.detailTemplate);\n    }\n    clickHandler(eventArg) {\n      const element = this.element.nativeElement;\n      const target = this.eventTarget(eventArg);\n      let cell, row, body, gridElement;\n      let currentTarget = target;\n      do {\n        cell = closest(currentTarget, matchesNodeName('td'));\n        row = closest(cell, matchesNodeName('tr'));\n        body = closest(row, matchesNodeName('tbody'));\n        currentTarget = body;\n        gridElement = closestInScope(currentTarget, matchesClasses('k-grid'), element);\n      } while (body && body !== element && !gridElement);\n      if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) && !hasClasses(row, NON_DATA_ROW_CLASSES) && body === element && !gridElement) {\n        this.editService.preventCellClose();\n        const focusable = target !== cell && isFocusableWithTabKey(target, false);\n        if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) && !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {\n          const args = this.cellClickArgs(cell, row, eventArg);\n          const selectionEnabled = this.selectable && this.selectable.enabled !== false;\n          if (selectionEnabled && !this.isRowSelectable({\n            index: args.rowIndex,\n            dataItem: args.dataItem\n          })) {\n            return;\n          }\n          if (eventArg.type === 'mousedown' || eventArg.type === 'touchstart') {\n            this.domEvents.cellMousedown.emit(args);\n          } else if (eventArg.type === 'mouseup' || eventArg.type === 'touchend') {\n            this.domEvents.cellMouseup.emit(args);\n          } else {\n            if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {\n              if (eventArg.type === 'click') {\n                this.clickTimeout = setTimeout(() => {\n                  this.emitCellClick(args);\n                }, 0);\n              } else {\n                this.emitCellClick(args);\n              }\n            }\n          }\n        }\n      }\n    }\n    emitCellClick(args) {\n      this.domEvents.cellClick.emit(Object.assign(args, {\n        isEdited: args.isEditedRow || args.isEditedColumn\n      }));\n    }\n    cellKeydownHandler(args) {\n      if (args.keyCode === Keys.Enter) {\n        this.clickHandler(args);\n      }\n    }\n    cellClickArgs(cell, row, eventArg) {\n      const index = columnCellIndex(cell, row.cells);\n      const column = this.columns.toArray()[index];\n      const columnIndex = this.lockedColumnsCount + index;\n      let rowIndex = row.getAttribute('data-kendo-grid-item-index');\n      rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;\n      const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);\n      const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);\n      const isEditedRow = this.editService.isEdited(rowIndex);\n      const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;\n      return {\n        column: column,\n        columnIndex: columnIndex,\n        dataItem: dataItem,\n        isEditedColumn: isEditedColumn,\n        isEditedRow: isEditedRow,\n        originalEvent: eventArg,\n        rowIndex: rowIndex,\n        type: type\n      };\n    }\n    eventTarget(args) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (args.type === 'touchend') {\n        const touch = args.changedTouches[0];\n        return document.elementFromPoint(touch.clientX, touch.clientY);\n      }\n      return args.target;\n    }\n    applyStickyRowsStyling() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll('.k-grid-row-sticky'));\n      const length = stickyRows.length;\n      if (length) {\n        let accumulatedHeight = 0;\n        const stickyRowsOffsets = [];\n        stickyRows.forEach(row => {\n          const rowHeight = row.getBoundingClientRect().height;\n          stickyRowsOffsets.push({\n            accumulatedHeight,\n            rowHeight\n          });\n          accumulatedHeight += rowHeight;\n        });\n        stickyRows.forEach((row, index) => {\n          this.renderer.setStyle(row, 'top', `${stickyRowsOffsets[index].accumulatedHeight}px`);\n          this.renderer.setStyle(row, 'bottom', `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);\n        });\n      }\n    }\n  }\n  _class163 = TableBodyComponent;\n  _defineProperty(TableBodyComponent, \"\\u0275fac\", function _class163_Factory(t) {\n    return new (t || _class163)(i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DomEventsService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(RowspanService));\n  });\n  _defineProperty(TableBodyComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class163,\n    selectors: [[\"\", \"kendoGridTableBody\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class163_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-table-tbody\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      allColumns: \"allColumns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      noRecordsTemplate: \"noRecordsTemplate\",\n      data: \"data\",\n      skip: \"skip\",\n      selectable: \"selectable\",\n      filterable: \"filterable\",\n      noRecordsText: \"noRecordsText\",\n      isLocked: \"isLocked\",\n      isLoading: \"isLoading\",\n      isVirtual: \"isVirtual\",\n      cellLoadingTemplate: \"cellLoadingTemplate\",\n      skipGroupDecoration: \"skipGroupDecoration\",\n      showGroupFooters: \"showGroupFooters\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      totalColumnsCount: \"totalColumnsCount\",\n      virtualColumns: \"virtualColumns\",\n      trackBy: \"trackBy\",\n      rowSticky: \"rowSticky\",\n      totalColumns: \"totalColumns\",\n      rowClass: \"rowClass\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c34,\n    decls: 4,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-grid-norecords\", \"role\", \"row\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"resize\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-grid-add-row\", \"k-grid-edit-row\", \"k-master-row\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"totalColumns\"], [\"class\", \"k-hierarchy-cell k-table-td\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngIf\"], [\"class\", \"k-table-td\", \"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", 3, \"rowIndex\", \"columnIndex\", \"isNew\", \"column\", \"dataItem\", \"k-grid-content-sticky\", \"ngClass\", \"left\", \"ngStyle\", \"logicalRowIndex\", \"logicalColIndex\", \"colSpan\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"k-group-cell k-table-td k-table-group-td\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-group-cell\", \"k-table-td\", \"k-table-group-td\"], [\"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 1, \"k-hierarchy-cell\", \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"rowIndex\", \"columnIndex\", \"isNew\", \"column\", \"dataItem\", \"ngClass\", \"ngStyle\", \"logicalRowIndex\", \"logicalColIndex\", \"colSpan\"], [\"role\", \"row\", 1, \"k-grid-norecords\"], [1, \"k-table-td\"], [3, \"templateContext\"], [\"kendoGridGroupHeader\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"groups\", \"item\", \"hasDetails\", \"skipGroupDecoration\", \"hasGroupHeaderColumn\", \"groupHeaderColumns\", \"rowIndex\", \"totalColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"class\", \"k-grid-row-sticky\", \"ngClass\", \"k-master-row\", \"k-expanded\", \"k-grid-edit-row\", \"k-selected\", 4, \"ngIf\"], [\"class\", \"k-detail-row\", \"kendoGridLogicalRow\", \"\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", 4, \"ngIf\"], [\"class\", \"k-group-footer\", \"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngIf\"], [\"kendoGridGroupHeader\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"groups\", \"item\", \"hasDetails\", \"skipGroupDecoration\", \"hasGroupHeaderColumn\", \"groupHeaderColumns\", \"rowIndex\", \"totalColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"kendoGridLogicalRow\", \"\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"ngClass\"], [\"class\", \"k-hierarchy-cell k-table-td\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", \"role\", \"gridcell\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"detailExpandCell\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", \"role\", \"gridcell\", 1, \"k-hierarchy-cell\", \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"detailExpandCell\"], [\"href\", \"#\", \"tabindex\", \"-1\", 3, \"click\", 4, \"ngIf\"], [\"href\", \"#\", \"tabindex\", \"-1\", 3, \"click\"], [3, \"name\", \"svgIcon\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", \"class\", \"k-table-td\", 3, \"rowIndex\", \"columnIndex\", \"column\", \"dataItem\", \"isLoading\", \"isVirtual\", \"loadingTemplate\", \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"colIndex\", \"colSpan\", \"rowSpan\", \"k-grid-content-sticky\", \"k-touch-action-none\", \"ngClass\", \"k-grid-edit-cell\", \"ngStyle\", \"k-selected\", 4, \"ngIf\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"rowIndex\", \"columnIndex\", \"column\", \"dataItem\", \"isLoading\", \"isVirtual\", \"loadingTemplate\", \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"colIndex\", \"colSpan\", \"rowSpan\", \"ngClass\", \"ngStyle\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-detail-row\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\"], [\"class\", \"k-group-cell k-table-td k-table-group-td\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-hierarchy-cell\", \"k-table-td\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", \"aria-selected\", \"false\", 1, \"k-detail-cell\", \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"colIndex\", \"colSpan\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-group-cell\", \"k-table-td\", \"k-table-group-td\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-group-footer\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"totalColumns\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"kendoGridLogicalCell\", \"\", \"class\", \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"kendoGridLogicalCell\", \"\", 1, \"k-table-td\", 3, \"logicalRowIndex\", \"logicalColIndex\"], [3, \"resize\"]],\n    template: function _class163_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class163_ng_container_0_Template, 5, 9, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class163_tr_1_Template, 4, 3, \"tr\", 1);\n        i0.ɵɵtemplate(2, _class163_ng_container_2_Template, 5, 4, \"ng-container\", 2);\n        i0.ɵɵtemplate(3, _class163_kendo_resize_sensor_3_Template, 1, 0, \"kendo-resize-sensor\", 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.editService.hasNewItem);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", (ctx.data == null ? null : ctx.data.length) === 0 || ctx.data === null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data)(\"ngForTrackBy\", ctx.trackByWrapper);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowSticky);\n      }\n    },\n    dependencies: [NgIf, LogicalRowDirective, NgFor, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective, GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return TableBodyComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `edit` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [edit]({% slug api_grid_gridcomponent %}#toc-edit) event\n * is triggered ([see example]({% slug basics_editing_grid %})).\n *\n * When the row is in the `edit` mode, the button with `kendoGridEditCommand` is automatically hidden.\n *\n * @example\n * ```html\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n */\nlet EditCommandDirective = /*#__PURE__*/(() => {\n  var _class164;\n  class EditCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    get visible() {\n      return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.editService.beginEdit(this.rowIndex);\n    }\n    constructor(editService, cellContext, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"rowIndex\", void 0);\n      _defineProperty(this, \"isEdited\", void 0);\n      _defineProperty(this, \"commandClass\", true);\n      this.editService = editService;\n      this.cellContext = cellContext;\n    }\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n  }\n  _class164 = EditCommandDirective;\n  _defineProperty(EditCommandDirective, \"\\u0275fac\", function _class164_Factory(t) {\n    return new (t || _class164)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(EditCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class164,\n    selectors: [[\"\", \"kendoGridEditCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class164_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class164_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-edit-command\", ctx.commandClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c40,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class164_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class164_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class164_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class164_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return EditCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `cancel` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})\n * ([see example](slug:editing_directives_grid#toc-command-column-directives)).\n * When an associated button with the directive is clicked, the\n * [cancel]({% slug api_grid_gridcomponent %}#toc-cancel) event\n * is triggered. When the row is not in the edit mode, the button with the `kendoGridCancelCommand` is automatically hidden.\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nlet CancelCommandDirective = /*#__PURE__*/(() => {\n  var _class165;\n  class CancelCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    get visible() {\n      return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      if (this.isEdited) {\n        this.editService.endEdit(this.rowIndex);\n      }\n    }\n    constructor(editService, cellContext, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"rowIndex\", void 0);\n      _defineProperty(this, \"isEdited\", void 0);\n      _defineProperty(this, \"commandClass\", true);\n      this.editService = editService;\n      this.cellContext = cellContext;\n    }\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n  }\n  _class165 = CancelCommandDirective;\n  _defineProperty(CancelCommandDirective, \"\\u0275fac\", function _class165_Factory(t) {\n    return new (t || _class165)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(CancelCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class165,\n    selectors: [[\"\", \"kendoGridCancelCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class165_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class165_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-cancel-command\", ctx.commandClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c41,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class165_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class165_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class165_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class165_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return CancelCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `save` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})\n * ([see example](slug:editing_directives_grid#toc-command-column-directives)).\n * When an associated button with the directive is clicked, the\n * [save]({% slug api_grid_gridcomponent %}#toc-save) event\n * is triggered. When the row is not in the edit mode, the button with `kendoGridSaveCommand` is automatically hidden.\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nlet SaveCommandDirective = /*#__PURE__*/(() => {\n  var _class166;\n  class SaveCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    get visible() {\n      return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      if (this.isEdited) {\n        this.editService.save(this.rowIndex);\n      }\n    }\n    constructor(editService, cellContext, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"rowIndex\", void 0);\n      _defineProperty(this, \"isEdited\", void 0);\n      _defineProperty(this, \"commandClass\", true);\n      this.editService = editService;\n      this.cellContext = cellContext;\n    }\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n  }\n  _class166 = SaveCommandDirective;\n  _defineProperty(SaveCommandDirective, \"\\u0275fac\", function _class166_Factory(t) {\n    return new (t || _class166)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(SaveCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class166,\n    selectors: [[\"\", \"kendoGridSaveCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class166_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class166_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-save-command\", ctx.commandClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c42,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class166_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class166_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class166_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class166_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return SaveCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `remove` command of the Grid. You can apply this directive to any `button` element\n * inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})\n * ([see example](slug:editing_directives_grid#toc-command-column-directives)).\n * When an associated button with the directive is clicked, the\n * [remove]({% slug api_grid_gridcomponent %}#toc-remove) event\n * is triggered.\n * When the row is in the `edit` mode, the button with the `kendoGridRemoveCommand` is automatically hidden.\n *\n * @example\n * ```html\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridRemoveCommand>Remove row</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nlet RemoveCommandDirective = /*#__PURE__*/(() => {\n  var _class167;\n  class RemoveCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    get visible() {\n      return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.editService.remove(this.rowIndex);\n    }\n    constructor(editService, cellContext, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"cellContext\", void 0);\n      _defineProperty(this, \"rowIndex\", void 0);\n      _defineProperty(this, \"isEdited\", void 0);\n      _defineProperty(this, \"commandClass\", true);\n      this.editService = editService;\n      this.cellContext = cellContext;\n    }\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n  }\n  _class167 = RemoveCommandDirective;\n  _defineProperty(RemoveCommandDirective, \"\\u0275fac\", function _class167_Factory(t) {\n    return new (t || _class167)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(RemoveCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class167,\n    selectors: [[\"\", \"kendoGridRemoveCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function _class167_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class167_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-remove-command\", ctx.commandClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c43,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class167_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class167_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class167_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class167_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return RemoveCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the command for adding a new item to the Grid. You can apply this directive to any\n * `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered\n * ([see example]({% slug basics_editing_grid %})).\n *\n * @example\n * ```html\n * <kendo-grid>\n *    <ng-template kendoGridToolbarTemplate>\n *       <button kendoGridAddCommand>Add new</button>\n *    </ng-template>\n * </kendo-grid>\n * ```\n */\nlet AddCommandDirective = /*#__PURE__*/(() => {\n  var _class168;\n  class AddCommandDirective extends Button {\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.editService.beginAdd();\n    }\n    /**\n     * @hidden\n     */\n    get commandClass() {\n      return true;\n    }\n    constructor(editService, element, renderer, ctx, ngZone) {\n      super(element, renderer, null, ctx.localization, ngZone);\n      _defineProperty(this, \"editService\", void 0);\n      this.editService = editService;\n    }\n  }\n  _class168 = AddCommandDirective;\n  _defineProperty(AddCommandDirective, \"\\u0275fac\", function _class168_Factory(t) {\n    return new (t || _class168)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(AddCommandDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class168,\n    selectors: [[\"\", \"kendoGridAddCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class168_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class168_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-add-command\", ctx.commandClass);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c44,\n    ngContentSelectors: _c11,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class168_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class168_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class168_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class168_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return AddCommandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the virtual scrolling cell template of the Grid while loading new data. Provides an option to customize the\n * appearance of the indicator that is displayed while new data is loading. To define the loading cell template,\n * nest an `<ng-template>` tag with the `kendoGridCellLoadingTemplate` directive inside `<kendo-grid>` tag [see example]({% slug virtualscrolling_grid %}#toc-custom-loading-skeleton).\n *\n *\n * The template context is set to the current column and the following additional field is passed:\n *\n * - `column`&mdash;The current column instance. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax (for example `let-column`).\n *\n * @example\n * ```html\n * <kendo-grid ... scrollable=\"virtual\" [rowHeight]=\"36\" [height]=\"450\">\n *   <ng-template kendoGridCellLoadingTemplate let-column>\n *    ...\n *   </ng-template>\n * </kendo-grid>\n * ```\n */\nlet CellLoadingTemplateDirective = /*#__PURE__*/(() => {\n  var _class169;\n  class CellLoadingTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class169 = CellLoadingTemplateDirective;\n  _defineProperty(CellLoadingTemplateDirective, \"\\u0275fac\", function _class169_Factory(t) {\n    return new (t || _class169)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(CellLoadingTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class169,\n    selectors: [[\"\", \"kendoGridCellLoadingTemplate\", \"\"]],\n    standalone: true\n  }));\n  return CellLoadingTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column row reorder cell template of the Grid.\n * Helps to customize the content of the drag handle cells. To define the cell template, nest an `<ng-template>`\n * tag with the `kendoGridRowDragHandleTemplate` directive inside the `<kendo-grid-rowreorder-column>` tag.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex=\"columnIndex\"` syntax.\n * - `rowIndex`&mdash;The provided data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n *\n * @example\n * ```html\n * <kendo-grid [kendoGridBinding]=\"data\" [rowReorderable]=\"true\">\n *    <kendo-grid-rowreorder-column>\n *      <ng-template kendoGridRowDragHandleTemplate>\n *        <span>Drag here</span>\n *      </ng-template>\n *    </kendo-grid-rowreorder-column>\n *   <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *   <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet RowDragHandleTemplateDirective = /*#__PURE__*/(() => {\n  var _class170;\n  class RowDragHandleTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class170 = RowDragHandleTemplateDirective;\n  _defineProperty(RowDragHandleTemplateDirective, \"\\u0275fac\", function _class170_Factory(t) {\n    return new (t || _class170)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(RowDragHandleTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class170,\n    selectors: [[\"\", \"kendoGridRowDragHandleTemplate\", \"\"]],\n    standalone: true\n  }));\n  return RowDragHandleTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the drag hint template of the Grid.\n * Helps to customize the content of the hint during row reordering. To define the hint template, nest an `<ng-template>`\n * tag with the `kendoGridRowDragHintTemplate` directive inside the `<kendo-grid-rowreorder-column>` tag.\n *\n * The template context is set to the current data item.\n * The provided data row index is passed as an additional field. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n *\n * @example\n * ```html\n * <kendo-grid [kendoGridBinding]=\"data\" [rowReorderable]=\"true\">\n *    <kendo-grid-rowreorder-column>\n *      <ng-template kendoGridRowDragHintTemplate>\n *        <span>Custom hint</span>\n *      </ng-template>\n *    </kendo-grid-rowreorder-column>\n *   <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *   <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet RowDragHintTemplateDirective = /*#__PURE__*/(() => {\n  var _class171;\n  class RowDragHintTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class171 = RowDragHintTemplateDirective;\n  _defineProperty(RowDragHintTemplateDirective, \"\\u0275fac\", function _class171_Factory(t) {\n    return new (t || _class171)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(RowDragHintTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class171,\n    selectors: [[\"\", \"kendoGridRowDragHintTemplate\", \"\"]],\n    standalone: true\n  }));\n  return RowDragHintTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the drag handle for reordering rows in the Grid ([see example](slug:reordering_rows_grid))\n */\nlet RowReorderColumnComponent = /*#__PURE__*/(() => {\n  var _class172;\n  class RowReorderColumnComponent extends ColumnBase {\n    /**\n     * @hidden\n     */\n    get rowDragHandleTemplateRef() {\n      const rowTemplate = this.dragHandleTemplate.first;\n      return rowTemplate ? rowTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get rowDragHintTemplateRef() {\n      const rowTemplate = this.dragHintTemplate.first;\n      return rowTemplate ? rowTemplate.templateRef : undefined;\n    }\n    constructor(parent, idService) {\n      super(parent, idService);\n      _defineProperty(this, \"parent\", void 0);\n      /**\n       * Defines the name for an existing font icon in the Kendo UI theme.\n       * @hidden\n       */\n      _defineProperty(this, \"dragHandleIcon\", void 0);\n      /**\n       * Defines an SVGIcon to be rendered as a drag handle.\n       * @hidden\n       */\n      _defineProperty(this, \"dragHandleSVGIcon\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dragHandleTemplate\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dragHintTemplate\", new QueryList());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isRowReorderColumn\", true);\n      this.parent = parent;\n    }\n  }\n  _class172 = RowReorderColumnComponent;\n  _defineProperty(RowReorderColumnComponent, \"\\u0275fac\", function _class172_Factory(t) {\n    return new (t || _class172)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  });\n  _defineProperty(RowReorderColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class172,\n    selectors: [[\"kendo-grid-rowreorder-column\"]],\n    contentQueries: function _class172_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, RowDragHandleTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, RowDragHintTemplateDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragHandleTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragHintTemplate = _t);\n      }\n    },\n    inputs: {\n      dragHandleIcon: \"dragHandleIcon\",\n      dragHandleSVGIcon: \"dragHandleSVGIcon\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => _class172)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class172_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return RowReorderColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass ZoneAwareEventEmitter extends EventEmitter {\n  constructor(ngZone, isAsync = false) {\n    super(isAsync);\n    _defineProperty(this, \"ngZone\", void 0);\n    this.ngZone = ngZone;\n  }\n  subscribe(generatorOrNext, error, complete) {\n    let schedulerFn;\n    let errorFn = _ => null;\n    let completeFn = () => null;\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = value => {\n        this.ngZone.run(() => generatorOrNext.next(value));\n      };\n      if (generatorOrNext.error) {\n        errorFn = err => {\n          this.ngZone.run(() => generatorOrNext.error(err));\n        };\n      }\n      if (generatorOrNext.complete) {\n        completeFn = () => {\n          this.ngZone.run(() => generatorOrNext.complete());\n        };\n      }\n    } else {\n      schedulerFn = value => {\n        this.ngZone.run(() => generatorOrNext(value));\n      };\n      if (error) {\n        errorFn = err => {\n          this.ngZone.run(() => error(err));\n        };\n      }\n      if (complete) {\n        completeFn = () => {\n          this.ngZone.run(() => complete());\n        };\n      }\n    }\n    return super.subscribe(schedulerFn, errorFn, completeFn);\n  }\n}\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-grid',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163816,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nconst normalizeSettings = ({\n  buttonCount = 10,\n  info = true,\n  type = 'numeric',\n  pageSizes = false,\n  previousNext = true,\n  responsive = true,\n  position = 'bottom'\n}) => ({\n  buttonCount,\n  info,\n  pageSizes,\n  previousNext,\n  type,\n  responsive,\n  position\n});\n/**\n * @hidden\n */\nconst normalize = settings => normalizeSettings(settings === true ? {} : settings);\nconst canCreateElement = () => isDocumentAvailable() && document.createElement;\nlet cachedScrollbarWidth = null;\nlet cachedPixelRatio;\nlet cachedRtlScrollLeft = null;\nfunction scrollbarWidth() {\n  if (cachedScrollbarWidth === null && canCreateElement()) {\n    cachedPixelRatio = window.devicePixelRatio || 1;\n    const div = document.createElement(\"div\");\n    div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n    div.innerHTML = \"&nbsp;\";\n    document.body.appendChild(div);\n    cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;\n    document.body.removeChild(div);\n  }\n  return cachedScrollbarWidth;\n}\nfunction rtlScrollLeft() {\n  if (cachedRtlScrollLeft === null && canCreateElement()) {\n    const outer = document.createElement('div');\n    outer.style.direction = 'rtl';\n    outer.style.display = 'block';\n    outer.style.clear = 'both';\n    outer.style.width = '100px';\n    outer.style.visibility = 'hidden';\n    outer.style.position = 'absolute';\n    outer.style.left = '-10000px';\n    outer.style.overflow = 'scroll';\n    outer.style.zoom = '1';\n    const inner = document.createElement('div');\n    inner.style.width = '200px';\n    inner.style.height = '1px';\n    outer.append(inner);\n    document.body.appendChild(outer);\n    const initial = outer.scrollLeft;\n    outer.scrollLeft = -1;\n    cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial;\n    document.body.removeChild(outer);\n  }\n  return cachedRtlScrollLeft;\n}\n/**\n * @hidden\n * move to kendo-common\n */\nlet BrowserSupportService = /*#__PURE__*/(() => {\n  var _class174;\n  class BrowserSupportService {\n    constructor(zone, changeDetector) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"changes\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", void 0);\n      this.zone = zone;\n      this.changeDetector = changeDetector;\n      if (typeof window === 'undefined') {\n        return;\n      }\n      this.zone.runOutsideAngular(() => {\n        this.subscriptions = fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {\n          if (cachedPixelRatio !== window.devicePixelRatio) {\n            zone.run(() => {\n              cachedScrollbarWidth = null;\n              this.changes.emit();\n              this.changeDetector.markForCheck();\n            });\n          }\n        });\n      });\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n        this.subscriptions = null;\n      }\n    }\n    get scrollbarWidth() {\n      return scrollbarWidth();\n    }\n    get rtlScrollLeft() {\n      return rtlScrollLeft();\n    }\n  }\n  _class174 = BrowserSupportService;\n  _defineProperty(BrowserSupportService, \"\\u0275fac\", function _class174_Factory(t) {\n    return new (t || _class174)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(BrowserSupportService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class174,\n    factory: _class174.ɵfac\n  }));\n  return BrowserSupportService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isGroupItem = source => {\n  return source.items !== undefined && source.field !== undefined;\n};\nconst isVirtualGroupItem = source => {\n  return source.offset !== undefined && source.skipHeader !== undefined;\n};\nconst flattenGroups = groups => groups.reduce((acc, curr) => {\n  if (isGroupItem(curr)) {\n    return acc.concat(flattenGroups(curr.items));\n  }\n  return acc.concat([curr]);\n}, []);\n/**\n * @hidden\n */\nconst itemAt = (data, index) => {\n  const first = data[0];\n  if (isPresent(first) && isGroupItem(first)) {\n    return flattenGroups(data)[index];\n  }\n  return data[index];\n};\n/**\n * @hidden\n */\nconst getIterator = (data, {\n  footers,\n  level,\n  dataIndex,\n  parentGroupIndex,\n  groupIndex,\n  parentGroup\n}) => {\n  const first = data[0];\n  if (isPresent(first) && isGroupItem(first)) {\n    if (isVirtualGroupItem(first)) {\n      groupIndex = isPresent(first.offset) ? first.offset : groupIndex;\n    }\n    return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);\n  }\n  return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);\n};\nclass ArrayIterator {\n  constructor(arr, idx = 0) {\n    _defineProperty(this, \"arr\", void 0);\n    _defineProperty(this, \"idx\", void 0);\n    this.arr = arr;\n    this.idx = idx;\n    this.arr = arr || [];\n  }\n  [iterator]() {\n    return this;\n  }\n  next() {\n    return this.idx < this.arr.length ? {\n      done: false,\n      value: this.arr[this.idx++]\n    } : {\n      done: true,\n      value: undefined\n    };\n  }\n}\n/**\n * @hidden\n */\nclass Iterator {\n  constructor(arr, dataIndex = 0, resultMap = x => x) {\n    _defineProperty(this, \"dataIndex\", void 0);\n    _defineProperty(this, \"resultMap\", void 0);\n    _defineProperty(this, \"_innerIterator\", void 0);\n    this.dataIndex = dataIndex;\n    this.resultMap = resultMap;\n    const iter = arr[iterator];\n    this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);\n  }\n  [iterator]() {\n    return this;\n  }\n  next() {\n    return this.resultMap(this._innerIterator.next(), this.dataIndex++);\n  }\n}\n/**\n * @hidden\n */\nclass ItemIterator extends Iterator {\n  constructor(arr, dataIndex, groupIndex, group) {\n    super(arr, dataIndex, (x, idx) => ({\n      done: x.done,\n      value: {\n        data: x.value,\n        groupIndex: groupIndex,\n        index: idx,\n        type: 'data',\n        group\n      }\n    }));\n  }\n  /**\n   * The index of the next record.\n   * @readonly\n   * @type {number}\n   */\n  get index() {\n    return this.dataIndex;\n  }\n}\nconst prefix = (s, n) => {\n  const p = s ? s + \"_\" : s;\n  return `${p}${n}`;\n};\n/**\n * @hidden\n */\nclass GroupIterator {\n  constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = '', groupIndex = 0, parentGroup = undefined) {\n    _defineProperty(this, \"arr\", void 0);\n    _defineProperty(this, \"outputFooters\", void 0);\n    _defineProperty(this, \"level\", void 0);\n    _defineProperty(this, \"dataIndex\", void 0);\n    _defineProperty(this, \"parentIndex\", void 0);\n    _defineProperty(this, \"groupIndex\", void 0);\n    _defineProperty(this, \"parentGroup\", void 0);\n    _defineProperty(this, \"current\", void 0);\n    _defineProperty(this, \"_innerIterator\", void 0);\n    _defineProperty(this, \"_iterator\", void 0);\n    _defineProperty(this, \"currentGroupIndex\", \"\");\n    this.arr = arr;\n    this.outputFooters = outputFooters;\n    this.level = level;\n    this.dataIndex = dataIndex;\n    this.parentIndex = parentIndex;\n    this.groupIndex = groupIndex;\n    this.parentGroup = parentGroup;\n    this.arr = arr || [];\n    this._iterator = new Iterator(this.arr, this.dataIndex);\n  }\n  [iterator]() {\n    return this;\n  }\n  nextGroupItem() {\n    this.current = this._iterator.next().value;\n    this._innerIterator = null;\n    if (this.current) {\n      this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);\n      return {\n        done: false,\n        value: {\n          data: this.current,\n          index: this.currentGroupIndex,\n          level: this.level,\n          type: 'group',\n          parentGroup: this.parentGroup\n        }\n      };\n    } else {\n      this.current = null;\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  }\n  footerItem() {\n    if (this.current) {\n      const group = this.current;\n      this.current = null;\n      return {\n        done: false,\n        value: {\n          data: group,\n          groupIndex: this.currentGroupIndex,\n          level: this.level,\n          type: 'footer',\n          group: {\n            data: group,\n            index: this.currentGroupIndex,\n            level: this.level,\n            type: 'group',\n            parentGroup: this.parentGroup\n          }\n        }\n      };\n    } else {\n      this.current = null;\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  }\n  innerIterator(group) {\n    if (!this._innerIterator) {\n      this._innerIterator = getIterator(group.items, {\n        dataIndex: this.dataIndex,\n        footers: this.outputFooters,\n        level: this.level + 1,\n        parentGroupIndex: this.currentGroupIndex,\n        parentGroup: {\n          data: this.current,\n          index: this.currentGroupIndex,\n          level: this.level,\n          type: 'group',\n          parentGroup: this.parentGroup\n        }\n      });\n    }\n    return this._innerIterator;\n  }\n  nextDataItem(group) {\n    const iterator = this.innerIterator(group);\n    const result = iterator.next();\n    if (isPresent(result.value) && !result.done && result.value.type === \"data\") {\n      this.dataIndex = result.value.index + 1;\n    }\n    return !result.done ? result : undefined;\n  }\n  next() {\n    if (!isPresent(this.current)) {\n      return this.nextGroupItem();\n    }\n    const item = this.nextDataItem(this.current);\n    return item ? item : this.outputFooters ? this.footerItem() : this.nextGroupItem();\n  }\n  /**\n   * The index of the last iterated data record.\n   * @readonly\n   * @type {number}\n   */\n  get index() {\n    return this.dataIndex + 1;\n  }\n}\n\n/**\n * @hidden\n */\nclass DataResultIterator {\n  constructor(source, skip = 0, groupFooters = false) {\n    _defineProperty(this, \"source\", void 0);\n    _defineProperty(this, \"skip\", void 0);\n    _defineProperty(this, \"groupFooters\", void 0);\n    _defineProperty(this, \"isObject\", void 0);\n    this.source = source;\n    this.skip = skip;\n    this.groupFooters = groupFooters;\n    this.source = this.source ? this.source : [];\n    this.isObject = this.isGridDataResult(this.source);\n  }\n  isGridDataResult(source) {\n    return source.total !== undefined && source.data !== undefined;\n  }\n  get total() {\n    return this.isObject ? this.source.total : this.source.length;\n  }\n  get data() {\n    return this.isObject ? this.source.data : this.source;\n  }\n  map(fn) {\n    return this.data.map(fn);\n  }\n  filter(fn) {\n    return this.data.filter(fn);\n  }\n  reduce(fn, init) {\n    return this.data.reduce(fn, init);\n  }\n  forEach(fn) {\n    this.data.forEach(fn);\n  }\n  some(fn) {\n    return this.data.some(fn);\n  }\n  [iterator]() {\n    return getIterator(this.data, {\n      dataIndex: this.skip,\n      footers: this.groupFooters,\n      groupIndex: this.skip\n    });\n  }\n  toString() {\n    return this.data.toString();\n  }\n}\n/**\n * @hidden\n */\nclass DataCollection {\n  constructor(accessor) {\n    _defineProperty(this, \"accessor\", void 0);\n    this.accessor = accessor;\n  }\n  get total() {\n    return this.accessor().total;\n  }\n  get length() {\n    return this.accessor().data.length;\n  }\n  get first() {\n    return this.accessor().data[0];\n  }\n  get last() {\n    return this.accessor().data[this.length - 1];\n  }\n  at(index) {\n    return itemAt(this.accessor().data, index);\n  }\n  map(fn) {\n    return this.accessor().map(fn);\n  }\n  filter(fn) {\n    return this.accessor().filter(fn);\n  }\n  reduce(fn, init) {\n    return this.accessor().reduce(fn, init);\n  }\n  forEach(fn) {\n    this.accessor().forEach(fn);\n  }\n  some(fn) {\n    return this.accessor().some(fn);\n  }\n  [iterator]() {\n    return this.accessor()[iterator]();\n  }\n  toString() {\n    return this.accessor().toString();\n  }\n}\n\n/**\n * @hidden\n *\n * Quick look-up structure for combinations of keys.\n * Similar to the native JS Set, however, working with a couple of keys instead of with a single key.\n * Supports both primitive keys and object keys (compared by reference).\n */\nclass PairSet {\n  /**\n   * Gets the total number of X/Y key pairs.\n   */\n  get size() {\n    return this.totalKeysCount;\n  }\n  /**\n   * Holds a set of Y keys for each defined X key.\n   * Each X key creates a map which holds a set of Y keys.\n   *\n   * Map { 1 => Set { 1, 2, 3 } } // pairs: [1, 1], [1, 2], [1, 3]\n   */\n\n  constructor(items, keyXField, keyYField) {\n    _defineProperty(this, \"keysX\", new Map());\n    /**\n     * Count the each added or deleted key manually to avoid iterating over all items when calling `this.size`.\n     */\n    _defineProperty(this, \"totalKeysCount\", 0);\n    if (items && keyXField && keyYField) {\n      items.forEach(item => this.add(item[keyXField], item[keyYField]));\n    }\n  }\n  /**\n   * Adds a couple of items identified as a combination.\n   */\n  add(keyX, keyY) {\n    if (!this.keysX.has(keyX)) {\n      this.keysX.set(keyX, new Set());\n    }\n    if (!this.has(keyX, keyY)) {\n      this.keysX.get(keyX).add(keyY);\n      this.totalKeysCount += 1;\n    }\n  }\n  /**\n   * Adds a combination of a couple of items identified together.\n   */\n  delete(keyX, keyY) {\n    if (this.has(keyX, keyY)) {\n      this.keysX.get(keyX).delete(keyY);\n      this.totalKeysCount -= 1;\n    }\n  }\n  /**\n   * Checks whether the defined combination is stored.\n   */\n  has(keyX, keyY) {\n    return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);\n  }\n  /**\n   * Clears all key combinations.\n   */\n  clear() {\n    this.keysX.clear();\n    this.totalKeysCount = 0;\n  }\n  /**\n   * Converts the persisted data structure to an array of objects,\n   * using the provided field names for the object props.\n   */\n  toArray(keyXField, keyYField) {\n    return Array.from(this.keysX).reduce((pairs, pair) => {\n      // Array.from(mapInstance) returns an array of arrays [[itemKey1, columnKeysSet1], [itemKey2, columnKeysSet2]]\n      const [keyX, keysY] = pair;\n      Array.from(keysY).forEach(keyY => pairs.push({\n        [keyXField]: keyX,\n        [keyYField]: keyY\n      }));\n      return pairs;\n    }, []);\n  }\n}\n\n/**\n * @hidden\n */\nlet Selection = /*#__PURE__*/(() => {\n  var _class181;\n  class Selection {\n    /**\n     * @hidden\n     */\n    get isCellSelectionMode() {\n      return isPresent(this.ctx.grid.selectable) && this.ctx.grid.selectable['cell'];\n    }\n    constructor(ctx, cd) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      /**\n       * Defines the collection that will store the selected item keys.\n       * @default []\n       */\n      _defineProperty(this, \"selectedKeys\", []);\n      /**\n       * Defines the initial shift-click range selection starting row index.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"rangeSelectionStartRow\", void 0);\n      /**\n       * Defines the initial shift-click range selection starting column index when cell selection is enabled.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"rangeSelectionStartColumnIndex\", 0);\n      /**\n       * Defines the item key that will be stored in the `selectedKeys` collection. [See example](slug:grid_selection_persistence#by-a-custom-key).\n       */\n      _defineProperty(this, \"selectionKey\", void 0);\n      /**\n       * Defines a function that determines the column key of a data cell.\n       *\n       * The function should return an unique value for each column.\n       * By default, the Grid uses the column index as a column key.\n       */\n      _defineProperty(this, \"columnKey\", void 0);\n      /**\n       * Fires when the `selectedKeys` collection has been updated.\n       */\n      _defineProperty(this, \"selectedKeysChange\", new EventEmitter());\n      _defineProperty(this, \"rowSelectionState\", new Set());\n      _defineProperty(this, \"cellSelectionState\", new PairSet());\n      _defineProperty(this, \"lastSelectionState\", void 0);\n      _defineProperty(this, \"selectionChangeSubscription\", void 0);\n      this.ctx = ctx;\n      this.cd = cd;\n      this.init();\n    }\n    ngOnChanges(changes) {\n      // skip reinitialization if the user data is the same as the last state change\n      if (isPresent(changes['selectedKeys']) && this.lastSelectionState !== this.selectedKeys) {\n        this.setState(this.selectedKeys);\n      }\n    }\n    init() {\n      if (!isPresent(this.ctx.grid.rowSelected)) {\n        this.ctx.grid.rowSelected = row => this.rowSelectionState.has(this.getItemKey(row));\n      }\n      if (!isPresent(this.ctx.grid.isRowSelectable)) {\n        this.ctx.grid.isRowSelectable = () => Boolean(this.ctx.grid.selectable);\n      }\n      if (!isPresent(this.ctx.grid.cellSelected)) {\n        this.ctx.grid.cellSelected = (row, column, colIndex) => {\n          const contender = this.getSelectionItem(row, column, colIndex);\n          return {\n            selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),\n            item: contender\n          };\n        };\n      }\n      this.selectionChangeSubscription = this.ctx.grid.selectionChange.subscribe(this.onSelectionChange.bind(this));\n    }\n    /**\n     * @hidden\n     */\n    destroy() {\n      this.selectionChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n      this.rowSelectionState.clear();\n      this.cellSelectionState.clear();\n    }\n    /**\n     * @hidden\n     */\n    getItemKey(row) {\n      if (this.selectionKey) {\n        if (typeof this.selectionKey === \"string\") {\n          return row.dataItem[this.selectionKey];\n        }\n        if (typeof this.selectionKey === \"function\") {\n          return this.selectionKey(row);\n        }\n      }\n      return row.index;\n    }\n    /**\n     * @hidden\n     */\n    stateToArray() {\n      return this.isCellSelectionMode ? this.cellSelectionState.toArray('itemKey', 'columnKey') : Array.from(this.rowSelectionState);\n    }\n    getSelectionItem(row, col, colIndex) {\n      const itemIdentifiers = {};\n      itemIdentifiers.itemKey = this.getItemKey(row);\n      if (!isPresent(col) && !isPresent(colIndex)) {\n        return itemIdentifiers;\n      }\n      if (this.columnKey) {\n        if (typeof this.columnKey === \"string\") {\n          itemIdentifiers.columnKey = row.dataItem[this.columnKey];\n        }\n        if (typeof this.columnKey === \"function\") {\n          itemIdentifiers.columnKey = this.columnKey(col, colIndex);\n        }\n      }\n      return {\n        itemKey: itemIdentifiers.itemKey,\n        columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex\n      };\n    }\n    onSelectionChange(selection) {\n      if (selection.selectedRows) {\n        selection.deselectedRows.forEach(item => {\n          const itemKey = this.getItemKey(item);\n          this.rowSelectionState.delete(itemKey);\n        });\n        if (this.ctx.grid.selectableSettings.mode === \"single\" && this.rowSelectionState.size > 0) {\n          this.reset();\n        }\n        selection.selectedRows.forEach(item => {\n          const itemKey = this.getItemKey(item);\n          this.rowSelectionState.add(itemKey);\n        });\n      } else {\n        selection.deselectedCells.forEach(({\n          itemKey,\n          columnKey\n        }) => {\n          this.cellSelectionState.delete(itemKey, columnKey);\n        });\n        if (this.ctx.grid.selectableSettings.mode === \"single\" && this.cellSelectionState.size > 0) {\n          this.reset();\n        }\n        selection.selectedCells.forEach(({\n          itemKey,\n          columnKey\n        }) => {\n          this.cellSelectionState.add(itemKey, columnKey);\n        });\n      }\n      this.cd.markForCheck();\n      this.notifyChange();\n    }\n    notifyChange() {\n      this.lastSelectionState = this.stateToArray();\n      this.selectedKeysChange.emit(this.lastSelectionState);\n    }\n    setState(selectedKeys) {\n      this.reset();\n      if (this.isCellSelectionMode) {\n        this.cellSelectionState = new PairSet(selectedKeys, 'itemKey', 'columnKey');\n      } else {\n        this.rowSelectionState = new Set(selectedKeys);\n      }\n    }\n  }\n  _class181 = Selection;\n  _defineProperty(Selection, \"\\u0275fac\", function _class181_Factory(t) {\n    return new (t || _class181)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(Selection, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class181,\n    selectors: [[\"kendo-grid-selection-base\"]],\n    inputs: {\n      selectedKeys: \"selectedKeys\",\n      rangeSelectionStartRow: \"rangeSelectionStartRow\",\n      rangeSelectionStartColumnIndex: \"rangeSelectionStartColumnIndex\",\n      selectionKey: [\"kendoGridSelectBy\", \"selectionKey\"],\n      columnKey: \"columnKey\"\n    },\n    outputs: {\n      selectedKeysChange: \"selectedKeysChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return Selection;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst set = value => pair => pair.forEach(x => x.style.height = value);\nconst clearHeight = pairs => pairs.filter(([left, right]) => left.style.height || right.style.height).forEach(set(\"\"));\nconst zip = (arr1, arr2) => {\n  const result = [];\n  for (let idx = 0, len = arr1.length; idx < len; idx++) {\n    if (!arr2[idx]) {\n      break;\n    }\n    result.push([arr1[idx], arr2[idx]]);\n  }\n  return result;\n};\nconst setHeight$1 = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);\nconst getHeights = rows => rows.map(([left, right]) => {\n  const height = left.offsetHeight;\n  const offsetHeight2 = right.offsetHeight;\n  if (height < offsetHeight2) {\n    return offsetHeight2;\n  }\n  return height;\n});\n/**\n * @hidden\n */\nconst syncRowsHeight = (table1, table2) => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  const activeElement = document.activeElement;\n  const rows = zip(table1.rows, table2.rows);\n  clearHeight(rows);\n  const heights = getHeights(rows);\n  [table1, table2].forEach(x => x.style.display = 'none');\n  rows.forEach(setHeight$1(heights));\n  [table1, table2].forEach(x => x.style.display = '');\n  if (document.activeElement !== activeElement && (table1.contains(activeElement) || table2.contains(activeElement))) {\n    activeElement.focus();\n  }\n};\n\n/**\n * Arguments for the `pdfExport` event.\n */\nclass PDFExportEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor() {\n    super();\n  }\n}\nconst bootstrapToMedia = media => ({\n  \"xs\": \"(max-width: 576px)\",\n  \"sm\": \"(min-width: 576px)\",\n  \"md\": \"(min-width: 768px)\",\n  \"lg\": \"(min-width: 992px)\",\n  \"xl\": \"(min-width: 1200px)\"\n})[media] || media;\nconst browserMatchMedia = media => window.matchMedia(media).matches;\n/**\n * @hidden\n */\nlet ResponsiveService = /*#__PURE__*/(() => {\n  var _class182;\n  class ResponsiveService {\n    constructor() {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"matchMedia\", browserMatchMedia);\n    }\n    /**\n     * @hidden\n     */\n    matchesMedia(media) {\n      return !media || this.matchMedia(bootstrapToMedia(media));\n    }\n  }\n  _class182 = ResponsiveService;\n  _defineProperty(ResponsiveService, \"\\u0275fac\", function _class182_Factory(t) {\n    return new (t || _class182)();\n  });\n  _defineProperty(ResponsiveService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class182,\n    factory: _class182.ɵfac\n  }));\n  return ResponsiveService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the toolbar template of the Grid.\n *\n * The template context has the following field:\n * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are `top`, `bottom`, and `both`.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\" style=\"height: 200px\">\n *    <ng-template kendoGridToolbarTemplate [position]=\"position\" let-position=\"position\">\n *       <button (click)=\"onClick()\">Custom action</button>\n *    </ng-template>\n *    <kendo-grid-column field=\"ProductName\">\n *    </kendo-grid-column>\n * </kendo-grid>\n * ```\n */\nlet ToolbarTemplateDirective = /*#__PURE__*/(() => {\n  var _class183;\n  class ToolbarTemplateDirective {\n    /**\n     * The position of the toolbar ([see example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).\n     *\n     * @default 'top'\n     */\n    set position(position) {\n      this._position = position;\n    }\n    get position() {\n      return this._position;\n    }\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      _defineProperty(this, \"_position\", 'top');\n      this.templateRef = templateRef;\n    }\n  }\n  _class183 = ToolbarTemplateDirective;\n  _defineProperty(ToolbarTemplateDirective, \"\\u0275fac\", function _class183_Factory(t) {\n    return new (t || _class183)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(ToolbarTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class183,\n    selectors: [[\"\", \"kendoGridToolbarTemplate\", \"\"]],\n    inputs: {\n      position: \"position\"\n    },\n    standalone: true\n  }));\n  return ToolbarTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass NavigationMetadata {\n  get maxLogicalRowIndex() {\n    const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;\n    return this.headerRows + dataRows - 1;\n  }\n  constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {\n    _defineProperty(this, \"dataRows\", void 0);\n    _defineProperty(this, \"headerRows\", void 0);\n    _defineProperty(this, \"isVirtual\", void 0);\n    _defineProperty(this, \"hasPager\", void 0);\n    _defineProperty(this, \"hasDetailTemplate\", void 0);\n    _defineProperty(this, \"gridElement\", void 0);\n    _defineProperty(this, \"virtualColumns\", void 0);\n    _defineProperty(this, \"columns\", void 0);\n    this.dataRows = dataRows;\n    this.headerRows = headerRows;\n    this.isVirtual = isVirtual;\n    this.hasPager = hasPager;\n    this.hasDetailTemplate = hasDetailTemplate;\n    this.gridElement = gridElement;\n    this.virtualColumns = virtualColumns;\n    this.columns = columns;\n  }\n}\n\n/**\n * Arguments for the `columnVisibilityChange` event.\n */\nclass ColumnVisibilityChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    /**\n     * The columns whose visibility is changed.\n     */\n    _defineProperty(this, \"columns\", void 0);\n    this.columns = columns;\n  }\n}\n\n/**\n * Arguments for the `columnLockedChange` event.\n */\nclass ColumnLockedChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    /**\n     * The columns whose locked state is changed.\n     */\n    _defineProperty(this, \"columns\", void 0);\n    this.columns = columns;\n  }\n}\n\n/**\n * @hidden\n */\nconst GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!\n/**\n * @hidden\n */\nconst RESPONSIVE_BREAKPOINT_MEDIUM = 600;\n/**\n * @hidden\n */\nconst RESPONSIVE_BREAKPOINT_LARGE = 768;\n\n/**\n * Arguments for the `columnStickyChange` event.\n */\nclass ColumnStickyChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    /**\n     * The columns whose sticky state is changed.\n     */\n    _defineProperty(this, \"columns\", void 0);\n    this.columns = columns;\n  }\n}\n\n/**\n * @hidden\n */\nconst isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;\n/**\n * @hidden\n */\nconst isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;\n/**\n * @hidden\n */\nconst isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;\n/**\n * @hidden\n */\nfunction getOffset(element) {\n  const {\n    clientTop,\n    clientLeft\n  } = getDocument(element);\n  const {\n    pageYOffset,\n    pageXOffset\n  } = getWindow(element);\n  const {\n    top,\n    left\n  } = element.getBoundingClientRect();\n  return {\n    top: top + pageYOffset - clientTop,\n    left: left + pageXOffset - clientLeft\n  };\n}\n/**\n * @hidden\n */\nconst hintIcons = {\n  forbidden: 'cancel',\n  before: 'insert-middle',\n  after: 'insert-middle'\n};\n/**\n * @hidden\n */\nconst hintSVGIcons = {\n  forbidden: cancelIcon,\n  before: insertMiddleIcon,\n  after: insertMiddleIcon\n};\n/**\n * @hidden\n */\nconst dropPosition = {\n  forbidden: 'forbidden',\n  before: 'before',\n  after: 'after'\n};\n/**\n * @hidden\n */\nconst hintStyles = {\n  zIndex: '20000',\n  display: 'flex',\n  position: 'fixed'\n};\n/**\n * @hidden\n */\nconst hintClasses = ['k-drag-clue', 'k-reorder-clue'];\n/**\n * @hidden\n */\nconst dropIndicatorStyles = {\n  zIndex: '19000',\n  position: 'absolute'\n};\n/**\n * @hidden\n */\nconst dropIndicatorClasses = ['k-drop-hint', 'k-drop-hint-h'];\n/**\n * @hidden\n */\nconst defaultSelectors = {\n  handle: '.k-table-td.k-drag-cell',\n  dragTarget: '.k-master-row',\n  dropTarget: '.k-master-row'\n};\nconst getDocument = element => element?.ownerDocument.documentElement;\nconst getWindow = element => element?.ownerDocument.defaultView;\n\n/**\n * @hidden\n */\nlet RowReorderService = /*#__PURE__*/(() => {\n  var _class188;\n  class RowReorderService {\n    constructor(renderer) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hintElement\", null);\n      _defineProperty(this, \"defaultSelectors\", defaultSelectors);\n      _defineProperty(this, \"hintText\", '');\n      _defineProperty(this, \"skip\", void 0);\n      _defineProperty(this, \"dropIndicator\", void 0);\n      _defineProperty(this, \"lastDropPosition\", dropPosition.forbidden);\n      _defineProperty(this, \"dragTarget\", null);\n      _defineProperty(this, \"dropTarget\", null);\n      _defineProperty(this, \"offsetY\", void 0);\n      _defineProperty(this, \"rowReorder\", new EventEmitter());\n      this.renderer = renderer;\n    }\n    press(ev) {\n      this.dragTarget = ev.dragTarget;\n      this.offsetY = ev.dragEvent.offsetY;\n    }\n    dragStart() {\n      this.createDropIndicator();\n    }\n    drag(ev) {\n      if (isPresent$1(ev.hintElement) && !isPresent$1(this.hintElement)) {\n        this.hintElement = ev.hintElement;\n        this.decorateHint();\n      }\n      const position = {\n        x: ev.dragEvent.clientX,\n        y: ev.dragEvent.clientY - this.offsetY\n      };\n      if (isPresent$1(this.hintElement)) {\n        this.renderer.setStyle(this.hintElement, 'left', `${position.x}px`);\n        this.renderer.setStyle(this.hintElement, 'top', `${position.y}px`);\n      }\n      this.positionDropIndicator(ev);\n    }\n    dragEnter(ev) {\n      this.dropTarget = ev.dropTarget;\n    }\n    dragLeave() {\n      this.dropTarget = null;\n      this.hide();\n    }\n    dragEnd() {\n      this.destroyDropIndicator();\n      this.dragTarget = null;\n      this.dropTarget = null;\n      this.hintElement = null;\n    }\n    drop(ev) {\n      this.destroyDropIndicator();\n      const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);\n      this.rowReorder.emit(rowReorderArgs);\n    }\n    reorderRows(ev, collection) {\n      if (this.lastDropPosition === dropPosition.forbidden) {\n        return;\n      }\n      const {\n        draggedRows,\n        dropTargetRow\n      } = ev;\n      const draggedDataItem = draggedRows[0].dataItem;\n      const dropTargetDataItem = dropTargetRow.dataItem;\n      const draggedItemIndex = collection.indexOf(draggedDataItem);\n      const dropTargetIndex = collection.indexOf(dropTargetDataItem);\n      const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);\n      collection.splice(draggedItemIndex, 1);\n      collection.splice(idxToAdd, 0, draggedDataItem);\n    }\n    get hintIcon() {\n      return hintIcons[this.lastDropPosition];\n    }\n    get hintSVGIcon() {\n      return hintSVGIcons[this.lastDropPosition];\n    }\n    getDefaultHintText(columns, data) {\n      let hintText = '';\n      const columnFieldsArray = columns.toArray().filter(column => !column.hidden && isPresent$1(column.field)).map(column => column.field);\n      const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);\n      const draggedDataItem = draggedDragRow?.dataItem;\n      isPresent$1(draggedDataItem) && columnFieldsArray.forEach(column => {\n        const columnValue = draggedDataItem[column];\n        isPresent$1(columnValue) ? hintText += `${columnValue} ` : null;\n      });\n      return hintText.trim();\n    }\n    getDraggedRow(data) {\n      return this.getDragRowPerElement(this.dragTarget, data);\n    }\n    rowReorderArgs(dragRow, dropRow, data) {\n      const dragRowData = this.getDragRowPerElement(dragRow, data);\n      const dropRowData = this.getDragRowPerElement(dropRow, data);\n      return {\n        draggedRows: [dragRowData],\n        dropTargetRow: dropRowData,\n        dropPosition: this.lastDropPosition\n      };\n    }\n    getDragRowPerElement(row, data) {\n      let rowIndex = row?.getAttribute('data-kendo-grid-item-index');\n      rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;\n      const skip = this.skip || 0;\n      const dataItem = rowIndex === -1 ? null : data[rowIndex - skip];\n      return {\n        dataItem,\n        rowIndex,\n        element: row\n      };\n    }\n    createDropIndicator() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.dropIndicator = document.createElement('div');\n      this.decorateDropIndicator();\n      this.dropIndicator.innerHTML = `\n            <div class=\"k-drop-hint-start\"></div>\n            <div class=\"k-drop-hint-line\"></div>\n        `;\n      document.body.appendChild(this.dropIndicator);\n      this.hide();\n    }\n    destroyDropIndicator() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.dropIndicator && this.dropIndicator.parentElement) {\n        document.body.removeChild(this.dropIndicator);\n        this.dropIndicator = null;\n      }\n    }\n    decorateHint() {\n      hintClasses.forEach(className => this.renderer.addClass(this.hintElement, className));\n      Object.keys(hintStyles).forEach(style => this.renderer.setStyle(this.hintElement, style, hintStyles[style]));\n    }\n    positionDropIndicator(ev) {\n      this.lastDropPosition = this.getDropPosition(ev.dragEvent);\n      this.updateDropIndicatorPosition();\n    }\n    calculateIndexToAdd(dragIndex, dropIndex) {\n      if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {\n        return dropIndex + 1;\n      } else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {\n        return dropIndex;\n      } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {\n        return dropIndex;\n      } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {\n        return dropIndex - 1;\n      }\n    }\n    decorateDropIndicator() {\n      dropIndicatorClasses.forEach(className => this.renderer.addClass(this.dropIndicator, className));\n      Object.keys(dropIndicatorStyles).forEach(style => this.renderer.setStyle(this.dropIndicator, style, dropIndicatorStyles[style]));\n    }\n    getDropPosition(e) {\n      if (this.dropTarget === this.dragTarget || !isPresent$1(this.dropTarget)) {\n        return dropPosition.forbidden;\n      }\n      if (isDifferentParent(this.dropTarget, this.dragTarget)) {\n        return dropPosition.forbidden;\n      }\n      const itemViewPortCoords = this.dropTarget.getBoundingClientRect();\n      const itemDivisionsCount = 2;\n      const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;\n      const pointerPosition = e.clientY;\n      const itemTop = itemViewPortCoords.top;\n      let currentDropPosition = null;\n      if (pointerPosition < itemTop + itemDivisionHeight) {\n        currentDropPosition = dropPosition.before;\n      } else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {\n        currentDropPosition = dropPosition.after;\n      }\n      if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {\n        currentDropPosition = dropPosition.forbidden;\n      } else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {\n        currentDropPosition = dropPosition.forbidden;\n      }\n      return currentDropPosition;\n    }\n    updateDropIndicatorPosition() {\n      if (this.shouldHideDropIndicator() || !this.dropTarget) {\n        this.hide();\n        return;\n      }\n      this.show();\n      const destinationItemOffset = getOffset(this.dropTarget);\n      let indicatorOffsetTop = destinationItemOffset.top;\n      const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;\n      if (this.lastDropPosition === dropPosition.after) {\n        indicatorOffsetTop += this.dropTarget.offsetHeight;\n      }\n      this.renderer.setStyle(this.dropIndicator, 'left', `${indicatorOffsetLeft}px`);\n      this.renderer.setStyle(this.dropIndicator, 'top', `${indicatorOffsetTop}px`);\n    }\n    shouldHideDropIndicator() {\n      return this.lastDropPosition === dropPosition.forbidden;\n    }\n    hide() {\n      if (isPresent$1(this.dropIndicator)) {\n        this.dropIndicator.style.display = 'none';\n      }\n    }\n    show() {\n      if (isPresent$1(this.dropIndicator)) {\n        this.dropIndicator.style.display = '';\n      }\n    }\n  }\n  _class188 = RowReorderService;\n  _defineProperty(RowReorderService, \"\\u0275fac\", function _class188_Factory(t) {\n    return new (t || _class188)(i0.ɵɵinject(i0.Renderer2));\n  });\n  _defineProperty(RowReorderService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class188,\n    factory: _class188.ɵfac\n  }));\n  return RowReorderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the status bar template of the Grid. Allows you to visualize the aggregates using custom rendering inside the template.\n * The template context has the following field:\n * - `aggregates`&mdash;The [SelectionAggregates]({% slug api_grid_selectionaggregates %}) object that contains all calculated aggregates.\n * Use the Angular [ngFor](link:site.data.urls.angular['ngfor']) structural directive combined with the [KeyValuePipe](https://angular.io/api/common/KeyValuePipe)\n * to loop through the aggregates as key-value pairs.\n */\nlet StatusBarTemplateDirective = /*#__PURE__*/(() => {\n  var _class189;\n  class StatusBarTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class189 = StatusBarTemplateDirective;\n  _defineProperty(StatusBarTemplateDirective, \"\\u0275fac\", function _class189_Factory(t) {\n    return new (t || _class189)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(StatusBarTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class189,\n    selectors: [[\"\", \"kendoGridStatusBarTemplate\", \"\"]],\n    standalone: true\n  }));\n  return StatusBarTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ClipboardService = /*#__PURE__*/(() => {\n  var _class190;\n  class ClipboardService {\n    constructor(contextService) {\n      _defineProperty(this, \"contextService\", void 0);\n      _defineProperty(this, \"targetColField\", void 0);\n      _defineProperty(this, \"targetRowIndex\", void 0);\n      _defineProperty(this, \"itemToString\", (item, cols) => {\n        if (!cols.length) {\n          return null;\n        }\n        return cols.map(col => item[col.field]).join(`\\t`);\n      });\n      this.contextService = contextService;\n    }\n    createClipboardData(data, columns, options) {\n      let result = {\n        gridItems: [],\n        dataString: ''\n      };\n      const fieldCols = columns.flatMap(c => c instanceof ColumnComponent && isPresent$1(c.field) ? [c] : []);\n      const clipboardData = {\n        items: [],\n        dataStrings: []\n      };\n      const colFields = fieldCols.map(c => c.field);\n      if (options.wholeRow) {\n        this.targetColField = fieldCols[0]?.field;\n        this.targetRowIndex = data[0].dataRowIndex;\n        data.forEach(item => {\n          clipboardData.items.push({\n            dataItem: {\n              ...item.dataItem\n            },\n            fields: colFields\n          });\n          clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));\n        });\n        result = {\n          gridItems: options.operationType === 'cut' ? clipboardData.items.map(item => {\n            item.fields.forEach(field => item.dataItem[field] = null);\n            return item;\n          }) : [...clipboardData.items],\n          dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\\r\\n`), fieldCols) : clipboardData.dataStrings.join(`\\n`)\n        };\n      } else {\n        if (options.target === 'selection') {\n          const {\n            tabular,\n            groups\n          } = this.groupSelection();\n          const selectionDirective = this.contextService.grid.selectionDirective;\n          const colIdentifier = selectionDirective.columnKey;\n          if (tabular) {\n            const selectionKeys = groups[0].items.map(item => item.columnKey);\n            const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent && c.field && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);\n            const selectedColFields = selectedFieldCols.map(c => c.field);\n            this.targetColField = selectedColFields[0];\n            result.dataString = data.flatMap(item => {\n              const itemString = this.itemToString(item.dataItem, selectedFieldCols);\n              const existingItem = isPresent$1(itemString);\n              if (!isPresent$1(this.targetRowIndex) && isPresent$1(itemString)) {\n                this.targetRowIndex = item.dataRowIndex;\n              }\n              if (options.operationType === 'cut') {\n                selectedColFields.forEach(f => item.dataItem[f] = null);\n              }\n              result.gridItems.push({\n                dataItem: item.dataItem,\n                fields: selectedColFields\n              });\n              return existingItem ? [itemString] : [];\n            }).join(`\\r\\n`);\n            if (options.copyHeaders) {\n              result.dataString = this.addHeaders(result.dataString, selectedFieldCols);\n            }\n          } else {\n            // split per row (uneven rows)\n            const rowIdentifier = selectionDirective.selectionKey;\n            result.dataString = data.flatMap(item => {\n              // determine cols per item\n              const key = rowIdentifier ? typeof rowIdentifier === 'string' ? item.dataItem[rowIdentifier] : rowIdentifier({\n                index: item.dataRowIndex,\n                dataItem: item.dataItem\n              }) : item.dataRowIndex;\n              const selectionKeys = groups.find(gr => gr.value === key).items.map(item => item.columnKey);\n              const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent && c.field && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);\n              const selectedColFields = selectedFieldCols.map(c => c.field);\n              if (!this.targetColField) {\n                this.targetColField = selectedColFields[0];\n              }\n              const itemString = this.itemToString(item.dataItem, selectedFieldCols);\n              const existingItem = isPresent$1(itemString);\n              if (!isPresent$1(this.targetRowIndex) && existingItem) {\n                this.targetRowIndex = item.dataRowIndex;\n              }\n              if (existingItem) {\n                if (options.operationType === 'cut') {\n                  selectedColFields.forEach(f => item.dataItem[f] = null);\n                }\n                result.gridItems.push({\n                  dataItem: item.dataItem,\n                  fields: selectedColFields\n                });\n              }\n              return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];\n            }).join(`\\r\\n`);\n          }\n        } else {\n          const item = data[0];\n          const col = columns[item.colIndex];\n          const colField = col.field;\n          const title = col.title;\n          const copiedData = item.dataItem[colField];\n          this.targetRowIndex = item.dataRowIndex;\n          this.targetColField = colField;\n          if (options.operationType === 'cut' && colField) {\n            item.dataItem[colField] = null;\n          }\n          result = {\n            gridItems: [{\n              dataItem: item.dataItem,\n              fields: colField ? [colField] : []\n            }],\n            dataString: options.copyHeaders ? [title || colField, copiedData].join(`\\r\\n`) : colField ? copiedData : ``\n          };\n        }\n      }\n      return result;\n    }\n    getGridData(data, columns, targetType, targetRowIndex, options) {\n      const separator = data.includes(`\\r\\n`) ? `\\r\\n` : data.includes(`\\n`) ? `\\n` : null;\n      const dataRows = separator ? data.split(separator).filter(rowData => rowData.length) : [data];\n      this.targetRowIndex = targetRowIndex;\n      if (targetType === 'activeCell') {\n        if (options.wholeRow) {\n          this.targetColField = columns.find(c => c instanceof ColumnComponent && c.field)?.field;\n        } else {\n          const activeCellIndex = this.contextService.grid.activeCell.colIndex;\n          for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (col instanceof ColumnComponent && col.field && i >= activeCellIndex) {\n              this.targetColField = col.field;\n              break;\n            }\n          }\n        }\n      } else {\n        if (options.wholeRow || !options.isCellSelection) {\n          this.targetColField = columns.filter(c => c instanceof ColumnComponent && c.field)[0]['field'];\n        } else {\n          const {\n            groups\n          } = this.groupSelection();\n          const selectionDirective = this.contextService.grid.selectionDirective;\n          const colIdentifier = selectionDirective.columnKey;\n          const visibleCols = columns.filter(c => c.isVisible);\n          const selectionKeys = groups[0].items.map(item => item.columnKey);\n          const selectedFieldCols = visibleCols.flatMap((c, i) => c instanceof ColumnComponent && c.field && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);\n          const selectedColFields = selectedFieldCols.map(c => c.field);\n          this.targetColField = selectedColFields[0];\n        }\n      }\n      const items = dataRows.map(rowString => {\n        const cells = rowString.includes(`\\t`) ? rowString.split(`\\t`) : [rowString];\n        const colFields = columns.flatMap(c => c instanceof ColumnComponent && c.field ? [c.field] : []);\n        const targetColFieldIndex = colFields.indexOf(this.targetColField);\n        const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);\n        const item = {};\n        colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);\n        return {\n          dataItem: item,\n          fields: affectedFields\n        };\n      });\n      return items;\n    }\n    groupSelection() {\n      const selection = this.contextService.grid.selection;\n      const groups = groupBy(selection, [{\n        field: 'itemKey'\n      }]).map(gr => {\n        gr.items.sort((a, b) => a.columnKey - b.columnKey);\n        return gr;\n      });\n      for (let i = 1; i < groups.length; i++) {\n        if (!this.areEqual(groups[i].items, groups[i - 1].items)) {\n          return {\n            tabular: false,\n            groups\n          };\n        }\n      }\n      return {\n        tabular: true,\n        groups\n      };\n    }\n    areEqual(arr1, arr2) {\n      if (arr1.length !== arr2.length) {\n        return false;\n      }\n      for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i].columnKey !== arr2[i].columnKey) {\n          return false;\n        }\n      }\n      return true;\n    }\n    addHeaders(initialData, cols) {\n      const headersRowData = cols.map(c => c.title || c.field).join(`\\t`);\n      return `${headersRowData}\\r\\n${initialData}`;\n    }\n  }\n  _class190 = ClipboardService;\n  _defineProperty(ClipboardService, \"\\u0275fac\", function _class190_Factory(t) {\n    return new (t || _class190)(i0.ɵɵinject(ContextService));\n  });\n  _defineProperty(ClipboardService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class190,\n    factory: _class190.ɵfac\n  }));\n  return ClipboardService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet StatusBarComponent = /*#__PURE__*/(() => {\n  var _class191;\n  class StatusBarComponent {\n    get isStatusBarTemplate() {\n      return this.statusBarTemplate ? '' : 'none';\n    }\n    constructor(aggregateService) {\n      _defineProperty(this, \"aggregateService\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"statusBarTemplate\", void 0);\n      this.aggregateService = aggregateService;\n    }\n    ngOnInit() {\n      this.aggregateService.init();\n    }\n    get aggregates() {\n      return this.aggregateService.aggregates;\n    }\n  }\n  _class191 = StatusBarComponent;\n  _defineProperty(StatusBarComponent, \"\\u0275fac\", function _class191_Factory(t) {\n    return new (t || _class191)(i0.ɵɵdirectiveInject(CellSelectionAggregateService));\n  });\n  _defineProperty(StatusBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class191,\n    selectors: [[\"kendo-grid-status-bar\"]],\n    hostVars: 6,\n    hostBindings: function _class191_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.isStatusBarTemplate);\n        i0.ɵɵclassProp(\"k-selection-aggregates\", ctx.hostClasses)(\"k-grid-selection-aggregates\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      statusBarTemplate: \"statusBarTemplate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class191_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class191_0_Template, 1, 4, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.statusBarTemplate);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return StatusBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst createElement = () => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  const marquee = document.createElement(\"div\");\n  marquee.className = \"k-marquee\";\n  const marqueeColor = document.createElement(\"div\");\n  marqueeColor.className = \"k-marquee-color\";\n  marquee.appendChild(marqueeColor);\n  return marquee;\n};\nconst POINTER_OFFSET = 2;\nconst MINIMAL_DRAG_DISTANCE = 5;\nconst offsets = {\n  topLeft: {\n    x: POINTER_OFFSET,\n    y: POINTER_OFFSET\n  },\n  topRight: {\n    x: -POINTER_OFFSET,\n    y: POINTER_OFFSET\n  },\n  bottomLeft: {\n    x: POINTER_OFFSET,\n    y: -POINTER_OFFSET\n  },\n  bottomRight: {\n    x: -POINTER_OFFSET,\n    y: -POINTER_OFFSET\n  }\n};\n/**\n * @hidden\n */\nlet GridMarqueeDirective = /*#__PURE__*/(() => {\n  var _class192;\n  class GridMarqueeDirective {\n    constructor(draggable, selection, cellSelection, domEvents, host, renderer) {\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"selection\", void 0);\n      _defineProperty(this, \"cellSelection\", void 0);\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      // possibly add snap\n      _defineProperty(this, \"pressArgs\", void 0);\n      _defineProperty(this, \"marqueeElement\", void 0);\n      _defineProperty(this, \"pressTarget\", void 0);\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"selectionStarted\", false);\n      _defineProperty(this, \"dragEndSubscription\", void 0);\n      this.draggable = draggable;\n      this.selection = selection;\n      this.cellSelection = cellSelection;\n      this.domEvents = domEvents;\n      this.host = host;\n      this.renderer = renderer;\n    }\n    ngOnInit() {\n      this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));\n      this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.clean();\n    }\n    start(args) {\n      const isInvalidTarget = args.originalEvent.target.matches('.k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox');\n      const isRowReorderColumn = isPresent$1(args.originalEvent.target.closest('.k-drag-cell'));\n      if (isInvalidTarget || isRowReorderColumn) {\n        this.pressArgs = null;\n        return;\n      }\n      this.pressArgs = args;\n      this.pressTarget = null;\n    }\n    moveMarquee(args) {\n      if (!this.pressTarget) {\n        this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;\n      }\n      const press = this.pressArgs;\n      if (!press) {\n        return;\n      }\n      if (!this.selectionStarted) {\n        const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);\n        if (distance > MINIMAL_DRAG_DISTANCE) {\n          this.selectionStarted = true;\n          this.renderer.addClass(this.host.nativeElement, 'user-select-none');\n          this.renderer.setStyle(this.host.nativeElement, 'user-select', 'none');\n          this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1))).subscribe(this.endSelection.bind(this));\n        } else {\n          return;\n        }\n      }\n      this.initMarquee();\n      const element = this.marqueeElement;\n      const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);\n      let left = Math.min(args.pageX, press.pageX);\n      let top = Math.min(args.pageY, press.pageY);\n      const width = Math.abs(args.pageX - press.pageX);\n      const height = Math.abs(args.pageY - press.pageY);\n      if (marqueeQuadrant) {\n        left += offsets[marqueeQuadrant].x;\n        top += offsets[marqueeQuadrant].y;\n      }\n      element.style.left = `${left}px`;\n      element.style.top = `${top}px`;\n      element.style.width = `${width}px`;\n      element.style.height = `${height}px`;\n    }\n    endSelection(args) {\n      if (args.type === 'mouseup' || args.type === 'touchend') {\n        if (this.cellSelection.active) {\n          this.cellSelection.dragging = true;\n          this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex));\n        } else if (this.selection.active) {\n          this.selection.dragging = true;\n          this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex));\n        }\n      }\n      this.clean();\n    }\n    clean() {\n      if (this.marqueeElement) {\n        document.body.removeChild(this.marqueeElement);\n        this.marqueeElement = null;\n      }\n      if (this.dragEndSubscription) {\n        this.dragEndSubscription.unsubscribe();\n      }\n      this.renderer.removeClass(this.host.nativeElement, 'user-select-none');\n      this.renderer.removeStyle(this.host.nativeElement, 'user-select');\n      this.dragEndSubscription = null;\n      this.pressTarget = null;\n      this.pressArgs = null;\n      this.selectionStarted = false;\n      // eslint-disable-next-line no-unused-expressions\n      this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;\n    }\n    initMarquee() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (!this.marqueeElement) {\n        this.marqueeElement = createElement();\n        document.body.appendChild(this.marqueeElement);\n      }\n    }\n    getMarqueeQuadrant(pointerX, pointerY, startX, startY) {\n      const leftHalf = pointerX < startX;\n      const rightHalf = pointerX > startX;\n      const topHalf = pointerY < startY;\n      const bottomHalf = pointerY > startY;\n      if (leftHalf && topHalf) {\n        return 'topLeft';\n      }\n      if (leftHalf && bottomHalf) {\n        return 'bottomLeft';\n      }\n      if (rightHalf && topHalf) {\n        return 'topRight';\n      }\n      if (rightHalf && bottomHalf) {\n        return 'bottomRight';\n      }\n      return null;\n    }\n  }\n  _class192 = GridMarqueeDirective;\n  _defineProperty(GridMarqueeDirective, \"\\u0275fac\", function _class192_Factory(t) {\n    return new (t || _class192)(i0.ɵɵdirectiveInject(i1$3.DraggableDirective), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(DomEventsService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(GridMarqueeDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class192,\n    selectors: [[\"\", \"kendoGridSelectionMarquee\", \"\"]],\n    standalone: true\n  }));\n  return GridMarqueeDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst update = (arr, idx, value) => [...arr.slice(0, idx + 1), ...arr.slice(idx + 1).map(x => x + value)];\n/**\n * @hidden\n */\nclass RowHeightService {\n  constructor(total = 0, rowHeight, detailRowHeight) {\n    _defineProperty(this, \"total\", void 0);\n    _defineProperty(this, \"rowHeight\", void 0);\n    _defineProperty(this, \"detailRowHeight\", void 0);\n    _defineProperty(this, \"offsets\", []);\n    _defineProperty(this, \"heights\", []);\n    this.total = total;\n    this.rowHeight = rowHeight;\n    this.detailRowHeight = detailRowHeight;\n    let agg = 0;\n    for (let idx = 0; idx < total; idx++) {\n      this.offsets.push(agg);\n      agg += rowHeight;\n      this.heights.push(rowHeight);\n    }\n  }\n  height(rowIndex) {\n    return this.heights[rowIndex];\n  }\n  expandDetail(rowIndex) {\n    if (this.height(rowIndex) === this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight);\n    }\n  }\n  collapseDetail(rowIndex) {\n    if (this.height(rowIndex) > this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n    }\n  }\n  isExpanded(rowIndex) {\n    return this.height(rowIndex) > this.rowHeight;\n  }\n  index(position) {\n    if (position < 0) {\n      return undefined;\n    }\n    const result = this.offsets.reduce((prev, current, idx) => {\n      if (prev !== undefined) {\n        return prev;\n      } else if (current === position) {\n        return idx;\n      } else if (current > position) {\n        return idx - 1;\n      }\n      return undefined;\n    }, undefined);\n    return result === undefined ? this.total - 1 : result;\n  }\n  offset(rowIndex, adjustIndex = false) {\n    if (adjustIndex) {\n      let targetOffset = 0;\n      let targetIndex = 0;\n      for (let i = 0; i < rowIndex; i++) {\n        targetOffset += this.rowHeight;\n        targetIndex++;\n        if (targetIndex === rowIndex) {\n          return targetOffset;\n        }\n        if (this.isExpanded(i)) {\n          targetOffset += this.detailRowHeight;\n          targetIndex++;\n          if (targetIndex === rowIndex) {\n            return targetOffset;\n          }\n        }\n      }\n      return targetOffset;\n    }\n    return this.offsets[rowIndex];\n  }\n  totalHeight() {\n    return this.heights.reduce((prev, curr) => prev + curr, 0);\n  }\n  updateRowHeight(rowIndex, value) {\n    if (this.total > 0) {\n      this.heights[rowIndex] += value;\n      this.offsets = update(this.offsets, rowIndex, value);\n    }\n  }\n}\n\n/**\n * @hidden\n */\nclass ScrollAction {\n  constructor(offset) {\n    _defineProperty(this, \"offset\", void 0);\n    this.offset = offset;\n  }\n}\n/**\n * @hidden\n */\nclass PageAction {\n  constructor(skip, take) {\n    _defineProperty(this, \"skip\", void 0);\n    _defineProperty(this, \"take\", void 0);\n    this.skip = skip;\n    this.take = take;\n  }\n}\n/**\n * @hidden\n */\nclass ScrollBottomAction {}\nconst SCROLL_BOTTOM_THRESHOLD = 2;\n/**\n * @hidden\n */\nclass ScrollerService {\n  constructor(scrollObservable) {\n    _defineProperty(this, \"scrollObservable\", void 0);\n    _defineProperty(this, \"firstLoaded\", 0);\n    _defineProperty(this, \"lastLoaded\", void 0);\n    _defineProperty(this, \"lastScrollTop\", void 0);\n    _defineProperty(this, \"take\", void 0);\n    _defineProperty(this, \"total\", void 0);\n    _defineProperty(this, \"rowHeightService\", void 0);\n    _defineProperty(this, \"scrollSubscription\", void 0);\n    _defineProperty(this, \"subscription\", void 0);\n    this.scrollObservable = scrollObservable;\n  }\n  create(rowHeightService, skip, take, total) {\n    this.rowHeightService = rowHeightService;\n    this.firstLoaded = skip;\n    this.lastLoaded = skip + take;\n    this.take = take;\n    this.total = total;\n    this.lastScrollTop = 0;\n    const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));\n    this.subscription = Observable.create(observer => {\n      this.unsubscribe();\n      this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n    }).subscribe(x => subject.next(x));\n    return subject;\n  }\n  destroy() {\n    this.unsubscribe();\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n  onScroll({\n    scrollTop,\n    offsetHeight,\n    scrollHeight,\n    clientHeight\n  }, observer) {\n    if (!isDocumentAvailable() || this.lastScrollTop === scrollTop) {\n      return;\n    }\n    const up = this.lastScrollTop >= scrollTop;\n    this.lastScrollTop = scrollTop;\n    let firstItemIndex = this.rowHeightService.index(scrollTop);\n    let firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n    const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);\n    if (!up) {\n      if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n        const overflow = firstItemIndex + this.take - this.total;\n        if (overflow > 0) {\n          firstItemIndex = firstItemIndex - overflow;\n          firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n        }\n        this.firstLoaded = firstItemIndex;\n        observer.next(new ScrollAction(firstItemOffset));\n        let nextTake = this.firstLoaded + this.take;\n        this.lastLoaded = Math.min(nextTake, this.total);\n        nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;\n        observer.next(new PageAction(this.firstLoaded, this.take));\n      } else {\n        const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;\n        if (atBottom) {\n          observer.next(new ScrollBottomAction());\n        }\n      }\n    }\n    if (up && firstItemIndex < this.firstLoaded) {\n      const nonVisibleBuffer = Math.floor(this.take * 0.3);\n      this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);\n      observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded, this.take));\n    }\n  }\n  unsubscribe() {\n    if (this.scrollSubscription) {\n      this.scrollSubscription.unsubscribe();\n      this.scrollSubscription = undefined;\n    }\n  }\n}\n\n/**\n * @hidden\n */\nconst columnsToResize = ({\n  columns\n}) => Math.max(1, resizableColumns(columns).filter(c => !c.isColumnGroup).length);\n/**\n * @hidden\n */\nconst row = selector => element => element.querySelector(selector);\n/**\n * @hidden\n */\nconst headerRow = index => element => element.querySelectorAll('thead>tr')[index];\n/**\n * @hidden\n */\nconst cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];\n/**\n * @hidden\n */\nconst offsetWidth = element => element.offsetWidth;\n/**\n * @hidden\n */\nconst pipe = (...fns) => data => fns.reduce((state, fn) => state ? fn(state) : 0, data);\n/**\n * @hidden\n */\nlet TableDirective = /*#__PURE__*/(() => {\n  var _class197;\n  class TableDirective {\n    get minWidth() {\n      return this.firstResize ? 0 : null;\n    }\n    constructor(element, renderer, service, zone, cdr, ctx) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"locked\", false);\n      _defineProperty(this, \"virtualColumns\", void 0);\n      _defineProperty(this, \"firstResize\", false);\n      _defineProperty(this, \"subscription\", void 0);\n      _defineProperty(this, \"autoFitSubscription\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.service = service;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.ctx = ctx;\n    }\n    ngOnInit() {\n      const obs = this.service.changes.pipe(filter(e => this.locked === e.locked));\n      this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap(take => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take)))).subscribe(this.resize.bind(this));\n      this.autoFitSubscription = this.service.registerTable({\n        autoFit: this.autoFitObservable.bind(this),\n        locked: this.locked\n      });\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      if (this.autoFitSubscription) {\n        this.autoFitSubscription();\n        this.autoFitSubscription = null;\n      }\n    }\n    initState() {\n      this.firstResize = true;\n      const constrainedWithVirtualColumns = this.ctx.grid?.resizable === 'constrained' && this.virtualColumns;\n      if (!this.virtualColumns || this.locked || constrainedWithVirtualColumns) {\n        this.service.originalWidth = offsetWidth(this.element.nativeElement);\n      }\n    }\n    resize(deltas) {\n      const constrainedModeNoShift = this.ctx.grid?.resizable === 'constrained' && !this.service.isShiftPressed;\n      const unconstrainedModeShift = (this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === 'unconstrained') && this.service.isShiftPressed;\n      const isConstrainedMode = constrainedModeNoShift || unconstrainedModeShift;\n      if (isConstrainedMode && !this.service.autoFitResize) {\n        this.renderer.setStyle(this.element.nativeElement, 'width', this.service.originalWidth + 'px');\n      } else {\n        if (!this.virtualColumns || this.locked) {\n          const delta = deltas.reduce((sum, item) => sum + item, 0);\n          const width = this.service.originalWidth + delta;\n          this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');\n        }\n      }\n      this.cdr.detectChanges();\n    }\n    autoFitObservable(columnInfo) {\n      return Observable.create(observer => {\n        this.zone.runOutsideAngular(() => {\n          this.renderer.addClass(this.element.nativeElement, 'k-autofitting');\n          this.cdr.detectChanges();\n          const widths = columnInfo.map(this.measureColumn.bind(this));\n          this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');\n          observer.next(widths);\n        });\n      });\n    }\n    measureColumn(info) {\n      const dom = this.element.nativeElement;\n      const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);\n      let data = 0;\n      if (!info.isParentSpan || info.isParentSpan && info.isLastInSpan) {\n        data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);\n      }\n      const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);\n      return Math.max(header, data, footer);\n    }\n  }\n  _class197 = TableDirective;\n  _defineProperty(TableDirective, \"\\u0275fac\", function _class197_Factory(t) {\n    return new (t || _class197)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(TableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class197,\n    selectors: [[\"\", \"kendoGridResizableTable\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class197_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"min-width\", ctx.minWidth);\n      }\n    },\n    inputs: {\n      locked: \"locked\",\n      virtualColumns: \"virtualColumns\"\n    },\n    standalone: true\n  }));\n  return TableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst elementAt = (index, elements, elementOffset) => {\n  for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {\n    const offset = elementOffset(elements[idx]);\n    if (elementIdx <= index && index <= elementIdx + offset - 1) {\n      return elements[idx];\n    }\n    elementIdx += offset;\n  }\n};\nconst rowAt = (index, rows) => elementAt(index, rows, () => 1);\nconst cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);\nconst EMPTY_OBJECT = {};\n/**\n * @hidden\n */\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');\n/**\n * @hidden\n */\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n  return new ScrollerService(observable);\n}\nconst wheelDeltaY = e => {\n  const deltaY = e.wheelDeltaY;\n  if (e.wheelDelta && (deltaY === undefined || deltaY)) {\n    return e.wheelDelta;\n  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {\n    return -e.detail * 10;\n  }\n  return 0;\n};\nconst preventLockedScroll = (args, element) => {\n  const delta = wheelDeltaY(args);\n  const scrollTop = element.scrollTop;\n  const allowScroll = scrollTop === 0 && 0 < delta || element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0;\n  if (!allowScroll) {\n    event.preventDefault();\n  }\n};\nconst translateY = (renderer, value) => el => renderer.setStyle(el, \"transform\", `translateY(${value}px)`);\nconst maybeNativeElement = el => el ? el.nativeElement : null;\nconst hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;\nconst setHeight = renderer => ({\n  el,\n  height\n}) => renderer.setStyle(el, \"height\", `${height}px`);\nconst bufferSize = 1;\n/**\n * @hidden\n */\nlet ListComponent = /*#__PURE__*/(() => {\n  var _class198;\n  class ListComponent {\n    get showFooter() {\n      return this.groupable && this.groupable.showFooter;\n    }\n    get totalWidth() {\n      if (this.virtualColumns && this.columns.unlockedWidth) {\n        return this.columns.unlockedWidth;\n      }\n    }\n    get lockedLeafColumns() {\n      return this.columns.lockedLeafColumns;\n    }\n    get nonLockedLeafColumns() {\n      return this.columns.nonLockedLeafColumns;\n    }\n    get nonLockedColumnsToRender() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.viewportColumns;\n      }\n      return this.nonLockedLeafColumns;\n    }\n    get leafColumns() {\n      return this.columns.leafColumnsToRender;\n    }\n    get lockedWidth() {\n      const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;\n      return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n    get nonLockedWidth() {\n      if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {\n        return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));\n      }\n      return undefined;\n    }\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo, rowspanService) {\n      _defineProperty(this, \"changeNotification\", void 0);\n      _defineProperty(this, \"suspendService\", void 0);\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"scrollSyncService\", void 0);\n      _defineProperty(this, \"resizeService\", void 0);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"supportService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"columnResizingService\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"pdfService\", void 0);\n      _defineProperty(this, \"columnInfo\", void 0);\n      _defineProperty(this, \"rowspanService\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"hostRole\", 'presentation');\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"groups\", []);\n      _defineProperty(this, \"total\", void 0);\n      _defineProperty(this, \"rowHeight\", void 0);\n      _defineProperty(this, \"stickyRowHeight\", void 0);\n      _defineProperty(this, \"detailRowHeight\", void 0);\n      _defineProperty(this, \"take\", void 0);\n      _defineProperty(this, \"skip\", 0);\n      _defineProperty(this, \"columns\", new ColumnsContainer(() => []));\n      _defineProperty(this, \"detailTemplate\", void 0);\n      _defineProperty(this, \"noRecordsTemplate\", void 0);\n      _defineProperty(this, \"selectable\", false);\n      _defineProperty(this, \"groupable\", false);\n      _defineProperty(this, \"filterable\", void 0);\n      _defineProperty(this, \"rowClass\", void 0);\n      _defineProperty(this, \"rowSticky\", void 0);\n      _defineProperty(this, \"loading\", void 0);\n      _defineProperty(this, \"trackBy\", defaultTrackBy);\n      _defineProperty(this, \"virtualColumns\", void 0);\n      _defineProperty(this, \"isVirtual\", void 0);\n      _defineProperty(this, \"cellLoadingTemplate\", void 0);\n      _defineProperty(this, \"loadingTemplate\", void 0);\n      _defineProperty(this, \"sort\", new Array());\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"contentScroll\", new EventEmitter());\n      _defineProperty(this, \"pageChange\", new EventEmitter());\n      _defineProperty(this, \"scrollBottom\", new EventEmitter());\n      _defineProperty(this, \"totalHeight\", void 0);\n      _defineProperty(this, \"columnsStartIdx\", 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"lockedContainer\", void 0);\n      _defineProperty(this, \"lockedTable\", void 0);\n      _defineProperty(this, \"table\", void 0);\n      _defineProperty(this, \"resizeSensors\", new QueryList());\n      _defineProperty(this, \"scroller\", void 0);\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"scrollerSubscription\", void 0);\n      _defineProperty(this, \"dispatcher\", new Subject());\n      _defineProperty(this, \"rowHeightService\", void 0);\n      _defineProperty(this, \"skipScroll\", void 0);\n      _defineProperty(this, \"rebind\", void 0);\n      _defineProperty(this, \"containerScrollTop\", 0);\n      _defineProperty(this, \"viewportColumns\", void 0);\n      _defineProperty(this, \"columnsEndIdx\", void 0);\n      _defineProperty(this, \"viewportColumnsWidth\", void 0);\n      _defineProperty(this, \"scrollLeft\", 0);\n      _defineProperty(this, \"observer\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      _defineProperty(this, \"columnUpdateFrame\", void 0);\n      _defineProperty(this, \"hasLockedContainer\", void 0);\n      this.changeNotification = changeNotification;\n      this.suspendService = suspendService;\n      this.groupsService = groupsService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.scrollSyncService = scrollSyncService;\n      this.resizeService = resizeService;\n      this.editService = editService;\n      this.supportService = supportService;\n      this.navigationService = navigationService;\n      this.ctx = ctx;\n      this.columnResizingService = columnResizingService;\n      this.changeDetector = changeDetector;\n      this.pdfService = pdfService;\n      this.columnInfo = columnInfo;\n      this.rowspanService = rowspanService;\n      this.scroller = scrollerFactory(this.dispatcher);\n      this.subscriptions = detailsService.changes.subscribe(x => this.detailExpand(x));\n      this.subscriptions.add(scrollRequestService.requests.subscribe(req => isPresent(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));\n    }\n    ngOnInit() {\n      this.init();\n      this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));\n      this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));\n      this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {\n        if (this.virtualColumns) {\n          this.ngZone.run(() => {\n            this.updateViewportColumns();\n            this.changeDetector.markForCheck();\n          });\n        }\n      }));\n      this.subscriptions.add(this.ctx.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl));\n    }\n    ngOnChanges(changes) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const changesInSkip = changes['skip'];\n      const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;\n      if (hasInitialSkip) {\n        this.handleInitialScrollToSkip();\n      }\n      if (isChanged$1(\"skip\", changes) && !this.rebind) {\n        this.skipScroll = true;\n        this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n      }\n      if (anyChanged(['total', 'take'], changes)) {\n        this.init();\n      }\n      this.rebind = false;\n    }\n    ngDoCheck() {\n      if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {\n        this.updateViewportColumns();\n      }\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.skip && this.isVirtual) {\n        this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n      }\n      this.resetNavigationViewport();\n      this.attachContainerScroll();\n      this.initResizeService();\n    }\n    ngAfterViewChecked() {\n      const isLocked = this.isLocked;\n      if (isLocked && !this.hasLockedContainer) {\n        this.syncRowsHeight();\n      }\n      this.hasLockedContainer = isLocked;\n    }\n    syncRowsHeight() {\n      if (this.lockedContainer) {\n        syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n      if (this.resizeService) {\n        this.resizeService.destroy();\n      }\n      this.observer?.disconnect();\n      this.cleanupScroller();\n    }\n    init() {\n      if (this.suspendService.scroll) {\n        return;\n      }\n      this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);\n      this.totalHeight = this.rowHeightService.totalHeight();\n      if (!isUniversal()) {\n        this.ngZone.runOutsideAngular(this.createScroller.bind(this));\n      }\n    }\n    lockedScroll() {\n      if (!this.suspendService.scroll) {\n        const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;\n        if (lockedScrollTop !== this.containerScrollTop) {\n          this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;\n        }\n      }\n    }\n    lockedMousewheel(args) {\n      if (!args.ctrlKey) {\n        preventLockedScroll(args, this.container.nativeElement);\n        const scrollDelta = wheelDeltaY(args);\n        this.container.nativeElement.scrollTop -= scrollDelta;\n      }\n    }\n    lockedKeydown(args) {\n      if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {\n        const dir = args.keyCode === Keys.PageDown ? 1 : -1;\n        const element = this.container.nativeElement;\n        element.scrollTop += element.offsetHeight * dir * 0.8;\n        args.preventDefault();\n      }\n    }\n    detailExpand({\n      index,\n      expand\n    }) {\n      if (expand) {\n        this.rowHeightService.expandDetail(index);\n      } else {\n        this.rowHeightService.collapseDetail(index);\n      }\n      this.totalHeight = this.rowHeightService.totalHeight();\n      this.resetNavigationViewport();\n    }\n    attachContainerScroll() {\n      if (isUniversal()) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map(event => event.target), filter(() => !this.suspendService.scroll), tap(target => {\n          this.onContainerScroll(target);\n          this.resetNavigationViewport();\n          if (this.virtualColumns || this.isVirtual) {\n            this.handleColumnScroll();\n          }\n          const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;\n          const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;\n          this.contentScroll.emit({\n            scrollLeft: target.scrollLeft,\n            scrollTop: target.scrollTop,\n            startRow: rowViewport.firstItemIndex,\n            endRow: rowViewport.lastItemIndex,\n            startColumn: columnViewport.firstItemIndex,\n            endColumn: columnViewport.lastItemIndex\n          });\n        })).subscribe(this.dispatcher));\n      });\n      this.scrollSyncService.registerEmitter(this.container.nativeElement, 'body');\n    }\n    createScroller() {\n      this.cleanupScroller();\n      const observable = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total);\n      this.skipScroll = false;\n      this.scrollerSubscription = observable.pipe(filter(x => x instanceof PageAction), filter(() => {\n        const temp = this.skipScroll;\n        this.skipScroll = false;\n        return !temp;\n      }), tap(() => this.rebind = true)).subscribe(x => this.ngZone.run(() => this.pageChange.emit(x)));\n      this.scrollerSubscription.add(observable.pipe(filter(x => x instanceof ScrollAction)).subscribe(this.scroll.bind(this)));\n      this.scrollerSubscription.add(observable.pipe(filter(x => x instanceof ScrollBottomAction)).subscribe(() => this.scrollBottom.emit()));\n    }\n    scroll({\n      offset = 0\n    }) {\n      if (this.isVirtual) {\n        [maybeNativeElement(this.table), maybeNativeElement(this.lockedTable)].filter(isPresent).forEach(translateY(this.renderer, offset));\n      }\n      this.resetNavigationViewport();\n    }\n    onContainerScroll({\n      scrollTop\n    }) {\n      this.containerScrollTop = scrollTop;\n      if (this.lockedContainer) {\n        this.lockedContainer.nativeElement.scrollTop = scrollTop;\n      }\n    }\n    handleInitialScrollToSkip() {\n      const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;\n      const sub = this.changeNotification.changes.pipe(filter(shouldScroll)).subscribe(() => {\n        this.scrollTo({\n          row: this.skip\n        });\n        sub.unsubscribe();\n      });\n    }\n    handleRowSync() {\n      const isLocked = () => isPresent(this.lockedContainer);\n      const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));\n      return merge(this.changeNotification.changes, this.groupsService.changes.pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes.pipe(filter(change => change.type === 'end')), this.supportService.changes).pipe(tap(() => {\n        this.ngZone.run(() => this.rowspanService.reset());\n        this.resetNavigationViewport();\n      }), filter(isLocked)).subscribe(() => {\n        const scrollTop = this.container.nativeElement.scrollTop;\n        const scrollLeft = this.container.nativeElement.scrollLeft;\n        this.syncRowsHeight();\n        this.syncContainerHeight();\n        this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;\n        // fixes scroll left position in IE when editing\n        this.container.nativeElement.scrollLeft = scrollLeft;\n        this.resizeSensors.forEach(sensor => sensor.acceptSize());\n      });\n    }\n    handleRowNavigationLocked() {\n      return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe(args => {\n        if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {\n          const cell = this.navigationService.activeCell;\n          if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {\n            this.container.nativeElement.scrollLeft = 0;\n          }\n        }\n      });\n    }\n    scrollToVirtualRow(itemIndex, adjustIndexForDetailTemplate = true) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (isPresent(this.detailTemplate) && adjustIndexForDetailTemplate) {\n        itemIndex = Math.floor(itemIndex / 2);\n      }\n      const offset = this.rowHeightService.offset(itemIndex, !adjustIndexForDetailTemplate);\n      this.container.nativeElement.scrollTop = offset;\n      this.resetNavigationViewport();\n    }\n    scrollTo({\n      row,\n      column\n    }, adjustIndex = false) {\n      if (isNumber(row)) {\n        if (this.isVirtual) {\n          this.scrollToVirtualRow(row, adjustIndex);\n        } else {\n          const element = rowAt(row, this.table.nativeElement.rows);\n          if (element) {\n            this.container.nativeElement.scrollTop = element.offsetTop;\n          }\n        }\n      }\n      if (isNumber(column)) {\n        column -= this.lockedLeafColumns.length;\n        if (this.virtualColumns) {\n          const columns = this.columns.leafColumnsToRender;\n          let offset = 0;\n          for (let idx = 0; idx < column; idx++) {\n            offset += columns[idx].width || 0;\n          }\n          const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);\n          this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);\n        } else if (column === 0 && this.detailTemplate) {\n          this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);\n        } else {\n          const firstRow = rowAt(0, this.table.nativeElement.rows);\n          if (firstRow) {\n            const element = cellAt(column, firstRow.cells);\n            if (element) {\n              this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);\n            }\n          }\n        }\n      }\n    }\n    scrollToItem(item) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const data = this.ctx.grid.data;\n      const gridData = Array.isArray(data) ? data : data.data;\n      const gridDataItems = gridData.flatMap(recursiveFlatMap);\n      const dataItemIndex = gridDataItems.findIndex(dataItem => dataItem[item.idField] === item.id);\n      if (dataItemIndex !== -1) {\n        const row = Array.from(this.table.nativeElement.rows).find(r => {\n          const dataAttribute = r.getAttribute('data-kendo-grid-item-index');\n          return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;\n        });\n        row && row.scrollIntoView();\n        this.isVirtual && this.resetNavigationViewport();\n      }\n    }\n    resetNavigationViewport() {\n      if (!isDocumentAvailable) {\n        return;\n      }\n      if (!this.container || !this.navigationService.tableEnabled || !this.navigationService.needsViewport() || this.data.length === 0) {\n        return;\n      }\n      const {\n        scrollTop,\n        offsetHeight\n      } = this.container.nativeElement;\n      const scrollBottom = scrollTop + offsetHeight;\n      const firstItemIndex = this.rowHeightService.index(scrollTop);\n      const lastItemIndex = this.rowHeightService.index(scrollBottom);\n      const lastItemOffset = this.rowHeightService.offset(lastItemIndex);\n      let viewportStart = firstItemIndex;\n      let viewportEnd = lastItemIndex;\n      if (isPresent(this.detailTemplate)) {\n        viewportStart *= 2;\n        viewportEnd *= 2;\n        const firstItemHeight = this.rowHeightService.offset(firstItemIndex);\n        if (firstItemHeight + this.rowHeight < scrollTop) {\n          viewportStart++;\n        }\n        const lastItemHeight = this.rowHeightService.height(lastItemIndex);\n        const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);\n        const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;\n        if (lastItemExpanded && !lastItemDetailOverflows) {\n          viewportEnd++;\n        }\n      }\n      this.navigationService.setViewport(viewportStart, viewportEnd);\n    }\n    cleanupScroller() {\n      if (this.scrollerSubscription) {\n        this.scrollerSubscription.unsubscribe();\n      }\n      if (this.scroller) {\n        this.scroller.destroy();\n      }\n    }\n    initResizeService() {\n      this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));\n    }\n    syncContainerHeight() {\n      [maybeNativeElement(this.lockedContainer)].filter(isPresent).map(el => {\n        el.style.height = '';\n        let height = this.container.nativeElement.offsetHeight;\n        if (hasScrollbar(this.table, this.container)) {\n          height -= this.supportService.scrollbarWidth;\n        }\n        return {\n          el,\n          height\n        };\n      }).forEach(setHeight(this.renderer));\n    }\n    updateViewportColumns(range) {\n      const columns = this.columns.nonLockedLeafColumns.toArray();\n      // eslint-disable-next-line prefer-const\n      let {\n        startIdx,\n        endIdx,\n        offset\n      } = range || this.calculateViewportColumns();\n      const start = Math.max(0, startIdx - bufferSize);\n      const end = Math.min(endIdx + bufferSize, columns.length - 1);\n      if (start < startIdx) {\n        for (let idx = startIdx - 1; idx >= start; idx--) {\n          offset -= columns[idx].width;\n        }\n      }\n      let currentColumns = columns.slice(start, end + 1);\n      this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);\n      const stickyBeforeStart = columns.slice(0, start).filter(c => c.sticky && !currentColumns.some(col => col === c));\n      const stickyAfterEnd = columns.slice(end, columns.length).filter(c => c.sticky && !currentColumns.some(col => col === c));\n      currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];\n      if (start > 0) {\n        const offsetColumn = new ColumnBase();\n        offsetColumn.width = offset;\n        currentColumns.unshift(offsetColumn);\n      }\n      this.viewportColumns = new QueryList();\n      this.viewportColumns.reset(currentColumns);\n      this.columnsStartIdx = start;\n      this.columnsEndIdx = end;\n      this.columnInfo.columnRangeChange.emit({\n        start,\n        end,\n        offset\n      });\n      if (!range) {\n        this.updateColumnViewport(startIdx, endIdx);\n      }\n    }\n    handleColumnScroll() {\n      const container = this.container.nativeElement;\n      const scrollLeft = container.scrollLeft;\n      if (this.scrollLeft !== scrollLeft) {\n        this.scrollLeft = scrollLeft;\n        const range = this.calculateViewportColumns();\n        this.updateColumnViewport(range.startIdx, range.endIdx);\n        if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {\n          cancelAnimationFrame(this.columnUpdateFrame);\n          this.columnUpdateFrame = requestAnimationFrame(() => {\n            this.ngZone.run(() => {\n              this.updateViewportColumns(range);\n              this.changeDetector.markForCheck();\n            });\n          });\n        }\n      }\n    }\n    updateColumnViewport(startIdx, endIdx) {\n      const lockedCount = this.lockedLeafColumns.length;\n      const leafColumns = this.nonLockedLeafColumns.toArray();\n      const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);\n      let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);\n      for (let idx = 0; idx < leafColumns.length; idx++) {\n        const column = leafColumns[idx];\n        if (column.isSpanColumn) {\n          viewportEnd += column.childColumns.length;\n        }\n      }\n      this.navigationService.setColumnViewport(viewportStart, viewportEnd);\n    }\n    calculateViewportColumns() {\n      const {\n        scrollLeft,\n        clientWidth\n      } = this.container.nativeElement;\n      const columns = this.columns.nonLockedLeafColumns.toArray();\n      const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);\n      const viewportEnd = normalizedScrollLeft + clientWidth;\n      let startIdx;\n      let endIdx = 0;\n      let current = 0;\n      let offset = 0;\n      let idx;\n      for (idx = 0; idx < columns.length; idx++) {\n        const column = columns[idx];\n        current += column.width || 0;\n        if (startIdx === undefined && current > normalizedScrollLeft) {\n          startIdx = idx;\n          offset = current - (column.width || 0);\n        }\n        if (current >= viewportEnd) {\n          endIdx = idx;\n          break;\n        }\n      }\n      if (!endIdx && idx > 0) {\n        endIdx = columns.length - 1;\n      }\n      return {\n        startIdx,\n        endIdx,\n        offset\n      };\n    }\n    viewportWidthChange() {\n      const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);\n      return currentWidth !== this.viewportColumnsWidth;\n    }\n    normalizeScrollLeft(position) {\n      return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;\n    }\n    elementScrollLeft(element) {\n      if (this.rtl) {\n        return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);\n      }\n      return element.offsetLeft;\n    }\n  }\n  _class198 = ListComponent;\n  _defineProperty(ListComponent, \"\\u0275fac\", function _class198_Factory(t) {\n    return new (t || _class198)(i0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(SuspendService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ScrollSyncService), i0.ɵɵdirectiveInject(ResizeService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(BrowserSupportService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(ScrollRequestService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(RowspanService));\n  });\n  _defineProperty(ListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class198,\n    selectors: [[\"kendo-grid-list\"]],\n    viewQuery: function _class198_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c46, 7);\n        i0.ɵɵviewQuery(_c47, 5);\n        i0.ɵɵviewQuery(_c48, 5);\n        i0.ɵɵviewQuery(_c49, 7);\n        i0.ɵɵviewQuery(ResizeSensorComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedTable = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.table = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeSensors = _t);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function _class198_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole);\n        i0.ɵɵclassProp(\"k-grid-container\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      groups: \"groups\",\n      total: \"total\",\n      rowHeight: \"rowHeight\",\n      stickyRowHeight: \"stickyRowHeight\",\n      detailRowHeight: \"detailRowHeight\",\n      take: \"take\",\n      skip: \"skip\",\n      columns: \"columns\",\n      detailTemplate: \"detailTemplate\",\n      noRecordsTemplate: \"noRecordsTemplate\",\n      selectable: \"selectable\",\n      groupable: \"groupable\",\n      filterable: \"filterable\",\n      rowClass: \"rowClass\",\n      rowSticky: \"rowSticky\",\n      loading: \"loading\",\n      trackBy: \"trackBy\",\n      virtualColumns: \"virtualColumns\",\n      isVirtual: \"isVirtual\",\n      cellLoadingTemplate: \"cellLoadingTemplate\",\n      loadingTemplate: \"loadingTemplate\",\n      sort: \"sort\",\n      size: \"size\"\n    },\n    outputs: {\n      contentScroll: \"contentScroll\",\n      pageChange: \"pageChange\",\n      scrollBottom: \"scrollBottom\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SCROLLER_FACTORY_TOKEN,\n      useValue: DEFAULT_SCROLLER_FACTORY\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 12,\n    vars: 37,\n    consts: [[\"class\", \"k-grid-content-locked\", \"role\", \"presentation\", \"tabindex\", \"-1\", 3, \"width\", \"kendoEventsOutsideAngular\", \"scope\", 4, \"ngIf\"], [1, \"k-grid-content\", \"k-virtual-content\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"container\", \"\"], [\"role\", \"presentation\"], [\"kendoGridResizableTable\", \"\", \"kendoGridTable\", \"\", \"role\", \"presentation\", 1, \"k-grid-table\", 3, \"virtualColumns\", \"size\"], [\"table\", \"\"], [\"kendoGridColGroup\", \"\", 3, \"groups\", \"columns\", \"detailTemplate\", \"sort\"], [\"kendoGridTableBody\", \"\", \"role\", \"rowgroup\", 3, \"skipGroupDecoration\", \"data\", \"groups\", \"showGroupFooters\", \"columns\", \"allColumns\", \"detailTemplate\", \"noRecordsTemplate\", \"lockedColumnsCount\", \"totalColumnsCount\", \"totalColumns\", \"skip\", \"selectable\", \"trackBy\", \"filterable\", \"rowClass\", \"rowSticky\", \"virtualColumns\", \"isLoading\", \"isVirtual\", \"cellLoadingTemplate\"], [4, \"ngIf\"], [\"class\", \"k-height-container\", \"role\", \"presentation\", 4, \"ngIf\"], [\"class\", \"k-width-container\", \"role\", \"presentation\", 4, \"ngIf\"], [\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-grid-content-locked\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"lockedContainer\", \"\"], [\"kendoGridResizableTable\", \"\", \"role\", \"presentation\", \"kendoGridTable\", \"\", 1, \"k-grid-table\", 3, \"locked\", \"size\"], [\"lockedTable\", \"\"], [\"kendoGridTableBody\", \"\", \"role\", \"presentation\", 3, \"groups\", \"isLocked\", \"data\", \"noRecordsText\", \"columns\", \"totalColumnsCount\", \"totalColumns\", \"detailTemplate\", \"showGroupFooters\", \"skip\", \"selectable\", \"trackBy\", \"filterable\", \"rowClass\", \"isLoading\", \"isVirtual\", \"cellLoadingTemplate\"], [\"role\", \"presentation\", 1, \"k-height-container\"], [\"role\", \"presentation\", 1, \"k-width-container\"]],\n    template: function _class198_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class198_div_0_Template, 9, 35, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"div\", 3)(4, \"table\", 4, 5);\n        i0.ɵɵelement(6, \"colgroup\", 6)(7, \"tbody\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, _class198_kendo_resize_sensor_8_Template, 1, 0, \"kendo-resize-sensor\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, _class198_kendo_resize_sensor_9_Template, 1, 0, \"kendo-resize-sensor\", 8);\n        i0.ɵɵtemplate(10, _class198_div_10_Template, 2, 2, \"div\", 9);\n        i0.ɵɵtemplate(11, _class198_div_11_Template, 2, 2, \"div\", 10);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx.lockedWidth + 1);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"width\", ctx.nonLockedWidth, \"px\");\n        i0.ɵɵproperty(\"virtualColumns\", ctx.virtualColumns)(\"size\", ctx.size);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"groups\", ctx.isLocked ? i0.ɵɵpureFunction0(36, _c51) : ctx.groups)(\"columns\", ctx.nonLockedColumnsToRender)(\"detailTemplate\", ctx.detailTemplate)(\"sort\", ctx.sort);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"skipGroupDecoration\", ctx.isLocked)(\"data\", ctx.data)(\"groups\", ctx.groups)(\"showGroupFooters\", ctx.showFooter)(\"columns\", ctx.nonLockedColumnsToRender)(\"allColumns\", ctx.nonLockedLeafColumns)(\"detailTemplate\", ctx.detailTemplate)(\"noRecordsTemplate\", ctx.noRecordsTemplate)(\"lockedColumnsCount\", ctx.lockedLeafColumns.length)(\"totalColumnsCount\", ctx.leafColumns.length)(\"totalColumns\", ctx.columns)(\"skip\", ctx.skip)(\"selectable\", ctx.selectable)(\"trackBy\", ctx.trackBy)(\"filterable\", ctx.filterable)(\"rowClass\", ctx.rowClass)(\"rowSticky\", ctx.rowSticky)(\"virtualColumns\", ctx.virtualColumns)(\"isLoading\", ctx.loading)(\"isVirtual\", ctx.isVirtual)(\"cellLoadingTemplate\", ctx.cellLoadingTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked || ctx.virtualColumns);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isVirtual);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.virtualColumns);\n      }\n    },\n    dependencies: [NgIf, EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective],\n    encapsulation: 2\n  }));\n  return ListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ToolbarComponent = /*#__PURE__*/(() => {\n  var _class199;\n  class ToolbarComponent {\n    get sizeSmallClass() {\n      return this.size === 'small';\n    }\n    get sizeMediumClass() {\n      return this.size === 'medium' || !this.size;\n    }\n    set position(value) {\n      this.context.position = value;\n    }\n    set size(size) {\n      this._size = size;\n      if (size === 'none') {\n        this.wrapper.nativeElement.classList.remove('k-toolbar-sm', 'k-toolbar-md');\n      }\n    }\n    get size() {\n      return this._size;\n    }\n    clickHandler(ev) {\n      if (this.navigable && isDocumentAvailable()) {\n        const closestFocusable = closest$1(ev.target, isFocusable$1);\n        const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusable);\n        if (targetIndex > -1) {\n          this.navigationService.currentActiveIndex = targetIndex;\n        }\n        this.navigationService.updateFocus();\n        if (ev.target === this.wrapper.nativeElement) {\n          this.navigationService.focus();\n        }\n      }\n    }\n    arrowLeftListener() {\n      if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {\n        this.navigationService.currentActiveIndex--;\n        if (this.navigationService.currentActiveIndex < 0) {\n          this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;\n        }\n        this.navigationService.updateFocus();\n      }\n    }\n    arrowRightListener() {\n      if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {\n        this.navigationService.currentActiveIndex++;\n        if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {\n          this.navigationService.currentActiveIndex = 0;\n        }\n        this.navigationService.updateFocus();\n      }\n    }\n    homeKeyListener(e) {\n      if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {\n        e.preventDefault();\n        this.navigationService.currentActiveIndex = 0;\n        this.navigationService.updateFocus();\n      }\n    }\n    endKeyListener(e) {\n      if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {\n        e.preventDefault();\n        this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;\n        this.navigationService.updateFocus();\n      }\n    }\n    get toolbarTemplateRef() {\n      return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : undefined;\n    }\n    constructor(ctx, wrapper) {\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"context\", {});\n      _defineProperty(this, \"role\", 'toolbar');\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"navigable\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"navigationService\", void 0);\n      this.ctx = ctx;\n      this.wrapper = wrapper;\n      this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute('position')}ToolbarNavigation`];\n    }\n  }\n  _class199 = ToolbarComponent;\n  _defineProperty(ToolbarComponent, \"\\u0275fac\", function _class199_Factory(t) {\n    return new (t || _class199)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ToolbarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class199,\n    selectors: [[\"kendo-grid-toolbar\"]],\n    hostVars: 11,\n    hostBindings: function _class199_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class199_click_HostBindingHandler($event) {\n          return ctx.clickHandler($event);\n        })(\"keydown.arrowleft\", function _class199_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.arrowLeftListener($event);\n        })(\"keydown.arrowright\", function _class199_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.arrowRightListener($event);\n        })(\"keydown.home\", function _class199_keydown_home_HostBindingHandler($event) {\n          return ctx.homeKeyListener($event);\n        })(\"keydown.end\", function _class199_keydown_end_HostBindingHandler($event) {\n          return ctx.endKeyListener($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-toolbar\", ctx.hostClasses)(\"k-grid-toolbar\", ctx.hostClasses)(\"k-toolbar-solid\", ctx.hostClasses)(\"k-toolbar-sm\", ctx.sizeSmallClass)(\"k-toolbar-md\", ctx.sizeMediumClass);\n      }\n    },\n    inputs: {\n      position: \"position\",\n      size: \"size\",\n      navigable: \"navigable\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class199_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class199_0_Template, 1, 2, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.toolbarTemplateRef);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return ToolbarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet GridMessages = /*#__PURE__*/(() => {\n  var _class200;\n  class GridMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The text for the empty group panel.\n       */\n      _defineProperty(this, \"groupPanelEmpty\", void 0);\n      /**\n       * The no-records text.\n       */\n      _defineProperty(this, \"noRecords\", void 0);\n      /**\n       * The label of the pager. Follows the pattern **Page {currentPage} of {totalPages}** by default.\n       * Тhe default label text when the current page is 1, and the total number of pages is 10 will be\n       * **Page navigation, page 1 of 10**.\n       *\n       * The message consists of several parts - the current page number, the total number of pages, and a localizable string.\n       * To allow for reordering its parts, the `pagerLabel` input accepts a string with placeholders for the current page\n       * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced\n       * internally with the respective actual values. [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"pagerLabel\", void 0);\n      /**\n       * The label for the **First page** button.\n       */\n      _defineProperty(this, \"pagerFirstPage\", void 0);\n      /**\n       * The label for the **Last page** button.\n       */\n      _defineProperty(this, \"pagerLastPage\", void 0);\n      /**\n       * The label for the **Previous page** button.\n       */\n      _defineProperty(this, \"pagerPreviousPage\", void 0);\n      /**\n       * The label for the **Next page** button.\n       */\n      _defineProperty(this, \"pagerNextPage\", void 0);\n      /**\n       * The text displayed before the pager input.\n       */\n      _defineProperty(this, \"pagerPage\", void 0);\n      /**\n       * The text displayed after the page-size selector.\n       */\n      _defineProperty(this, \"pagerItemsPerPage\", void 0);\n      /**\n       * The text displayed before the total-page number.\n       */\n      _defineProperty(this, \"pagerOf\", void 0);\n      /**\n       * The text displayed after the total number of items.\n       */\n      _defineProperty(this, \"pagerItems\", void 0);\n      /**\n       * The title attribute of the page number input element.\n       */\n      _defineProperty(this, \"pagerPageNumberInputTitle\", void 0);\n      /**\n       * The text of the aria-label attribute applied to the page number input element.\n       */\n      _defineProperty(this, \"pagerInputLabel\", void 0);\n      /**\n       * The text of the title and `aria-label` attributes applied to the page chooser in the Grid Pager.\n       */\n      _defineProperty(this, \"pagerSelectPage\", void 0);\n      /**\n       * The label of the filter cell or icon.\n       */\n      _defineProperty(this, \"filter\", void 0);\n      /**\n       * The label of the filter input.\n       *\n       * The filter input label consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default label will be **Product Name Filter**.\n       *\n       * To allow reordering the column name and the localizable part, the `filterInputLabel` accepts a string with a\n       * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting label will be rendered as **filter for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"filterInputLabel\", void 0);\n      /**\n       * The title of the filter menu icon.\n       *\n       * The title consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default title will be **Product Name Filter Menu**.\n       *\n       * To allow reordering the column name and the localizable part, the `filterMenuTitle` accepts a string with a\n       * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting title will be rendered as **filter for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"filterMenuTitle\", void 0);\n      /**\n       * The label of the filter menu operators DropDownList.\n       *\n       * The label consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default label will be **Product Name Filter Menu Operators**.\n       *\n       * To allow reordering the column name and the localizable part, the `filterMenuOperatorsDropDownLabel` accepts a string with a\n       * placeholder for the column name, for example, **filter operators for {columnName**'. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting label will be rendered as **filter operators for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"filterMenuOperatorsDropDownLabel\", void 0);\n      /**\n       * The label of the filter menu logic DropDownList.\n       *\n       * The label consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default label will be **Product Name Filter Menu Logic**.\n       *\n       * To allow reordering the column name and the localizable part, the `filterMenuLogicDropDownLabel` accepts a string with a\n       * placeholder for the column name, for example, **filter logic for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting label will be rendered as **filter logic for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"filterMenuLogicDropDownLabel\", void 0);\n      /**\n       * The label of the filter cell operators DropDownList.\n       *\n       * The label consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default label will be **Filter cell operators for Product Name**.\n       *\n       * To allow reordering the column name and the localizable part, the `filterCellOperatorLabel` accepts a string with a\n       * placeholder for the column name, for example, **Filter operators for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting label will be rendered as **Filter operators for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"filterCellOperatorLabel\", void 0);\n      /**\n       * The label of the boolean filter cell DropDownList.\n       *\n       * The label consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default label will be **Boolean filter cell for Product Name**.\n       *\n       * To allow reordering the column name and the localizable part, the `booleanFilterCellLabel` accepts a string with a\n       * placeholder for the column name, for example, **Boolean Filter operator for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting label will be rendered as **Boolean Filter operator for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"booleanFilterCellLabel\", void 0);\n      /**\n       * The text of the `Equal` (**Is equal to**) filter operator.\n       */\n      _defineProperty(this, \"filterEqOperator\", void 0);\n      /**\n       * The text of the `NotEqual` (**Is not equal to**) filter operator.\n       */\n      _defineProperty(this, \"filterNotEqOperator\", void 0);\n      /**\n       * The text of the `IsNull` (**Is null**) filter operator.\n       */\n      _defineProperty(this, \"filterIsNullOperator\", void 0);\n      /**\n       * The text of the `IsNotNull` (**Is not null**) filter operator.\n       */\n      _defineProperty(this, \"filterIsNotNullOperator\", void 0);\n      /**\n       * The text of the `IsEmpty` (**Is empty**) filter operator.\n       */\n      _defineProperty(this, \"filterIsEmptyOperator\", void 0);\n      /**\n       * The text of the `IsNotEmpty` (**Is not empty**) filter operator.\n       */\n      _defineProperty(this, \"filterIsNotEmptyOperator\", void 0);\n      /**\n       * The text of the `StartsWith` (**Starts with**) filter operator.\n       */\n      _defineProperty(this, \"filterStartsWithOperator\", void 0);\n      /**\n       * The text of the `Contains` (**Contains**) filter operator.\n       */\n      _defineProperty(this, \"filterContainsOperator\", void 0);\n      /**\n       * The text of the `DoesNotContain` (**Does not contain**) filter operator.\n       */\n      _defineProperty(this, \"filterNotContainsOperator\", void 0);\n      /**\n       * The text of the `EndsWith` (**Ends with**) string filter operator.\n       */\n      _defineProperty(this, \"filterEndsWithOperator\", void 0);\n      /**\n       * The text of the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.\n       */\n      _defineProperty(this, \"filterGteOperator\", void 0);\n      /**\n       * The text of the `Greater` (**Is greater than**) numeric filter operator.\n       */\n      _defineProperty(this, \"filterGtOperator\", void 0);\n      /**\n       * The text of the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.\n       */\n      _defineProperty(this, \"filterLteOperator\", void 0);\n      /**\n       * The text of the `Less` (**Is less than**) numeric filter operator.\n       */\n      _defineProperty(this, \"filterLtOperator\", void 0);\n      /**\n       * The text of the `IsTrue` Boolean filter option.\n       */\n      _defineProperty(this, \"filterIsTrue\", void 0);\n      /**\n       * The text of the `IsFalse` Boolean filter option.\n       */\n      _defineProperty(this, \"filterIsFalse\", void 0);\n      /**\n       * The text of the `(All)` option for Boolean filter.\n       */\n      _defineProperty(this, \"filterBooleanAll\", void 0);\n      /**\n       * The text of the `AfterOrEqualTo` (**Is after or equal to**) date filter operator.\n       */\n      _defineProperty(this, \"filterAfterOrEqualOperator\", void 0);\n      /**\n       * The text of the `After` (**Is after**) date filter operator.\n       */\n      _defineProperty(this, \"filterAfterOperator\", void 0);\n      /**\n       * The text of the `Before` (**Is before**) date filter operator.\n       */\n      _defineProperty(this, \"filterBeforeOperator\", void 0);\n      /**\n       * The text of the `BeforeOrEqualTo` (**Is before or equal to**) date filter operator.\n       */\n      _defineProperty(this, \"filterBeforeOrEqualOperator\", void 0);\n      /**\n       * The text of the **Filter** button.\n       */\n      _defineProperty(this, \"filterFilterButton\", void 0);\n      /**\n       * The text of the **Clear filter** button.\n       */\n      _defineProperty(this, \"filterClearButton\", void 0);\n      /**\n       * The text of the `And` filter logic.\n       */\n      _defineProperty(this, \"filterAndLogic\", void 0);\n      /**\n       * The text of the `Or` filter logic.\n       */\n      _defineProperty(this, \"filterOrLogic\", void 0);\n      /**\n       * The loading text. The `loading` property is part of the accessibility support of the Grid.\n       * Its value is detectable by screen readers and is not otherwise visible.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      /**\n       * The text of the `aria-label` attribute placed on the Grid focusable element.\n       */\n      _defineProperty(this, \"gridLabel\", void 0);\n      /**\n       * The title of the column menu icon.\n       *\n       * The title consists of a two-part message - the name of the column and a localizable string.\n       * For a column named **Product Name**, the default title will be **Product Name Column Menu**.\n       *\n       * To allow reordering the column name and the localizable part, the `columnMenu` accepts a string with a\n       * placeholder for the column name, for example, **menu for {columnName}**. The `{columnName}` placeholder will be replaced\n       * internally with the current column name, and the resulting title will be rendered as **menu for Product Name**.\n       * [See example](slug:globalization_grid#toc-custom-messages).\n       */\n      _defineProperty(this, \"columnMenu\", void 0);\n      /**\n       * The text that is displayed in the column menu for the set column position item.\n       */\n      _defineProperty(this, \"setColumnPosition\", void 0);\n      /**\n       * The text that is displayed in the column menu for the column items.\n       */\n      _defineProperty(this, \"columns\", void 0);\n      /**\n       * The text that is displayed in the column menu for the lock item.\n       */\n      _defineProperty(this, \"lock\", void 0);\n      /**\n       * The text that is displayed in the column menu for the unlock item.\n       */\n      _defineProperty(this, \"unlock\", void 0);\n      /**\n       * The text that is displayed in the column menu for the stick item.\n       */\n      _defineProperty(this, \"stick\", void 0);\n      /**\n       * The text that is displayed in the column menu for the unstick item.\n       */\n      _defineProperty(this, \"unstick\", void 0);\n      /**\n       * The label of the sort icon.\n       */\n      _defineProperty(this, \"sortable\", void 0);\n      /**\n       * The text that is displayed in the column menu for the ascending sort item.\n       */\n      _defineProperty(this, \"sortAscending\", void 0);\n      /**\n       * The text that is displayed in the column menu for the descending sort item.\n       */\n      _defineProperty(this, \"sortDescending\", void 0);\n      /**\n       * The text shown in the column menu for the autosize this column item.\n       */\n      _defineProperty(this, \"autosizeThisColumn\", void 0);\n      /**\n       * The text shown in the column menu for the autosize all columns item.\n       */\n      _defineProperty(this, \"autosizeAllColumns\", void 0);\n      /**\n       * The title of the Group Chip indicating the ascending sorting order of the groups.\n       */\n      _defineProperty(this, \"sortedAscending\", void 0);\n      /**\n       * The title of the Group Chip indicating the descending sorting order of the groups\n       */\n      _defineProperty(this, \"sortedDescending\", void 0);\n      /**\n       * The status announcement when a column is no longer sorted.\n       */\n      _defineProperty(this, \"sortedDefault\", void 0);\n      /**\n       * The text that is displayed in the column menu or in the column chooser item\n       * for the **Apply** button of the columns.\n       */\n      _defineProperty(this, \"columnsApply\", void 0);\n      /**\n       * The text that is displayed in the column menu or in the column chooser item\n       * for the **Reset** button of the columns.\n       */\n      _defineProperty(this, \"columnsReset\", void 0);\n      /**\n       * The title of the expand icon of detail rows.\n       */\n      _defineProperty(this, \"detailExpand\", void 0);\n      /**\n       * The title of the collapse icon of detail rows.\n       */\n      _defineProperty(this, \"detailCollapse\", void 0);\n      /**\n       * The text of the Today button of the Date filter.\n       */\n      _defineProperty(this, \"filterDateToday\", void 0);\n      /**\n       * The title of the Toggle button of the Date filter.\n       */\n      _defineProperty(this, \"filterDateToggle\", void 0);\n      /**\n       * The title of the Decrement button of the Numeric filter.\n       */\n      _defineProperty(this, \"filterNumericDecrement\", void 0);\n      /**\n       * The title of the Increment button of the Numeric filter.\n       */\n      _defineProperty(this, \"filterNumericIncrement\", void 0);\n      /**\n       * The labels of the checkbox column checkboxes.\n       */\n      _defineProperty(this, \"selectionCheckboxLabel\", void 0);\n      /**\n       * The label of the checkbox column select all checkbox.\n       */\n      _defineProperty(this, \"selectAllCheckboxLabel\", void 0);\n      /**\n       * The text of the title and `aria-label` attributes applied to the collapse icon of group rows.\n       */\n      _defineProperty(this, \"groupCollapse\", void 0);\n      /**\n       * The text of the title and `aria-label` attributes applied to the expand icon of group rows.\n       */\n      _defineProperty(this, \"groupExpand\", void 0);\n      /**\n       * The label for the top toolbar.\n       */\n      _defineProperty(this, \"topToolbarLabel\", void 0);\n      /**\n       * The label for the bottom toolbar.\n       */\n      _defineProperty(this, \"bottomToolbarLabel\", void 0);\n      /**\n       * The label for the group panel toolbar.\n       */\n      _defineProperty(this, \"groupPanelLabel\", void 0);\n      /**\n       * The label for the Grid drag row handle.\n       */\n      _defineProperty(this, \"dragRowHandleLabel\", void 0);\n      /**\n       * The title for the column menu Filter tab.\n       */\n      _defineProperty(this, \"columnMenuFilterTabTitle\", void 0);\n      /**\n       * The title for the column menu General tab.\n       */\n      _defineProperty(this, \"columnMenuGeneralTabTitle\", void 0);\n      /**\n       * The title for the column menu Columns tab.\n       */\n      _defineProperty(this, \"columnMenuColumnsTabTitle\", void 0);\n      /**\n       * The text for the Group pane Chip Menu Move as previous item.\n       */\n      _defineProperty(this, \"groupChipMenuPrevious\", void 0);\n      /**\n       * The text for the Group pane Chip Menu Move as next item.\n       */\n      _defineProperty(this, \"groupChipMenuNext\", void 0);\n    }\n  }\n  _class200 = GridMessages;\n  _defineProperty(GridMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class200_BaseFactory;\n    return function _class200_Factory(t) {\n      return (ɵ_class200_BaseFactory || (ɵ_class200_BaseFactory = i0.ɵɵgetInheritedFactory(_class200)))(t || _class200);\n    };\n  }());\n  _defineProperty(GridMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class200,\n    selectors: [[\"kendo-grid-messages-base\"]],\n    inputs: {\n      groupPanelEmpty: \"groupPanelEmpty\",\n      noRecords: \"noRecords\",\n      pagerLabel: \"pagerLabel\",\n      pagerFirstPage: \"pagerFirstPage\",\n      pagerLastPage: \"pagerLastPage\",\n      pagerPreviousPage: \"pagerPreviousPage\",\n      pagerNextPage: \"pagerNextPage\",\n      pagerPage: \"pagerPage\",\n      pagerItemsPerPage: \"pagerItemsPerPage\",\n      pagerOf: \"pagerOf\",\n      pagerItems: \"pagerItems\",\n      pagerPageNumberInputTitle: \"pagerPageNumberInputTitle\",\n      pagerInputLabel: \"pagerInputLabel\",\n      pagerSelectPage: \"pagerSelectPage\",\n      filter: \"filter\",\n      filterInputLabel: \"filterInputLabel\",\n      filterMenuTitle: \"filterMenuTitle\",\n      filterMenuOperatorsDropDownLabel: \"filterMenuOperatorsDropDownLabel\",\n      filterMenuLogicDropDownLabel: \"filterMenuLogicDropDownLabel\",\n      filterCellOperatorLabel: \"filterCellOperatorLabel\",\n      booleanFilterCellLabel: \"booleanFilterCellLabel\",\n      filterEqOperator: \"filterEqOperator\",\n      filterNotEqOperator: \"filterNotEqOperator\",\n      filterIsNullOperator: \"filterIsNullOperator\",\n      filterIsNotNullOperator: \"filterIsNotNullOperator\",\n      filterIsEmptyOperator: \"filterIsEmptyOperator\",\n      filterIsNotEmptyOperator: \"filterIsNotEmptyOperator\",\n      filterStartsWithOperator: \"filterStartsWithOperator\",\n      filterContainsOperator: \"filterContainsOperator\",\n      filterNotContainsOperator: \"filterNotContainsOperator\",\n      filterEndsWithOperator: \"filterEndsWithOperator\",\n      filterGteOperator: \"filterGteOperator\",\n      filterGtOperator: \"filterGtOperator\",\n      filterLteOperator: \"filterLteOperator\",\n      filterLtOperator: \"filterLtOperator\",\n      filterIsTrue: \"filterIsTrue\",\n      filterIsFalse: \"filterIsFalse\",\n      filterBooleanAll: \"filterBooleanAll\",\n      filterAfterOrEqualOperator: \"filterAfterOrEqualOperator\",\n      filterAfterOperator: \"filterAfterOperator\",\n      filterBeforeOperator: \"filterBeforeOperator\",\n      filterBeforeOrEqualOperator: \"filterBeforeOrEqualOperator\",\n      filterFilterButton: \"filterFilterButton\",\n      filterClearButton: \"filterClearButton\",\n      filterAndLogic: \"filterAndLogic\",\n      filterOrLogic: \"filterOrLogic\",\n      loading: \"loading\",\n      gridLabel: \"gridLabel\",\n      columnMenu: \"columnMenu\",\n      setColumnPosition: \"setColumnPosition\",\n      columns: \"columns\",\n      lock: \"lock\",\n      unlock: \"unlock\",\n      stick: \"stick\",\n      unstick: \"unstick\",\n      sortable: \"sortable\",\n      sortAscending: \"sortAscending\",\n      sortDescending: \"sortDescending\",\n      autosizeThisColumn: \"autosizeThisColumn\",\n      autosizeAllColumns: \"autosizeAllColumns\",\n      sortedAscending: \"sortedAscending\",\n      sortedDescending: \"sortedDescending\",\n      sortedDefault: \"sortedDefault\",\n      columnsApply: \"columnsApply\",\n      columnsReset: \"columnsReset\",\n      detailExpand: \"detailExpand\",\n      detailCollapse: \"detailCollapse\",\n      filterDateToday: \"filterDateToday\",\n      filterDateToggle: \"filterDateToggle\",\n      filterNumericDecrement: \"filterNumericDecrement\",\n      filterNumericIncrement: \"filterNumericIncrement\",\n      selectionCheckboxLabel: \"selectionCheckboxLabel\",\n      selectAllCheckboxLabel: \"selectAllCheckboxLabel\",\n      groupCollapse: \"groupCollapse\",\n      groupExpand: \"groupExpand\",\n      topToolbarLabel: \"topToolbarLabel\",\n      bottomToolbarLabel: \"bottomToolbarLabel\",\n      groupPanelLabel: \"groupPanelLabel\",\n      dragRowHandleLabel: \"dragRowHandleLabel\",\n      columnMenuFilterTabTitle: \"columnMenuFilterTabTitle\",\n      columnMenuGeneralTabTitle: \"columnMenuGeneralTabTitle\",\n      columnMenuColumnsTabTitle: \"columnMenuColumnsTabTitle\",\n      groupChipMenuPrevious: \"groupChipMenuPrevious\",\n      groupChipMenuNext: \"groupChipMenuNext\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return GridMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  var _class201;\n  class LocalizedMessagesDirective extends GridMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class201 = LocalizedMessagesDirective;\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275fac\", function _class201_Factory(t) {\n    return new (t || _class201)(i0.ɵɵdirectiveInject(i1$2.LocalizationService));\n  });\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class201,\n    selectors: [[\"\", \"kendoGridLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: GridMessages,\n      useExisting: forwardRef(() => _class201)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst createControl = source => (acc, key) => {\n  acc[key] = new FormControl(source[key]);\n  return acc;\n};\nconst validateColumnsField = columns => expandColumns(columns.toArray()).filter(isColumnComponent).filter(({\n  field\n}) => !isValidFieldName(field)).forEach(({\n  field\n}) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));\nconst handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map) => service.changes.pipe(filter(({\n  group,\n  emit\n}) => emit && isPresent(group))).subscribe(x => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x)));\nconst handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map) => service.changes.pipe(filter(({\n  dataItem\n}) => isPresent(dataItem))).subscribe(x => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x)));\nconst isInEditedCell = (element, gridElement) => closest(element, matchesClasses('k-grid-edit-cell')) && closest(element, matchesNodeName('kendo-grid')) === gridElement;\nconst NOTIFY_DELAY = 500;\n/**\n * Represents the Kendo UI for Angular Data Grid component.\n *\n * @example\n * ```html\n * <kendo-grid [data]=\"gridData\"></kendo-grid>\n * ```\n */\nlet GridComponent = /*#__PURE__*/(() => {\n  var _class202;\n  class GridComponent {\n    /**\n     * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count\n     * ([more information and example]({% slug binding_grid %})).\n     */\n    set data(value) {\n      this._data = value;\n      if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {\n        this.blockArrowSelection = false;\n      }\n      if (this.notifyTimeout) {\n        clearTimeout(this.notifyTimeout);\n        this.notifyTimeout = null;\n      }\n      if (this.rowReorderable) {\n        this.ngZone.runOutsideAngular(() => {\n          this.notifyTimeout = setTimeout(() => {\n            this.notifyReorderContainers();\n          }, NOTIFY_DELAY);\n        });\n      }\n    }\n    get data() {\n      return this._data;\n    }\n    get hintText() {\n      return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);\n    }\n    /**\n     * @hidden\n     */\n    get customHintTemplate() {\n      if (this.rowReorderable) {\n        const allColumns = this.columnList.toArray();\n        const rowReorderColumn = allColumns.find(column => column.isRowReorderColumn);\n        return rowReorderColumn.rowDragHintTemplateRef;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get hintContext() {\n      if (this.customHintTemplate) {\n        const draggedRow = this.rowReorderService?.getDraggedRow(this.flatData);\n        return {\n          $implicit: draggedRow?.dataItem,\n          rowIndex: draggedRow?.rowIndex\n        };\n      }\n    }\n    /**\n     * Defines the page size used by the Grid pager.\n     * Required by the [paging]({% slug paging_grid %}) functionality.\n     */\n\n    /**\n     * Defines the number of records to be skipped by the pager.\n     * Required by the [paging]({% slug paging_grid %}) functionality.\n     */\n    get skip() {\n      return this._skip;\n    }\n    set skip(value) {\n      if (typeof value === 'number' && value >= 0) {\n        this._skip = this.rowReorderService.skip = value;\n      }\n    }\n    /**\n     * Defines the scroll mode used by the Grid.\n     *\n     * @default 'scrollable'\n     */\n\n    /**\n     * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).\n     */\n    set sort(value) {\n      if (isArray(value)) {\n        this._sort = value;\n      }\n    }\n    get sort() {\n      return this._sort;\n    }\n    /**\n     * Specifies the sizing of various Grid building blocks (e.g. tables, buttons, inputs, dropdowns, etc.)\n     * @default 'medium'\n     */\n    set size(size) {\n      this._size = size;\n      if (size === 'none') {\n        this.wrapper.nativeElement.classList.remove('k-grid-sm', 'k-grid-md');\n      }\n      this.sizingService.changes.next(this.size);\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * A function that defines how to track changes for the data rows.\n     * By default, the Grid tracks changes by the index of the data item.\n     * Edited rows are tracked by reference.\n     * [See example](slug:track_changes_grid)\n     */\n\n    /**\n     * The descriptors by which the data will be grouped ([see example]({% slug grouping_grid %})).\n     */\n    set group(value) {\n      if (isArray(value)) {\n        this._group = value;\n      }\n    }\n    get group() {\n      return this._group;\n    }\n    /**\n     * If set to `true`, the grid will render only the columns in the current viewport.\n     * @default false\n     */\n\n    /**\n     * @hidden\n     */\n    get showStatusBar() {\n      return !!this.selectable;\n    }\n    /**\n     * @hidden\n     */\n    get showTopToolbar() {\n      return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n    get showBottomToolbar() {\n      return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n    /**\n     * @hidden\n     */\n    get showTopPager() {\n      const position = this.pageable.position;\n      return !this.isVirtual && this.pageable !== false && ['top', 'both'].indexOf(position) > -1;\n    }\n    /**\n     * @hidden\n     */\n    get showBottomPager() {\n      const position = this.pageable.position;\n      return !this.isVirtual && this.pageable !== false && position !== 'top';\n    }\n    /**\n     * @hidden\n     */\n    get hasPager() {\n      return this.showTopPager || this.showBottomPager;\n    }\n    /**\n     * @hidden\n     */\n    get showGroupPanel() {\n      return this.groupable && this.groupable.enabled !== false;\n    }\n    /**\n     * @hidden\n     */\n    get groupableEmptyText() {\n      return this.groupable.emptyText;\n    }\n    /**\n     * @hidden\n     */\n    get marqueeSelection() {\n      return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;\n    }\n    /**\n     * @hidden\n     */\n\n    get normalizedPageableSettings() {\n      return normalize(this.pageable);\n    }\n    /**\n     * If set to `true`, the user can group the Grid by dragging the column header cells ([see example]({% slug grouping_grid %})).\n     * @default false\n     */\n\n    /**\n     * Enables the [row reordering]({% slug reordering_rows_grid %}) of the Grid.\n     * @default false\n     */\n    set rowReorderable(value) {\n      this._rowReorderable = value;\n      if (value) {\n        this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe(args => {\n          this.ngZone.run(() => {\n            this.rowReorder.emit(args);\n          });\n        });\n      } else {\n        this.rowReorderSubscription?.unsubscribe();\n      }\n    }\n    get rowReorderable() {\n      return this._rowReorderable;\n    }\n    /**\n     * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.\n     * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.\n     * To enable navigation through separate Grid sections only, provide a [`GridNavigableSection`]({% slug api_grid_gridnavigablesection %}) array.\n     */\n    set navigable(value) {\n      if (typeof value === 'boolean') {\n        this._navigable = value ? ['table', 'pager', 'toolbar'] : [];\n        this.ctx.navigable = value;\n        return;\n      } else {\n        this.ctx.navigable = value.includes('table');\n      }\n      this._navigable = value;\n    }\n    get navigable() {\n      return this._navigable;\n    }\n    /**\n     * @hidden\n     *\n     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.\n     */\n    set navigatable(value) {\n      this.navigable = value;\n    }\n    /**\n     * @hidden\n     */\n    get navigatable() {\n      return this.navigable;\n    }\n    /**\n     * Indicates whether the Grid columns will be resized during initialization so that\n     * they fit their headers and row content.\n     * Columns with `autoSize` set to `false` are excluded.\n     * To dynamically update the column width to match the new content,\n     * refer to [this example]({% slug resizing_columns_grid %}).\n     * @default false\n     */\n\n    /**\n     * Defines a function that is executed for every data row in the component\n     * ([see example](slug:styling_grid_rows)).\n     */\n    set rowClass(fn) {\n      if (isDevMode() && typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('rowClass', fn));\n      }\n      this._rowClass = fn;\n    }\n    get rowClass() {\n      return this._rowClass;\n    }\n    /**\n     * Defines a function that is executed for every data row in the component,\n     * and determines whether the row will be sticky, i.e. always visible after scrolling.\n     */\n    set rowSticky(fn) {\n      if (isDevMode() && isPresent(fn) && typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('rowSticky', fn));\n      }\n      if (isPresent(fn)) {\n        this._rowSticky = fn;\n      }\n    }\n    get rowSticky() {\n      return this._rowSticky;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data row in the component\n     * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).\n     * Determines whether the row will be selected.\n     */\n    set rowSelected(fn) {\n      if (isDevMode() && typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('rowSelected', fn));\n      }\n      this._rowSelected = fn;\n    }\n    get rowSelected() {\n      return this._rowSelected;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data row in the component.\n     * Determines whether the row will be selectable.\n     */\n    set isRowSelectable(fn) {\n      if (isDevMode() && typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('isRowSelectable', fn));\n      }\n      this._isRowSelectable = fn;\n    }\n    get isRowSelectable() {\n      return this._isRowSelectable;\n    }\n    /**\n     * Defines a function that determines the selected state of a data cell.\n     * Returns an object with `selected` and `item` properties.\n     * The cell is marked as selected only if the `selected` property equals `true`.\n     *\n     * The function is executed for each data cell and may be called more than once\n     * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))\n     */\n    set cellSelected(fn) {\n      if (isDevMode() && typeof fn !== 'function') {\n        throw new Error(GridConfigurationErrorMessages.functionType('cellSelected', fn));\n      }\n      this._cellSelected = fn;\n    }\n    get cellSelected() {\n      return this._cellSelected;\n    }\n    /**\n     * Returns the currently focused cell (if any).\n     */\n    get activeCell() {\n      return this.navigationService.activeCell;\n    }\n    /**\n     * Returns the currently focused row (if any).\n     */\n    get activeRow() {\n      return this.navigationService.activeRow;\n    }\n    /**\n     * Returns the current Grid selection.\n     *\n     * @hidden\n     */\n    get selection() {\n      return this.selectable || this.selectionDirective ? this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() : [];\n    }\n    /**\n     * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells\n     * ([see example]({% slug resizing_columns_grid %})).\n     *\n     * @default false\n     */\n\n    /**\n     * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug binding_grid %})).\n     *\n     * @default false\n     */\n    set loading(value) {\n      this._loading = value;\n      this.rowReorderable && this.notifyReorderContainers();\n    }\n    get loading() {\n      return this._loading;\n    }\n    /**\n     * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).\n     *\n     * @default false\n     */\n\n    get dir() {\n      return this.direction;\n    }\n    get sizeSmallClass() {\n      return this.size === 'small';\n    }\n    get sizeMediumClass() {\n      return this.size === 'medium' || !this.size;\n    }\n    get lockedClasses() {\n      return this.lockedLeafColumns.length > 0;\n    }\n    get virtualClasses() {\n      return this.isVirtual;\n    }\n    get noScrollbarClass() {\n      return this.scrollbarWidth === 0;\n    }\n    get isResizable() {\n      return Boolean(this.gridResizable);\n    }\n    get minWidth() {\n      return this.gridResizable.minWidth;\n    }\n    get maxWidth() {\n      return this.gridResizable.maxWidth;\n    }\n    get minHeight() {\n      return this.gridResizable.minHeight;\n    }\n    get maxHeight() {\n      return this.gridResizable.maxHeight;\n    }\n    get detailTemplate() {\n      if (this._customDetailTemplate) {\n        return this._customDetailTemplate;\n      }\n      return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;\n    }\n    set detailTemplate(detailTemplate) {\n      this._customDetailTemplate = detailTemplate;\n    }\n    get cellLoadingTemplate() {\n      if (this._cellLoadingTemplate) {\n        return this._customDetailTemplate;\n      }\n      return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : undefined;\n    }\n    set cellLoadingTemplate(cellLoadingTemplate) {\n      this._cellLoadingTemplate = cellLoadingTemplate;\n    }\n    get loadingTemplate() {\n      if (this._loadingTemplate) {\n        return this._loadingTemplate;\n      }\n      return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : undefined;\n    }\n    set loadingTemplate(loadingTemplate) {\n      this._loadingTemplate = loadingTemplate;\n    }\n    get statusBarTemplate() {\n      if (this._statusBarTemplate) {\n        return this._statusBarTemplate;\n      }\n      return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : undefined;\n    }\n    set statusBarTemplate(statusBarTemplate) {\n      this._statusBarTemplate = statusBarTemplate;\n    }\n    get noRecordsTemplate() {\n      if (this._customNoRecordsTemplate) {\n        return this._customNoRecordsTemplate;\n      }\n      return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;\n    }\n    set noRecordsTemplate(customNoRecordsTemplate) {\n      this._customNoRecordsTemplate = customNoRecordsTemplate;\n    }\n    get pagerTemplate() {\n      if (this._customPagerTemplate) {\n        return this._customPagerTemplate;\n      }\n      return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;\n    }\n    set pagerTemplate(customPagerTemplate) {\n      this._customPagerTemplate = customPagerTemplate;\n    }\n    get toolbarTemplate() {\n      if (this._customToolbarTemplate) {\n        return this._customToolbarTemplate;\n      }\n      return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;\n    }\n    set toolbarTemplate(customToolbarTemplate) {\n      this._customToolbarTemplate = customToolbarTemplate;\n    }\n    get scrollbarWidth() {\n      return this.supportService.scrollbarWidth;\n    }\n    get headerPadding() {\n      if (isUniversal()) {\n        return '';\n      }\n      const padding = Math.max(0, this.scrollbarWidth) + 'px';\n      const right = this.rtl ? 0 : padding;\n      const left = this.rtl ? padding : 0;\n      return `0 ${right} 0 ${left}`;\n    }\n    get hasGroupFooters() {\n      return this.columnsContainer.hasGroupFooter;\n    }\n    get showFooter() {\n      return this.columnsContainer.hasFooter;\n    }\n    get showGroupFooters() {\n      return this.groupable && this.groupable.showFooter;\n    }\n    get ariaRowCount() {\n      return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);\n    }\n    get ariaColCount() {\n      return this.columnsContainer.leafColumnsToRender.length;\n    }\n    get navigation() {\n      return this.navigationService;\n    }\n    get isVirtual() {\n      return this.scrollable === 'virtual';\n    }\n    get isScrollable() {\n      return this.scrollable !== 'none';\n    }\n    get visibleColumns() {\n      return this.columnsContainer.allColumns;\n    }\n    get lockedColumns() {\n      return this.columnsContainer.lockedColumns;\n    }\n    get nonLockedColumns() {\n      return this.columnsContainer.nonLockedColumns;\n    }\n    get lockedLeafColumns() {\n      return this.columnsContainer.lockedLeafColumns;\n    }\n    get stickyColumns() {\n      return this.columns.filter(column => column.sticky);\n    }\n    get nonLockedLeafColumns() {\n      return this.columnsContainer.nonLockedLeafColumns;\n    }\n    get leafColumns() {\n      return this.columnsContainer.leafColumns;\n    }\n    get totalColumnLevels() {\n      return this.columnsContainer.totalLevels;\n    }\n    get headerColumns() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.viewportColumns;\n      }\n      return this.nonLockedColumns;\n    }\n    get headerLeafColumns() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.leafViewportColumns;\n      }\n      return this.nonLockedLeafColumns;\n    }\n    get lockedWidth() {\n      const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;\n      return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n    get nonLockedWidth() {\n      if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {\n        return !this.virtualColumns ? this.columnsContainer.unlockedWidth : this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);\n      }\n      return undefined;\n    }\n    get selectableSettings() {\n      if (this.selectionService) {\n        return this.selectionService.options;\n      }\n      return undefined;\n    }\n    get columnMenuTemplate() {\n      const template = this.columnMenuTemplates.first;\n      return template ? template.templateRef : null;\n    }\n    get totalCount() {\n      if (this.isVirtual || !isPresent(this.pageSize)) {\n        return this.view.total;\n      }\n      return this.pageSize;\n    }\n    /**\n     * @hidden\n     */\n    getDefaultSelectors(type) {\n      return this.rowReorderService.defaultSelectors[type];\n    }\n    /**\n     * @hidden\n     */\n    getHintSettings(type) {\n      return this.rowReorderService[type];\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, rowReorderService) {\n      _defineProperty(this, \"supportService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"cellSelectionService\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"groupInfoService\", void 0);\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"changeNotification\", void 0);\n      _defineProperty(this, \"detailsService\", void 0);\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"filterService\", void 0);\n      _defineProperty(this, \"pdfService\", void 0);\n      _defineProperty(this, \"responsiveService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"excelService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"scrollSyncService\", void 0);\n      _defineProperty(this, \"domEvents\", void 0);\n      _defineProperty(this, \"columnResizingService\", void 0);\n      _defineProperty(this, \"changeDetectorRef\", void 0);\n      _defineProperty(this, \"columnReorderService\", void 0);\n      _defineProperty(this, \"columnInfoService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"sortService\", void 0);\n      _defineProperty(this, \"scrollRequestService\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      _defineProperty(this, \"sizingService\", void 0);\n      _defineProperty(this, \"rowReorderService\", void 0);\n      _defineProperty(this, \"pageSize\", void 0);\n      /**\n       * Defines the height (in pixels) that is used when the `scrollable` option of the Grid is set.\n       * To set the height of the Grid, you can also use `style.height`. The `style.height`\n       * option supports units such as `px`, `%`, `em`, `rem`, and others.\n       */\n      _defineProperty(this, \"height\", void 0);\n      /**\n       * Represent the actual height of each Grid row (`tr`) element in the DOM.\n       * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).\n       * Set the `rowHeight` option to the exact pixels as the height of the `tr` element appears in the DOM.\n       */\n      _defineProperty(this, \"rowHeight\", void 0);\n      /**\n       * Represent the actual height of each Grid detail row (`tr`) element in the DOM.\n       * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).\n       * Set the `detailRowHeight` option to the exact pixels as the height of the detail Grid `tr` element appears in the DOM.\n       */\n      _defineProperty(this, \"detailRowHeight\", void 0);\n      _defineProperty(this, \"scrollable\", 'scrollable');\n      /**\n       * Enables the [single-row selection](slug:grid_row_selection) of the Grid.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"selectable\", false);\n      _defineProperty(this, \"trackBy\", defaultTrackBy);\n      /**\n       * The descriptor by which the data will be filtered ([see examples]({% slug filtering_grid %})).\n       */\n      _defineProperty(this, \"filter\", void 0);\n      _defineProperty(this, \"virtualColumns\", false);\n      _defineProperty(this, \"gridData\", () => {\n        return this.flatData;\n      });\n      /**\n       * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.\n       * @default false\n       */\n      _defineProperty(this, \"filterable\", false);\n      /**\n       * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.\n       * @default false\n       */\n      _defineProperty(this, \"sortable\", false);\n      /**\n       * Configures the pager of the Grid ([see example](slug:paging_grid_settings)).\n       * @default false\n       */\n      _defineProperty(this, \"pageable\", false);\n      _defineProperty(this, \"groupable\", false);\n      /**\n       * Determines whether the Grid can be resized.\n       * @default false\n       */\n      _defineProperty(this, \"gridResizable\", false);\n      _defineProperty(this, \"autoSize\", false);\n      _defineProperty(this, \"resizable\", false);\n      /**\n       * If set to `true`, the user can reorder columns by dragging their header cells\n       * ([see example]({% slug reordering_columns_grid %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"reorderable\", false);\n      _defineProperty(this, \"columnMenu\", false);\n      /**\n       * Specifies if the header of the grid will be hidden. The header is visible by default.\n       * The header includes column headers and the [filter row](slug:filter_row).\n       * @default false\n       */\n      _defineProperty(this, \"hideHeader\", false);\n      /**\n       * Fires when the Grid filter is modified through the UI.\n       * You have to handle the event yourself and filter the data.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).\n       * You have to handle the event yourself and page the data.\n       */\n      _defineProperty(this, \"pageChange\", new EventEmitter());\n      /**\n       * Fires when the grouping of the Grid is changed.\n       * You have to handle the event yourself and group the data ([see example]({% slug grouping_grid %})).\n       */\n      _defineProperty(this, \"groupChange\", void 0);\n      /**\n       * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).\n       * You have to handle the event yourself and sort the data.\n       */\n      _defineProperty(this, \"sortChange\", new EventEmitter());\n      /**\n       * Fires when the user selects a Grid row.\n       */\n      _defineProperty(this, \"selectionChange\", new EventEmitter());\n      /**\n       * Fires when the user drops the dragged row and reordering is performed.\n       */\n      _defineProperty(this, \"rowReorder\", new EventEmitter());\n      /**\n       * Fires when the data state of the Grid is changed.\n       */\n      _defineProperty(this, \"dataStateChange\", new EventEmitter());\n      /**\n       * Fires when the user expands a group header.\n       */\n      _defineProperty(this, \"groupExpand\", new EventEmitter());\n      /**\n       * Fires when the user collapses a group header.\n       */\n      _defineProperty(this, \"groupCollapse\", new EventEmitter());\n      /**\n       * Fires when the user expands a master row.\n       */\n      _defineProperty(this, \"detailExpand\", new EventEmitter());\n      /**\n       * Fires when the user collapses a master row.\n       */\n      _defineProperty(this, \"detailCollapse\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Edit** command button to edit a row\n       * ([see example])({% slug inline_editing_grid %}#toc-editing-records-1).\n       */\n      _defineProperty(this, \"edit\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Cancel** command button to close a row\n       * ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).\n       */\n      _defineProperty(this, \"cancel\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Save** command button to save changes in a row\n       * ([see example]({% slug inline_editing_grid %}#toc-saving-records-1)).\n       */\n      _defineProperty(this, \"save\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Remove** command button to remove a row\n       * ([see example]({% slug inline_editing_grid %}#toc-removing-records-1)).\n       */\n      _defineProperty(this, \"remove\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Add** command button to add a new row\n       * ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).\n       */\n      _defineProperty(this, \"add\", new EventEmitter());\n      /**\n       * Fires when the user leaves an edited cell ([see example](slug:editing_incell_grid)).\n       */\n      _defineProperty(this, \"cellClose\", new EventEmitter());\n      /**\n       * Fires when the user clicks a cell ([see example](slug:editing_incell_grid)).\n       */\n      _defineProperty(this, \"cellClick\", void 0);\n      /**\n       * Fires when the user clicks the **Export to PDF** command button.\n       */\n      _defineProperty(this, \"pdfExport\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Export to Excel** command button.\n       */\n      _defineProperty(this, \"excelExport\", new EventEmitter());\n      /**\n       * Fires when the user completes the resizing of the column.\n       */\n      _defineProperty(this, \"columnResize\", void 0);\n      /**\n       * Fires when the user completes the reordering of the column.\n       */\n      _defineProperty(this, \"columnReorder\", new EventEmitter());\n      /**\n       * Fires when the user changes the visibility of the columns from the column menu or column chooser.\n       */\n      _defineProperty(this, \"columnVisibilityChange\", new EventEmitter());\n      /**\n       * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.\n       */\n      _defineProperty(this, \"columnLockedChange\", new EventEmitter());\n      /**\n       * Fires when the user changes the sticky state of the columns from the column menu.\n       */\n      _defineProperty(this, \"columnStickyChange\", new EventEmitter());\n      /**\n       * Fires when the user scrolls to the last record on the page and enables endless scrolling\n       * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).\n       * You have to handle the event yourself and page the data.\n       */\n      _defineProperty(this, \"scrollBottom\", new EventEmitter());\n      /**\n       * Fires when the grid content is scrolled.\n       * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.\n       */\n      _defineProperty(this, \"contentScroll\", new EventEmitter());\n      /**\n       * A query list of all declared columns.\n       */\n      _defineProperty(this, \"columns\", new QueryList());\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"detailTemplateChildren\", void 0);\n      _defineProperty(this, \"cellLoadingTemplateChildren\", void 0);\n      _defineProperty(this, \"loadingTemplateChildren\", void 0);\n      _defineProperty(this, \"statusBarTemplateChildren\", void 0);\n      _defineProperty(this, \"noRecordsTemplateChildren\", void 0);\n      _defineProperty(this, \"pagerTemplateChildren\", void 0);\n      _defineProperty(this, \"toolbarTemplateChildren\", void 0);\n      _defineProperty(this, \"columnMenuTemplates\", void 0);\n      _defineProperty(this, \"lockedHeader\", void 0);\n      _defineProperty(this, \"header\", void 0);\n      _defineProperty(this, \"footer\", new QueryList());\n      _defineProperty(this, \"ariaRoot\", void 0);\n      _defineProperty(this, \"dragTargetContainer\", void 0);\n      _defineProperty(this, \"dropTargetContainer\", void 0);\n      _defineProperty(this, \"columnMenuOptions\", void 0);\n      _defineProperty(this, \"columnList\", void 0);\n      _defineProperty(this, \"selectionDirective\", false);\n      _defineProperty(this, \"ariaRootId\", `k-${guid()}`);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"columnsContainer\", new ColumnsContainer(() => this.columnList.filterHierarchy(column => {\n        if (!isUniversal()) {\n          column.matchesMedia = this.matchesMedia(column);\n        }\n        return column.isVisible;\n      })));\n      _defineProperty(this, \"view\", new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters)));\n      _defineProperty(this, \"shouldGenerateColumns\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"notifyTimeout\", null);\n      _defineProperty(this, \"_sort\", new Array());\n      _defineProperty(this, \"_group\", new Array());\n      _defineProperty(this, \"_skip\", 0);\n      _defineProperty(this, \"_data\", []);\n      _defineProperty(this, \"cachedWindowWidth\", 0);\n      _defineProperty(this, \"defaultSelection\", void 0);\n      _defineProperty(this, \"_rowSelected\", null);\n      _defineProperty(this, \"_isRowSelectable\", null);\n      _defineProperty(this, \"_cellSelected\", null);\n      _defineProperty(this, \"_customDetailTemplate\", void 0);\n      _defineProperty(this, \"_cellLoadingTemplate\", void 0);\n      _defineProperty(this, \"_loadingTemplate\", void 0);\n      _defineProperty(this, \"_statusBarTemplate\", void 0);\n      _defineProperty(this, \"_customNoRecordsTemplate\", void 0);\n      _defineProperty(this, \"_customPagerTemplate\", void 0);\n      _defineProperty(this, \"_customToolbarTemplate\", void 0);\n      _defineProperty(this, \"_rowReorderable\", false);\n      _defineProperty(this, \"leafViewportColumns\", void 0);\n      _defineProperty(this, \"viewportColumns\", void 0);\n      _defineProperty(this, \"_navigable\", []);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_loading\", false);\n      _defineProperty(this, \"blockArrowSelection\", false);\n      _defineProperty(this, \"selectionSubscription\", void 0);\n      _defineProperty(this, \"stateChangeSubscription\", void 0);\n      _defineProperty(this, \"groupExpandCollapseSubscription\", void 0);\n      _defineProperty(this, \"editServiceSubscription\", void 0);\n      _defineProperty(this, \"detailsServiceSubscription\", void 0);\n      _defineProperty(this, \"filterSubscription\", void 0);\n      _defineProperty(this, \"sortSubscription\", void 0);\n      _defineProperty(this, \"columnsChangeSubscription\", void 0);\n      _defineProperty(this, \"pdfSubscription\", void 0);\n      _defineProperty(this, \"excelSubscription\", void 0);\n      _defineProperty(this, \"columnsContainerChangeSubscription\", void 0);\n      _defineProperty(this, \"cellClickSubscription\", void 0);\n      _defineProperty(this, \"footerChangeSubscription\", void 0);\n      _defineProperty(this, \"columnResizingSubscription\", void 0);\n      _defineProperty(this, \"columnReorderSubscription\", void 0);\n      _defineProperty(this, \"detachElementEventHandlers\", void 0);\n      _defineProperty(this, \"localizationSubscription\", void 0);\n      _defineProperty(this, \"columnVisibilityChangeSubscription\", void 0);\n      _defineProperty(this, \"columnLockedChangeSubscription\", void 0);\n      _defineProperty(this, \"columnStickyChangeSubscription\", void 0);\n      _defineProperty(this, \"focusElementSubscription\", void 0);\n      _defineProperty(this, \"columnRangeChangeSubscription\", void 0);\n      _defineProperty(this, \"rowReorderSubscription\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      _defineProperty(this, \"_rowSticky\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"messageFor\", token => this.localization.get(token));\n      _defineProperty(this, \"_rowClass\", () => null);\n      this.supportService = supportService;\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.wrapper = wrapper;\n      this.groupInfoService = groupInfoService;\n      this.groupsService = groupsService;\n      this.changeNotification = changeNotification;\n      this.detailsService = detailsService;\n      this.editService = editService;\n      this.filterService = filterService;\n      this.pdfService = pdfService;\n      this.responsiveService = responsiveService;\n      this.renderer = renderer;\n      this.excelService = excelService;\n      this.ngZone = ngZone;\n      this.scrollSyncService = scrollSyncService;\n      this.domEvents = domEvents;\n      this.columnResizingService = columnResizingService;\n      this.changeDetectorRef = changeDetectorRef;\n      this.columnReorderService = columnReorderService;\n      this.columnInfoService = columnInfoService;\n      this.navigationService = navigationService;\n      this.sortService = sortService;\n      this.scrollRequestService = scrollRequestService;\n      this.localization = localization;\n      this.ctx = ctx;\n      this.sizingService = sizingService;\n      this.rowReorderService = rowReorderService;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      this.ctx.grid = this;\n      this.groupChange = new ZoneAwareEventEmitter(this.ngZone);\n      this.cellClick = new ZoneAwareEventEmitter(this.ngZone);\n      this.columnResize = new ZoneAwareEventEmitter(this.ngZone);\n      this.localizationSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n      this.groupInfoService.registerColumnsContainer(() => this.columnList);\n      this.columnInfoService.init(this.columnsContainer, () => this.columnList);\n      this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe(changed => {\n        this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));\n      });\n      this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe(changed => {\n        this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));\n      });\n      this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe(changed => {\n        this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));\n      });\n      this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({\n        group,\n        groupIndex,\n        parentGroup\n      }) => ({\n        group,\n        groupIndex,\n        parentGroup\n      }));\n      this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, args => args);\n      this.filterSubscription = this.filterService.changes.subscribe(x => {\n        this.filterChange.emit(x);\n      });\n      this.sortSubscription = this.sortService.changes.subscribe(x => {\n        this.sortChange.emit(x);\n      });\n      this.attachStateChangesEmitter();\n      this.attachEditHandlers();\n      this.attachDomEventHandlers();\n      this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));\n      this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));\n      this.columnsContainerChange();\n      this.handleColumnResize();\n      this.columnList = new ColumnList(this.columns);\n      this.columnReorderSubscription = this.columnReorderService.changes.subscribe(this.reorder.bind(this));\n      this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));\n    }\n    /**\n     * Expands the specified master row ([see example]({% slug hierarchy_grid %})).\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded state internally using the data row index.\n     *\n     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})\n     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})\n     * for examples on how to control the expanded state.\n     *\n     * @param index - The data row index of the master row.\n     */\n    expandRow(index) {\n      this.toggleDetailRowLegacy(index, true);\n    }\n    /**\n     * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded state internally using the data row index.\n     *\n     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})\n     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})\n     * for examples on how to control the expanded state.\n     *\n     * @param index - The data row index of the master row.\n     */\n    collapseRow(index) {\n      this.toggleDetailRowLegacy(index, false);\n    }\n    /**\n     * Expands a group header item for the given index. For example,\n     * `0_1` expands the second inner group of the first master group.\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded group state internally using the hierarchical group index.\n     *\n     * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n    expandGroup(index) {\n      this.toggleGroupRowLegacy(index, true);\n    }\n    /**\n     * Collapses a group header item for the given index. For example,\n     * `0_1` collapses the second inner group of the first master group.\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded group state internally using the hierarchical group index.\n     *\n     * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n    collapseGroup(index) {\n      this.toggleGroupRowLegacy(index, false);\n    }\n    /**\n     * @hidden\n     */\n    resetGroupsState() {\n      this.groupsService.reset();\n    }\n    /**\n     * @hidden\n     */\n    onDataChange() {\n      this.autoGenerateColumns();\n      this.changeNotification.notify();\n      this.pdfService.dataChanged.emit();\n      if (isPresent(this.defaultSelection)) {\n        this.defaultSelection.reset();\n      }\n      this.initSelectionService();\n      this.updateNavigationMetadata();\n    }\n    ngOnChanges(changes) {\n      if (isChanged$1(\"data\", changes)) {\n        this.onDataChange();\n      }\n      if (this.lockedLeafColumns.length && anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\"], changes)) {\n        this.changeNotification.notify();\n      }\n      if (anyChanged([\"pageSize\", \"scrollable\", 'virtualColumns'], changes)) {\n        this.updateNavigationMetadata();\n      }\n      if (isChanged$1(\"virtualColumns\", changes)) {\n        this.viewportColumns = this.leafViewportColumns = null;\n      }\n      if (isChanged$1(\"height\", changes, false)) {\n        this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);\n      }\n      if (isChanged$1(\"filterable\", changes) && this.lockedColumns.length) {\n        this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));\n      }\n      if (anyChanged([\"columnMenu\", \"sortable\", \"filterable\"], changes, false)) {\n        this.columnMenuOptions = this.columnMenu && Object.assign({\n          filter: Boolean(this.filterable),\n          sort: Boolean(this.sortable)\n        }, this.columnMenu);\n      }\n      if (isChanged$1(\"scrollable\", changes) && this.isScrollable) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());\n      }\n      if (isChanged$1(\"selectable\", changes) && this.shouldResetSelection(changes['selectable'])) {\n        if (this.defaultSelection) {\n          this.defaultSelection.reset();\n        } else if (this.selectionDirective) {\n          this.selectionDirective.reset();\n        }\n      }\n      if (isChanged$1('groupable', changes, true)) {\n        this.groupable = changes['groupable'].currentValue;\n      }\n      if (isChanged$1('navigable', changes, true)) {\n        if (this.navigationService.enabled) {\n          this.navigationService.setActiveSections(this.navigable);\n        } else {\n          if (this.navigable.length) {\n            this.navigationService.init(this.navigationMetadata(), this.navigable);\n          }\n        }\n      }\n    }\n    ngAfterContentInit() {\n      this.shouldGenerateColumns = !this.columns.length;\n      this.autoGenerateColumns();\n      this.columnList = new ColumnList(this.columns);\n      this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());\n    }\n    ngAfterViewInit() {\n      this.attachScrollSync();\n      this.attachElementEventHandlers();\n      this.updateNavigationMetadata();\n      this.applyAutoSize();\n      const toolbarComponentWrapper = this.wrapper?.nativeElement?.querySelector('kendo-toolbar');\n      if (toolbarComponentWrapper) {\n        this.renderer.addClass(toolbarComponentWrapper, 'k-grid-toolbar');\n      }\n    }\n    ngAfterContentChecked() {\n      this.columnsContainer.refresh();\n      this.verifySettings();\n      this.initSelectionService();\n    }\n    ngOnInit() {\n      if (this.navigable.length) {\n        this.navigationService.init(this.navigationMetadata(), this.navigable);\n      }\n    }\n    ngOnDestroy() {\n      if (this.selectionSubscription) {\n        this.selectionSubscription.unsubscribe();\n      }\n      if (this.stateChangeSubscription) {\n        this.stateChangeSubscription.unsubscribe();\n      }\n      if (this.groupExpandCollapseSubscription) {\n        this.groupExpandCollapseSubscription.unsubscribe();\n      }\n      if (this.detailsServiceSubscription) {\n        this.detailsServiceSubscription.unsubscribe();\n      }\n      if (this.editServiceSubscription) {\n        this.editServiceSubscription.unsubscribe();\n      }\n      if (this.pdfSubscription) {\n        this.pdfSubscription.unsubscribe();\n      }\n      if (this.filterSubscription) {\n        this.filterSubscription.unsubscribe();\n      }\n      if (this.sortSubscription) {\n        this.sortSubscription.unsubscribe();\n      }\n      if (this.columnsChangeSubscription) {\n        this.columnsChangeSubscription.unsubscribe();\n      }\n      if (this.excelSubscription) {\n        this.excelSubscription.unsubscribe();\n      }\n      if (this.columnsContainerChangeSubscription) {\n        this.columnsContainerChangeSubscription.unsubscribe();\n      }\n      if (this.scrollSyncService) {\n        this.scrollSyncService.destroy();\n      }\n      if (this.detachElementEventHandlers) {\n        this.detachElementEventHandlers();\n      }\n      if (this.defaultSelection) {\n        this.defaultSelection.destroy();\n      }\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n      }\n      if (this.footerChangeSubscription) {\n        this.footerChangeSubscription.unsubscribe();\n      }\n      this.ngZone = null;\n      if (this.columnResizingSubscription) {\n        this.columnResizingSubscription.unsubscribe();\n      }\n      if (this.columnReorderSubscription) {\n        this.columnReorderSubscription.unsubscribe();\n      }\n      if (this.localizationSubscription) {\n        this.localizationSubscription.unsubscribe();\n      }\n      if (this.columnVisibilityChangeSubscription) {\n        this.columnVisibilityChangeSubscription.unsubscribe();\n      }\n      if (this.columnLockedChangeSubscription) {\n        this.columnLockedChangeSubscription.unsubscribe();\n      }\n      if (this.columnStickyChangeSubscription) {\n        this.columnStickyChangeSubscription.unsubscribe();\n      }\n      if (this.focusElementSubscription) {\n        this.focusElementSubscription.unsubscribe();\n      }\n      if (this.rowReorderSubscription) {\n        this.rowReorderSubscription.unsubscribe();\n      }\n      this.columnRangeChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    attachScrollSync() {\n      if (isUniversal()) {\n        return;\n      }\n      if (this.header) {\n        this.scrollSyncService.registerEmitter(this.header.nativeElement, \"header\");\n      }\n      if (this.footer) {\n        this.footerChangeSubscription = observe(this.footer).subscribe(footers => footers.map(footer => footer.nativeElement).filter(isPresent).forEach(element => {\n          this.scrollSyncService.registerEmitter(element, \"footer\");\n          // sync footers and content scroll positions when footer visibility is changed dynamically\n          element.scrollLeft = this.wrapper.nativeElement.querySelector('.k-grid-content')?.scrollLeft;\n        }));\n      }\n    }\n    /**\n     * @hidden\n     */\n    get ariaLabel() {\n      return this.localization.get('gridLabel');\n    }\n    /**\n     * Switches the specified table row in the edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).\n     *\n     * @param rowIndex - The data row index that will be switched in the edit mode.\n     * @param group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])\n     * that describes the edit form.\n     * @param options - Additional options configuring the focus target once the editor opens.\n     */\n    editRow(rowIndex, group, options) {\n      this.editService.editRow(rowIndex, group);\n      if (isPresent(options) && options.skipFocus) {\n        return;\n      }\n      const row = `tr[data-kendo-grid-item-index=\"${rowIndex}\"]`;\n      const columnIndex = options && options.columnIndex;\n      const target = isNaN(columnIndex) ? row : `${row} td[data-kendo-grid-column-index=\"${columnIndex}\"]`;\n      this.focusEditElement(target);\n    }\n    /**\n     * Closes the editor for a given row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).\n     *\n     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed\n     * that the new item editor will be closed.\n     */\n    closeRow(index) {\n      this.editService.close(index);\n    }\n    /**\n     * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).\n     *\n     * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi']) that describes\n     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.\n     */\n    addRow(group) {\n      const isFormGroup = group instanceof FormGroup;\n      if (!isFormGroup) {\n        const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?\n        group = new FormGroup(fields);\n      }\n      this.editService.addRow(group);\n      this.focusEditElement('.k-grid-add-row');\n    }\n    /**\n     * Puts the cell that is specified by the table row and column in edit mode ([see example](slug:editing_incell_grid)).\n     *\n     * @param {number} rowIndex - The data row index that will be switched in the edit mode.\n     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.\n     * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])\n     * that describes the edit form.\n     */\n    editCell(rowIndex, column, group) {\n      const instance = this.columnInstance(column);\n      this.editService.editCell(rowIndex, instance, group);\n      this.focusEditElement('.k-grid-edit-cell');\n    }\n    /**\n     * Closes the current cell in edit mode and fires\n     * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.\n     *\n     * @return {boolean} Indicates whether the edited cell was closed.\n     * A `false` value indicates that the\n     * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.\n     */\n    closeCell() {\n      return !this.editService.closeCell();\n    }\n    /**\n     * Closes the current cell in edit mode.\n     */\n    cancelCell() {\n      this.editService.cancelCell();\n    }\n    /**\n     * Returns a flag which indicates if a row or a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a row or a cell is currently edited.\n     */\n    isEditing() {\n      return this.editService.isEditing();\n    }\n    /**\n     * Returns a flag which indicates if a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a cell is currently being edited.\n     */\n    isEditingCell() {\n      return this.editService.isEditingCell();\n    }\n    /**\n     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).\n     */\n    saveAsPDF() {\n      this.pdfService.save(this);\n    }\n    /**\n     * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.\n     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).\n     *\n     * @return {Promise} A promise that will be resolved with the Drawing `Group`.\n     */\n    drawPDF() {\n      const promise = createPromise();\n      this.pdfService.draw(this, promise);\n      return promise;\n    }\n    /**\n     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).\n     */\n    saveAsExcel() {\n      this.excelService.save(this);\n    }\n    /**\n     * Applies the minimum possible width for the specified column,\n     * so that the whole text fits without wrapping. This method expects the Grid\n     * to be [resizable](slug:resizing_columns_grid). The method must be executed\n     * after the Grid is already populated with data.\n     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)\n     */\n    autoFitColumn(column) {\n      this.columnResizingService.autoFit(column);\n    }\n    /**\n     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.\n     * If no columns are specified, `autoFitColumns` is applied to all columns.The method must be executed\n     * after the Grid is already populated with data.\n     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)\n     *\n     */\n    autoFitColumns(columns = this.columns) {\n      let cols;\n      if (columns instanceof QueryList) {\n        cols = columns.toArray();\n      } else {\n        cols = columns;\n      }\n      this.columnResizingService.autoFit(...cols);\n    }\n    /**\n     * @hidden\n     */\n    notifyPageChange(source, event) {\n      if (source === \"list\" && !this.isVirtual) {\n        return;\n      }\n      this.pageChange.emit(event);\n    }\n    /**\n     * @hidden\n     */\n    notifyScrollBottom() {\n      if (this.scrollable === 'none') {\n        return;\n      }\n      if (hasObservers(this.scrollBottom)) {\n        this.ngZone.run(() => this.scrollBottom.emit({\n          sender: this\n        }));\n      }\n    }\n    /**\n     * @hidden\n     */\n    focusEditElement(containerSelector) {\n      if (this.focusElementSubscription) {\n        this.focusElementSubscription.unsubscribe();\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          const wrapper = this.wrapper.nativeElement;\n          if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {\n            this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));\n          }\n          this.focusElementSubscription = null;\n        });\n      });\n    }\n    /**\n     * Focuses the last active or the first cell of the Grid.\n     *\n     * @returns {NavigationCell} The focused cell.\n     */\n    focus() {\n      this.assertNavigable();\n      return this.navigationService.focusCell();\n    }\n    /**\n     * Focuses the cell with the specified row and column index.\n     *\n     * The row index is based on the logical structure of the Grid and does not correspond to the data item index.\n     * Header rows are included, starting at index 0.\n     * Group headers and footers are included.\n     * The row indexing is absolute and does not change with paging.\n     *\n     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.\n     * If the row is not present on the current page, the method will have no effect.\n     *\n     * @param rowIndex - The logical row index to focus. The top header row has an index 0.\n     * @param colIndex - The column index to focus.\n     * @returns {NavigationCell} The focused cell.\n     *\n     */\n    focusCell(rowIndex, colIndex) {\n      this.assertNavigable();\n      return this.navigationService.focusCell(rowIndex, colIndex);\n    }\n    /**\n     * Focuses the next cell, optionally wrapping to the next row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.\n     */\n    focusNextCell(wrap = true) {\n      this.assertNavigable();\n      return this.navigationService.focusNextCell(wrap);\n    }\n    /**\n     * Focuses the previous cell. Optionally wraps to the previous row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.\n     */\n    focusPrevCell(wrap = true) {\n      this.assertNavigable();\n      return this.navigationService.focusPrevCell(wrap);\n    }\n    /**\n     * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).\n     */\n    scrollTo(request) {\n      this.scrollRequestService.scrollTo(request, false);\n    }\n    /**\n     * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).\n     */\n    scrollToItem(request) {\n      this.scrollRequestService.scrollToItem(request);\n    }\n    /**\n     * Changes the position of the specified column.\n     * The reordering of columns operates only on the level\n     * which is inferred by the source column.\n     * For the `reorderColumn` method to work properly,\n     * the `source` column has to be visible.\n     *\n     * @param {ColumnBase} source - The column whose position will be changed.\n     * @param {number} destIndex - The new position of the column.\n     * @param {ColumnReorderConfig} options - Additional options.\n     *\n     */\n    reorderColumn(source, destIndex, options = {\n      before: false\n    }) {\n      const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));\n      let target = columnsForLevel[destIndex];\n      if (!target) {\n        return;\n      }\n      const lastNonLocked = target.isLocked && !source.isLocked && this.columnsContainer.nonLockedColumns.length === 1;\n      if (lastNonLocked) {\n        return;\n      }\n      if (isSpanColumnComponent(target) && !options.before) {\n        target = target.childColumns.last;\n      }\n      this.reorder({\n        before: options.before,\n        source: source,\n        target: target\n      });\n    }\n    /**\n     * A function which determines if a specific row is expanded.\n     */\n    set isDetailExpanded(callback) {\n      this.detailsService.userCallback = callback;\n    }\n    get isDetailExpanded() {\n      return this.detailsService.userCallback;\n    }\n    /**\n     * A function which determines if a specific group row is expanded.\n     */\n    set isGroupExpanded(callback) {\n      this.groupsService.userCallback = callback;\n      this.groupable = isPresent(callback);\n    }\n    get isGroupExpanded() {\n      return this.groupsService.userCallback;\n    }\n    /**\n     * @hidden\n     */\n    handleReorderEvents(ev, evType) {\n      this.rowReorderService[evType](ev);\n    }\n    /**\n     * @hidden\n     */\n    get flatData() {\n      return isArray(this.data) ? this.data : this.data.data;\n    }\n    /**\n     * @hidden\n     */\n    updateNavigationMetadata() {\n      this.navigationService.metadata = this.navigationMetadata();\n    }\n    /**\n     * @hidden\n     */\n    reorder({\n      target,\n      source,\n      before,\n      changeContainer\n    }) {\n      this.ngZone.run(() => {\n        const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));\n        let newIndex = columnsForLevel.indexOf(target);\n        if (target.parent && target.parent.isSpanColumn) {\n          newIndex = columnsForLevel.indexOf(target.parent);\n          if (before) {\n            target = target.parent;\n          }\n        }\n        const oldIndex = columnsForLevel.indexOf(source);\n        if (changeContainer) {\n          if (before && 0 < newIndex && oldIndex < newIndex) {\n            // dropped before the first not locked column\n            newIndex--;\n          } else if (!before && oldIndex > newIndex) {\n            // dropped after the last locked column\n            newIndex++;\n          }\n        }\n        const args = new ColumnReorderEvent({\n          column: source,\n          oldIndex: oldIndex,\n          newIndex: newIndex\n        });\n        this.columnReorder.emit(args);\n        if (args.isDefaultPrevented()) {\n          return;\n        }\n        if (changeContainer) {\n          this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));\n        }\n        this.updateColumnIndices({\n          columnsForLevel,\n          source,\n          target,\n          before\n        });\n        if (source.locked !== target.locked) {\n          source.locked = target.locked;\n        }\n        this.columnsContainer.refresh();\n        this.changeDetectorRef.markForCheck();\n      });\n    }\n    updateColumnIndices({\n      columnsForLevel,\n      source,\n      target,\n      before\n    }) {\n      const expandedColumns = expandColumnsWithSpan(columnsForLevel);\n      const sourceColumnIndex = expandedColumns.indexOf(source);\n      let nextSourceIndex = 0;\n      let nextIndex = 0;\n      let toSkip = 1;\n      // Possible only when called from the API.\n      if (source.isSpanColumn) {\n        toSkip += source.childColumns.length;\n      }\n      let i = 0;\n      while (i < expandedColumns.length) {\n        const column = expandedColumns[i];\n        if (column === target) {\n          nextSourceIndex = before ? nextIndex : nextIndex + 1;\n          nextIndex = before ? nextIndex + toSkip : nextIndex;\n          column.orderIndex = nextIndex;\n          if (nextSourceIndex === nextIndex + 1) {\n            nextIndex += toSkip;\n          }\n        } else if (column === source) {\n          i += toSkip;\n          column.isReordered = true;\n          continue;\n        } else {\n          column.orderIndex = nextIndex;\n        }\n        column.isReordered = true;\n        nextIndex++;\n        i++;\n      }\n      for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {\n        expandedColumns[i].orderIndex = nextSourceIndex++;\n        expandedColumns[i].isReordered = true;\n      }\n      this.updateIndicesForLevel(source.level + 1);\n      this.columnResizingService.areColumnsReordered = true;\n    }\n    updateIndicesForLevel(level) {\n      const colsForParentLevel = this.allColumnsForLevel(level - 1);\n      const colsForLevel = [];\n      sortColumns(colsForParentLevel).forEach(c => {\n        if (c.isColumnGroup) {\n          colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));\n        }\n      });\n      expandColumnsWithSpan(colsForLevel).map((c, i) => {\n        c.orderIndex = i;\n        c.isReordered = true;\n        return c;\n      });\n      if (level < this.columnList.totalColumnLevels()) {\n        this.updateIndicesForLevel(level + 1);\n      }\n    }\n    allColumnsForLevel(level) {\n      return this.columnList.toArray().filter(column => column.level === level);\n    }\n    initSelectionService() {\n      if (!this.selectable) {\n        this.selectionService.ngOnDestroy();\n        this.cellSelectionService.ngOnDestroy();\n        return;\n      }\n      if (!this.selectionDirective && !isPresent(this.defaultSelection)) {\n        this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);\n      }\n      const cellSelectionMode = this.selectable['cell'];\n      const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;\n      const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;\n      if (inactiveService.active) {\n        inactiveService.ngOnDestroy();\n        activeService.addSubscriptions();\n        inactiveService.active = false;\n      }\n      activeService.active = true;\n      activeService.init({\n        cellSelected: cellSelectionMode ? this.cellSelected : undefined,\n        rowSelected: cellSelectionMode ? undefined : this.rowSelected,\n        isRowSelectable: this.isRowSelectable,\n        selectable: this.selectable,\n        view: this.view,\n        columns: cellSelectionMode ? this.columnList.toArray() : undefined\n      });\n      if (!this.selectionDirective && !this.selectableSettings.enabled) {\n        this.defaultSelection.reset();\n      }\n      if (this.selectionSubscription) {\n        this.selectionSubscription.unsubscribe();\n      }\n      if (cellSelectionMode) {\n        this.selectionSubscription = this.cellSelectionService.changes.subscribe(event => {\n          this.ngZone.run(() => this.selectionChange.emit(event));\n        });\n      } else {\n        this.selectionSubscription = this.selectionService.changes.subscribe(event => {\n          this.ngZone.run(() => this.selectionChange.emit(event));\n        });\n      }\n    }\n    setEditFocus(element) {\n      if (element) {\n        return this.navigationService.tryFocus(element);\n      }\n    }\n    columnInstance(column) {\n      let instance;\n      if (typeof column === 'number') {\n        instance = this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];\n      } else if (typeof column === 'string') {\n        instance = this.columnList.filter(item => item.field === column)[0];\n      } else {\n        instance = column;\n      }\n      if (!instance && isDevMode()) {\n        throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));\n      }\n      return instance;\n    }\n    verifySettings() {\n      if (isDevMode()) {\n        const locked = this.lockedLeafColumns.length || this.columnMenu && this.columnMenu.lock;\n        const stickyColumns = this.stickyColumns.length || this.columnMenu && this.columnMenu.stick;\n        if (locked && this.detailTemplate) {\n          throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'locked columns'));\n        }\n        if (stickyColumns && this.detailTemplate) {\n          throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'sticky columns'));\n        }\n        if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {\n          console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);\n        }\n        if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {\n          console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? 'Locked' : 'Virtual'));\n        }\n        if (locked && !this.isScrollable) {\n          console.warn(ColumnConfigurationErrorMessages.requiredScroll('Locked'));\n        }\n        if (stickyColumns && !this.isScrollable) {\n          console.warn(ColumnConfigurationErrorMessages.requiredScroll('Sticky'));\n        }\n        if (this.virtualColumns && !this.isScrollable) {\n          console.warn(ColumnConfigurationErrorMessages.requiredScroll('Virtual'));\n        }\n        if (this.columnList.filter(isColumnGroupComponent).filter(x => !x.hasChildren).length) {\n          throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);\n        }\n        if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {\n          throw new Error(ColumnConfigurationErrorMessages.lockedParent);\n        }\n        if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {\n          console.warn(GridConfigurationErrorMessages.rowHeightVirtual);\n        }\n        if (!this.rowHeight && this.isVirtual) {\n          console.warn(GridConfigurationErrorMessages.rowHeightVirtual);\n        }\n        if (!this.detailRowHeight && this.isVirtual && this.detailTemplate) {\n          console.warn(GridConfigurationErrorMessages.rowHeightVirtual);\n        }\n        if (stickyColumns && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {\n          console.warn(ColumnConfigurationErrorMessages.requiredWidth('Sticky'));\n        }\n        if (this.rowSticky && this.scrollable === 'virtual') {\n          throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'row virtualization (scrollable=\"virtual\")'));\n        }\n        if (this.rowSticky && this.groupable) {\n          throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'grouping'));\n        }\n        if (this.wrapper?.nativeElement?.querySelector('kendo-toolbar') && this.toolbarTemplate) {\n          console.warn(GridConfigurationErrorMessages.unsupportedToolbarConfig);\n        }\n        validateColumnsField(this.columnList);\n      }\n    }\n    autoGenerateColumns() {\n      if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {\n        this.columns.reset(Object.keys(this.view.at(0)).map(field => {\n          const column = new ColumnComponent();\n          column.field = field;\n          return column;\n        }));\n      }\n    }\n    attachStateChangesEmitter() {\n      this.stateChangeSubscription = merge(this.pageChange.pipe(map(x => ({\n        filter: this.filter,\n        group: this.group,\n        skip: x.skip,\n        sort: this.sort,\n        take: x.take\n      }))), this.sortChange.pipe(map(sort => ({\n        filter: this.filter,\n        group: this.group,\n        skip: this.skip,\n        sort: sort,\n        take: this.pageSize\n      }))), this.groupChange.pipe(map(group => ({\n        filter: this.filter,\n        group: group,\n        skip: this.skip,\n        sort: this.sort,\n        take: this.pageSize\n      }))), this.filterChange.pipe(map(filter => ({\n        filter: filter,\n        group: this.group,\n        skip: 0,\n        sort: this.sort,\n        take: this.pageSize\n      })))).subscribe(x => {\n        this.closeCell();\n        this.cancelCell();\n        if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {\n          this.blockArrowSelection = true;\n        }\n        this.dataStateChange.emit(x);\n      });\n    }\n    attachEditHandlers() {\n      if (!this.editService) {\n        return;\n      }\n      this.editServiceSubscription = this.editService.changes.subscribe(this.emitCRUDEvent.bind(this));\n    }\n    emitCRUDEvent(args) {\n      const {\n        action,\n        rowIndex,\n        formGroup\n      } = args;\n      let dataItem = this.view.at(rowIndex - this.skip);\n      if (action !== 'add' && !dataItem) {\n        dataItem = formGroup.value;\n      }\n      this.closeCell();\n      Object.assign(args, {\n        dataItem: dataItem,\n        sender: this\n      });\n      switch (action) {\n        case 'add':\n          this.add.emit(args);\n          break;\n        case 'cancel':\n          this.cancel.emit(args);\n          break;\n        case 'edit':\n          this.edit.emit(args);\n          break;\n        case 'remove':\n          this.remove.emit(args);\n          break;\n        case 'save':\n          this.save.emit(args);\n          break;\n        case 'cellClose':\n          this.cellClose.emit(args);\n          break;\n        default:\n          break;\n      }\n    }\n    attachDomEventHandlers() {\n      this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n        this.cellClick.emit(Object.assign({\n          sender: this\n        }, args));\n      });\n    }\n    attachElementEventHandlers() {\n      if (isUniversal()) {\n        return;\n      }\n      const wrapper = this.wrapper.nativeElement;\n      const ariaRoot = this.ariaRoot.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        const resizeCheck = this.resizeCheck.bind(this);\n        const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);\n        const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);\n        const documentClickSubscription = this.renderer.listen('document', 'click', args => {\n          const activeElement = document.activeElement;\n          if (this.editService.shouldCloseCell() && !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) && !(activeElement && (closest(activeElement, matchesClasses('k-animation-container')) || isInEditedCell(activeElement, this.wrapper.nativeElement)))) {\n            this.editService.closeCell(args);\n          }\n        });\n        const windowBlurSubscription = this.renderer.listen('window', 'blur', args => {\n          const activeElement = document.activeElement;\n          if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' && isInEditedCell(activeElement, this.wrapper.nativeElement))) {\n            this.editService.closeCell(args);\n          }\n          this.domEvents.windowBlur.emit(args);\n        });\n        const clickSubscription = this.renderer.listen(wrapper, 'click', args => {\n          this.domEvents.click.emit(args);\n        });\n        const keydownSubscription = this.renderer.listen(wrapper, 'keydown', args => {\n          this.domEvents.keydown.emit(args);\n        });\n        // focusIn and focusOut are relative to the element with ARIA role \"grid\"\n        let focused = false;\n        const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', args => {\n          this.domEvents.focus.emit(args);\n          if (!focused) {\n            this.domEvents.focusIn.emit(args);\n            focused = true;\n          }\n        });\n        const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', args => {\n          const next = args.relatedTarget || document.activeElement;\n          const outside = !closest(next, node => node === ariaRoot);\n          if (outside) {\n            this.domEvents.focusOut.emit(args);\n            focused = false;\n          }\n        });\n        this.detachElementEventHandlers = () => {\n          resizeSubscription();\n          orientationSubscription();\n          documentClickSubscription();\n          windowBlurSubscription();\n          clickSubscription();\n          keydownSubscription();\n          focusInSubscription();\n          focusOutSubscription();\n        };\n      });\n    }\n    matchesMedia(c) {\n      return this.responsiveService.matchesMedia(c.media);\n    }\n    resizeCheck() {\n      if (window.innerWidth !== this.cachedWindowWidth) {\n        this.cachedWindowWidth = window.innerWidth;\n        let hasChanges = false;\n        this.columnList.filterHierarchy(column => {\n          const matchesMedia = this.matchesMedia(column);\n          if (column.matchesMedia !== matchesMedia) {\n            hasChanges = true;\n            column.matchesMedia = matchesMedia;\n          }\n          return column.isVisible;\n        });\n        if (hasChanges) {\n          this.ngZone.run(() => {\n            this.changeDetectorRef.markForCheck();\n          });\n        }\n      }\n    }\n    emitPDFExportEvent() {\n      const args = new PDFExportEvent();\n      this.pdfExport.emit(args);\n      if (!args.isDefaultPrevented()) {\n        this.saveAsPDF();\n      }\n    }\n    syncHeaderHeight(observable) {\n      return observable.pipe(filter(() => isPresent(this.lockedHeader))).subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));\n    }\n    columnsContainerChange() {\n      this.columnsContainerChangeSubscription = this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));\n    }\n    handleColumnResize() {\n      const resizes = this.columnResizingService.changes;\n      this.columnResizingSubscription = resizes.pipe(tap(e => {\n        if (e.type === 'start') {\n          this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n        } else if (e.type === 'end') {\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n        }\n      }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end')))).subscribe(this.notifyResize.bind(this));\n    }\n    notifyResize(e) {\n      const args = e.resizedColumns.filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup).map(item => ({\n        column: item.column,\n        newWidth: roundDown(item.column.width),\n        oldWidth: roundDown(item.oldWidth)\n      }));\n      this.columnResize.emit(args);\n    }\n    assertNavigable() {\n      if (isDevMode() && !this.navigationService.enabled) {\n        throw new Error(GridConfigurationErrorMessages.focusNavigable);\n      }\n    }\n    navigationMetadata() {\n      const isVirtual = this.isVirtual;\n      const pageSize = this.pageSize;\n      const dataRows = isVirtual ? this.view.total : pageSize;\n      const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n      const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n      const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;\n      return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);\n    }\n    applyAutoSize() {\n      const cols = this.columns.filter(c => this.autoSize ? c.autoSize !== false : c.autoSize);\n      if (cols.length > 0) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.autoFitColumns(cols));\n      }\n    }\n    onColumnRangeChange(range) {\n      const viewportColumns = this.viewportColumns = [];\n      const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();\n      let leafViewportColumns = columnsArray.slice(range.start, range.end + 1);\n      const stickyBeforeStart = columnsArray.slice(0, range.start).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));\n      const stickyAfterEnd = columnsArray.slice(range.end, columnsArray.length).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));\n      leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];\n      for (let idx = 0; idx < leafViewportColumns.length; idx++) {\n        let column = leafViewportColumns[idx];\n        while (column.parent) {\n          column = column.parent;\n        }\n        const toAdd = [column];\n        while (toAdd.length) {\n          column = toAdd.shift();\n          viewportColumns.push(column);\n          if (column.isColumnGroup) {\n            toAdd.unshift(...column.childrenArray);\n          }\n        }\n        const lastFromGroup = viewportColumns[viewportColumns.length - 1];\n        column = leafViewportColumns[idx];\n        while (column !== lastFromGroup && idx < leafViewportColumns.length) {\n          idx++;\n          column = leafViewportColumns[idx];\n        }\n      }\n      if (range.start > 0) {\n        const first = leafViewportColumns[0];\n        let offset = range.offset;\n        let current = viewportColumns[0];\n        let index = 0;\n        while (current !== first) {\n          offset -= current.isColumnGroup ? 0 : current.width;\n          index++;\n          current = viewportColumns[index];\n        }\n        if (offset > 0) {\n          const totalLevels = this.columnsContainer.totalLevels;\n          let previous;\n          for (let idx = 0; idx <= totalLevels; idx++) {\n            const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase(previous);\n            previous = offsetColumn;\n            offsetColumn.title = \"\\u00A0\";\n            offsetColumn.width = offset;\n            viewportColumns.unshift(offsetColumn);\n          }\n        }\n      }\n      this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);\n    }\n    toggleDetailRowLegacy(index, expand) {\n      const hasCallback = typeof this.isDetailExpanded === 'function';\n      if (isDevMode() && hasCallback) {\n        throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandRow', 'collapseRow', 'kendoGridDetailsExpandBy', 'isDetailExpanded'));\n      }\n      if (!isDevMode() && hasCallback) {\n        return;\n      }\n      if (this.detailsService.isExpanded(index, null) !== expand) {\n        this.detailsService.toggleRow(index, null);\n      }\n    }\n    toggleGroupRowLegacy(index, expand) {\n      const hasCallback = typeof this.isGroupExpanded === 'function';\n      if (isDevMode() && hasCallback) {\n        throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandGroup', 'collapseGroup', 'kendoGridExpandGroupBy', 'isGroupExpanded'));\n      }\n      if (!isDevMode() && hasCallback) {\n        return;\n      }\n      if (this.groupsService.isExpanded({\n        groupIndex: index\n      }) !== expand) {\n        this.groupsService.toggleRow({\n          index\n        }, false);\n        if (this.ctx.groupBindingDirective) {\n          this.ctx.groupBindingDirective[`group${expand ? 'Expand' : 'Collapse'}`]({\n            groupIndex: index\n          });\n        }\n      }\n    }\n    shouldResetSelection(selectableChanges) {\n      const previousValue = selectableChanges.previousValue;\n      if (!previousValue) {\n        // Selection was disabled, no need to reset.\n        return false;\n      }\n      const currentValue = selectableChanges.currentValue;\n      if (!currentValue || currentValue.enabled === false) {\n        // Selection disabled, reset.\n        return true;\n      }\n      return previousValue.cell !== currentValue.cell;\n    }\n    notifyReorderContainers() {\n      this.dragTargetContainer?.notify();\n      this.dropTargetContainer?.notify();\n    }\n  }\n  _class202 = GridComponent;\n  _defineProperty(GridComponent, \"\\u0275fac\", function _class202_Factory(t) {\n    return new (t || _class202)(i0.ɵɵdirectiveInject(BrowserSupportService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(ResponsiveService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ScrollSyncService), i0.ɵɵdirectiveInject(DomEventsService), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ColumnReorderService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(ScrollRequestService), i0.ɵɵdirectiveInject(i1$2.LocalizationService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(SizingOptionsService), i0.ɵɵdirectiveInject(RowReorderService));\n  });\n  _defineProperty(GridComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class202,\n    selectors: [[\"kendo-grid\"]],\n    contentQueries: function _class202_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n        i0.ɵɵcontentQuery(dirIndex, DetailTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, CellLoadingTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, LoadingTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, StatusBarTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.statusBarTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);\n      }\n    },\n    viewQuery: function _class202_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c52, 5);\n        i0.ɵɵviewQuery(_c53, 5);\n        i0.ɵɵviewQuery(_c54, 7);\n        i0.ɵɵviewQuery(DragTargetContainerDirective, 5);\n        i0.ɵɵviewQuery(DropTargetContainerDirective, 5);\n        i0.ɵɵviewQuery(_c55, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragTargetContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropTargetContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footer = _t);\n      }\n    },\n    hostVars: 23,\n    hostBindings: function _class202_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵstyleProp(\"min-width\", ctx.minWidth)(\"max-width\", ctx.maxWidth)(\"min-height\", ctx.minHeight)(\"max-height\", ctx.maxHeight);\n        i0.ɵɵclassProp(\"k-grid\", ctx.hostClass)(\"k-grid-sm\", ctx.sizeSmallClass)(\"k-grid-md\", ctx.sizeMediumClass)(\"k-grid-lockedcolumns\", ctx.lockedClasses)(\"k-grid-virtual\", ctx.virtualClasses)(\"k-grid-no-scrollbar\", ctx.noScrollbarClass)(\"k-grid-resizable\", ctx.isResizable);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      pageSize: \"pageSize\",\n      height: \"height\",\n      rowHeight: \"rowHeight\",\n      detailRowHeight: \"detailRowHeight\",\n      skip: \"skip\",\n      scrollable: \"scrollable\",\n      selectable: \"selectable\",\n      sort: \"sort\",\n      size: \"size\",\n      trackBy: \"trackBy\",\n      filter: \"filter\",\n      group: \"group\",\n      virtualColumns: \"virtualColumns\",\n      filterable: \"filterable\",\n      sortable: \"sortable\",\n      pageable: \"pageable\",\n      groupable: \"groupable\",\n      gridResizable: \"gridResizable\",\n      rowReorderable: \"rowReorderable\",\n      navigable: \"navigable\",\n      navigatable: \"navigatable\",\n      autoSize: \"autoSize\",\n      rowClass: \"rowClass\",\n      rowSticky: \"rowSticky\",\n      rowSelected: \"rowSelected\",\n      isRowSelectable: \"isRowSelectable\",\n      cellSelected: \"cellSelected\",\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      loading: \"loading\",\n      columnMenu: \"columnMenu\",\n      hideHeader: \"hideHeader\",\n      isDetailExpanded: \"isDetailExpanded\",\n      isGroupExpanded: \"isGroupExpanded\"\n    },\n    outputs: {\n      filterChange: \"filterChange\",\n      pageChange: \"pageChange\",\n      groupChange: \"groupChange\",\n      sortChange: \"sortChange\",\n      selectionChange: \"selectionChange\",\n      rowReorder: \"rowReorder\",\n      dataStateChange: \"dataStateChange\",\n      groupExpand: \"groupExpand\",\n      groupCollapse: \"groupCollapse\",\n      detailExpand: \"detailExpand\",\n      detailCollapse: \"detailCollapse\",\n      edit: \"edit\",\n      cancel: \"cancel\",\n      save: \"save\",\n      remove: \"remove\",\n      add: \"add\",\n      cellClose: \"cellClose\",\n      cellClick: \"cellClick\",\n      pdfExport: \"pdfExport\",\n      excelExport: \"excelExport\",\n      columnResize: \"columnResize\",\n      columnReorder: \"columnReorder\",\n      columnVisibilityChange: \"columnVisibilityChange\",\n      columnLockedChange: \"columnLockedChange\",\n      columnStickyChange: \"columnStickyChange\",\n      scrollBottom: \"scrollBottom\",\n      contentScroll: \"contentScroll\"\n    },\n    exportAs: [\"kendoGrid\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {\n      provide: CELL_CONTEXT,\n      useValue: EMPTY_CELL_CONTEXT\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.grid'\n    }, FilterService, ResponsiveService, PagerContextService, PagerNavigationService, ExcelService, ScrollSyncService, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService, RowspanService]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c226,\n    decls: 19,\n    vars: 32,\n    consts: function () {\n      let i18n_56;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label visible in the Grid group panel when it is empty\n         * @meaning kendo.grid.groupPanelEmpty\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57 = goog.getMsg(\"Drag a column header and drop it here to group by that column\");\n        i18n_56 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57;\n      } else {\n        i18n_56 = $localize`:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty:Drag a column header and drop it here to group by that column`;\n      }\n      let i18n_58;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label visible in the Grid when there are no records\n         * @meaning kendo.grid.noRecords\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59 = goog.getMsg(\"No records available.\");\n        i18n_58 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59;\n      } else {\n        i18n_58 = $localize`:kendo.grid.noRecords|The label visible in the Grid when there are no records:No records available.`;\n      }\n      let i18n_60;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the first page button in Grid pager\n         * @meaning kendo.grid.pagerFirstPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61 = goog.getMsg(\"Go to the first page\");\n        i18n_60 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61;\n      } else {\n        i18n_60 = $localize`:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager:Go to the first page`;\n      }\n      let i18n_62;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the previous page button in Grid pager\n         * @meaning kendo.grid.pagerPreviousPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63 = goog.getMsg(\"Go to the previous page\");\n        i18n_62 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63;\n      } else {\n        i18n_62 = $localize`:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager:Go to the previous page`;\n      }\n      let i18n_64;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the next page button in Grid pager\n         * @meaning kendo.grid.pagerNextPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65 = goog.getMsg(\"Go to the next page\");\n        i18n_64 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65;\n      } else {\n        i18n_64 = $localize`:kendo.grid.pagerNextPage|The label for the next page button in Grid pager:Go to the next page`;\n      }\n      let i18n_66;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the last page button in Grid pager\n         * @meaning kendo.grid.pagerLastPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67 = goog.getMsg(\"Go to the last page\");\n        i18n_66 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67;\n      } else {\n        i18n_66 = $localize`:kendo.grid.pagerLastPage|The label for the last page button in Grid pager:Go to the last page`;\n      }\n      let i18n_68;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label before the current page number in the Grid pager\n         * @meaning kendo.grid.pagerPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69 = goog.getMsg(\"Page\");\n        i18n_68 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69;\n      } else {\n        i18n_68 = $localize`:kendo.grid.pagerPage|The label before the current page number in the Grid pager:Page`;\n      }\n      let i18n_70;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label before the total pages number in the Grid pager\n         * @meaning kendo.grid.pagerOf\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71 = goog.getMsg(\"of\");\n        i18n_70 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71;\n      } else {\n        i18n_70 = $localize`:kendo.grid.pagerOf|The label before the total pages number in the Grid pager:of`;\n      }\n      let i18n_72;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label after the total pages number in the Grid pager\n         * @meaning kendo.grid.pagerItems\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73 = goog.getMsg(\"items\");\n        i18n_72 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73;\n      } else {\n        i18n_72 = $localize`:kendo.grid.pagerItems|The label after the total pages number in the Grid pager:items`;\n      }\n      let i18n_74;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the pager input in the Grid pager\n         * @meaning kendo.grid.pagerPageNumberInputTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75 = goog.getMsg(\"Page Number\");\n        i18n_74 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75;\n      } else {\n        i18n_74 = $localize`:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager:Page Number`;\n      }\n      let i18n_76;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the page size chooser in the Grid pager\n         * @meaning kendo.grid.pagerItemsPerPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77 = goog.getMsg(\"items per page\");\n        i18n_76 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77;\n      } else {\n        i18n_76 = $localize`:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager:items per page`;\n      }\n      let i18n_78;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the aria-label attribute applied to the input element for entering the page number\n         * @meaning kendo.grid.pagerInputLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79 = goog.getMsg(\"Type a page number\");\n        i18n_78 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79;\n      } else {\n        i18n_78 = $localize`:kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number:Type a page number`;\n      }\n      let i18n_80;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter cell or icon\n         * @meaning kendo.grid.filter\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81 = goog.getMsg(\"Filter\");\n        i18n_80 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81;\n      } else {\n        i18n_80 = $localize`:kendo.grid.filter|The label of the filter cell or icon:Filter`;\n      }\n      let i18n_82;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the equal filter operator\n         * @meaning kendo.grid.filterEqOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83 = goog.getMsg(\"Is equal to\");\n        i18n_82 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83;\n      } else {\n        i18n_82 = $localize`:kendo.grid.filterEqOperator|The text of the equal filter operator:Is equal to`;\n      }\n      let i18n_84;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the not equal filter operator\n         * @meaning kendo.grid.filterNotEqOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85 = goog.getMsg(\"Is not equal to\");\n        i18n_84 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85;\n      } else {\n        i18n_84 = $localize`:kendo.grid.filterNotEqOperator|The text of the not equal filter operator:Is not equal to`;\n      }\n      let i18n_86;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is null filter operator\n         * @meaning kendo.grid.filterIsNullOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87 = goog.getMsg(\"Is null\");\n        i18n_86 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87;\n      } else {\n        i18n_86 = $localize`:kendo.grid.filterIsNullOperator|The text of the is null filter operator:Is null`;\n      }\n      let i18n_88;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is not null filter operator\n         * @meaning kendo.grid.filterIsNotNullOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89 = goog.getMsg(\"Is not null\");\n        i18n_88 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89;\n      } else {\n        i18n_88 = $localize`:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator:Is not null`;\n      }\n      let i18n_90;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is empty filter operator\n         * @meaning kendo.grid.filterIsEmptyOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91 = goog.getMsg(\"Is empty\");\n        i18n_90 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91;\n      } else {\n        i18n_90 = $localize`:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator:Is empty`;\n      }\n      let i18n_92;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is not empty filter operator\n         * @meaning kendo.grid.filterIsNotEmptyOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93 = goog.getMsg(\"Is not empty\");\n        i18n_92 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93;\n      } else {\n        i18n_92 = $localize`:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator:Is not empty`;\n      }\n      let i18n_94;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the starts with filter operator\n         * @meaning kendo.grid.filterStartsWithOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95 = goog.getMsg(\"Starts with\");\n        i18n_94 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95;\n      } else {\n        i18n_94 = $localize`:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator:Starts with`;\n      }\n      let i18n_96;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the contains filter operator\n         * @meaning kendo.grid.filterContainsOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97 = goog.getMsg(\"Contains\");\n        i18n_96 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97;\n      } else {\n        i18n_96 = $localize`:kendo.grid.filterContainsOperator|The text of the contains filter operator:Contains`;\n      }\n      let i18n_98;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the does not contain filter operator\n         * @meaning kendo.grid.filterNotContainsOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99 = goog.getMsg(\"Does not contain\");\n        i18n_98 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99;\n      } else {\n        i18n_98 = $localize`:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator:Does not contain`;\n      }\n      let i18n_100;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the ends with filter operator\n         * @meaning kendo.grid.filterEndsWithOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101 = goog.getMsg(\"Ends with\");\n        i18n_100 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101;\n      } else {\n        i18n_100 = $localize`:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator:Ends with`;\n      }\n      let i18n_102;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the greater than or equal filter operator\n         * @meaning kendo.grid.filterGteOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103 = goog.getMsg(\"Is greater than or equal to\");\n        i18n_102 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103;\n      } else {\n        i18n_102 = $localize`:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator:Is greater than or equal to`;\n      }\n      let i18n_104;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the greater than filter operator\n         * @meaning kendo.grid.filterGtOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105 = goog.getMsg(\"Is greater than\");\n        i18n_104 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105;\n      } else {\n        i18n_104 = $localize`:kendo.grid.filterGtOperator|The text of the greater than filter operator:Is greater than`;\n      }\n      let i18n_106;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the less than or equal filter operator\n         * @meaning kendo.grid.filterLteOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107 = goog.getMsg(\"Is less than or equal to\");\n        i18n_106 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107;\n      } else {\n        i18n_106 = $localize`:kendo.grid.filterLteOperator|The text of the less than or equal filter operator:Is less than or equal to`;\n      }\n      let i18n_108;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the less than filter operator\n         * @meaning kendo.grid.filterLtOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109 = goog.getMsg(\"Is less than\");\n        i18n_108 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109;\n      } else {\n        i18n_108 = $localize`:kendo.grid.filterLtOperator|The text of the less than filter operator:Is less than`;\n      }\n      let i18n_110;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the IsTrue boolean filter option\n         * @meaning kendo.grid.filterIsTrue\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111 = goog.getMsg(\"Is True\");\n        i18n_110 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111;\n      } else {\n        i18n_110 = $localize`:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option:Is True`;\n      }\n      let i18n_112;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the IsFalse boolean filter option\n         * @meaning kendo.grid.filterIsFalse\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113 = goog.getMsg(\"Is False\");\n        i18n_112 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113;\n      } else {\n        i18n_112 = $localize`:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option:Is False`;\n      }\n      let i18n_114;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the (All) boolean filter option\n         * @meaning kendo.grid.filterBooleanAll\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_115 = goog.getMsg(\"(All)\");\n        i18n_114 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_115;\n      } else {\n        i18n_114 = $localize`:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option:(All)`;\n      }\n      let i18n_116;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the after or equal date filter operator\n         * @meaning kendo.grid.filterAfterOrEqualOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_117 = goog.getMsg(\"Is after or equal to\");\n        i18n_116 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_117;\n      } else {\n        i18n_116 = $localize`:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator:Is after or equal to`;\n      }\n      let i18n_118;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the after date filter operator\n         * @meaning kendo.grid.filterAfterOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_119 = goog.getMsg(\"Is after\");\n        i18n_118 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_119;\n      } else {\n        i18n_118 = $localize`:kendo.grid.filterAfterOperator|The text of the after date filter operator:Is after`;\n      }\n      let i18n_120;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the before date filter operator\n         * @meaning kendo.grid.filterBeforeOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_121 = goog.getMsg(\"Is before\");\n        i18n_120 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_121;\n      } else {\n        i18n_120 = $localize`:kendo.grid.filterBeforeOperator|The text of the before date filter operator:Is before`;\n      }\n      let i18n_122;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the before or equal date filter operator\n         * @meaning kendo.grid.filterBeforeOrEqualOperator\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_123 = goog.getMsg(\"Is before or equal to\");\n        i18n_122 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_123;\n      } else {\n        i18n_122 = $localize`:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator:Is before or equal to`;\n      }\n      let i18n_124;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the filter button\n         * @meaning kendo.grid.filterFilterButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_125 = goog.getMsg(\"Filter\");\n        i18n_124 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_125;\n      } else {\n        i18n_124 = $localize`:kendo.grid.filterFilterButton|The text of the filter button:Filter`;\n      }\n      let i18n_126;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the clear filter button\n         * @meaning kendo.grid.filterClearButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_127 = goog.getMsg(\"Clear\");\n        i18n_126 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_127;\n      } else {\n        i18n_126 = $localize`:kendo.grid.filterClearButton|The text of the clear filter button:Clear`;\n      }\n      let i18n_128;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the And filter logic\n         * @meaning kendo.grid.filterAndLogic\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_129 = goog.getMsg(\"And\");\n        i18n_128 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_129;\n      } else {\n        i18n_128 = $localize`:kendo.grid.filterAndLogic|The text of the And filter logic:And`;\n      }\n      let i18n_130;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Or filter logic\n         * @meaning kendo.grid.filterOrLogic\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_131 = goog.getMsg(\"Or\");\n        i18n_130 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_131;\n      } else {\n        i18n_130 = $localize`:kendo.grid.filterOrLogic|The text of the Or filter logic:Or`;\n      }\n      let i18n_132;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The loading text\n         * @meaning kendo.grid.loading\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_133 = goog.getMsg(\"Loading\");\n        i18n_132 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_133;\n      } else {\n        i18n_132 = $localize`:kendo.grid.loading|The loading text:Loading`;\n      }\n      let i18n_134;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Grid aria-label\n         * @meaning kendo.grid.gridLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_135 = goog.getMsg(\"Data table\");\n        i18n_134 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_135;\n      } else {\n        i18n_134 = $localize`:kendo.grid.gridLabel|The Grid aria-label:Data table`;\n      }\n      let i18n_136;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the columns item\n         * @meaning kendo.grid.columns\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_137 = goog.getMsg(\"Columns\");\n        i18n_136 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_137;\n      } else {\n        i18n_136 = $localize`:kendo.grid.columns|The text shown in the column menu for the columns item:Columns`;\n      }\n      let i18n_138;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the lock item\n         * @meaning kendo.grid.lock\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_139 = goog.getMsg(\"Lock\");\n        i18n_138 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_139;\n      } else {\n        i18n_138 = $localize`:kendo.grid.lock|The text shown in the column menu for the lock item:Lock`;\n      }\n      let i18n_140;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the unlock item\n         * @meaning kendo.grid.unlock\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_141 = goog.getMsg(\"Unlock\");\n        i18n_140 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_141;\n      } else {\n        i18n_140 = $localize`:kendo.grid.unlock|The text shown in the column menu for the unlock item:Unlock`;\n      }\n      let i18n_142;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the set column position item\n         * @meaning kendo.grid.setColumnPosition\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_143 = goog.getMsg(\"Set Column Position\");\n        i18n_142 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_143;\n      } else {\n        i18n_142 = $localize`:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item:Set Column Position`;\n      }\n      let i18n_144;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the stick item\n         * @meaning kendo.grid.stick\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_145 = goog.getMsg(\"Stick\");\n        i18n_144 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_145;\n      } else {\n        i18n_144 = $localize`:kendo.grid.stick|The text shown in the column menu for the stick item:Stick`;\n      }\n      let i18n_146;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the unstick item\n         * @meaning kendo.grid.unstick\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_147 = goog.getMsg(\"Unstick\");\n        i18n_146 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_147;\n      } else {\n        i18n_146 = $localize`:kendo.grid.unstick|The text shown in the column menu for the unstick item:Unstick`;\n      }\n      let i18n_148;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the sort icon\n         * @meaning kendo.grid.sortable\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_149 = goog.getMsg(\"Sortable\");\n        i18n_148 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_149;\n      } else {\n        i18n_148 = $localize`:kendo.grid.sortable|The label of the sort icon:Sortable`;\n      }\n      let i18n_150;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the sort ascending item\n         * @meaning kendo.grid.sortAscending\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_151 = goog.getMsg(\"Sort Ascending\");\n        i18n_150 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_151;\n      } else {\n        i18n_150 = $localize`:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item:Sort Ascending`;\n      }\n      let i18n_152;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the sort descending item\n         * @meaning kendo.grid.sortDescending\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_153 = goog.getMsg(\"Sort Descending\");\n        i18n_152 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_153;\n      } else {\n        i18n_152 = $localize`:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item:Sort Descending`;\n      }\n      let i18n_154;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the autosize all columns item\n         * @meaning kendo.grid.autosizeAllColumns\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_155 = goog.getMsg(\"Autosize All Columns\");\n        i18n_154 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_155;\n      } else {\n        i18n_154 = $localize`:kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item:Autosize All Columns`;\n      }\n      let i18n_156;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the autosize this column item\n         * @meaning kendo.grid.autosizeThisColumn\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_157 = goog.getMsg(\"Autosize This Column\");\n        i18n_156 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_157;\n      } else {\n        i18n_156 = $localize`:kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item:Autosize This Column`;\n      }\n      let i18n_158;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The status announcement when a column is no longer sorted\n         * @meaning kendo.grid.sortedDefault\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_159 = goog.getMsg(\"Not Sorted\");\n        i18n_158 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_159;\n      } else {\n        i18n_158 = $localize`:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted:Not Sorted`;\n      }\n      let i18n_160;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Group Chip indicating the ascending sorting order of the groups\n         * @meaning kendo.grid.sortedAscending\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_161 = goog.getMsg(\"Sorted Ascending\");\n        i18n_160 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_161;\n      } else {\n        i18n_160 = $localize`:kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups:Sorted Ascending`;\n      }\n      let i18n_162;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Group Chip indicating the descending sorting order of the groups\n         * @meaning kendo.grid.sortedDescending\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_163 = goog.getMsg(\"Sorted Descending\");\n        i18n_162 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_163;\n      } else {\n        i18n_162 = $localize`:kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups:Sorted Descending`;\n      }\n      let i18n_164;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu or column chooser for the columns apply button\n         * @meaning kendo.grid.columnsApply\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_165 = goog.getMsg(\"Apply\");\n        i18n_164 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_165;\n      } else {\n        i18n_164 = $localize`:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button:Apply`;\n      }\n      let i18n_166;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu or column chooser for the columns reset button\n         * @meaning kendo.grid.columnsReset\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_167 = goog.getMsg(\"Reset\");\n        i18n_166 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_167;\n      } else {\n        i18n_166 = $localize`:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button:Reset`;\n      }\n      let i18n_168;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the expand icon of detail rows.\n         * @meaning kendo.grid.detailExpand\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_169 = goog.getMsg(\"Expand Details\");\n        i18n_168 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_169;\n      } else {\n        i18n_168 = $localize`:kendo.grid.detailExpand|The title of the expand icon of detail rows.:Expand Details`;\n      }\n      let i18n_170;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the collapse icon of detail rows.\n         * @meaning kendo.grid.detailCollapse\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_171 = goog.getMsg(\"Collapse Details\");\n        i18n_170 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_171;\n      } else {\n        i18n_170 = $localize`:kendo.grid.detailCollapse|The title of the collapse icon of detail rows.:Collapse Details`;\n      }\n      let i18n_172;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Today button of the Date filter.\n         * @meaning kendo.grid.filterDateToday\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_173 = goog.getMsg(\"TODAY\");\n        i18n_172 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_173;\n      } else {\n        i18n_172 = $localize`:kendo.grid.filterDateToday|The text of the Today button of the Date filter.:TODAY`;\n      }\n      let i18n_174;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Toggle button of the Date filter.\n         * @meaning kendo.grid.filterDateToggle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_175 = goog.getMsg(\"Toggle Calendar\");\n        i18n_174 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_175;\n      } else {\n        i18n_174 = $localize`:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.:Toggle Calendar`;\n      }\n      let i18n_176;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Decrement button of the Numeric filter.\n         * @meaning kendo.grid.filterNumericDecrement\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_177 = goog.getMsg(\"Decrement\");\n        i18n_176 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_177;\n      } else {\n        i18n_176 = $localize`:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.:Decrement`;\n      }\n      let i18n_178;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Increment button of the Numeric filter.\n         * @meaning kendo.grid.filterNumericIncrement\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_179 = goog.getMsg(\"Increment\");\n        i18n_178 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_179;\n      } else {\n        i18n_178 = $localize`:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.:Increment`;\n      }\n      let i18n_180;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The labels of the checkbox column checkboxes.\n         * @meaning kendo.grid.selectionCheckboxLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_181 = goog.getMsg(\"Select Row\");\n        i18n_180 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_181;\n      } else {\n        i18n_180 = $localize`:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.:Select Row`;\n      }\n      let i18n_182;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the checkbox column select all checkbox.\n         * @meaning kendo.grid.selectAllCheckboxLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_183 = goog.getMsg(\"Select All Rows\");\n        i18n_182 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_183;\n      } else {\n        i18n_182 = $localize`:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.:Select All Rows`;\n      }\n      let i18n_184;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the title and aria-label attributes applied to the collapse icon of group rows.\n         * @meaning kendo.grid.groupCollapse\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_185 = goog.getMsg(\"Collapse Group\");\n        i18n_184 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_185;\n      } else {\n        i18n_184 = $localize`:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.:Collapse Group`;\n      }\n      let i18n_186;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the title and aria-label attributes applied to the expand icon of group rows.\n         * @meaning kendo.grid.groupExpand\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_187 = goog.getMsg(\"Expand Group\");\n        i18n_186 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_187;\n      } else {\n        i18n_186 = $localize`:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.:Expand Group`;\n      }\n      let i18n_188;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the title and aria-label attributes applied to the page chooser in the Grid Pager\n         * @meaning kendo.grid.pagerSelectPage\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_189 = goog.getMsg(\"Select page\");\n        i18n_188 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_189;\n      } else {\n        i18n_188 = $localize`:kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager:Select page`;\n      }\n      let i18n_190;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid top toolbar\n         * @meaning kendo.grid.topToolbarLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_191 = goog.getMsg(\"Top toolbar\");\n        i18n_190 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_191;\n      } else {\n        i18n_190 = $localize`:kendo.grid.topToolbarLabel|The label for the Grid top toolbar:Top toolbar`;\n      }\n      let i18n_192;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid bottom toolbar\n         * @meaning kendo.grid.bottomToolbarLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_193 = goog.getMsg(\"Bottom toolbar\");\n        i18n_192 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_193;\n      } else {\n        i18n_192 = $localize`:kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar:Bottom toolbar`;\n      }\n      let i18n_194;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid group panel toolbar\n         * @meaning kendo.grid.groupPanelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_195 = goog.getMsg(\"Group panel\");\n        i18n_194 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_195;\n      } else {\n        i18n_194 = $localize`:kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar:Group panel`;\n      }\n      let i18n_196;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid drag row handle\n         * @meaning kendo.grid.dragRowHandleLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_197 = goog.getMsg(\"Drag row\");\n        i18n_196 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_197;\n      } else {\n        i18n_196 = $localize`:kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle:Drag row`;\n      }\n      let i18n_198;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the column menu Filter tab\n         * @meaning kendo.grid.columnMenuFilterTabTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_199 = goog.getMsg(\"Filter\");\n        i18n_198 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_199;\n      } else {\n        i18n_198 = $localize`:kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab:Filter`;\n      }\n      let i18n_200;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the column menu General tab\n         * @meaning kendo.grid.columnMenuGeneralTabTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_201 = goog.getMsg(\"General\");\n        i18n_200 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_201;\n      } else {\n        i18n_200 = $localize`:kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab:General`;\n      }\n      let i18n_202;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the column menu Columns tab\n         * @meaning kendo.grid.columnMenuColumnsTabTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_203 = goog.getMsg(\"Columns\");\n        i18n_202 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_203;\n      } else {\n        i18n_202 = $localize`:kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab:Columns`;\n      }\n      let i18n_204;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the Group pane Chip Menu Move as previous item\n         * @meaning kendo.grid.groupChipMenuPrevious\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_205 = goog.getMsg(\"Move as previous\");\n        i18n_204 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_205;\n      } else {\n        i18n_204 = $localize`:kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item:Move as previous`;\n      }\n      let i18n_206;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the Group pane Chip Menu Move as next item\n         * @meaning kendo.grid.groupChipMenuNext\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_207 = goog.getMsg(\"Move as next\");\n        i18n_206 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_207;\n      } else {\n        i18n_206 = $localize`:kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item:Move as next`;\n      }\n      let i18n_208;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid pager\n         * @meaning kendo.grid.pagerLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_209 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ 'Page navigation, page {currentPage} of {totalPages}' }}\"\n          }\n        });\n        i18n_208 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_209;\n      } else {\n        i18n_208 = $localize`:kendo.grid.pagerLabel|The label for the Grid pager:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_210;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter row and menu inputs\n         * @meaning kendo.grid.filterInputLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_211 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{columnName} Filter' }}\"\n          }\n        });\n        i18n_210 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_211;\n      } else {\n        i18n_210 = $localize`:kendo.grid.filterInputLabel|The label of the filter row and menu inputs:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_212;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the filter menu icon\n         * @meaning kendo.grid.filterMenuTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_213 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{columnName} Filter Menu' }}\"\n          }\n        });\n        i18n_212 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_213;\n      } else {\n        i18n_212 = $localize`:kendo.grid.filterMenuTitle|The title of the filter menu icon:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_214;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter menu operators dropdown\n         * @meaning kendo.grid.filterMenuOperatorsDropDownLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_215 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{columnName} Filter Operators' }}\"\n          }\n        });\n        i18n_214 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_215;\n      } else {\n        i18n_214 = $localize`:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_216;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter cell operators dropdown\n         * @meaning kendo.grid.filterCellOperatorLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_217 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ 'Filter cell operators for {columnName}' }}\"\n          }\n        });\n        i18n_216 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_217;\n      } else {\n        i18n_216 = $localize`:kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_218;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the boolean filter cell dropdown\n         * @meaning kendo.grid.booleanFilterCellLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_219 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ 'Boolean filter cell for {columnName}' }}\"\n          }\n        });\n        i18n_218 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_219;\n      } else {\n        i18n_218 = $localize`:kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_220;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter menu logic dropdown\n         * @meaning kendo.grid.filterMenuLogicDropDownLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_221 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{columnName} Filter Logic' }}\"\n          }\n        });\n        i18n_220 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_221;\n      } else {\n        i18n_220 = $localize`:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      let i18n_222;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the column menu icon\n         * @meaning kendo.grid.columnMenu\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_223 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{columnName} Column Menu' }}\"\n          }\n        });\n        i18n_222 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_223;\n      } else {\n        i18n_222 = $localize`:kendo.grid.columnMenu|The title of the column menu icon:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      return [[\"kendoGridLocalizedMessages\", \"\", \"groupPanelEmpty\", i18n_56, \"noRecords\", i18n_58, \"pagerFirstPage\", i18n_60, \"pagerPreviousPage\", i18n_62, \"pagerNextPage\", i18n_64, \"pagerLastPage\", i18n_66, \"pagerPage\", i18n_68, \"pagerOf\", i18n_70, \"pagerItems\", i18n_72, \"pagerPageNumberInputTitle\", i18n_74, \"pagerItemsPerPage\", i18n_76, \"pagerInputLabel\", i18n_78, \"filter\", i18n_80, \"filterEqOperator\", i18n_82, \"filterNotEqOperator\", i18n_84, \"filterIsNullOperator\", i18n_86, \"filterIsNotNullOperator\", i18n_88, \"filterIsEmptyOperator\", i18n_90, \"filterIsNotEmptyOperator\", i18n_92, \"filterStartsWithOperator\", i18n_94, \"filterContainsOperator\", i18n_96, \"filterNotContainsOperator\", i18n_98, \"filterEndsWithOperator\", i18n_100, \"filterGteOperator\", i18n_102, \"filterGtOperator\", i18n_104, \"filterLteOperator\", i18n_106, \"filterLtOperator\", i18n_108, \"filterIsTrue\", i18n_110, \"filterIsFalse\", i18n_112, \"filterBooleanAll\", i18n_114, \"filterAfterOrEqualOperator\", i18n_116, \"filterAfterOperator\", i18n_118, \"filterBeforeOperator\", i18n_120, \"filterBeforeOrEqualOperator\", i18n_122, \"filterFilterButton\", i18n_124, \"filterClearButton\", i18n_126, \"filterAndLogic\", i18n_128, \"filterOrLogic\", i18n_130, \"loading\", i18n_132, \"gridLabel\", i18n_134, \"columns\", i18n_136, \"lock\", i18n_138, \"unlock\", i18n_140, \"setColumnPosition\", i18n_142, \"stick\", i18n_144, \"unstick\", i18n_146, \"sortable\", i18n_148, \"sortAscending\", i18n_150, \"sortDescending\", i18n_152, \"autosizeAllColumns\", i18n_154, \"autosizeThisColumn\", i18n_156, \"sortedDefault\", i18n_158, \"sortedAscending\", i18n_160, \"sortedDescending\", i18n_162, \"columnsApply\", i18n_164, \"columnsReset\", i18n_166, \"detailExpand\", i18n_168, \"detailCollapse\", i18n_170, \"filterDateToday\", i18n_172, \"filterDateToggle\", i18n_174, \"filterNumericDecrement\", i18n_176, \"filterNumericIncrement\", i18n_178, \"selectionCheckboxLabel\", i18n_180, \"selectAllCheckboxLabel\", i18n_182, \"groupCollapse\", i18n_184, \"groupExpand\", i18n_186, \"pagerSelectPage\", i18n_188, \"topToolbarLabel\", i18n_190, \"bottomToolbarLabel\", i18n_192, \"groupPanelLabel\", i18n_194, \"dragRowHandleLabel\", i18n_196, \"columnMenuFilterTabTitle\", i18n_198, \"columnMenuGeneralTabTitle\", i18n_200, \"columnMenuColumnsTabTitle\", i18n_202, \"groupChipMenuPrevious\", i18n_204, \"groupChipMenuNext\", i18n_206, 6, \"pagerLabel\", \"filterInputLabel\", \"filterMenuTitle\", \"filterMenuOperatorsDropDownLabel\", \"filterCellOperatorLabel\", \"booleanFilterCellLabel\", \"filterMenuLogicDropDownLabel\", \"columnMenu\"], [\"pagerLabel\", i18n_208, \"filterInputLabel\", i18n_210, \"filterMenuTitle\", i18n_212, \"filterMenuOperatorsDropDownLabel\", i18n_214, \"filterCellOperatorLabel\", i18n_216, \"booleanFilterCellLabel\", i18n_218, \"filterMenuLogicDropDownLabel\", i18n_220, \"columnMenu\", i18n_222], [\"position\", \"top\", 3, \"size\", \"navigable\", 4, \"ngIf\"], [\"class\", \"k-grid-pager k-grid-pager-top\", 3, \"navigable\", \"pageSize\", \"total\", \"skip\", \"size\", \"responsive\", \"buttonCount\", \"info\", \"pageSizeValues\", \"previousNext\", \"type\", \"pageChange\", 4, \"ngIf\"], [\"role\", \"toolbar\", 3, \"navigable\", \"text\", \"groups\", \"change\", 4, \"ngIf\"], [\"role\", \"grid\", \"kendoDragTargetContainer\", \"\", \"kendoDropTargetContainer\", \"\", \"mode\", \"manual\", 1, \"k-grid-aria-root\", 3, \"dragDisabled\", \"dropDisabled\", \"dragTargetFilter\", \"dropTargetFilter\", \"dragHandle\", \"hint\", \"hintContext\", \"dragData\", \"id\", \"onPress\", \"onDragStart\", \"onDrag\", \"onDragEnter\", \"onDragLeave\", \"onDragEnd\", \"onDrop\"], [\"ariaRoot\", \"\"], [4, \"ngIf\"], [\"kendoGridLoading\", \"\", 3, \"loadingTemplate\", 4, \"ngIf\"], [3, \"statusBarTemplate\", 4, \"ngIf\"], [\"class\", \"k-grid-pager\", 3, \"navigable\", \"pageSize\", \"total\", \"skip\", \"size\", \"responsive\", \"buttonCount\", \"info\", \"pageSizeValues\", \"previousNext\", \"type\", \"pageChange\", 4, \"ngIf\"], [\"class\", \"k-grid-toolbar-bottom\", \"position\", \"bottom\", 3, \"size\", \"navigable\", 4, \"ngIf\"], [\"defaultHint\", \"\"], [\"defaultPager\", \"\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [\"position\", \"top\", 3, \"size\", \"navigable\"], [1, \"k-grid-pager\", \"k-grid-pager-top\", 3, \"navigable\", \"pageSize\", \"total\", \"skip\", \"size\", \"responsive\", \"buttonCount\", \"info\", \"pageSizeValues\", \"previousNext\", \"type\", \"pageChange\"], [\"topPager\", \"\"], [\"kendoPagerTemplate\", \"\"], [3, \"ariaLabel\", \"firstPage\", \"inputLabel\", \"previousPage\", \"nextPage\", \"lastPage\", \"selectPage\", \"page\", \"itemsPerPage\", \"items\", \"of\", \"pageNumberInputTitle\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"role\", \"toolbar\", 3, \"navigable\", \"text\", \"groups\", \"change\"], [\"class\", \"k-grid-header\", \"role\", \"presentation\", 3, \"k-grid-draggable-header\", \"padding\", 4, \"ngIf\"], [\"kendoDraggable\", \"\", \"kendoGridSelectionMarquee\", \"\", 3, \"data\", \"rowHeight\", \"detailRowHeight\", \"total\", \"take\", \"groups\", \"groupable\", \"skip\", \"trackBy\", \"columns\", \"selectable\", \"filterable\", \"detailTemplate\", \"noRecordsTemplate\", \"size\", \"rowClass\", \"rowSticky\", \"loading\", \"isVirtual\", \"cellLoadingTemplate\", \"loadingTemplate\", \"virtualColumns\", \"enableDrag\", \"sort\", \"pageChange\", \"scrollBottom\", \"contentScroll\"], [\"class\", \"k-grid-footer\", 3, \"padding\", 4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-grid-header\"], [\"role\", \"presentation\", \"class\", \"k-grid-header-locked\", 3, \"width\", 4, \"ngIf\"], [\"role\", \"presentation\", \"data-scrollable\", \"\", 1, \"k-grid-header-wrap\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"header\", \"\"], [\"role\", \"presentation\", \"kendoGridResizableTable\", \"\", \"kendoGridTable\", \"\", 1, \"k-grid-header-table\", 3, \"virtualColumns\", \"size\"], [\"kendoGridColGroup\", \"\", 3, \"columns\", \"groups\", \"detailTemplate\"], [\"kendoGridHeader\", \"\", \"role\", \"rowgroup\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"sort\", \"filter\", \"filterable\", \"groupable\", \"reorderable\", \"groups\", \"sortable\", \"columnMenu\", \"columnMenuTemplate\", \"lockedColumnsCount\", \"totalColumnsCount\", \"totalColumns\", \"detailTemplate\", \"tabIndex\"], [\"class\", \"k-width-container\", \"role\", \"presentation\", 4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-grid-header-locked\"], [\"lockedHeader\", \"\"], [\"kendoGridResizableTable\", \"\", \"role\", \"presentation\", \"kendoGridTable\", \"\", 1, \"k-grid-header-table\", 3, \"locked\", \"size\"], [\"kendoGridHeader\", \"\", \"role\", \"rowgroup\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"sort\", \"groups\", \"filter\", \"filterable\", \"groupable\", \"reorderable\", \"sortable\", \"columnMenu\", \"columnMenuTemplate\", \"totalColumnsCount\", \"totalColumns\", \"detailTemplate\", \"tabIndex\"], [\"role\", \"presentation\", 1, \"k-width-container\"], [1, \"k-grid-footer\"], [\"class\", \"k-grid-footer-locked\", 3, \"width\", 4, \"ngIf\"], [\"data-scrollable\", \"\", 1, \"k-grid-footer-wrap\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"footer\", \"\"], [\"role\", \"presentation\", \"kendoGridTable\", \"\", \"kendoGridResizableTable\", \"\", 1, \"k-grid-footer-table\", 3, \"size\"], [\"kendoGridFooter\", \"\", 3, \"logicalRowIndex\", \"scrollable\", \"groups\", \"columns\", \"lockedColumnsCount\", \"detailTemplate\", \"totalColumns\"], [1, \"k-grid-footer-locked\"], [\"role\", \"presentation\", \"kendoGridResizableTable\", \"\", \"kendoGridTable\", \"\", 1, \"k-grid-footer-table\", 3, \"locked\", \"size\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"groups\", \"columns\", \"detailTemplate\", \"logicalRowIndex\", \"totalColumns\"], [\"kendoGridTable\", \"\", \"kendoGridResizableTable\", \"\", \"role\", \"presentation\", 3, \"size\"], [\"kendoGridColGroup\", \"\", 3, \"columns\", \"groups\", \"sort\", \"detailTemplate\"], [\"kendoGridHeader\", \"\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"totalColumns\", \"groups\", \"groupable\", \"reorderable\", \"sort\", \"sortable\", \"filter\", \"filterable\", \"columnMenu\", \"columnMenuTemplate\", \"detailTemplate\", \"tabIndex\", 4, \"ngIf\"], [\"kendoGridTableBody\", \"\", \"kendoDraggable\", \"\", \"kendoGridSelectionMarquee\", \"\", 3, \"isLoading\", \"groups\", \"data\", \"skip\", \"columns\", \"selectable\", \"filterable\", \"noRecordsTemplate\", \"detailTemplate\", \"showGroupFooters\", \"trackBy\", \"rowClass\", \"enableDrag\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"logicalRowIndex\", \"groups\", \"columns\", \"detailTemplate\", \"totalColumns\", 4, \"ngIf\"], [\"kendoGridHeader\", \"\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"totalColumns\", \"groups\", \"groupable\", \"reorderable\", \"sort\", \"sortable\", \"filter\", \"filterable\", \"columnMenu\", \"columnMenuTemplate\", \"detailTemplate\", \"tabIndex\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"logicalRowIndex\", \"groups\", \"columns\", \"detailTemplate\", \"totalColumns\"], [\"kendoGridLoading\", \"\", 3, \"loadingTemplate\"], [3, \"statusBarTemplate\"], [1, \"k-grid-pager\", 3, \"navigable\", \"pageSize\", \"total\", \"skip\", \"size\", \"responsive\", \"buttonCount\", \"info\", \"pageSizeValues\", \"previousNext\", \"type\", \"pageChange\"], [\"bottomPager\", \"\"], [\"position\", \"bottom\", 1, \"k-grid-toolbar-bottom\", 3, \"size\", \"navigable\"], [\"innerCssClass\", \"k-drag-status\", 3, \"name\", \"svgIcon\"], [1, \"k-pager-numbers-wrap\"], [3, \"size\", 4, \"ngIf\"], [3, \"size\", \"buttonCount\", 4, \"ngIf\"], [3, \"size\", \"pageSizes\", 4, \"ngIf\"], [3, \"size\"], [3, \"size\", \"buttonCount\"], [3, \"size\", \"pageSizes\"], [\"kendoWatermarkOverlay\", \"\"]];\n    },\n    template: function _class202_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c224);\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵi18nAttributes(1, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(2, _class202_kendo_grid_toolbar_2_Template, 1, 4, \"kendo-grid-toolbar\", 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵtemplate(4, _class202_kendo_pager_4_Template, 4, 23, \"kendo-pager\", 3);\n        i0.ɵɵtemplate(5, _class202_kendo_grid_group_panel_5_Template, 1, 5, \"kendo-grid-group-panel\", 4);\n        i0.ɵɵelementStart(6, \"div\", 5, 6);\n        i0.ɵɵlistener(\"onPress\", function _class202_Template_div_onPress_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"press\");\n        })(\"onDragStart\", function _class202_Template_div_onDragStart_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"dragStart\");\n        })(\"onDrag\", function _class202_Template_div_onDrag_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"drag\");\n        })(\"onDragEnter\", function _class202_Template_div_onDragEnter_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"dragEnter\");\n        })(\"onDragLeave\", function _class202_Template_div_onDragLeave_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"dragLeave\");\n        })(\"onDragEnd\", function _class202_Template_div_onDragEnd_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"dragEnd\");\n        })(\"onDrop\", function _class202_Template_div_onDrop_6_listener($event) {\n          return ctx.handleReorderEvents($event, \"drop\");\n        });\n        i0.ɵɵtemplate(8, _class202_ng_container_8_Template, 4, 26, \"ng-container\", 7);\n        i0.ɵɵtemplate(9, _class202_ng_container_9_Template, 6, 22, \"ng-container\", 7);\n        i0.ɵɵtemplate(10, _class202_div_10_Template, 1, 1, \"div\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(11, _class202_kendo_grid_status_bar_11_Template, 1, 1, \"kendo-grid-status-bar\", 9);\n        i0.ɵɵtemplate(12, _class202_kendo_pager_12_Template, 4, 23, \"kendo-pager\", 10);\n        i0.ɵɵtemplate(13, _class202_kendo_grid_toolbar_13_Template, 1, 4, \"kendo-grid-toolbar\", 11);\n        i0.ɵɵtemplate(14, _class202_ng_template_14_Template, 2, 3, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(16, _class202_ng_template_16_Template, 7, 6, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(18, _class202_div_18_Template, 1, 0, \"div\", 14);\n      }\n      if (rf & 2) {\n        const _r10 = i0.ɵɵreference(15);\n        i0.ɵɵi18nExp(\"Page navigation, page {currentPage} of {totalPages}\")(\"{columnName} Filter\")(\"{columnName} Filter Menu\")(\"{columnName} Filter Operators\")(\"Filter cell operators for {columnName}\")(\"Boolean filter cell for {columnName}\")(\"{columnName} Filter Logic\")(\"{columnName} Column Menu\");\n        i0.ɵɵi18nApply(1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTopToolbar);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTopPager);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showGroupPanel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"dragDisabled\", !ctx.rowReorderable)(\"dropDisabled\", !ctx.rowReorderable)(\"dragTargetFilter\", ctx.getDefaultSelectors(\"dragTarget\"))(\"dropTargetFilter\", ctx.getDefaultSelectors(\"dropTarget\"))(\"dragHandle\", ctx.getDefaultSelectors(\"handle\"))(\"hint\", i0.ɵɵpureFunction1(30, _c225, ctx.customHintTemplate || _r10))(\"hintContext\", ctx.hintContext)(\"dragData\", ctx.gridData)(\"id\", ctx.ariaRootId);\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-rowcount\", ctx.ariaRowCount)(\"aria-colcount\", ctx.ariaColCount);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.isScrollable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isScrollable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showStatusBar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showBottomPager);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showBottomToolbar);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgIf, ToolbarComponent, GroupPanelComponent, TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent, ResizableContainerDirective, ListComponent, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective, GridMarqueeDirective, FooterComponent, TableBodyComponent, LoadingComponent, StatusBarComponent, IconWrapperComponent, WatermarkOverlayComponent, i44.CustomMessagesComponent, i44.PagerInfoComponent, i44.PagerInputComponent, i44.PagerNextButtonsComponent, i44.PagerNumericButtonsComponent, i44.PagerPageSizesComponent, i44.PagerPrevButtonsComponent, i44.PagerTemplateDirective, i44.PagerComponent, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return GridComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example](slug:globalization_grid#toc-custom-messages)).\n */\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class203;\n  class CustomMessagesComponent extends GridMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class203 = CustomMessagesComponent;\n  _defineProperty(CustomMessagesComponent, \"\\u0275fac\", function _class203_Factory(t) {\n    return new (t || _class203)(i0.ɵɵdirectiveInject(i1$2.LocalizationService));\n  });\n  _defineProperty(CustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class203,\n    selectors: [[\"kendo-grid-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: GridMessages,\n      useExisting: forwardRef(() => _class203)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class203_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return CustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the in-memory handling of data operations such as [paging]({% slug paging_grid %}),\n * [sorting]({% slug sorting_grid %}), and [grouping]({% slug grouping_grid %})\n * ([more information and examples]({% slug local_data_grid %}#toc-using-the-data-binding-directive)).\n *\n * @example\n * ```html\n * <kendo-grid [kendoGridBinding]=\"gridData\" ...></kendo-grid>\n * ```\n */\nlet DataBindingDirective = /*#__PURE__*/(() => {\n  var _class204;\n  class DataBindingDirective {\n    /**\n     * Defines the number of records that will be skipped by the pager.\n     * @default 0\n     */\n    set skip(value) {\n      if (!isPresent(value)) {\n        value = 0;\n      }\n      this.grid.skip = this.state.skip = value;\n      if (this.rowReorderService) {\n        this.rowReorderService.skip = value;\n      }\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n    set sort(value) {\n      this.grid.sort = this.state.sort = value;\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n    set filter(value) {\n      this.grid.filter = this.state.filter = value;\n    }\n    /**\n     * Defines the page size used by the Grid pager.\n     */\n    set pageSize(value) {\n      this.grid.pageSize = this.state.take = value;\n    }\n    /**\n     * The descriptors by which the data will be grouped.\n     */\n    set group(value) {\n      this.grid.group = this.state.group = value;\n    }\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n    set data(value) {\n      this.originalData = value || [];\n      if (this.localDataChangesService) {\n        this.localDataChangesService.data = value;\n      }\n      this.dataChanged = true;\n    }\n    constructor(grid, changeDetector, localDataChangesService, rowReorderService) {\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      _defineProperty(this, \"rowReorderService\", void 0);\n      _defineProperty(this, \"state\", {\n        skip: 0\n      });\n      _defineProperty(this, \"originalData\", []);\n      _defineProperty(this, \"dataChanged\", void 0);\n      _defineProperty(this, \"stateChangeSubscription\", void 0);\n      _defineProperty(this, \"dataChangedSubscription\", void 0);\n      _defineProperty(this, \"rowReorderSubscription\", void 0);\n      this.grid = grid;\n      this.changeDetector = changeDetector;\n      this.localDataChangesService = localDataChangesService;\n      this.rowReorderService = rowReorderService;\n      if (localDataChangesService) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      this.applyState(this.state);\n      this.stateChangeSubscription = this.grid.dataStateChange.subscribe(this.onStateChange.bind(this));\n      if (this.rowReorderService) {\n        this.rowReorderSubscription = this.grid.rowReorder.subscribe(this.onRowReorder.bind(this));\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      if (this.stateChangeSubscription) {\n        this.stateChangeSubscription.unsubscribe();\n      }\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n      }\n      if (this.rowReorderSubscription) {\n        this.rowReorderSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\", \"filter\"], changes)) {\n        this.rebind();\n      }\n    }\n    ngDoCheck() {\n      if (this.dataChanged) {\n        this.updateGridData();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onStateChange(state) {\n      this.applyState(state);\n      this.rebind();\n    }\n    /**\n     * @hidden\n     */\n    onRowReorder(ev) {\n      this.rowReorderService.reorderRows(ev, this.originalData);\n      this.rebind();\n    }\n    /**\n     * @hidden\n     */\n    rebind() {\n      this.data = this.originalData;\n      this.updateGridData();\n      this.notifyDataChange();\n    }\n    /**\n     * Notifies the Grid that its data has changed.\n     */\n    notifyDataChange() {\n      this.grid.onDataChange();\n      if (this.changeDetector) {\n        this.changeDetector.markForCheck();\n      }\n    }\n    process(state) {\n      return process(this.originalData, state);\n    }\n    applyState({\n      skip,\n      take,\n      sort,\n      group,\n      filter\n    }) {\n      this.skip = skip;\n      this.pageSize = take;\n      this.sort = sort;\n      this.group = group;\n      this.filter = filter;\n    }\n    updateGridData() {\n      this.grid.data = this.process(this.state);\n      this.grid.updateNavigationMetadata();\n      this.dataChanged = false;\n    }\n  }\n  _class204 = DataBindingDirective;\n  _defineProperty(DataBindingDirective, \"\\u0275fac\", function _class204_Factory(t) {\n    return new (t || _class204)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(LocalDataChangesService), i0.ɵɵdirectiveInject(RowReorderService));\n  });\n  _defineProperty(DataBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class204,\n    selectors: [[\"\", \"kendoGridBinding\", \"\"]],\n    inputs: {\n      skip: \"skip\",\n      sort: \"sort\",\n      filter: \"filter\",\n      pageSize: \"pageSize\",\n      group: \"group\",\n      data: [\"kendoGridBinding\", \"data\"]\n    },\n    exportAs: [\"kendoGridBinding\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return DataBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which stores the row selection state of the Grid in memory\n * ([see example]({% slug selection_grid %}#toc-toggling-the-selection-functionality)).\n */\nlet SelectionDirective = /*#__PURE__*/(() => {\n  var _class205;\n  class SelectionDirective extends Selection {\n    constructor(ctx, cd) {\n      super(ctx, cd);\n      _defineProperty(this, \"ctx\", void 0);\n      this.ctx = ctx;\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      if (this.ctx.grid.selectable === false) {\n        this.ctx.grid.selectable = true;\n      }\n      this.ctx.grid.selectionDirective = this;\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      super.destroy();\n    }\n  }\n  _class205 = SelectionDirective;\n  _defineProperty(SelectionDirective, \"\\u0275fac\", function _class205_Factory(t) {\n    return new (t || _class205)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(SelectionDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class205,\n    selectors: [[\"\", \"kendoGridSelectBy\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return SelectionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass LocalEditService {\n  constructor(grid, localDataChangesService) {\n    _defineProperty(this, \"grid\", void 0);\n    _defineProperty(this, \"localDataChangesService\", void 0);\n    this.grid = grid;\n    this.localDataChangesService = localDataChangesService;\n  }\n  create(item) {\n    if (this.hasLocalData && this.grid.skip) {\n      this.localDataChangesService.data.splice(this.grid.skip, 0, item);\n    } else {\n      this.data.unshift(item);\n    }\n    this.dataChanged();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  update(_item) {\n    /* noop */\n  }\n  remove(item) {\n    const data = this.data;\n    for (let idx = 0; idx < data.length; idx++) {\n      if (item === data[idx]) {\n        data.splice(idx, 1);\n        this.dataChanged({\n          action: 'remove',\n          item: item\n        });\n        break;\n      }\n    }\n  }\n  assignValues(target, source) {\n    Object.assign(target, source);\n  }\n  dataChanged(args = {}) {\n    if (this.hasLocalData) {\n      this.localDataChangesService.changes.emit(args);\n    }\n  }\n  get hasLocalData() {\n    return Array.isArray(this.localDataChangesService.data);\n  }\n  get data() {\n    if (this.hasLocalData) {\n      return this.localDataChangesService.data;\n    }\n    const data = this.grid.data;\n    if (Array.isArray(data)) {\n      return data;\n    }\n    if (isDevMode()) {\n      throw new Error(GridConfigurationErrorMessages.requiredEditService);\n    }\n    return [];\n  }\n}\n\n/**\n * @hidden\n */\nlet EditingDirectiveBase = /*#__PURE__*/(() => {\n  var _class207;\n  class EditingDirectiveBase {\n    // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.\n    // The Input should still be kept.\n    /**\n     * The edit service that will handle the operations.\n     */\n    set editService(value) {\n      this.userEditService = value;\n    }\n    get editService() {\n      return this.userEditService || this.defaultEditService;\n    }\n    /**\n     * A function that is called to confirm if the `dataItem` will be removed.\n     */\n\n    constructor(grid, localDataChangesService) {\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      _defineProperty(this, \"removeConfirmation\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"defaultEditService\", void 0);\n      _defineProperty(this, \"userEditService\", void 0);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n      this.defaultEditService = this.createDefaultService();\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));\n      this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));\n      this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));\n      this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));\n      this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    createDefaultService() {\n      return new LocalEditService(this.grid, this.localDataChangesService);\n    }\n    addHandler() {\n      this.grid.addRow(this.createModel({\n        isNew: true\n      }));\n    }\n    saveHandler(args) {\n      const item = this.saveModel(args);\n      if (item) {\n        if (args.isNew) {\n          this.editService.create(item);\n        } else {\n          this.editService.update(item);\n        }\n      }\n      this.grid.closeRow(args.rowIndex);\n    }\n    cancelHandler({\n      rowIndex\n    }) {\n      this.closeEditor(rowIndex);\n    }\n    removeHandler({\n      dataItem\n    }) {\n      const removeItem = shouldRemove => {\n        if (shouldRemove) {\n          this.editService.remove(dataItem);\n        }\n      };\n      if (this.removeConfirmation) {\n        const result = this.removeConfirmation(dataItem);\n        if (result instanceof Promise) {\n          result.then(removeItem);\n        } else if (result instanceof Observable) {\n          result.pipe(take(1)).subscribe(removeItem);\n        } else {\n          removeItem(result);\n        }\n      } else {\n        removeItem(true);\n      }\n    }\n    onStateChange() {\n      this.closeEditor();\n    }\n    closeEditor(rowIndex) {\n      this.grid.closeRow(rowIndex);\n    }\n  }\n  _class207 = EditingDirectiveBase;\n  _defineProperty(EditingDirectiveBase, \"\\u0275fac\", function _class207_Factory(t) {\n    return new (t || _class207)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  });\n  _defineProperty(EditingDirectiveBase, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class207,\n    selectors: [[\"\", \"kendoGridEditingDirectiveBase\", \"\"]],\n    inputs: {\n      editService: \"editService\",\n      removeConfirmation: \"removeConfirmation\"\n    }\n  }));\n  return EditingDirectiveBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass LocalRowEditService extends LocalEditService {\n  update() {\n    this.dataChanged();\n  }\n}\n\n/**\n * @hidden\n */\nlet RowEditingDirectiveBase = /*#__PURE__*/(() => {\n  var _class208;\n  class RowEditingDirectiveBase extends EditingDirectiveBase {\n    constructor(...args) {\n      super(...args);\n      _defineProperty(this, \"rowIndex\", void 0);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      super.ngOnInit();\n      this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));\n    }\n    createDefaultService() {\n      return new LocalRowEditService(this.grid, this.localDataChangesService);\n    }\n    addHandler() {\n      this.closeEditor();\n      super.addHandler();\n    }\n    editHandler(args) {\n      this.closeEditor();\n      this.rowIndex = args.rowIndex;\n      this.grid.editRow(args.rowIndex, this.createModel(args));\n    }\n    saveHandler(args) {\n      super.saveHandler(args);\n      this.clean();\n    }\n    closeEditor(rowIndex = this.rowIndex) {\n      super.closeEditor(rowIndex);\n      this.clean();\n    }\n    clean() {\n      delete this.rowIndex;\n    }\n  }\n  _class208 = RowEditingDirectiveBase;\n  _defineProperty(RowEditingDirectiveBase, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class208_BaseFactory;\n    return function _class208_Factory(t) {\n      return (ɵ_class208_BaseFactory || (ɵ_class208_BaseFactory = i0.ɵɵgetInheritedFactory(_class208)))(t || _class208);\n    };\n  }());\n  _defineProperty(RowEditingDirectiveBase, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class208,\n    selectors: [[\"\", \"kendoGridRowEditingDirectiveBase\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return RowEditingDirectiveBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using\n * the Template-Driven Angular Forms ([see example]({% slug editing_directives_grid %}#toc-template-editing-directive)).\n */\nlet TemplateEditingDirective = /*#__PURE__*/(() => {\n  var _class209;\n  class TemplateEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n      super(grid, localDataChangesService);\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      /**\n       * The function that creates the `dataItem` for the new rows.\n       */\n      _defineProperty(this, \"createNewItem\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"originalValues\", void 0);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n    }\n    editHandler(args) {\n      super.editHandler(args);\n      this.dataItem = args.dataItem;\n      this.originalValues = {};\n      this.editService.assignValues(this.originalValues, this.dataItem);\n    }\n    closeEditor(rowIndex) {\n      if (this.dataItem) {\n        this.editService.assignValues(this.dataItem, this.originalValues);\n      }\n      super.closeEditor(rowIndex);\n    }\n    createModel(args) {\n      if (args.isNew) {\n        return this.createNewItem();\n      }\n    }\n    saveModel(args) {\n      return args.dataItem;\n    }\n    clean() {\n      super.clean();\n      delete this.dataItem;\n    }\n  }\n  _class209 = TemplateEditingDirective;\n  _defineProperty(TemplateEditingDirective, \"\\u0275fac\", function _class209_Factory(t) {\n    return new (t || _class209)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  });\n  _defineProperty(TemplateEditingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class209,\n    selectors: [[\"\", \"kendoGridTemplateEditing\", \"\"]],\n    inputs: {\n      createNewItem: [\"kendoGridTemplateEditing\", \"createNewItem\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return TemplateEditingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst markAllAsTouched = control => {\n  control.markAsTouched();\n  if (control.hasOwnProperty('controls')) {\n    const controls = control.controls;\n    for (const inner in controls) {\n      if (controls.hasOwnProperty(inner)) {\n        markAllAsTouched(controls[inner]);\n      }\n    }\n  }\n};\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using the\n * Reactive Forms ([see example](slug:editing_directives_grid#toc-reactive-editing-directive)).\n */\nlet ReactiveEditingDirective = /*#__PURE__*/(() => {\n  var _class210;\n  class ReactiveEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n      super(grid, localDataChangesService);\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      /**\n       * The function that creates the `FormGroup` for the edited model.\n       */\n      _defineProperty(this, \"createFormGroup\", void 0);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n    }\n    createModel(args) {\n      return this.createFormGroup(args);\n    }\n    saveModel({\n      dataItem,\n      formGroup,\n      isNew\n    }) {\n      if (!formGroup.dirty && !isNew) {\n        return;\n      }\n      if (formGroup.valid) {\n        this.editService.assignValues(dataItem, formGroup.value);\n        return dataItem;\n      }\n      markAllAsTouched(formGroup);\n    }\n  }\n  _class210 = ReactiveEditingDirective;\n  _defineProperty(ReactiveEditingDirective, \"\\u0275fac\", function _class210_Factory(t) {\n    return new (t || _class210)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  });\n  _defineProperty(ReactiveEditingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class210,\n    selectors: [[\"\", \"kendoGridReactiveEditing\", \"\"]],\n    inputs: {\n      createFormGroup: [\"kendoGridReactiveEditing\", \"createFormGroup\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return ReactiveEditingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using the in-cell\n * editing with Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-in-cell-editing)).\n */\nlet InCellEditingDirective = /*#__PURE__*/(() => {\n  var _class211;\n  class InCellEditingDirective extends EditingDirectiveBase {\n    constructor(grid, localDataChangesService, cdr) {\n      super(grid, localDataChangesService);\n      _defineProperty(this, \"grid\", void 0);\n      _defineProperty(this, \"localDataChangesService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      /**\n       * The function that creates the `FormGroup` for the edited model.\n       */\n      _defineProperty(this, \"createFormGroup\", void 0);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n      this.cdr = cdr;\n    }\n    // Need mixin\n    createModel(args) {\n      return this.createFormGroup(args);\n    }\n    saveModel({\n      dataItem,\n      formGroup,\n      isNew\n    }) {\n      if (!formGroup.dirty && !isNew) {\n        return;\n      }\n      if (formGroup.valid) {\n        this.editService.assignValues(dataItem, formGroup.value);\n        return dataItem;\n      }\n      markAllAsTouched(formGroup);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      super.ngOnInit();\n      this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));\n      this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));\n    }\n    removeHandler(args) {\n      super.removeHandler(args);\n      this.grid.cancelCell();\n    }\n    cellClickHandler(args) {\n      if (!args.isEdited && args.type !== 'contextmenu') {\n        this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));\n        this.cdr.markForCheck();\n      }\n    }\n    cellCloseHandler(args) {\n      const {\n        formGroup,\n        dataItem\n      } = args;\n      if (!formGroup.valid) {\n        args.preventDefault();\n      } else if (formGroup.dirty) {\n        if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {\n          return;\n        }\n        this.editService.assignValues(dataItem, formGroup.value);\n        this.editService.update(dataItem);\n      }\n    }\n  }\n  _class211 = InCellEditingDirective;\n  _defineProperty(InCellEditingDirective, \"\\u0275fac\", function _class211_Factory(t) {\n    return new (t || _class211)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(InCellEditingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class211,\n    selectors: [[\"\", \"kendoGridInCellEditing\", \"\"]],\n    inputs: {\n      createFormGroup: [\"kendoGridInCellEditing\", \"createFormGroup\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return InCellEditingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which controls the expanded state of the master detail rows. ([see example](slug:master_detail_expanded_state_grid#toc-built-in-directive))\n */\nlet ExpandDetailsDirective = /*#__PURE__*/(() => {\n  var _class212;\n  class ExpandDetailsDirective {\n    /**\n     * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).\n     */\n    get expandDetailsKey() {\n      return this._expandBy;\n    }\n    set expandDetailsKey(key) {\n      if (isString(key)) {\n        this._expandBy = getter(key);\n      } else {\n        this._expandBy = key;\n      }\n    }\n    /**\n     *\n     * @hidden\n     * A deprecated alias for setting the `expandDetailsKey` property.\n     */\n    get expandDetailBy() {\n      return this.expandDetailsKey;\n    }\n    set expandDetailBy(key) {\n      this.expandDetailsKey = key;\n    }\n    /**\n     * Defines the collection that will store the expanded keys.\n     */\n\n    constructor(grid) {\n      _defineProperty(this, \"grid\", void 0);\n      /**\n       * Fires when the expandedDetailKeys are changed.\n       */\n      _defineProperty(this, \"expandedDetailKeysChange\", new EventEmitter());\n      _defineProperty(this, \"expandedDetailKeys\", []);\n      /**\n       * Specifies if the items should be initially expanded.\n       * When set to `true` items added to the `expandedDetailKeys` collection will be collapsed, and items that are not present in it will be expanded.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"initiallyExpanded\", false);\n      _defineProperty(this, \"expandedState\", new Set());\n      _defineProperty(this, \"lastExpandedState\", void 0);\n      _defineProperty(this, \"_expandBy\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.grid = grid;\n      this.grid.isDetailExpanded = this.isExpanded.bind(this);\n      this.subscriptions.add(merge(this.grid.detailExpand.pipe(map(e => ({\n        expand: true,\n        ...e\n      }))), this.grid.detailCollapse.pipe(map(e => ({\n        expand: false,\n        ...e\n      })))).subscribe(this.toggleState.bind(this)));\n    }\n    ngOnChanges(changes) {\n      // skip reinitialization if the user data is the same as the last state change\n      if (isPresent(changes['expandedDetailKeys']) && this.lastExpandedState !== this.expandedDetailKeys) {\n        this.expandedState = new Set(this.expandedDetailKeys);\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    get keyGetter() {\n      return this._expandBy || getter(undefined);\n    }\n    /**\n     * @hidden\n     */\n    isExpanded(args) {\n      const key = this.keyGetter(args.dataItem);\n      const hasKey = this.expandedState.has(key);\n      // when [initiallyExpanded]=\"true\" a present key means the corresponding detail row is collapsed\n      return this.initiallyExpanded ? !hasKey : hasKey;\n    }\n    toggleState(args) {\n      const key = this.keyGetter(args.dataItem);\n      if (Boolean(this.initiallyExpanded) !== args.expand) {\n        this.expandedState.add(key);\n      } else {\n        this.expandedState.delete(key);\n      }\n      this.notifyChange();\n    }\n    notifyChange() {\n      this.lastExpandedState = Array.from(this.expandedState);\n      this.expandedDetailKeysChange.emit(this.lastExpandedState);\n    }\n  }\n  _class212 = ExpandDetailsDirective;\n  _defineProperty(ExpandDetailsDirective, \"\\u0275fac\", function _class212_Factory(t) {\n    return new (t || _class212)(i0.ɵɵdirectiveInject(GridComponent));\n  });\n  _defineProperty(ExpandDetailsDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class212,\n    selectors: [[\"\", \"kendoGridExpandDetailsBy\", \"\"]],\n    inputs: {\n      expandDetailsKey: [\"kendoGridExpandDetailsBy\", \"expandDetailsKey\"],\n      expandDetailBy: \"expandDetailBy\",\n      expandedDetailKeys: \"expandedDetailKeys\",\n      initiallyExpanded: \"initiallyExpanded\"\n    },\n    outputs: {\n      expandedDetailKeysChange: \"expandedDetailKeysChange\"\n    },\n    exportAs: [\"kendoGridExpandDetailsBy\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return ExpandDetailsDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst mapParentGroup = parentGroup => {\n  const parentGroupKeys = [];\n  while (parentGroup) {\n    parentGroupKeys.push({\n      field: parentGroup.group.field,\n      value: parentGroup.group.value\n    });\n    parentGroup = parentGroup.parentGroup;\n  }\n  return parentGroupKeys;\n};\nconst DEFAULT_KEY_GETTER = groupRowArgs => ({\n  field: groupRowArgs.group.field,\n  value: groupRowArgs.group.value,\n  parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)\n});\n/**\n * A directive which controls the expanded state of the group rows\n * ([see example]({% slug groups_expanded_state_grid %}#toc-built-in-directive)).\n */\nlet ExpandGroupDirective = /*#__PURE__*/(() => {\n  var _class213;\n  class ExpandGroupDirective {\n    /**\n     * Defines the item format that will be stored in the `expandedGroupKeys`\n     * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).\n     */\n    get expandGroupBy() {\n      return this._expandGroupBy;\n    }\n    set expandGroupBy(key) {\n      if (typeof key === 'function') {\n        this._expandGroupBy = key;\n      }\n    }\n    /**\n     * Defines the collection that will store the expanded group keys.\n     */\n    get expandedGroupKeys() {\n      return this._expandedGroupKeys;\n    }\n    set expandedGroupKeys(expandedGroups) {\n      this._expandedGroupKeys = (expandedGroups || []).slice();\n    }\n    /**\n     * Specifies if the group items should be initially expanded.\n     * @default false\n     */\n\n    constructor(grid) {\n      _defineProperty(this, \"grid\", void 0);\n      /**\n       * Fires when the expandedGroupKeys are changed.\n       */\n      _defineProperty(this, \"expandedGroupKeysChange\", new EventEmitter());\n      _defineProperty(this, \"groupsInitiallyExpanded\", false);\n      _defineProperty(this, \"_expandGroupBy\", void 0);\n      _defineProperty(this, \"_expandedGroupKeys\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.grid = grid;\n      this.grid.isGroupExpanded = this.isExpanded.bind(this);\n      this.subscriptions.add(merge(this.grid.groupExpand.pipe(map(e => ({\n        expand: true,\n        ...e\n      }))), this.grid.groupCollapse.pipe(map(e => ({\n        expand: false,\n        ...e\n      })))).subscribe(this.toggleState.bind(this)));\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    get keyGetter() {\n      return this.expandGroupBy || DEFAULT_KEY_GETTER;\n    }\n    /**\n     * @hidden\n     */\n    isExpanded(groupArgs) {\n      const itemIndex = this.getItemIndex(groupArgs);\n      return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;\n    }\n    getItemIndex(groupArgs) {\n      if (this.expandGroupBy) {\n        return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));\n      }\n      return this.expandedGroupKeys.findIndex(item => {\n        let index = 0;\n        let parentGroup = groupArgs.parentGroup;\n        while (isPresent(parentGroup)) {\n          if (!isPresent(item.parentGroupKeys) || !isPresent(item.parentGroupKeys[index]) || parentGroup.group.value !== item.parentGroupKeys[index].value || parentGroup.group.field !== item.parentGroupKeys[index].field) {\n            return false;\n          }\n          parentGroup = parentGroup.parentGroup;\n          index++;\n        }\n        return item.value === groupArgs.group.value && item.field === groupArgs.group.field;\n      });\n    }\n    toggleState(groupArgs) {\n      const key = this.keyGetter(groupArgs);\n      if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {\n        this.expandedGroupKeys.push(key);\n      } else {\n        const index = this.expandedGroupKeys.findIndex(group => {\n          if (this.expandGroupBy) {\n            return group === key;\n          } else if (key.parentGroupKeys?.length === 0) {\n            return group.value === key.value;\n          }\n          return JSON.stringify(group) === JSON.stringify(key);\n        });\n        this.expandedGroupKeys.splice(index, 1);\n      }\n      this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());\n    }\n  }\n  _class213 = ExpandGroupDirective;\n  _defineProperty(ExpandGroupDirective, \"\\u0275fac\", function _class213_Factory(t) {\n    return new (t || _class213)(i0.ɵɵdirectiveInject(GridComponent));\n  });\n  _defineProperty(ExpandGroupDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class213,\n    selectors: [[\"\", \"kendoGridExpandGroupBy\", \"\"]],\n    inputs: {\n      expandGroupBy: [\"kendoGridExpandGroupBy\", \"expandGroupBy\"],\n      expandedGroupKeys: \"expandedGroupKeys\",\n      groupsInitiallyExpanded: \"groupsInitiallyExpanded\"\n    },\n    outputs: {\n      expandedGroupKeysChange: \"expandedGroupKeysChange\"\n    },\n    exportAs: [\"kendoGridExpandGroupBy\"],\n    standalone: true\n  }));\n  return ExpandGroupDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst hasGroups = items => items && items.length && items[0].field && items[0].items;\nconst groupDescriptorsPresent = descriptors => isPresent(descriptors) && descriptors.length > 0;\nconst processGroups = (data, state) => process(data, state).data;\nconst removeParentDescriptors = (parents, owner) => g => g.field !== owner.field && !parents.some(y => y.field === g.field);\nconst findGroup = (groupIndex, groups) => {\n  const parents = [];\n  return {\n    group: groupIndex.split(\"_\").reduce((acc, x) => {\n      const idx = parseInt(x, 10);\n      if (acc.items) {\n        parents.push(acc);\n        return acc.items[idx];\n      }\n      return isArray(acc) ? acc[idx] : acc;\n    }, groups),\n    parents\n  };\n};\nconst findChildren = (data, parents) => {\n  const filters = parents.map(p => ({\n    field: p.field,\n    operator: \"eq\",\n    value: p.value\n  }));\n  return filterBy(data, {\n    filters: filters,\n    logic: \"and\"\n  });\n};\n/**\n * @hidden\n */\nconst count = (groups, includeFooters = false) => groups.reduce((acc, group) => {\n  if (!group.skipHeader) {\n    acc++;\n  }\n  if (group.items) {\n    const children = count(group.items, includeFooters);\n    if (includeFooters && children && !group.hideFooter) {\n      acc++;\n    }\n    acc += children;\n  }\n  return acc;\n}, 0);\n/**\n * @hidden\n */\nconst noDescriptors = descriptors => !isPresent(descriptors) || !descriptors.length;\n/**\n * @hidden\n */\nconst slice = (groups, skip, take, includeFooters = false) => {\n  if (!isPresent(take)) {\n    return groups;\n  }\n  const result = [];\n  for (let idx = 0, length = groups.length; idx < length; idx++) {\n    if (take <= 0) {\n      break;\n    }\n    const group = groups[idx];\n    const groupItems = group.items;\n    let itemCount = count(groupItems, includeFooters);\n    if (includeFooters && groupItems.length) {\n      itemCount++;\n    }\n    const skipHeader = skip > 0;\n    if (skip) {\n      skip--;\n      if (itemCount && skip >= itemCount) {\n        skip -= itemCount;\n        continue;\n      }\n    }\n    if (!skipHeader || itemCount) {\n      const items = [];\n      let hideFooter = true;\n      if (!skipHeader) {\n        take--;\n      }\n      if (take) {\n        if (hasGroups(groupItems)) {\n          const children = slice(groupItems, skip, take, includeFooters);\n          items.push(...children);\n          take -= count(children, includeFooters);\n        } else {\n          items.push(...groupItems.slice(skip, Math.min(skip + take, groupItems.length)));\n          take -= items.length;\n        }\n        if (take && includeFooters) {\n          hideFooter = false;\n          take--;\n        }\n        skip = 0;\n      }\n      result.push({\n        aggregates: group.aggregates,\n        field: group.field,\n        hideFooter,\n        items,\n        offset: idx,\n        skipHeader,\n        value: group.value\n      });\n    }\n  }\n  return result;\n};\nconst skippedHeaders = groupItem => {\n  let total = 0;\n  while (groupItem) {\n    if (groupItem.skipHeader) {\n      total++;\n    }\n    groupItem = groupItem.items && groupItem.items[0] || null;\n  }\n  return total;\n};\n/**\n * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.\n */\nlet GroupBindingDirective = /*#__PURE__*/(() => {\n  var _class214;\n  class GroupBindingDirective extends DataBindingDirective {\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n    set kendoGridGroupBinding(value) {\n      this.groups = null;\n      this.grid.resetGroupsState();\n      this.data = value;\n    }\n    /**\n     * @hidden\n     */\n    set data(value) {\n      this.originalData = value || [];\n      this.dataChanged = true;\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n    set sort(value) {\n      const noCurrentDescriptors = noDescriptors(this.state.sort);\n      const noIncomingDescriptors = noDescriptors(value);\n      const clear = this.state.sort !== value && !(noCurrentDescriptors && noIncomingDescriptors);\n      this.grid.sort = this.state.sort = value;\n      if (clear) {\n        this.groups = null;\n        this.grid.resetGroupsState();\n      }\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n    set filter(value) {\n      const clear = diffFilters(this.state.filter, value);\n      if (clear) {\n        this.state.filter = value;\n        this.grid.filter = cloneFilters(value);\n        this.groups = null;\n        this.grid.resetGroupsState();\n      }\n    }\n    /**\n     * Defines the descriptors by which the data will be grouped.\n     */\n    set group(value) {\n      // don't clear if no groups are present in previous and current value\n      const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value);\n      const clear = this.state.group !== value && groupsPresent;\n      this.grid.group = this.state.group = value;\n      if (clear) {\n        this.groups = null;\n        this.grid.resetGroupsState();\n        this.skip = 0;\n      }\n    }\n    constructor(changeDetector, localDataChangesService, ctxService, groupsService) {\n      super(ctxService.grid, changeDetector, localDataChangesService);\n      _defineProperty(this, \"groupsService\", void 0);\n      _defineProperty(this, \"groups\", void 0);\n      _defineProperty(this, \"gridSubs\", new Subscription());\n      this.groupsService = groupsService;\n      ctxService.groupBindingDirective = this;\n    }\n    ngOnInit() {\n      super.ngOnInit();\n      this.gridSubs.add(this.grid.groupExpand.subscribe(this.groupExpand.bind(this)));\n      this.gridSubs.add(this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this)));\n    }\n    ngAfterContentInit() {\n      if (isDevMode() && this.grid.isGroupExpanded) {\n        throw new Error(GridConfigurationErrorMessages.groupBindingDirectives);\n      }\n    }\n    ngOnDestroy() {\n      this.gridSubs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    toggleAll(expand) {\n      this.skip = 0;\n      this.grid.scrollTo({\n        row: 0,\n        column: 0\n      });\n      this.groups.forEach((gr, idx) => {\n        const expanded = this.groupsService.isExpanded({\n          group: gr,\n          groupIndex: idx.toString(),\n          parentGroup: undefined\n        });\n        const performToggle = expand && !expanded || !expand && expanded;\n        if (performToggle) {\n          this.grid.groupsService.toggleRow({\n            type: 'group',\n            data: gr,\n            index: idx.toString(),\n            level: 0,\n            parentGroup: undefined\n          });\n          this[expand ? 'groupExpand' : 'groupCollapse']({\n            groupIndex: idx.toString()\n          });\n        }\n      });\n    }\n    /**\n     * Collapses all expanded root level groups.\n     */\n    collapseAll() {\n      this.toggleAll(false);\n    }\n    /**\n     * Expands all expanded root level groups.\n     */\n    expandAll() {\n      this.toggleAll(true);\n    }\n    /**\n     * @hidden\n     */\n    groupExpand({\n      groupIndex\n    }) {\n      const {\n        group,\n        parents\n      } = findGroup(groupIndex, this.groups);\n      if (!group) {\n        return;\n      }\n      this.groupsService.expandChildren(groupIndex);\n      if (!group.items.length) {\n        const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));\n        const children = findChildren(this.originalData, parents.concat(group));\n        group.items = processGroups(children, {\n          filter: this.state.filter,\n          group: descriptors,\n          sort: this.state.sort\n        });\n      }\n      this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n    /**\n     * @hidden\n     */\n    groupCollapse({\n      groupIndex\n    }) {\n      const {\n        group\n      } = findGroup(groupIndex, this.groups);\n      if (group) {\n        group.items = [];\n      } else {\n        return;\n      }\n      this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n    process(state) {\n      if (state.group && state.group.length) {\n        const groups = this.processGroups(state);\n        this.grid.skip -= skippedHeaders(groups.data[0]);\n        return groups;\n      } else {\n        this.groups = null;\n      }\n      return super.process(state);\n    }\n    processGroups(state) {\n      if (!this.groups || !this.groups.length) {\n        this.groups = processGroups(this.originalData, {\n          filter: state.filter,\n          group: state.group,\n          sort: state.sort\n        });\n      }\n      return this.dataResult(state.skip, state.take);\n    }\n    dataResult(skip, take) {\n      const includeFooters = this.grid.showGroupFooters;\n      return {\n        data: slice(this.groups, skip, take, includeFooters),\n        total: count(this.groups, includeFooters)\n      };\n    }\n    applyState({\n      skip,\n      take,\n      sort,\n      group,\n      filter\n    }) {\n      this.skip = skip;\n      this.state.take = take;\n      // this.pageSize = take; // do need to update take as the process with slice correctly\n      this.sort = sort;\n      this.group = group;\n      this.filter = filter;\n    }\n  }\n  _class214 = GroupBindingDirective;\n  _defineProperty(GroupBindingDirective, \"\\u0275fac\", function _class214_Factory(t) {\n    return new (t || _class214)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(LocalDataChangesService), i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(GroupsService));\n  });\n  _defineProperty(GroupBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class214,\n    selectors: [[\"\", \"kendoGridGroupBinding\", \"\"]],\n    inputs: {\n      kendoGridGroupBinding: \"kendoGridGroupBinding\",\n      sort: \"sort\",\n      filter: \"filter\",\n      group: \"group\"\n    },\n    exportAs: [\"kendoGridGroupBinding\"],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return GroupBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the Kendo UI GridSpacer component for Angular.\n * Used to give additional white space between the Pager inner elements,\n * and provides a way for customizing the spacer width.\n * It can also be used in any flex container within the Grid\n * ([see example](slug:toolbartemplate_grid#toc-defining-the-spacing-between-toolbar-elements)).\n */\nlet GridSpacerComponent = /*#__PURE__*/(() => {\n  var _class215;\n  class GridSpacerComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * Specifies the width of the GridSpacer.\n       * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).\n       *\n       * If not set, the GridSpacer will take all the available space.\n       */\n      _defineProperty(this, \"width\", void 0);\n    }\n    get sizedClass() {\n      return isPresent(this.width);\n    }\n    get flexBasisStyle() {\n      return this.width;\n    }\n  }\n  _class215 = GridSpacerComponent;\n  _defineProperty(GridSpacerComponent, \"\\u0275fac\", function _class215_Factory(t) {\n    return new (t || _class215)();\n  });\n  _defineProperty(GridSpacerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class215,\n    selectors: [[\"kendo-grid-spacer\"]],\n    hostVars: 6,\n    hostBindings: function _class215_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"flex-basis\", ctx.flexBasisStyle);\n        i0.ɵɵclassProp(\"k-spacer\", ctx.hostClass)(\"k-spacer-sized\", ctx.sizedClass);\n      }\n    },\n    inputs: {\n      width: \"width\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class215_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return GridSpacerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive applied to all toolbar elements that need to be a part of the Grid\n * keyboard navigation.\n */\nlet GridToolbarFocusableDirective = /*#__PURE__*/(() => {\n  var _class216;\n  class GridToolbarFocusableDirective {\n    /**\n     * @hidden\n     */\n    get element() {\n      return this.host.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    get toolbarPosition() {\n      return isDocumentAvailable() && this.host.nativeElement.closest('.k-toolbar')?.getAttribute('position');\n    }\n    constructor(host, ctx) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"ctx\", void 0);\n      this.host = host;\n      this.ctx = ctx;\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable() || !this.toolbarPosition) {\n        return;\n      }\n      this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);\n      this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();\n    }\n    ngOnDestroy() {\n      if (!isDocumentAvailable() || !this.toolbarPosition) {\n        return;\n      }\n      const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;\n      this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter(el => el !== this.element);\n      this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();\n    }\n  }\n  _class216 = GridToolbarFocusableDirective;\n  _defineProperty(GridToolbarFocusableDirective, \"\\u0275fac\", function _class216_Factory(t) {\n    return new (t || _class216)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ContextService));\n  });\n  _defineProperty(GridToolbarFocusableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class216,\n    selectors: [[\"\", \"kendoGridToolbarFocusable\", \"\"], [\"\", \"kendoGridAddCommand\", \"\"], [\"\", \"kendoGridCancelCommand\", \"\"], [\"\", \"kendoGridEditCommand\", \"\"], [\"\", \"kendoGridRemoveCommand\", \"\"], [\"\", \"kendoGridSaveCommand\", \"\"], [\"\", \"kendoGridExcelCommand\", \"\"], [\"\", \"kendoGridPDFCommand\", \"\"]],\n    standalone: true\n  }));\n  return GridToolbarFocusableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The directive that enables the Grid built-in clipboard support. Allows copy, cut, and paste interactions\n * with the Grid.\n */\nlet GridClipboardDirective = /*#__PURE__*/(() => {\n  var _class217;\n  class GridClipboardDirective {\n    /**\n     * Determines the target of the clipboard operation ([see example]({% slug clipboard_grid %}#toc-clipboard-target)). The possible options are:\n     * - `activeCell`\n     * - `selection`\n     *\n     * @default 'selection'\n     */\n    set clipboardTarget(value) {\n      if (isDevMode()) {\n        this.zone.onStable.pipe(take(1)).subscribe(() => {\n          if (value === 'activeCell' && !this.host.navigable.length) {\n            console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);\n          } else if (value === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {\n            console.warn(ClipboardErrorMessages.selectionSelectable);\n          }\n        });\n      }\n      this._target = value;\n    }\n    get clipboardTarget() {\n      return this._target;\n    }\n    /**\n     * The `GridClipboardDirective` settings.\n     *\n     * @default { wholeRow: false, copyHeaders: false copy: true, cut: true, paste: true }\n     */\n    set clipboardSettings(value) {\n      this._clipboardSettings = Object.assign({}, this._clipboardSettings, value);\n    }\n    get clipboardSettings() {\n      return this._clipboardSettings;\n    }\n    /**\n     * Fires when the user performs `cut`, `copy` or `paste` action within the Grid content area.\n     */\n\n    constructor(host, clipboardService, renderer, zone) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"clipboardService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"clipboard\", new EventEmitter());\n      _defineProperty(this, \"_target\", 'selection');\n      _defineProperty(this, \"_clipboardSettings\", {\n        wholeRow: false,\n        copyHeaders: false,\n        copy: true,\n        cut: true,\n        paste: true\n      });\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"onClipboard\", (operationType, args) => {\n        if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {\n          return;\n        }\n        const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;\n        const gridDataItems = gridData.flatMap(recursiveFlatMap);\n        const selection = this.host.selection;\n        const selectionDirective = this.host.selectionDirective;\n        const targetType = this.clipboardTarget;\n        const isCellSelection = this.host.selectable?.cell || selectionDirective.isCellSelectionMode;\n        let clipboardData = [];\n        switch (targetType) {\n          case 'activeCell':\n            {\n              const targetCell = {\n                ...this.host.activeCell\n              };\n              clipboardData = targetCell && [{\n                dataItem: targetCell.dataItem,\n                dataRowIndex: targetCell.dataRowIndex,\n                colIndex: targetCell.colIndex\n              }];\n            }\n            break;\n          case 'selection':\n            {\n              const identifier = selectionDirective.selectionKey;\n              clipboardData = gridDataItems.flatMap((item, index) => {\n                if (identifier) {\n                  const key = typeof identifier === 'string' ? item[identifier] : identifier({\n                    index: index + this.host.skip,\n                    dataItem: item\n                  });\n                  return isCellSelection ? selection.some(s => s.itemKey === key) ? [{\n                    dataItem: item,\n                    dataRowIndex: index + this.host.skip\n                  }] : [] : selection.indexOf(key) > -1 ? [{\n                    dataItem: item,\n                    dataRowIndex: index + this.host.skip\n                  }] : [];\n                }\n                return isCellSelection ? selection.some(s => s.itemKey === index + this.host.skip) ? [{\n                  dataItem: item,\n                  dataRowIndex: index + this.host.skip\n                }] : [] : selection.indexOf(index + this.host.skip) > -1 ? [{\n                  dataItem: item,\n                  dataRowIndex: index + this.host.skip\n                }] : [];\n              });\n            }\n            break;\n        }\n        const isPaste = operationType === 'paste';\n        const pastedData = args.clipboardData.getData('text');\n        const visibleCols = this.host.columns.toArray().filter(c => c.isVisible);\n        const data = isPaste ? {\n          dataString: pastedData,\n          gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {\n            wholeRow: this.clipboardSettings.wholeRow,\n            isCellSelection\n          })\n        } : this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {\n          wholeRow: this.clipboardSettings.wholeRow || this.clipboardTarget === 'selection' && !isCellSelection,\n          target: this.clipboardTarget,\n          copyHeaders: this.clipboardSettings.copyHeaders,\n          operationType\n        });\n        !isPaste && navigator.clipboard.writeText(data.dataString);\n        if (hasObservers(this.clipboard)) {\n          this.zone.run(() => {\n            this.clipboard.emit({\n              type: operationType,\n              originalEvent: args,\n              clipboardData: data.dataString,\n              gridData: data.gridItems,\n              target: {\n                dataRowIndex: this.clipboardService.targetRowIndex,\n                colField: this.clipboardService.targetColField,\n                dataItem: clipboardData.find(item => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem\n              }\n            });\n          });\n        }\n        this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;\n      });\n      _defineProperty(this, \"inGrid\", args => {\n        const target = document.activeElement.matches('.k-table-td') ? document.activeElement : args.target;\n        const inContentArea = closest(target, node => node.parentElement?.classList.contains('k-grid-container'));\n        const inHost = contains$1(this.host.wrapper.nativeElement, target);\n        return target && inHost && inContentArea;\n      });\n      this.host = host;\n      this.clipboardService = clipboardService;\n      this.renderer = renderer;\n      this.zone = zone;\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.clipboardTarget === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {\n        console.warn(ClipboardErrorMessages.selectionSelectable);\n      }\n      // needed due to the following issue in Chrome\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1156117&q=focus%20programmatically%20paste&can=2\n      this.zone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(document, 'copy', args => this.onClipboard('copy', args)));\n        this.subs.add(this.renderer.listen(document, 'cut', args => this.onClipboard('cut', args)));\n        this.subs.add(this.renderer.listen(document, 'paste', args => this.onClipboard('paste', args)));\n      });\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n  }\n  _class217 = GridClipboardDirective;\n  _defineProperty(GridClipboardDirective, \"\\u0275fac\", function _class217_Factory(t) {\n    return new (t || _class217)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(ClipboardService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(GridClipboardDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class217,\n    selectors: [[\"\", \"kendoGridClipboard\", \"\"]],\n    inputs: {\n      clipboardTarget: \"clipboardTarget\",\n      clipboardSettings: \"clipboardSettings\"\n    },\n    outputs: {\n      clipboard: \"clipboard\"\n    },\n    exportAs: [\"kendoGridClipboard\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([ClipboardService])]\n  }));\n  return GridClipboardDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `export-to-PDF` toolbar tool of the Grid.\n * You can apply this directive to any `kendo-toolbar-button` element inside a\n * ToolbarComponent used in the Grid.\n *\n * When the user clicks the toolbar button that is associated with the directive, the\n * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event\n * fires ([see example]({% slug pdfexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <kendo-toolbar>\n *         <kendo-toolbar-button text=\"PDF Export\" kendoGridPDFTool></kendo-toolbar-button>\n *      </kendo-toolbar>\n *      <kendo-grid-pdf fileName=\"Grid.pdf\">\n *      </kendo-grid-pdf>\n * </kendo-grid>\n * ```\n */\nlet PDFCommandToolbarDirective = /*#__PURE__*/(() => {\n  var _class218;\n  class PDFCommandToolbarDirective {\n    constructor(pdfService, host) {\n      _defineProperty(this, \"pdfService\", void 0);\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"clickSub\", new Subscription());\n      this.pdfService = pdfService;\n      this.host = host;\n    }\n    ngOnInit() {\n      this.clickSub = this.host.click.subscribe(e => this.onClick(e));\n      this.host.className = 'k-grid-pdf';\n      this.host.svgIcon = filePdfIcon;\n      this.host.icon = 'file-pdf';\n    }\n    ngOnDestroy() {\n      this.clickSub.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.pdfService.exportClick.emit();\n    }\n  }\n  _class218 = PDFCommandToolbarDirective;\n  _defineProperty(PDFCommandToolbarDirective, \"\\u0275fac\", function _class218_Factory(t) {\n    return new (t || _class218)(i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(i45.ToolBarButtonComponent));\n  });\n  _defineProperty(PDFCommandToolbarDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class218,\n    selectors: [[\"\", \"kendoGridPDFTool\", \"\"]],\n    standalone: true\n  }));\n  return PDFCommandToolbarDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the `export-to-Excel` toolbar tool of the Grid.\n * You can apply this directive to any `kendo-toolbar-button` element inside a\n * ToolbarComponent used in the Grid.\n *\n * When the user clicks a button associated with the directive, the\n * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event\n * fires ([see example]({% slug excelexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <kendo-toolbar>\n *         <kendo-toolbar-button text=\"Excel Export\" kendoGridExcelTool></kendo-toolbar-button>\n *      </kendo-toolbar>\n *      <kendo-grid-excel fileName=\"Grid.xlsx\">\n *      </kendo-grid-excel>\n * </kendo-grid>\n * ```\n */\nlet ExcelCommandToolbarDirective = /*#__PURE__*/(() => {\n  var _class219;\n  class ExcelCommandToolbarDirective {\n    constructor(excelService, host) {\n      _defineProperty(this, \"excelService\", void 0);\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"clickSub\", new Subscription());\n      this.excelService = excelService;\n      this.host = host;\n    }\n    ngOnInit() {\n      this.clickSub = this.host.click.subscribe(e => this.onClick(e));\n      this.host.className = 'k-grid-excel';\n      this.host.svgIcon = fileExcelIcon;\n      this.host.icon = 'file-excel';\n    }\n    ngOnDestroy() {\n      this.clickSub.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.excelService.exportClick.emit();\n    }\n  }\n  _class219 = ExcelCommandToolbarDirective;\n  _defineProperty(ExcelCommandToolbarDirective, \"\\u0275fac\", function _class219_Factory(t) {\n    return new (t || _class219)(i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i45.ToolBarButtonComponent));\n  });\n  _defineProperty(ExcelCommandToolbarDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class219,\n    selectors: [[\"\", \"kendoGridExcelTool\", \"\"]],\n    standalone: true\n  }));\n  return ExcelCommandToolbarDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the command for adding a new item to the Grid.\n * You can apply this directive to any `kendo-toolbar-button` element inside a\n * ToolbarComponent used in the Grid.\n *\n * When the user clicks the toolbar button that is associated with the directive, , the\n * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered\n * ([see example]({% slug basics_editing_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <kendo-toolbar>\n *         <kendo-toolbar-button text=\"Add new\" kendoGridAddTool></kendo-toolbar-button>\n *      </kendo-toolbar>\n * </kendo-grid>\n * ```\n */\nlet AddCommandToolbarDirective = /*#__PURE__*/(() => {\n  var _class220;\n  class AddCommandToolbarDirective {\n    constructor(editService, host) {\n      _defineProperty(this, \"editService\", void 0);\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"clickSub\", new Subscription());\n      this.editService = editService;\n      this.host = host;\n    }\n    ngOnInit() {\n      this.clickSub = this.host.click.subscribe(e => this.onClick(e));\n      this.host.className = 'k-grid-add-command';\n      this.host.svgIcon = plusIcon;\n      this.host.icon = 'plus';\n    }\n    ngOnDestroy() {\n      this.clickSub.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n      e.preventDefault();\n      this.editService.beginAdd();\n    }\n  }\n  _class220 = AddCommandToolbarDirective;\n  _defineProperty(AddCommandToolbarDirective, \"\\u0275fac\", function _class220_Factory(t) {\n    return new (t || _class220)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(i45.ToolBarButtonComponent));\n  });\n  _defineProperty(AddCommandToolbarDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class220,\n    selectors: [[\"\", \"kendoGridAddTool\", \"\"]],\n    standalone: true\n  }));\n  return AddCommandToolbarDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// DRAGGABLE COLUMN\n/**\n * @hidden\n *\n * Utility array that contains all column dragging components and directives\n */\nconst KENDO_GRID_COLUMN_DRAGANDDROP = [DraggableColumnDirective, DropTargetDirective];\n/**\n * @hidden\n *\n * Utility array that contains the former Shared module exports\n */\nconst KENDO_GRID_SHARED = [ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective];\n/**\n * @hidden\n *\n * Utility array that contains the former Group module exports\n */\nconst KENDO_GRID_GROUP_EXPORTS = [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent];\n/**\n * @hidden\n *\n * Utility array that contains the filter operator components\n */\nconst KENDO_GRID_FILTER_OPERATORS = [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent];\n/**\n * @hidden\n *\n * Utility array that contains the former SharedFilterModule exports\n */\nconst KENDO_GRID_FILTER_SHARED = [...KENDO_GRID_SHARED, ...KENDO_GRID_FILTER_OPERATORS, FilterInputDirective];\n/**\n * @hidden\n *\n * Utility array that contains the former FilterMenuModule declarations\n */\nconst KENDO_GRID_FILTER_MENU_EXPORTS = [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective];\n/**\n * @hidden\n *\n * Utility array that contains the former FilterMenuModule exports\n */\nconst KENDO_GRID_FILTER_MENU = [...KENDO_GRID_FILTER_SHARED, ...KENDO_GRID_FILTER_MENU_EXPORTS];\n/**\n * @hidden\n *\n * Utility array that contains the former RowFilterModule declarations\n */\nconst KENDO_GRID_FILTER_ROW_EXPORTS = [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent];\n/**\n * @hidden\n *\n * Utility array that contains the former RowFilterModule exports\n */\nconst KENDO_GRID_FILTER_ROW = [...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_SHARED];\n/**\n * @hidden\n *\n * Utility array that contains the former ColumnMenu module declarations\n */\nconst KENDO_GRID_COLUMN_MENU_DECLARATIONS = [ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];\n/**\n * @hidden\n *\n * Utility array that contains the former ColumnMenu module exports\n */\nconst KENDO_GRID_COLUMN_MENU_EXPORTS = [ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];\n/**\n * @hidden\n */\nconst KENDO_GRID_HEADER_EXPORTS = [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective];\n/**\n * @hidden\n *\n * Utility array that contains the Footer module exports\n */\nconst KENDO_GRID_FOOTER_EXPORTS = [FooterComponent];\n/**\n * @hidden\n *\n * Utility array that contains the Body module exports\n */\nconst KENDO_GRID_BODY_EXPORTS = [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent];\n/**\n * @hidden\n *\n * Utility array that contains the Grid module declarations\n */\nconst KENDO_GRID_DECLARATIONS = [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective];\n/**\n * @hidden\n *\n * Utility array that contains the Grid module exports\n */\nconst KENDO_GRID_EXPORTS = [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, ...KENDO_GRID_GROUP_EXPORTS, ...KENDO_GRID_SHARED, ...KENDO_GRID_BODY_EXPORTS, ...KENDO_GRID_HEADER_EXPORTS, ...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_OPERATORS, ...KENDO_GRID_FILTER_MENU_EXPORTS, ...KENDO_GRID_COLUMN_MENU_EXPORTS, GridClipboardDirective];\n/**\n * @hidden\n *\n * Utility array that contains the ExcelExport module exports\n */\nconst KENDO_GRID_EXCEL_EXPORT = [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent$1, ColumnGroupComponent$1, FooterTemplateDirective$1, GroupFooterTemplateDirective$1, GroupHeaderColumnTemplateDirective$1, GroupHeaderTemplateDirective$1];\n/**\n * @hidden\n *\n * Utility array that contains the PDFModule declarations and exports\n */\nconst KENDO_GRID_PDF_EXPORT = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective];\n/**\n * Utility array that contains all `Grid` related components and directives\n */\nconst KENDO_GRID = [...KENDO_GRID_EXPORTS, ...KENDO_GRID_EXCEL_EXPORT, ...KENDO_GRID_PDF_EXPORT];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Grid component.\n *\n * @example\n *\n * ```ts\n * import { NgModule } from '@angular/core';\n * import { GridModule } from '@progress/kendo-angular-grid';\n * import { BrowserModule } from \"@angular/platform-browser\";\n * import { AppComponent } from './app.component';\n *\n * @NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, GridModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet GridModule = /*#__PURE__*/(() => {\n  var _class221;\n  class GridModule {}\n  _class221 = GridModule;\n  _defineProperty(GridModule, \"\\u0275fac\", function _class221_Factory(t) {\n    return new (t || _class221)();\n  });\n  _defineProperty(GridModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class221\n  }));\n  _defineProperty(GridModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService$1],\n    imports: [GroupHeaderComponent, GroupPanelComponent, TableBodyComponent, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, HeaderComponent, i44.CustomMessagesComponent, i44.PagerInfoComponent, i44.PagerInputComponent, i44.PagerNextButtonsComponent, i44.PagerNumericButtonsComponent, i44.PagerPageSizesComponent, i44.PagerPrevButtonsComponent, i44.PagerComponent, i44.PagerSpacerComponent, i45.ToolBarComponent, i45.ToolbarCustomMessagesComponent, i45.ToolBarButtonComponent, i45.ToolBarButtonGroupComponent, i45.ToolBarDropDownButtonComponent, i45.ToolBarSeparatorComponent, i45.ToolBarSpacerComponent, i45.ToolBarSplitButtonComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, FilterCellOperatorsComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, i45.ToolBarComponent, i45.ToolbarCustomMessagesComponent, i45.ToolBarButtonComponent, i45.ToolBarButtonGroupComponent, i45.ToolBarDropDownButtonComponent, i45.ToolBarSeparatorComponent, i45.ToolBarSpacerComponent, i45.ToolBarSplitButtonComponent]\n  }));\n  return GridModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Grid PDF component.\n *\n * @example\n *\n * ```ts\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from \"@angular/platform-browser\";\n * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';\n * import { AppComponent } from './app.component';\n *\n * @NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, GridModule, PDFModule],\n *     bootstrap:    [AppComponent]\n * })\n *\n * export class AppModule {}\n *\n * ```\n */\nlet PDFModule = /*#__PURE__*/(() => {\n  var _class222;\n  class PDFModule {}\n  _class222 = PDFModule;\n  _defineProperty(PDFModule, \"\\u0275fac\", function _class222_Factory(t) {\n    return new (t || _class222)();\n  });\n  _defineProperty(PDFModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class222\n  }));\n  _defineProperty(PDFModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [KENDO_ICONS, PDFCommandDirective]\n  }));\n  return PDFModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Excel component of the Grid.\n *\n * @example\n *\n * ```ts\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from \"@angular/platform-browser\";\n * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, GridModule, ExcelModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet ExcelModule = /*#__PURE__*/(() => {\n  var _class223;\n  class ExcelModule {}\n  _class223 = ExcelModule;\n  _defineProperty(ExcelModule, \"\\u0275fac\", function _class223_Factory(t) {\n    return new (t || _class223)();\n  });\n  _defineProperty(ExcelModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class223\n  }));\n  _defineProperty(ExcelModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [KENDO_ICONS, ExcelCommandDirective, i5$1.ColumnComponent, i5$1.ColumnGroupComponent]\n  }));\n  return ExcelModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AddCommandDirective, AddCommandToolbarDirective, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, AutoCompleteFilterCellComponent, BaseFilterCellComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, BooleanFilterCellComponent, BooleanFilterComponent, BooleanFilterMenuComponent, BooleanFilterRadioButtonDirective, BrowserSupportService, CELL_CONTEXT, CancelCommandDirective, CellCloseEvent, CellComponent, CellLoadingTemplateDirective, CellSelectionAggregateService, CellSelectionService, CellTemplateDirective, ChangeNotificationService, CheckboxColumnComponent, ColGroupComponent, ColumnBase, ColumnChooserComponent, ColumnComponent, ColumnGroupComponent, ColumnHandleDirective, ColumnInfoService, ColumnListComponent, ColumnLockedChangeEvent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuChooserComponent, ColumnMenuComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuPositionComponent, ColumnMenuService, ColumnMenuSortComponent, ColumnMenuStickComponent, ColumnMenuTemplateDirective, ColumnReorderEvent, ColumnReorderService, ColumnResizingService, ColumnStickyChangeEvent, ColumnVisibilityChangeEvent, ColumnsContainer, CommandColumnComponent, ContainsFilterOperatorComponent, ContextService, CustomMessagesComponent, DEFAULT_SCROLLER_FACTORY, DataBindingDirective, DateFilterCellComponent, DateFilterComponent, DateFilterMenuComponent, DateFilterMenuInputComponent, DetailCollapseEvent, DetailExpandEvent, DetailTemplateDirective, DetailsService, DoesNotContainFilterOperatorComponent, DomEventsService, DragAndDropService, DragHintService, DropCueService, EditCommandDirective, EditTemplateDirective, EditingDirectiveBase, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ExcelComponent, ExcelExportEvent, ExcelModule, ExcelService, ExpandDetailsDirective, ExpandGroupDirective, FieldAccessorPipe, FilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellTemplateDirective, FilterCellWrapperComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuDropDownListDirective, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuTemplateDirective, FilterRowComponent, FilterService, FocusRoot, FocusableDirective, FooterComponent, FooterTemplateDirective, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, GridClipboardDirective, GridComponent, GridModule, GridSpacerComponent, GridTableDirective, GridToolbarFocusableDirective, GridToolbarNavigationService, GroupBindingDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderComponent, GroupHeaderTemplateDirective, GroupInfoService, GroupPanelComponent, GroupsService, HeaderComponent, HeaderTemplateDirective, IdService, InCellEditingDirective, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, KENDO_GRID, KENDO_GRID_BODY_EXPORTS, KENDO_GRID_COLUMN_DRAGANDDROP, KENDO_GRID_COLUMN_MENU_DECLARATIONS, KENDO_GRID_COLUMN_MENU_EXPORTS, KENDO_GRID_DECLARATIONS, KENDO_GRID_EXCEL_EXPORT, KENDO_GRID_EXPORTS, KENDO_GRID_FILTER_MENU, KENDO_GRID_FILTER_MENU_EXPORTS, KENDO_GRID_FILTER_OPERATORS, KENDO_GRID_FILTER_ROW, KENDO_GRID_FILTER_ROW_EXPORTS, KENDO_GRID_FILTER_SHARED, KENDO_GRID_FOOTER_EXPORTS, KENDO_GRID_GROUP_EXPORTS, KENDO_GRID_HEADER_EXPORTS, KENDO_GRID_PDF_EXPORT, KENDO_GRID_SHARED, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, ListComponent, LoadingComponent, LoadingTemplateDirective, LocalDataChangesService, LogicalCellDirective, LogicalRowDirective, MenuTabbingService, NavigationService, NoRecordsTemplateDirective, NotEqualFilterOperatorComponent, NumericFilterCellComponent, NumericFilterComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, PDFCommandDirective, PDFCommandToolbarDirective, PDFComponent, PDFMarginComponent, PDFModule, PDFService, PDFTemplateDirective, PopupCloseEvent, ReactiveEditingDirective, RemoveCommandDirective, ResizableContainerDirective, ResizeService, ResponsiveService, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, RowEditingDirectiveBase, RowReorderColumnComponent, RowReorderService, SaveCommandDirective, ScrollRequestService, ScrollSyncService, SelectAllCheckboxDirective, SelectionCheckboxDirective, SelectionDirective, SelectionService, SinglePopupService, SizingOptionsService, Skip, SortService, SpanColumnComponent, StartsWithFilterOperatorComponent, StatusBarTemplateDirective, StringFilterCellComponent, StringFilterComponent, StringFilterMenuComponent, StringFilterMenuInputComponent, SuspendService, TableBodyComponent, TableDirective, TemplateEditingDirective, ToolbarComponent, ToolbarTemplateDirective, count, defaultTrackBy, hasFilterMenu, hasFilterRow, isFilterable, slice };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}