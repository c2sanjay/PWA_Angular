{"ast":null,"code":"import { Constants } from '../common/constants';\nimport { Key } from '../common/key';\n/**\n * @hidden\n */\nexport const padZero = length => new Array(Math.max(length, 0)).fill('0').join('');\n/**\n * @hidden\n */\nexport const unpadZero = value => value.replace(/^0*/, '');\n/**\n * @hidden\n */\nexport const approximateStringMatching = ({\n  oldText,\n  newText,\n  formatPattern,\n  selectionStart,\n  isInCaretMode,\n  keyEvent\n}) => {\n  /*\n    Remove the right part of the cursor.\n    oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n  */\n  const oldIndex = selectionStart + oldText.length - newText.length;\n  const oldTextSeparator = oldText[oldIndex];\n  const oldSegmentText = oldText.substring(0, oldIndex);\n  const newSegmentText = newText.substring(0, selectionStart);\n  const diff = [];\n  /* Handle the typing of a single character over the same selection. */\n  if (oldSegmentText === newSegmentText && selectionStart > 0) {\n    diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);\n    return diff;\n  }\n  if (oldSegmentText.indexOf(newSegmentText) === 0 && isInCaretMode && (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE) || oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode && (newSegmentText.length === 0 || formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length])) {\n    /* Handle Delete/Backspace. */\n    let deletedSymbol = '';\n    /*\n        The whole text is replaced by the same character.\n        A nasty patch is required to keep the selection in the first segment.\n    */\n    if (!isInCaretMode && newSegmentText.length === 1) {\n      diff.push([formatPattern[0], newSegmentText[0]]);\n    }\n    for (let i = newSegmentText.length; i < oldSegmentText.length; i++) {\n      if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {\n        deletedSymbol = formatPattern[i];\n        diff.push([deletedSymbol, '']);\n      }\n    }\n    return diff;\n  }\n  /*\n      Handle the insertion of the text (the new text is longer than the previous one).\n      Handle the typing over a literal as well.\n  */\n  if (isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator) || !isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator)) {\n    let symbol = formatPattern[0];\n    for (let i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {\n      if (formatPattern[i] !== Constants.formatSeparator) {\n        symbol = formatPattern[i];\n        break;\n      }\n    }\n    return [[symbol, newSegmentText[selectionStart - 1]]];\n  }\n  /* Handle the entering of a space or a separator for navigating to the next item. */\n  if (newSegmentText[newSegmentText.length - 1] === ' ' || newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === '_') {\n    return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];\n  }\n  /* Handle typing over a correctly selected part. */\n  const result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];\n  return result;\n};\n/**\n * @hidden\n */\nexport const dateSymbolMap = (map, part) => {\n  map[part.pattern[0]] = part.type;\n  return map;\n};\n/**\n * @hidden\n */\nexport const isInRange = (candidate, min, max) => candidate === null || !(min && min > candidate || max && max < candidate);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}