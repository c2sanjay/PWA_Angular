{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, isDevMode, EventEmitter, Component, Optional, Input, Output, HostBinding, HostListener, ContentChildren, Directive, InjectionToken, Inject, ElementRef, ViewContainerRef, ViewChild, ContentChild, forwardRef, NgModule } from '@angular/core';\nimport { Subject, Subscription, fromEvent, merge } from 'rxjs';\nimport * as i12 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, isFirefox, isSafari, isChanged, hasObservers, Keys, TemplateContextDirective, MultiTabStop, guid, isPresent as isPresent$1, EventsOutsideAngularDirective, anyChanged, ToggleButtonTabStopDirective, ResizeBatchService, KENDO_TOGGLEBUTTONTABSTOP } from '@progress/kendo-angular-common';\nexport { ToggleButtonTabStopDirective } from '@progress/kendo-angular-common';\nimport { caretAltDownIcon, xCircleIcon, moreVerticalIcon } from '@progress/kendo-svg-icons';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\nimport { NgIf, NgClass, NgStyle, NgFor, NgTemplateOutlet } from '@angular/common';\nimport { filter, tap, take } from 'rxjs/operators';\nimport * as i3 from '@progress/kendo-angular-popup';\nimport { PopupService } from '@progress/kendo-angular-popup';\nimport * as i4 from '@angular/animations';\nimport { sequence, query, style, stagger, animate } from '@angular/animations';\n\n/**\n * @hidden\n */\nconst _c0 = [\"kendoButton\", \"\"];\nfunction _class2_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵelement(1, \"img\", 7);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nfunction _class2_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.arrowIcon.iconClass);\n  }\n}\nfunction _class2_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 10);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r4.arrowIcon.icon || \"caret-alt-down\")(\"svgIcon\", ctx_r4.arrowIcon.svgIcon || ctx_r4.caretAltDownIcon);\n  }\n}\nconst _c1 = [\"*\"];\nconst _c2 = [[[\"\", \"kendoButton\", \"\"]]];\nconst _c3 = [\"[kendoButton]\"];\nfunction _class5_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r0.icon)(\"svgIcon\", ctx_r0.svgIcon);\n  }\n}\nfunction _class5_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"customFontClass\", ctx_r1.customIconClass);\n  }\n}\nfunction _class5_span_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 10);\n    i0.ɵɵelement(2, \"img\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵpropertyInterpolate(\"src\", ctx_r6.avatarSettings.imageSrc, i0.ɵɵsanitizeUrl);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r6.avatarSettings.imageCssStyle);\n    i0.ɵɵattribute(\"alt\", ctx_r6.avatarSettings.imageAltText);\n  }\n}\nfunction _class5_span_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 12);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r7.avatarSettings.initialsCssStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.avatarSettings.initials.substring(0, 2));\n  }\n}\nfunction _class5_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, _class5_span_2_ng_container_1_Template, 3, 3, \"ng-container\", 5);\n    i0.ɵɵtemplate(2, _class5_span_2_ng_container_2_Template, 3, 2, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.avatarSettings.cssStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.avatarSettings == null ? null : ctx_r2.avatarSettings.imageSrc);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.avatarSettings == null ? null : ctx_r2.avatarSettings.initials);\n  }\n}\nfunction _class5_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.label, \" \");\n  }\n}\nfunction _class5_ng_content_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!label\"]);\n  }\n}\nfunction _class5_span_6_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 17);\n    i0.ɵɵlistener(\"click\", function _class5_span_6_span_1_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r10.onMenuClick($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 18);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r8.defaultMenuIcon || ctx_r8.menuSvgIcon)(\"customFontClass\", ctx_r8.menuIcon);\n  }\n}\nfunction _class5_span_6_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 19);\n    i0.ɵɵlistener(\"click\", function _class5_span_6_span_2_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.onRemoveClick($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 20);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r9.removeSvgIcon || ctx_r9.defaultRemoveIcon)(\"customFontClass\", ctx_r9.removeIcon);\n  }\n}\nfunction _class5_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 14);\n    i0.ɵɵtemplate(1, _class5_span_6_span_1_Template, 2, 2, \"span\", 15);\n    i0.ɵɵtemplate(2, _class5_span_6_span_2_Template, 2, 2, \"span\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.hasMenu);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.removable);\n  }\n}\nfunction _class12_li_1_ng_template_1_ng_template_1_Template(rf, ctx) {}\nconst _c4 = function (a0, a1) {\n  return {\n    templateRef: a0,\n    $implicit: a1\n  };\n};\nfunction _class12_li_1_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtemplate(1, _class12_li_1_ng_template_1_ng_template_1_Template, 0, 0, \"ng-template\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", dataItem_r1.disabled);\n    i0.ɵɵproperty(\"ngClass\", dataItem_r1.cssClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(4, _c4, ctx_r3.itemTemplate == null ? null : ctx_r3.itemTemplate.templateRef, dataItem_r1));\n  }\n}\nfunction _class12_li_1_ng_template_2_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 9);\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"name\", dataItem_r1.icon)(\"svgIcon\", dataItem_r1.svgIcon)(\"customFontClass\", dataItem_r1.iconClass);\n  }\n}\nfunction _class12_li_1_ng_template_2_img_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 10);\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"src\", dataItem_r1.imageUrl, i0.ɵɵsanitizeUrl)(\"alt\", dataItem_r1.imageAlt);\n  }\n}\nfunction _class12_li_1_ng_template_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.getText(dataItem_r1), \" \");\n  }\n}\nfunction _class12_li_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtemplate(1, _class12_li_1_ng_template_2_kendo_icon_wrapper_1_Template, 1, 3, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵtemplate(2, _class12_li_1_ng_template_2_img_2_Template, 1, 2, \"img\", 7);\n    i0.ɵɵtemplate(3, _class12_li_1_ng_template_2_span_3_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-disabled\", dataItem_r1.disabled);\n    i0.ɵɵproperty(\"ngClass\", dataItem_r1.cssClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", dataItem_r1.icon || dataItem_r1.iconClass || dataItem_r1.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", dataItem_r1.imageUrl);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.getText(dataItem_r1));\n  }\n}\nfunction _class12_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 2);\n    i0.ɵɵlistener(\"click\", function _class12_li_1_Template_li_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r15);\n      const index_r2 = restoredCtx.index;\n      const ctx_r14 = i0.ɵɵnextContext();\n      $event.stopImmediatePropagation();\n      return i0.ɵɵresetView(ctx_r14.onClick(index_r2));\n    })(\"blur\", function _class12_li_1_Template_li_blur_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.onBlur());\n    });\n    i0.ɵɵtemplate(1, _class12_li_1_ng_template_1_Template, 2, 7, \"ng-template\", 3);\n    i0.ɵɵtemplate(2, _class12_li_1_ng_template_2_Template, 4, 6, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"index\", index_r2);\n    i0.ɵɵattribute(\"aria-disabled\", dataItem_r1.disabled ? true : false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef));\n  }\n}\nconst _c5 = [\"button\"];\nconst _c6 = [\"buttonList\"];\nconst _c7 = [\"popupTemplate\"];\nconst _c8 = [\"container\"];\nfunction _class14_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-button-list\", 4, 5);\n    i0.ɵɵlistener(\"onItemClick\", function _class14_ng_template_3_Template_kendo_button_list_onItemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.onItemClick($event));\n    })(\"keydown\", function _class14_ng_template_3_Template_kendo_button_list_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.keyDownHandler($event));\n    })(\"keyup\", function _class14_ng_template_3_Template_kendo_button_list_keyup_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.keyUpHandler($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r2.listId)(\"data\", ctx_r2.data)(\"textField\", ctx_r2.textField)(\"itemTemplate\", ctx_r2.itemTemplate)(\"size\", ctx_r2.size);\n    i0.ɵɵattribute(\"dir\", ctx_r2.dir)(\"aria-labelledby\", ctx_r2.buttonId);\n  }\n}\nconst _c9 = [\"kendoDialItem\", \"\"];\nfunction _class17_0_ng_template_0_Template(rf, ctx) {}\nconst _c10 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    index: a1,\n    isFocused: a2\n  };\n};\nfunction _class17_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_0_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.dialItemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(2, _c10, ctx_r0.item, ctx_r0.index, ctx_r0.isFocused));\n  }\n}\nfunction _class17_ng_container_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.item.label);\n  }\n}\nfunction _class17_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r4.item.icon)(\"customFontClass\", ctx_r4.item.iconClass)(\"svgIcon\", ctx_r4.item.svgIcon);\n  }\n}\nfunction _class17_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class17_ng_container_1_span_1_Template, 2, 1, \"span\", 2);\n    i0.ɵɵtemplate(2, _class17_ng_container_1_kendo_icon_wrapper_2_Template, 1, 3, \"kendo-icon-wrapper\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.item.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.item.icon || ctx_r1.item.iconClass || ctx_r1.item.svgIcon);\n  }\n}\nconst _c11 = [\"kendoDialList\", \"\"];\nfunction _class18_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"li\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const idx_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"item\", ctx_r0.dialItems[idx_r2])(\"index\", idx_r2)(\"dialItemTemplate\", ctx_r0.dialItemTemplate)(\"isFocused\", ctx_r0.isFocused(idx_r2))(\"ngClass\", item_r1.cssClass)(\"ngStyle\", item_r1.cssStyle)(\"align\", ctx_r0.align);\n  }\n}\nfunction _class19_2_ng_template_0_Template(rf, ctx) {}\nfunction _class19_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class19_2_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.fabTemplate == null ? null : ctx_r1.fabTemplate.templateRef);\n  }\n}\nfunction _class19_ng_container_3_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"name\", ctx_r6.icon)(\"customFontClass\", ctx_r6.iconClass)(\"svgIcon\", ctx_r6.svgIcon);\n  }\n}\nfunction _class19_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.text);\n  }\n}\nfunction _class19_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class19_ng_container_3_kendo_icon_wrapper_1_Template, 1, 3, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtemplate(2, _class19_ng_container_3_span_2_Template, 2, 1, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.icon || ctx_r2.iconClass || ctx_r2.svgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.text);\n  }\n}\nconst _c12 = function (a0, a1) {\n  return {\n    keydown: a0,\n    focusout: a1\n  };\n};\nfunction _class19_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ul\", 9);\n    i0.ɵɵlistener(\"click\", function _class19_ng_template_4_Template_ul_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.onItemClick($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r4.dialListId)(\"ngClass\", ctx_r4.dialClass)(\"dialItems\", ctx_r4.dialItems)(\"dialItemTemplate\", ctx_r4.dialItemTemplate == null ? null : ctx_r4.dialItemTemplate.templateRef)(\"align\", ctx_r4.align)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(7, _c12, ctx_r4.keyDownHandler.bind(ctx_r4), ctx_r4.focusOutHandler.bind(ctx_r4)));\n    i0.ɵɵattribute(\"aria-labelledby\", ctx_r4.id);\n  }\n}\nconst _c13 = function (a0, a1, a2) {\n  return {\n    keydown: a0,\n    click: a1,\n    pointerdown: a2\n  };\n};\nfunction _class23_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.text, \" \");\n  }\n}\nfunction _class23_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-button-list\", 10);\n    i0.ɵɵlistener(\"onItemClick\", function _class23_ng_template_8_Template_kendo_button_list_onItemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.onItemClick($event));\n    })(\"keydown\", function _class23_ng_template_8_Template_kendo_button_list_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.keyDownHandler($event));\n    })(\"keyup\", function _class23_ng_template_8_Template_kendo_button_list_keyup_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.keyUpHandler($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r4.listId)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.textField)(\"itemTemplate\", ctx_r4.itemTemplate)(\"size\", ctx_r4.size);\n    i0.ɵɵattribute(\"dir\", ctx_r4.dir);\n  }\n}\nlet KendoButtonService = /*#__PURE__*/(() => {\n  var _class;\n  class KendoButtonService {\n    constructor() {\n      _defineProperty(this, \"buttonClicked\", new Subject());\n      _defineProperty(this, \"buttonClicked$\", this.buttonClicked.asObservable());\n    }\n    click(button) {\n      this.buttonClicked.next(button);\n    }\n  }\n  _class = KendoButtonService;\n  _defineProperty(KendoButtonService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)();\n  });\n  _defineProperty(KendoButtonService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return KendoButtonService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-buttons',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163507,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * @hidden\n */\nconst resolvedPromise = Promise.resolve(null);\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst tick = f => resolvedPromise.then(f);\n/**\n * @hidden\n */\nfunction isDocumentNode(container) {\n  return container.nodeType === 9;\n}\n/**\n * @hidden\n */\nfunction closest(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);\n  let node = element;\n  while (node && !isDocumentNode(node)) {\n    if (matches(node, selector)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n}\n/**\n * @hidden\n */\nconst replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\\{\\\\s*${name}\\\\s*\\}`, 'g'), value);\n/**\n * @hidden\n */\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\nconst ROUNDNESS = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''\n      };\n    case 'fillMode':\n      return {\n        toRemove: `k-${componentType}-${previousValue}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''\n      };\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n *\n * Returns the themeColor classes to be added and removed\n */\nconst getThemeColorClasses = (componentType, prevFillMode, fillMode, previousValue, newValue) => {\n  return {\n    toRemove: `k-${componentType}-${prevFillMode}-${previousValue}`,\n    toAdd: newValue !== 'none' ? `k-${componentType}-${fillMode}-${newValue}` : ''\n  };\n};\n/**\n * @hidden\n *\n * Checks for an empty object - {}\n */\nconst isObjectEmpty = obj => obj && Object.keys(obj).length === 0 && obj.constructor === Object;\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_THEME_COLOR$2 = 'base';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * Represents the Kendo UI Button component for Angular.\n *\n * As of package v17, the `span[kendoButton]` and `kendo-button` selectors are removed.\n * Please use the `button[kendoButton]` selector only.\n */\nlet ButtonComponent = /*#__PURE__*/(() => {\n  var _class2;\n  class ButtonComponent {\n    /**\n     * Backwards-compatible alias\n     *\n     * @hidden\n     */\n    get togglable() {\n      return this.toggleable;\n    }\n    /**\n     * @hidden\n     */\n    set togglable(value) {\n      this.toggleable = value;\n    }\n    /**\n     * Sets the selected state of the Button.\n     *\n     * @default false\n     */\n    get selected() {\n      return this._selected || false;\n    }\n    set selected(value) {\n      this._selected = value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(index) {\n      this.element.tabIndex = index;\n    }\n    get tabIndex() {\n      return this.element.tabIndex;\n    }\n    /**\n     * Defines a URL which is used for an `img` element inside the Button.\n     * The URL can be relative or absolute. If relative, it is evaluated with relation to the web page URL.\n     */\n\n    /**\n     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;\n     * which are applied to a `span` element inside the Button. Allows the usage of custom icons.\n     */\n    set iconClass(value) {\n      if (isDevMode() && value && (this.icon || this.svgIcon)) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._iconClass = value;\n    }\n    get iconClass() {\n      return this._iconClass;\n    }\n    /**\n     * Defines the name for an existing font icon in the Kendo UI theme.\n     */\n    set icon(name) {\n      if (isDevMode() && name && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._icon = name;\n    }\n    get icon() {\n      return this._icon;\n    }\n    /**\n     * If set to `true`, it disables the Button.\n     *\n     * @default false\n     */\n    set disabled(disabled) {\n      //Required, because in FF focused buttons are not blurred on disabled\n      if (disabled && isDocumentAvailable() && isFirefox(navigator.userAgent)) {\n        this.blur();\n      }\n      this.isDisabled = disabled;\n      this.renderer.setProperty(this.element, 'disabled', disabled);\n    }\n    get disabled() {\n      return this.isDisabled;\n    }\n    /**\n     * The size property specifies the padding of the Button\n     * ([see example]({% slug appearance_button %}#toc-size)).\n     *\n     * @default 'medium'\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$2;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the Button\n     * ([see example](slug:appearance_button#toc-roundness)).\n     *\n     * @default 'medium'\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Button\n     * ([see example](slug:appearance_button#toc-fill-mode)).\n     *\n     * @default 'solid'\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The Button allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example](slug:appearance_button#toc-theme-colors)).\n     *\n     * @default 'base'\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR$2;\n      this.handleThemeColor(newThemeColor);\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Defines an SVGIcon to be rendered within the button.\n     */\n    set svgIcon(icon) {\n      if (isDevMode() && icon && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    /**\n     * Fires each time the selected state of a toggleable button is changed.\n     *\n     * The event argument is the new selected state (boolean).\n     */\n\n    set isFocused(isFocused) {\n      this.toggleClass('k-focus', isFocused);\n      this._focused = isFocused;\n    }\n    get isFocused() {\n      return this._focused;\n    }\n    get classButton() {\n      return true;\n    }\n    get isToggleable() {\n      return this.toggleable;\n    }\n    get iconButtonClass() {\n      const hasIcon = this.icon || this.iconClass || this.imageUrl || this.svgIcon;\n      return hasIcon && !this.hasText;\n    }\n    get classDisabled() {\n      return this.isDisabled;\n    }\n    get classActive() {\n      return this.selected;\n    }\n    get getDirection() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    onFocus() {\n      this.isFocused = true;\n    }\n    /**\n     * @hidden\n     */\n    onBlur() {\n      this.isFocused = false;\n    }\n    /**\n     * @hidden\n     */\n    set primary(value) {\n      this.themeColor = value ? 'primary' : 'base';\n    }\n    /**\n     * @hidden\n     */\n    set look(value) {\n      switch (value) {\n        case 'default':\n          this.fillMode = 'solid';\n          break;\n        default:\n          this.fillMode = value;\n          break;\n      }\n    }\n    /**\n     * Alias for ElementRef.nativeElement to workaround\n     * ViewChild() selectors that used to return the host element before v11.\n     *\n     * @hidden\n     */\n    get nativeElement() {\n      return this.element;\n    }\n    constructor(element, renderer, service, localization, ngZone) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      /**\n       * @hidden\n       * @default false\n       * required for DropDownButton arrow icon.\n       */\n      _defineProperty(this, \"arrowIcon\", false);\n      /**\n       * Provides visual styling that indicates if the Button is active.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"toggleable\", false);\n      _defineProperty(this, \"imageUrl\", void 0);\n      _defineProperty(this, \"selectedChange\", new EventEmitter());\n      /**\n       * Fires each time the user clicks the button.\n       */\n      _defineProperty(this, \"click\", new EventEmitter());\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"isDisabled\", false);\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE$2);\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED$3);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE$3);\n      _defineProperty(this, \"_themeColor\", DEFAULT_THEME_COLOR$2);\n      _defineProperty(this, \"_focused\", false);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"_selected\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"_iconClass\", void 0);\n      _defineProperty(this, \"_icon\", void 0);\n      _defineProperty(this, \"_svgIcon\", void 0);\n      this.renderer = renderer;\n      this.service = service;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.element = element.nativeElement;\n    }\n    ngOnInit() {\n      if (!this.element.hasAttribute('role') && this.togglable) {\n        this.toggleAriaPressed(this.toggleable);\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(this.element, 'click', this._onButtonClick.bind(this)));\n        this.subs.add(this.renderer.listen(this.element, 'mousedown', event => {\n          const isBrowserSafari = isDocumentAvailable() && isSafari(navigator.userAgent);\n          if (!this.isDisabled && isBrowserSafari) {\n            event.preventDefault();\n            this.element.focus();\n          }\n        }));\n      });\n    }\n    ngOnChanges(change) {\n      if (isChanged('togglable', change) || isChanged('toggleable', change)) {\n        this.toggleAriaPressed(this.toggleable);\n      }\n    }\n    ngAfterViewInit() {\n      const stylingOptions = ['size', 'rounded', 'fillMode'];\n      stylingOptions.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    get hasText() {\n      return isDocumentAvailable() && this.element.textContent.trim().length > 0;\n    }\n    /**\n     * Focuses the Button component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.element.focus();\n        this.isFocused = true;\n      }\n    }\n    /**\n     * Blurs the Button component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.element.blur();\n        this.isFocused = false;\n      }\n    }\n    /**\n     * @hidden\n     */\n    setAttribute(attribute, value) {\n      this.renderer.setAttribute(this.element, attribute, value);\n    }\n    /**\n     * @hidden\n     */\n    removeAttribute(attribute) {\n      this.renderer.removeAttribute(this.element, attribute);\n    }\n    /**\n     * @hidden\n     *\n     * Internal setter that triggers selectedChange\n     */\n    setSelected(value) {\n      const changed = this.selected !== value;\n      this.selected = value;\n      this.setAttribute('aria-pressed', this.selected.toString());\n      this.toggleClass('k-selected', this.selected);\n      if (changed && hasObservers(this.selectedChange)) {\n        this.ngZone.run(() => {\n          this.selectedChange.emit(value);\n        });\n      }\n    }\n    toggleAriaPressed(shouldSet) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (shouldSet) {\n        this.setAttribute('aria-pressed', this.selected.toString());\n      } else {\n        this.removeAttribute('aria-pressed');\n      }\n    }\n    toggleClass(className, add) {\n      if (add) {\n        this.renderer.addClass(this.element, className);\n      } else {\n        this.renderer.removeClass(this.element, className);\n      }\n    }\n    _onButtonClick() {\n      if (!this.disabled && this.service) {\n        this.ngZone.run(() => {\n          this.service.click(this);\n        });\n      }\n      if (this.togglable && !this.service) {\n        this.setSelected(!this.selected);\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.element;\n      const classes = getStylingClasses('button', input, this[input], value);\n      if (input === 'fillMode') {\n        this.handleThemeColor(this.themeColor, this[input], value);\n      }\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleThemeColor(value, prevFillMode, fillMode) {\n      const elem = this.element;\n      const removeFillMode = prevFillMode ? prevFillMode : this.fillMode;\n      const addFillMode = fillMode ? fillMode : this.fillMode;\n      const themeColorClass = getThemeColorClasses('button', removeFillMode, addFillMode, this.themeColor, value);\n      this.renderer.removeClass(elem, themeColorClass.toRemove);\n      if (addFillMode !== 'none' && fillMode !== 'none') {\n        if (themeColorClass.toAdd) {\n          this.renderer.addClass(elem, themeColorClass.toAdd);\n        }\n      }\n    }\n  }\n  _class2 = ButtonComponent;\n  _defineProperty(ButtonComponent, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(KendoButtonService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class2,\n    selectors: [[\"button\", \"kendoButton\", \"\"]],\n    hostVars: 11,\n    hostBindings: function _class2_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function _class2_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function _class2_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.getDirection);\n        i0.ɵɵclassProp(\"k-button\", ctx.classButton)(\"k-toggle-button\", ctx.isToggleable)(\"k-icon-button\", ctx.iconButtonClass)(\"k-disabled\", ctx.classDisabled)(\"k-selected\", ctx.classActive);\n      }\n    },\n    inputs: {\n      arrowIcon: \"arrowIcon\",\n      toggleable: \"toggleable\",\n      togglable: \"togglable\",\n      selected: \"selected\",\n      tabIndex: \"tabIndex\",\n      imageUrl: \"imageUrl\",\n      iconClass: \"iconClass\",\n      icon: \"icon\",\n      disabled: \"disabled\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      svgIcon: \"svgIcon\",\n      primary: \"primary\",\n      look: \"look\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      click: \"click\"\n    },\n    exportAs: [\"kendoButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c0,\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 5,\n    consts: [[\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"class\", \"k-button-arrow\", 4, \"ngIf\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"], [1, \"k-button-arrow\"], [3, \"name\", \"svgIcon\"]],\n    template: function _class2_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class2_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class2_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class2_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, _class2_span_5_Template, 1, 1, \"span\", 2);\n        i0.ɵɵtemplate(6, _class2_span_6_Template, 2, 2, \"span\", 4);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.arrowIcon.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.arrowIcon && !ctx.arrowIcon.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return ButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * @hidden\n */\nconst tabindex = 'tabindex';\n/**\n * Represents the Kendo UI ButtonGroup component for Angular.\n */\nlet ButtonGroupComponent = /*#__PURE__*/(() => {\n  var _class4;\n  class ButtonGroupComponent {\n    /**\n     * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabIndex(value) {\n      this._tabIndex = value;\n      this.currentTabIndex = value;\n    }\n    get tabIndex() {\n      return this._tabIndex;\n    }\n    /**\n     * When this option is set to `true` (default), the component is a single tab-stop,\n     * and focus is moved through the inner buttons via the arrow keys.\n     *\n     * When the option is set to `false`, the inner buttons are part of the natural tab sequence of the page.\n     *\n     * @default true\n     */\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    get stretchedClass() {\n      return !!this.width;\n    }\n    get dir() {\n      return this.direction;\n    }\n    get ariaDisabled() {\n      return this.disabled;\n    }\n    get wrapperWidth() {\n      return this.width;\n    }\n    get wrapperTabIndex() {\n      return this.disabled ? undefined : this.navigable ? this.currentTabIndex : undefined;\n    }\n    constructor(service, localization, renderer, element) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      /**\n       * By default, the ButtonGroup is enabled.\n       * To disable the whole group of buttons, set its `disabled` attribute to `true`.\n       *\n       * To disable a specific button, set its own `disabled` attribute to `true`\n       * and leave the `disabled` attribute of the ButtonGroup undefined.\n       * If you define the `disabled` attribute of the ButtonGroup, it will take\n       * precedence over the `disabled` attributes of the underlying buttons and they will be ignored.\n       *\n       * For more information on how to configure the Button, refer to\n       * its [API documentation]({% slug api_buttons_buttoncomponent %}).\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      /**\n       * The selection mode of the ButtonGroup.\n       * @default 'multiple'\n       */\n      _defineProperty(this, \"selection\", 'multiple');\n      /**\n       * Sets the width of the ButtonGroup.\n       * If the width of the ButtonGroup is set:\n       * - The buttons resize automatically to fill the full width of the group wrapper.\n       * - The buttons acquire the same width.\n       */\n      _defineProperty(this, \"width\", void 0);\n      _defineProperty(this, \"navigable\", true);\n      /**\n       * Fires every time keyboard navigation occurs.\n       */\n      _defineProperty(this, \"navigate\", new EventEmitter());\n      _defineProperty(this, \"buttons\", void 0);\n      _defineProperty(this, \"_tabIndex\", 0);\n      _defineProperty(this, \"currentTabIndex\", 0);\n      _defineProperty(this, \"lastFocusedIndex\", -1);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"wrapperClasses\", true);\n      _defineProperty(this, \"role\", 'group');\n      _defineProperty(this, \"focusHandler\", () => {\n        this.currentTabIndex = -1;\n        this.defocus(this.buttons.toArray());\n        const firstFocusableIndex = this.buttons.toArray().findIndex(current => !current.disabled);\n        const index = this.lastFocusedIndex === -1 ? firstFocusableIndex : this.lastFocusedIndex;\n        this.focus(this.buttons.filter((_current, i) => {\n          return i === index;\n        }));\n      });\n      this.service = service;\n      this.renderer = renderer;\n      this.element = element;\n      validatePackage(packageMetadata);\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n    }\n    ngOnInit() {\n      this.subs.add(this.service.buttonClicked$.subscribe(button => {\n        let newSelectionValue;\n        if (this.isSelectionSingle()) {\n          newSelectionValue = true;\n          this.deactivate(this.buttons.filter(current => current !== button));\n        } else {\n          if (this.navigable) {\n            this.defocus(this.buttons.toArray());\n          }\n          newSelectionValue = !button.selected;\n        }\n        if (button.togglable) {\n          button.setSelected(newSelectionValue);\n        }\n        if (this.navigable) {\n          this.currentTabIndex = -1;\n          this.renderer.setAttribute(button, tabindex, '0');\n        }\n      }));\n      this.handleSubs('focus', () => this.navigable, this.focusHandler);\n      this.handleSubs('keydown', () => this.navigable && !this.disabled, event => this.navigateFocus(event));\n      this.handleSubs('focusout', event => this.navigable && event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement, () => {\n        this.lastFocusedIndex = this.buttons.toArray().findIndex(button => button.tabIndex !== -1);\n        this.defocus(this.buttons.toArray());\n        this.currentTabIndex = this.tabIndex;\n      });\n      this.subs.add(fromEvent(this.element.nativeElement, 'focusout').pipe(filter(event => this.navigable && event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement)).subscribe(() => {\n        this.defocus(this.buttons.toArray());\n        this.currentTabIndex = this.tabIndex;\n      }));\n    }\n    ngOnChanges(changes) {\n      if (isChanged('disabled', changes)) {\n        this.buttons.forEach(button => {\n          if (isPresent(this.disabled)) {\n            button.disabled = this.disabled;\n          }\n        });\n      }\n      if (isChanged('navigable', changes)) {\n        if (changes['navigable'].currentValue) {\n          this.defocus(this.buttons.toArray());\n          this.currentTabIndex = 0;\n        } else {\n          this.currentTabIndex = -1;\n          this.buttons.forEach(button => this.renderer.setAttribute(button, tabindex, '0'));\n        }\n      }\n    }\n    ngAfterContentInit() {\n      if (!this.navigable) {\n        return;\n      }\n      this.defocus(this.buttons.toArray());\n    }\n    ngAfterViewChecked() {\n      if (this.buttons.length) {\n        this.renderer.addClass(this.buttons.first.element, 'k-group-start');\n        this.renderer.addClass(this.buttons.last.element, 'k-group-end');\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    navigateFocus(event) {\n      const navigationButtons = this.buttons.toArray().filter(button => !button.disabled);\n      const focusedIndex = navigationButtons.findIndex(current => current.element.tabIndex !== -1);\n      const firstIndex = 0;\n      const lastIndex = navigationButtons.length - 1;\n      const eventArgs = new PreventableEvent();\n      if (event.keyCode === Keys.ArrowRight && focusedIndex < lastIndex) {\n        this.navigate.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n          this.defocus(navigationButtons);\n          this.focus(navigationButtons.filter((_current, index) => {\n            return index === focusedIndex + 1;\n          }));\n        }\n      }\n      if (event.keyCode === Keys.ArrowLeft && focusedIndex > firstIndex) {\n        this.navigate.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n          this.defocus(navigationButtons);\n          this.focus(navigationButtons.filter((_current, index) => {\n            return index === focusedIndex - 1;\n          }));\n        }\n      }\n    }\n    deactivate(buttons) {\n      buttons.forEach(button => {\n        button.setSelected(false);\n        if (this.navigable) {\n          this.renderer.setAttribute(button, tabindex, '-1');\n        }\n      });\n    }\n    activate(buttons) {\n      buttons.forEach(button => {\n        button.setSelected(true);\n        if (this.navigable) {\n          this.renderer.setAttribute(button, tabindex, '0');\n        }\n        button.focus();\n      });\n    }\n    defocus(buttons) {\n      buttons.forEach(button => {\n        this.renderer.setAttribute(button, tabindex, '-1');\n      });\n    }\n    focus(buttons) {\n      buttons.forEach(button => {\n        this.renderer.setAttribute(button, tabindex, '0');\n        button.focus();\n      });\n    }\n    verifySettings() {\n      if (isDevMode()) {\n        if (this.isSelectionSingle() && this.buttons.filter(button => button.selected).length > 1) {\n          throw new Error('Having multiple selected buttons with single selection mode is not supported');\n        }\n      }\n    }\n    isSelectionSingle() {\n      return this.selection === 'single';\n    }\n    handleSubs(eventName, predicate, handler) {\n      this.subs.add(fromEvent(this.element.nativeElement, eventName).pipe(filter(predicate)).subscribe(handler));\n    }\n  }\n  _class4 = ButtonGroupComponent;\n  _defineProperty(ButtonGroupComponent, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵdirectiveInject(KendoButtonService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ButtonGroupComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class4,\n    selectors: [[\"kendo-buttongroup\"]],\n    contentQueries: function _class4_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttons = _t);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function _class4_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"dir\", ctx.dir)(\"aria-disabled\", ctx.ariaDisabled)(\"tabindex\", ctx.wrapperTabIndex);\n        i0.ɵɵstyleProp(\"width\", ctx.wrapperWidth);\n        i0.ɵɵclassProp(\"k-button-group\", ctx.wrapperClasses)(\"k-disabled\", ctx.disabledClass)(\"k-button-group-stretched\", ctx.stretchedClass);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      selection: \"selection\",\n      width: \"width\",\n      tabIndex: \"tabIndex\",\n      navigable: \"navigable\"\n    },\n    outputs: {\n      navigate: \"navigate\"\n    },\n    exportAs: [\"kendoButtonGroup\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([KendoButtonService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.buttongroup'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c3,\n    decls: 1,\n    vars: 0,\n    template: function _class4_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c2);\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ButtonGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_THEME_COLOR$1 = 'base';\nconst DEFAULT_FILL_MODE$2 = 'solid';\n/**\n * Displays a Chip that represents an input, attribute or an action.\n */\nlet ChipComponent = /*#__PURE__*/(() => {\n  var _class5;\n  class ChipComponent {\n    /**\n     * The size property specifies the padding of the Chip\n     * ([see example]({% slug appearance_chip %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      !this.sizeIsSet && (this.sizeIsSet = true);\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the Chip\n     * ([see example](slug:appearance_chip#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$2;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the Chip\n     * ([see example](slug:appearance_chip#toc-fill-mode)).\n     *\n     * The possible values are:\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$2;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The Chip allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example](slug:appearance_chip#toc-theme-colors)).\n     *\n     * The possible values are:\n     * * `base` (default)\n     * * `info`\n     * * `success`\n     * * `warning`\n     * * `error`\n     * * `none`\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR$1;\n      this.handleThemeColor(newThemeColor);\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Fires each time the user clicks the remove icon of the Chip.\n     */\n\n    get hasIconClass() {\n      return Boolean(this.icon || this.iconClass || this.avatarSettings && !isObjectEmpty(this.avatarSettings));\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get selectedClass() {\n      return this.selected;\n    }\n    get focusedClass() {\n      return this.focused;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(element, renderer, ngZone, localizationService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      /**\n       * Sets the label text of the Chip.\n       */\n      _defineProperty(this, \"label\", void 0);\n      /**\n       * Defines the name for an existing icon in a Kendo UI theme.\n       * The icon is rendered inside the Chip by a `span.k-icon` element.\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * Defines an [`SVGIcon`](slug:api_icons_svgicon) icon to be rendered inside the Chip using\n       * a [`KendoSVGIcon`](slug:api_icons_svgiconcomponent) component.\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Defines a CSS class — or multiple classes separated by spaces —\n       * which are applied to a span element.\n       * Allows the usage of custom icons.\n       */\n      _defineProperty(this, \"iconClass\", void 0);\n      /**\n       * Use these settings to render an avatar within the Chip.\n       */\n      _defineProperty(this, \"avatarSettings\", void 0);\n      /**\n       * Specifies the selected state of the Chip.\n       * @default false\n       */\n      _defineProperty(this, \"selected\", false);\n      /**\n       * Specifies if the Chip will be removable or not.\n       * If the property is set to `true`, the Chip renders a remove icon.\n       * @default false\n       */\n      _defineProperty(this, \"removable\", false);\n      /**\n       * Specifies a custom remove font icon class that will be rendered when the Chip is removable.\n       * [see example]({% slug icons %})\n       */\n      _defineProperty(this, \"removeIcon\", void 0);\n      /**\n       * Specifies a custom remove SVG icon that will be rendered when the Chip is removable.\n       */\n      _defineProperty(this, \"removeSvgIcon\", void 0);\n      /**\n       * @hidden\n       *\n       * Determines whether the Chip has a menu.\n       */\n      _defineProperty(this, \"hasMenu\", false);\n      /**\n       * @hidden\n       *\n       * Specifies a custom menu font icon class that will be rendered when the Chip has menu.\n       */\n      _defineProperty(this, \"menuIcon\", void 0);\n      /**\n       * @hidden\n       *\n       * Specifies a custom menu SVG icon that will be rendered when the Chip has menu.\n       */\n      _defineProperty(this, \"menuSvgIcon\", void 0);\n      /**\n       * If set to `true`, the Chip will be disabled.\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"remove\", new EventEmitter());\n      /**\n       * @hidden\n       *\n       * Fires each time the user clicks the menu icon of the Chip.\n       */\n      _defineProperty(this, \"menuToggle\", new EventEmitter());\n      /**\n       * Fires each time the user clicks the content of the Chip.\n       */\n      _defineProperty(this, \"contentClick\", new EventEmitter());\n      _defineProperty(this, \"tabIndex\", 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"defaultRemoveIcon\", xCircleIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"defaultMenuIcon\", moreVerticalIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"sizeIsSet\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_themeColor\", 'base');\n      _defineProperty(this, \"focused\", false);\n      _defineProperty(this, \"subs\", new Subscription());\n      this.element = element;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.localizationService = localizationService;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.subs.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.renderer.setAttribute(this.element.nativeElement, 'role', 'button');\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    ngOnChanges(changes) {\n      if (changes && changes['selected']) {\n        const hasAriaSelected = this.element.nativeElement.hasAttribute('aria-selected');\n        if (!hasAriaSelected) {\n          this.renderer.setAttribute(this.element.nativeElement, 'aria-pressed', `${this.selected}`);\n        }\n      }\n    }\n    ngAfterViewInit() {\n      const chip = this.element.nativeElement;\n      const stylingOptions = ['size', 'rounded', 'fillMode'];\n      stylingOptions.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.attachElementEventHandlers(chip);\n    }\n    /**\n     * @hidden\n     */\n    get kendoIconClass() {\n      this.verifyIconSettings([this.iconClass]);\n      return `k-i-${this.icon}`;\n    }\n    /**\n     * @hidden\n     */\n    get customIconClass() {\n      this.verifyIconSettings([this.icon]);\n      return this.iconClass;\n    }\n    /**\n     * @hidden\n     */\n    get removeIconClass() {\n      return this.removeIcon ? this.removeIcon : 'k-i-x-circle';\n    }\n    /**\n     * Focuses the Chip component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.element.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the Chip component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.element.nativeElement.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onRemoveClick(e) {\n      if (this.removable) {\n        this.remove.emit({\n          sender: this,\n          originalEvent: e\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onMenuClick(e) {\n      if (this.hasMenu) {\n        this.menuToggle.emit({\n          sender: this,\n          originalEvent: e\n        });\n      }\n    }\n    attachElementEventHandlers(chip) {\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(chip, 'focus', () => {\n          this.renderer.addClass(chip, 'k-focus');\n        }));\n        this.subs.add(this.renderer.listen(chip, 'blur', () => {\n          this.renderer.removeClass(chip, 'k-focus');\n        }));\n        this.subs.add(this.renderer.listen(chip, 'click', e => {\n          const isActionClicked = closest(e.target, '.k-chip-action');\n          if (!isActionClicked) {\n            this.ngZone.run(() => {\n              this.contentClick.emit({\n                sender: this,\n                originalEvent: e\n              });\n            });\n          }\n        }));\n        this.subs.add(this.renderer.listen(chip, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n    /**\n     * @hidden\n     */\n    verifyIconSettings(iconsToCheck) {\n      if (isDevMode()) {\n        if (iconsToCheck.filter(icon => icon !== null && icon !== undefined).length > 0) {\n          this.renderer.removeClass(this.element.nativeElement, 'k-chip-has-icon');\n          throw new Error('Invalid configuration: Having multiple icons is not supported. Only a single icon on a chip can be displayed.');\n        }\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('chip', input, this[input], value);\n      if (input === 'fillMode') {\n        this.handleThemeColor(this.themeColor, this[input], value);\n      }\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleThemeColor(value, prevFillMode, fillMode) {\n      const elem = this.element.nativeElement;\n      const removeFillMode = prevFillMode ? prevFillMode : this.fillMode;\n      const addFillMode = fillMode ? fillMode : this.fillMode;\n      const themeColorClass = getThemeColorClasses('chip', removeFillMode, addFillMode, this.themeColor, value);\n      this.renderer.removeClass(elem, themeColorClass.toRemove);\n      if (addFillMode !== 'none' && fillMode !== 'none') {\n        if (themeColorClass.toAdd) {\n          this.renderer.addClass(elem, themeColorClass.toAdd);\n        }\n      }\n    }\n    keyDownHandler(e) {\n      const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n      const isDeleteOrBackspace = e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace;\n      if (this.disabled) {\n        return;\n      }\n      if (isEnterOrSpace) {\n        this.ngZone.run(() => {\n          this.contentClick.emit({\n            sender: this,\n            originalEvent: e\n          });\n        });\n      } else if (isDeleteOrBackspace && this.removable) {\n        this.ngZone.run(() => {\n          this.remove.emit({\n            sender: this,\n            originalEvent: e\n          });\n        });\n      }\n    }\n  }\n  _class5 = ChipComponent;\n  _defineProperty(ChipComponent, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ChipComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class5,\n    selectors: [[\"kendo-chip\"]],\n    hostVars: 13,\n    hostBindings: function _class5_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex)(\"aria-disabled\", ctx.disabledClass)(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-chip\", ctx.hostClass)(\"k-chip-has-icon\", ctx.hasIconClass)(\"k-disabled\", ctx.disabledClass)(\"k-selected\", ctx.selectedClass)(\"k-focus\", ctx.focusedClass);\n      }\n    },\n    inputs: {\n      label: \"label\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      avatarSettings: \"avatarSettings\",\n      selected: \"selected\",\n      removable: \"removable\",\n      removeIcon: \"removeIcon\",\n      removeSvgIcon: \"removeSvgIcon\",\n      hasMenu: \"hasMenu\",\n      menuIcon: \"menuIcon\",\n      menuSvgIcon: \"menuSvgIcon\",\n      disabled: \"disabled\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\"\n    },\n    outputs: {\n      remove: \"remove\",\n      menuToggle: \"menuToggle\",\n      contentClick: \"contentClick\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chip'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 6,\n    consts: [[\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"customFontClass\", 4, \"ngIf\"], [\"class\", \"k-chip-avatar k-avatar k-avatar-sm k-avatar-solid k-avatar-solid-primary k-rounded-full\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"k-chip-content\"], [\"class\", \"k-chip-label\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-chip-actions\", 4, \"ngIf\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"name\", \"svgIcon\"], [\"size\", \"small\", \"innerCssClass\", \"k-chip-icon\", 3, \"customFontClass\"], [1, \"k-chip-avatar\", \"k-avatar\", \"k-avatar-sm\", \"k-avatar-solid\", \"k-avatar-solid-primary\", \"k-rounded-full\", 3, \"ngStyle\"], [1, \"k-avatar-image\"], [3, \"src\", \"ngStyle\"], [1, \"k-avatar-text\", 3, \"ngStyle\"], [1, \"k-chip-label\"], [1, \"k-chip-actions\"], [\"class\", \"k-chip-action k-chip-more-action\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"k-chip-action k-chip-remove-action\", 3, \"click\", 4, \"ngIf\"], [1, \"k-chip-action\", \"k-chip-more-action\", 3, \"click\"], [\"name\", \"more-vertical\", \"size\", \"small\", 3, \"svgIcon\", \"customFontClass\"], [1, \"k-chip-action\", \"k-chip-remove-action\", 3, \"click\"], [\"name\", \"x-circle\", \"size\", \"small\", 3, \"svgIcon\", \"customFontClass\"]],\n    template: function _class5_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class5_kendo_icon_wrapper_0_Template, 1, 2, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class5_kendo_icon_wrapper_1_Template, 1, 1, \"kendo-icon-wrapper\", 1);\n        i0.ɵɵtemplate(2, _class5_span_2_Template, 3, 3, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵtemplate(4, _class5_span_4_Template, 2, 1, \"span\", 4);\n        i0.ɵɵtemplate(5, _class5_ng_content_5_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, _class5_span_6_Template, 3, 2, \"span\", 6);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.avatarSettings);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.label);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.label);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasMenu || ctx.removable);\n      }\n    },\n    dependencies: [NgIf, NgStyle, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ChipComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ChipListComponent = /*#__PURE__*/(() => {\n  var _class6;\n  class ChipListComponent {\n    /**\n     * The size property specifies the gap between the Chips in the ChipList\n     * ([see example]({% slug appearance_chiplist %}#toc-size)).\n     *\n     * The possible values are:\n     * * `'small'`\n     * * `'medium'` (default)\n     * * `'large'`\n     * * `none`\n     */\n    set size(size) {\n      const sizeValue = size ? size : 'medium';\n      this.handleClasses(sizeValue, 'size');\n      this.chips?.forEach(chip => this.setChipSize(chip, sizeValue));\n      this._size = sizeValue;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Fires each time when the ChipList selection is changed.\n     */\n\n    get single() {\n      return this.selection === 'single';\n    }\n    get multiple() {\n      return this.selection === 'multiple';\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    onClick($event) {\n      const target = $event.target;\n      const isRemoveClicked = closest(target, '.k-chip-remove-action');\n      const clickedChip = closest(target, '.k-chip');\n      const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n      this.currentActiveIndex = this.chips.toArray().indexOf(chip);\n      chip && chip.focus();\n      if (chip && this.navigable) {\n        this.chips.forEach(c => {\n          this.renderer.setAttribute(c.element.nativeElement, 'tabindex', '-1');\n        });\n        this.renderer.setAttribute(chip.element.nativeElement, 'tabindex', '0');\n      }\n      if (isRemoveClicked && clickedChip) {\n        const removeEventArgs = {\n          sender: this,\n          originalEvent: $event,\n          removedChip: chip\n        };\n        this.remove.emit(removeEventArgs);\n      }\n      if (this.selection !== 'none' && clickedChip && !isRemoveClicked) {\n        this.setSelection(chip);\n      }\n    }\n    /**\n     * By default, keyboard navigation is available through arrow keys and roving tabindex.\n     * When set to `false`, all chips are part of the default tabbing sequence of the page.\n     *\n     * @default true\n     */\n    set navigable(value) {\n      this._navigable = value;\n      this.chips?.forEach(c => this.renderer.setAttribute(c.element.nativeElement, 'tabindex', value ? '-1' : '0'));\n      this.chips?.first && this.renderer.setAttribute(this.chips.first.element.nativeElement, 'tabindex', '0');\n    }\n    get navigable() {\n      return this._navigable;\n    }\n    constructor(localizationService, renderer, element, ngZone) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"orientation\", 'horizontal');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Sets the selection mode of the ChipList.\n       *\n       * The available values are:\n       * * `none` (default)\n       * * `single`\n       * * `multiple`\n       */\n      _defineProperty(this, \"selection\", 'none');\n      _defineProperty(this, \"selectedChange\", new EventEmitter());\n      /**\n       * Fires each time the user clicks on the remove icon of the Chip.\n       */\n      _defineProperty(this, \"remove\", new EventEmitter());\n      _defineProperty(this, \"chips\", void 0);\n      _defineProperty(this, \"role\", 'listbox');\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"_navigable\", true);\n      _defineProperty(this, \"currentActiveIndex\", 0);\n      this.localizationService = localizationService;\n      this.renderer = renderer;\n      this.element = element;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.attachElementEventHandlers();\n      this.updateChips();\n    }\n    ngAfterContentInit() {\n      this.subs.add(this.chips?.changes.subscribe(() => this.updateChips()));\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n      this.subs.unsubscribe();\n    }\n    selectedChips() {\n      return this.chips.reduce((acc, cur, idx) => {\n        return cur.selected ? acc.concat(idx) : acc;\n      }, []);\n    }\n    /**\n     * Updates the selection on click of a Chip. Emits events.\n     */\n    setSelection(chip) {\n      if (this.selection === 'single') {\n        this.clearSelection(chip);\n      }\n      chip.selected = !chip.selected;\n      const chipEl = chip.element.nativeElement;\n      this.renderer.setAttribute(chipEl, 'aria-selected', `${chip.selected}`);\n      this.selectedChange.emit(this.selectedChips());\n    }\n    clearSelection(chip) {\n      this.chips.forEach(c => {\n        if (chip !== c) {\n          c.selected = false;\n          this.renderer.setAttribute(c.element.nativeElement, 'aria-selected', 'false');\n        }\n      });\n    }\n    handleClasses(value, input) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('chip-list', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    attachElementEventHandlers() {\n      const chiplist = this.element.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(chiplist, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n    keyDownHandler(e) {\n      const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n      const isDeleteOrBackspace = e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace;\n      const isLeftArrow = e.keyCode === Keys.ArrowLeft;\n      const isRightArrow = e.keyCode === Keys.ArrowRight;\n      if (isEnterOrSpace) {\n        const target = e.target;\n        const clickedChip = closest(target, '.k-chip');\n        const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n        this.currentActiveIndex = this.chips.toArray().findIndex(chip => clickedChip === chip.element.nativeElement);\n        if (this.selection !== 'none' && clickedChip) {\n          this.ngZone.run(() => {\n            this.setSelection(chip);\n          });\n        }\n      } else if (isDeleteOrBackspace) {\n        const target = e.target;\n        const clickedChip = closest(target, '.k-chip');\n        const chip = this.chips.find(chip => clickedChip === chip.element.nativeElement);\n        if (clickedChip) {\n          const removeEventArgs = {\n            sender: this,\n            originalEvent: e,\n            removedChip: chip\n          };\n          this.ngZone.run(() => {\n            this.remove.emit(removeEventArgs);\n          });\n        }\n      } else if (isLeftArrow) {\n        this.handleArrowKeys('left');\n      } else if (isRightArrow) {\n        this.handleArrowKeys('right');\n      }\n    }\n    handleArrowKeys(direction) {\n      if (!this.navigable) {\n        return;\n      }\n      const directionDelta = direction === 'left' ? -1 : 1;\n      this.currentActiveIndex = this.currentActiveIndex + directionDelta;\n      if (this.currentActiveIndex >= this.chips.length) {\n        this.currentActiveIndex = 0;\n      } else if (this.currentActiveIndex < 0) {\n        this.currentActiveIndex = this.chips.length - 1;\n      }\n      this.chips.forEach((chip, idx) => {\n        this.renderer.setAttribute(chip.element.nativeElement, 'tabindex', '-1');\n        if (idx === this.currentActiveIndex) {\n          this.renderer.setAttribute(chip.element.nativeElement, 'tabindex', '0');\n          chip.focus();\n        }\n      });\n    }\n    updateChips() {\n      this.normalizeActiveIndex();\n      this.chips.forEach((chip, idx) => {\n        const chipEl = chip.element.nativeElement;\n        this.renderer.removeAttribute(chipEl, 'aria-pressed');\n        this.renderer.setAttribute(chipEl, 'aria-selected', `${chip.selected}`);\n        this.role === 'listbox' && this.renderer.setAttribute(chipEl, 'role', 'option');\n        if (!this.navigable) {\n          return;\n        }\n        this.renderer.setAttribute(chipEl, 'tabindex', '-1');\n        if (idx === this.currentActiveIndex) {\n          this.renderer.setAttribute(chipEl, 'tabindex', '0');\n          if (isDocumentAvailable() && document.activeElement.closest('.k-chip-list')) {\n            chip.focus();\n          }\n        }\n        if (chip.removable) {\n          this.renderer.setAttribute(chipEl, 'aria-keyshortcuts', 'Enter Delete');\n        }\n        this.setChipSize(chip, this.size);\n      });\n    }\n    normalizeActiveIndex() {\n      if (this.currentActiveIndex >= this.chips.length) {\n        this.currentActiveIndex = Math.max(this.chips.length - 1, 0);\n      }\n    }\n    setChipSize(chip, size) {\n      const hasSize = chip.sizeIsSet;\n      !hasSize && chip.size !== size && (chip.size = size);\n      !hasSize && (chip.sizeIsSet = false);\n    }\n  }\n  _class6 = ChipListComponent;\n  _defineProperty(ChipListComponent, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ChipListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class6,\n    selectors: [[\"kendo-chiplist\"], [\"kendo-chip-list\"]],\n    contentQueries: function _class6_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ChipComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chips = _t);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function _class6_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class6_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"dir\", ctx.direction)(\"aria-multiselectable\", ctx.multiple)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-chip-list\", ctx.hostClass)(\"k-selection-single\", ctx.single)(\"k-selection-multiple\", ctx.multiple);\n      }\n    },\n    inputs: {\n      selection: \"selection\",\n      size: \"size\",\n      role: \"role\",\n      navigable: \"navigable\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      remove: \"remove\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chiplist'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function _class6_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ChipListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Used for rendering the list item content.\n *\n * To define the item template, nest a `<ng-template>` tag with the `kendo<ComponentName>ItemTemplate` directive inside the component tag.\n *\n * For the DropDownButton, use the `kendoDropDownButtonItemTemplate` directive.\n * For the SplitButton, use the `kendoSplitButtonItemTemplate` directive.\n *\n * The template context is set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"listItems\">\n *    <ng-template kendoSplitButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-splitbutton>\n *  <kendo-dropdownbutton [data]=\"listItems\">\n *    <ng-template kendoDropDownButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<any> = [{\n *      text: 'item1',\n *      icon: 'arrow-rotate-cw',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }, {\n *      text: 'item2',\n *      icon: 'arrow-rotate-cw',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }]\n * }\n * ```\n *\n * For more examples, refer to the article on the [DropDownButton templates](slug:itemstemplates_dropdownbutton).\n */\nlet ButtonItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class7;\n  class ButtonItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class7 = ButtonItemTemplateDirective;\n  _defineProperty(ButtonItemTemplateDirective, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(ButtonItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class7,\n    selectors: [[\"\", \"kendoDropDownButtonItemTemplate\", \"\"], [\"\", \"kendoSplitButtonItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ButtonItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FocusService = /*#__PURE__*/(() => {\n  var _class8;\n  class FocusService {\n    constructor() {\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      _defineProperty(this, \"focusedIndex\", void 0);\n    }\n    isFocused(index) {\n      return index === this.focused;\n    }\n    focus(index) {\n      if (this.isFocused(index)) {\n        return;\n      }\n      this.focused = index;\n      this.onFocus.emit(index);\n    }\n    resetFocus() {\n      this.focused = -1;\n    }\n    get focused() {\n      return this.focusedIndex;\n    }\n    set focused(index) {\n      this.focusedIndex = index;\n      this.onFocus.emit(index);\n    }\n  }\n  _class8 = FocusService;\n  _defineProperty(FocusService, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)();\n  });\n  _defineProperty(FocusService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class8,\n    factory: _class8.ɵfac\n  }));\n  return FocusService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nvar KeyEvents = /*#__PURE__*/function (KeyEvents) {\n  KeyEvents[KeyEvents[\"keydown\"] = 0] = \"keydown\";\n  KeyEvents[KeyEvents[\"keypress\"] = 1] = \"keypress\";\n  KeyEvents[KeyEvents[\"keyup\"] = 2] = \"keyup\";\n  return KeyEvents;\n}(KeyEvents || {});\n/**\n * @hidden\n */\nvar NavigationAction = /*#__PURE__*/function (NavigationAction) {\n  // eslint-disable-next-line id-denylist\n  NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n  NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n  NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n  NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n  NavigationAction[NavigationAction[\"EnterPress\"] = 4] = \"EnterPress\";\n  NavigationAction[NavigationAction[\"EnterUp\"] = 5] = \"EnterUp\";\n  NavigationAction[NavigationAction[\"Tab\"] = 6] = \"Tab\";\n  NavigationAction[NavigationAction[\"Esc\"] = 7] = \"Esc\";\n  NavigationAction[NavigationAction[\"Navigate\"] = 8] = \"Navigate\";\n  return NavigationAction;\n}(NavigationAction || {});\n/**\n * @hidden\n */\nconst NAVIGATION_CONFIG = new InjectionToken('navigation.config');\n\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class9;\n  class NavigationService {\n    constructor(config) {\n      _defineProperty(this, \"navigate\", new EventEmitter());\n      _defineProperty(this, \"open\", new EventEmitter());\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"enter\", new EventEmitter());\n      _defineProperty(this, \"enterpress\", new EventEmitter());\n      _defineProperty(this, \"enterup\", new EventEmitter());\n      _defineProperty(this, \"tab\", new EventEmitter());\n      _defineProperty(this, \"esc\", new EventEmitter());\n      _defineProperty(this, \"useLeftRightArrows\", void 0);\n      this.useLeftRightArrows = config.useLeftRightArrows;\n    }\n    process(args) {\n      const keyCode = args.keyCode;\n      const keyEvent = args.keyEvent;\n      let index;\n      let action = NavigationAction.Undefined;\n      if (keyEvent === KeyEvents.keyup) {\n        if (this.isEnterOrSpace(keyCode)) {\n          action = NavigationAction.EnterUp;\n        }\n      } else {\n        if (args.altKey && keyCode === Keys.ArrowDown) {\n          action = NavigationAction.Open;\n        } else if (args.altKey && keyCode === Keys.ArrowUp) {\n          action = NavigationAction.Close;\n        } else if (this.isEnterOrSpace(keyCode)) {\n          action = NavigationAction.Enter;\n        } else if (keyCode === Keys.Escape) {\n          action = NavigationAction.Esc;\n        } else if (keyCode === Keys.Tab) {\n          action = NavigationAction.Tab;\n        } else if (keyCode === Keys.ArrowUp || this.useLeftRightArrows && keyCode === Keys.ArrowLeft) {\n          const step = args.flipNavigation ? 1 : -1;\n          const start = args.flipNavigation ? args.min : args.max;\n          const end = args.flipNavigation ? args.max : args.min;\n          index = this.next({\n            current: args.current,\n            start: start,\n            end: end,\n            step: step\n          });\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.ArrowDown || this.useLeftRightArrows && keyCode === Keys.ArrowRight) {\n          const step = args.flipNavigation ? -1 : 1;\n          const start = args.flipNavigation ? args.max : args.min;\n          const end = args.flipNavigation ? args.min : args.max;\n          index = this.next({\n            current: args.current,\n            start: start,\n            end: end,\n            step: step\n          });\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.Home) {\n          index = args.min;\n          action = NavigationAction.Navigate;\n        } else if (keyCode === Keys.End) {\n          index = args.max;\n          action = NavigationAction.Navigate;\n        }\n      }\n      if (action !== NavigationAction.Undefined) {\n        this[NavigationAction[action].toLowerCase()].emit({\n          index,\n          target: args.target,\n          esc: action === NavigationAction.Esc\n        });\n      }\n      return action;\n    }\n    isEnterOrSpace(keyCode) {\n      return keyCode === Keys.Enter || keyCode === Keys.Space;\n    }\n    next(args) {\n      if (!isPresent(args.current)) {\n        return args.start;\n      } else {\n        return args.current !== args.end ? args.current + args.step : args.end;\n      }\n    }\n  }\n  _class9 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵinject(NAVIGATION_CONFIG));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class9,\n    factory: _class9.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet PopupContainerService = /*#__PURE__*/(() => {\n  var _class10;\n  class PopupContainerService {\n    constructor() {\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"template\", void 0);\n    }\n  }\n  _class10 = PopupContainerService;\n  _defineProperty(PopupContainerService, \"\\u0275fac\", function _class10_Factory(t) {\n    return new (t || _class10)();\n  });\n  _defineProperty(PopupContainerService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class10,\n    factory: _class10.ɵfac\n  }));\n  return PopupContainerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FocusableDirective = /*#__PURE__*/(() => {\n  var _class11;\n  class FocusableDirective {\n    constructor(focusService, elementRef, renderer) {\n      _defineProperty(this, \"focusService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      this.focusService = focusService;\n      this.renderer = renderer;\n      this.element = elementRef.nativeElement;\n      this.subscribeEvents();\n    }\n    ngOnInit() {\n      if (this.index === this.focusService.focused) {\n        this.renderer.addClass(this.element, 'k-focus');\n      } else {\n        this.renderer.removeClass(this.element, 'k-focus');\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subs.add(this.focusService.onFocus.subscribe(index => {\n        if (this.index === index) {\n          this.renderer.addClass(this.element, 'k-focus');\n          this.renderer.setAttribute(this.element, 'tabindex', '0');\n          this.element.focus();\n        } else {\n          this.renderer.setAttribute(this.element, 'tabindex', '-1');\n          this.renderer.removeClass(this.element, 'k-focus');\n        }\n      }));\n    }\n  }\n  _class11 = FocusableDirective;\n  _defineProperty(FocusableDirective, \"\\u0275fac\", function _class11_Factory(t) {\n    return new (t || _class11)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(FocusableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class11,\n    selectors: [[\"\", \"kendoButtonFocusable\", \"\"]],\n    inputs: {\n      index: \"index\"\n    },\n    standalone: true\n  }));\n  return FocusableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ListComponent = /*#__PURE__*/(() => {\n  var _class12;\n  class ListComponent {\n    set size(size) {\n      if (size) {\n        this.sizeClass = `k-menu-group-${SIZES[size]}`;\n      } else {\n        this.sizeClass = '';\n      }\n    }\n    constructor() {\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"onItemClick\", new EventEmitter());\n      _defineProperty(this, \"onItemBlur\", new EventEmitter());\n      _defineProperty(this, \"sizeClass\", '');\n      validatePackage(packageMetadata);\n    }\n    getText(dataItem) {\n      if (dataItem) {\n        return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n      }\n      return undefined;\n    }\n    getIconClasses(dataItem) {\n      const icon = dataItem.icon ? 'k-icon k-i-' + dataItem.icon : undefined;\n      const classes = {};\n      classes[icon || dataItem.iconClass] = true;\n      return classes;\n    }\n    onClick(index) {\n      this.onItemClick.emit(index);\n    }\n    onBlur() {\n      this.onItemBlur.emit();\n    }\n  }\n  _class12 = ListComponent;\n  _defineProperty(ListComponent, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)();\n  });\n  _defineProperty(ListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class12,\n    selectors: [[\"kendo-button-list\"]],\n    inputs: {\n      data: \"data\",\n      textField: \"textField\",\n      itemTemplate: \"itemTemplate\",\n      size: \"size\"\n    },\n    outputs: {\n      onItemClick: \"onItemClick\",\n      onItemBlur: \"onItemBlur\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"role\", \"list\", 1, \"k-group\", \"k-menu-group\", \"k-reset\", 3, \"ngClass\"], [\"kendoButtonFocusable\", \"\", \"tabindex\", \"-1\", \"class\", \"k-item k-menu-item\", \"role\", \"listitem\", 3, \"index\", \"click\", \"blur\", 4, \"ngFor\", \"ngForOf\"], [\"kendoButtonFocusable\", \"\", \"tabindex\", \"-1\", \"role\", \"listitem\", 1, \"k-item\", \"k-menu-item\", 3, \"index\", \"click\", \"blur\"], [3, \"ngIf\"], [1, \"k-link\", \"k-menu-link\", 3, \"ngClass\"], [3, \"templateContext\"], [3, \"name\", \"svgIcon\", \"customFontClass\", 4, \"ngIf\"], [\"class\", \"k-image\", 3, \"src\", \"alt\", 4, \"ngIf\"], [\"class\", \"k-menu-link-text\", 4, \"ngIf\"], [3, \"name\", \"svgIcon\", \"customFontClass\"], [1, \"k-image\", 3, \"src\", \"alt\"], [1, \"k-menu-link-text\"]],\n    template: function _class12_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, _class12_li_1_Template, 3, 4, \"li\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.sizeClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    dependencies: [NgClass, NgFor, FocusableDirective, NgIf, TemplateContextDirective, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ListButton = /*#__PURE__*/(() => {\n  var _class13;\n  class ListButton extends MultiTabStop {\n    /**\n     * Sets the disabled state of the DropDownButton.\n     */\n    set disabled(value) {\n      if (value && this.openState) {\n        this.openState = false;\n      }\n      this._disabled = value;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.containerService.container : appendTo;\n    }\n    /**\n     * Configures the popup of the DropDownButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'bottom'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'top'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    constructor(focusService, navigationService, wrapperRef, _zone, popupService, elRef, localization, cdr, containerService) {\n      super();\n      _defineProperty(this, \"focusService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"wrapperRef\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"elRef\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"containerService\", void 0);\n      _defineProperty(this, \"listId\", guid());\n      _defineProperty(this, \"buttonId\", guid());\n      _defineProperty(this, \"_data\", void 0);\n      _defineProperty(this, \"_open\", false);\n      _defineProperty(this, \"_disabled\", false);\n      _defineProperty(this, \"_active\", false);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true,\n        popupClass: ''\n      });\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"_itemClick\", void 0);\n      _defineProperty(this, \"_blur\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"popupSubs\", new Subscription());\n      _defineProperty(this, \"button\", void 0);\n      _defineProperty(this, \"buttonList\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"tabIndex\", 0);\n      /**\n       * The CSS classes that will be rendered on the main button.\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"buttonClass\", void 0);\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Needed by the kendoToggleButtonTabStop directive\n       *\n       * @hidden\n       */\n      _defineProperty(this, \"escape\", new EventEmitter());\n      _defineProperty(this, \"isClosePrevented\", false);\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.wrapperRef = wrapperRef;\n      this._zone = _zone;\n      this.popupService = popupService;\n      this.elRef = elRef;\n      this.cdr = cdr;\n      this.containerService = containerService;\n      validatePackage(packageMetadata);\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.wrapper = wrapperRef.nativeElement;\n      this.subs.add(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.subscribeEvents();\n    }\n    ngOnChanges(changes) {\n      if (isChanged(\"popupSettings\", changes) && isPresent(this.popupRef)) {\n        const popup = this.popupRef.popup.instance;\n        const newSettings = changes['popupSettings'].currentValue;\n        popup.popupClass = newSettings.popupClass;\n        popup.animate = newSettings.animate;\n        popup.popupAlign = this.popupAlign;\n      }\n    }\n    get popupClasses() {\n      const popupClasses = ['k-menu-popup'];\n      if (this._popupSettings.popupClass) {\n        popupClasses.push(this._popupSettings.popupClass);\n      }\n      return popupClasses.join(' ');\n    }\n    get openState() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n    set openState(open) {\n      if (this.disabled) {\n        return;\n      }\n      this._open = open;\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n      if (this._disabled) {\n        return;\n      }\n      this._toggle(!this.openState, true);\n      if (!this.isClosePrevented) {\n        this.focusService.focus(this.openState ? 0 : -1);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(index) {\n      this.emitItemClickHandler(index);\n      this.togglePopupVisibility();\n      if (isDocumentAvailable() && !this.isClosePrevented) {\n        this.focusButton();\n      }\n    }\n    ngOnDestroy() {\n      this.openState = false;\n      this.subs.unsubscribe();\n      this.destroyPopup();\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subscribeListItemFocusEvent();\n      this.subscribeComponentBlurredEvent();\n      this.subscribeNavigationEvents();\n    }\n    subscribeListItemFocusEvent() {\n      this.subs.add(this.focusService.onFocus.subscribe(() => {\n        this._isFocused = true;\n      }));\n    }\n    subscribeComponentBlurredEvent() {\n      this._zone.runOutsideAngular(() => {\n        this.subs.add(this.navigationService.tab.pipe(filter(() => this._isFocused), tap(() => this.focusButton())).subscribe(this.handleTab.bind(this)));\n        this.subs.add(fromEvent(document, 'click').pipe(filter(event => !this.wrapperContains(event.target)), filter(() => this._isFocused)).subscribe(() => this._zone.run(() => this.blurWrapper())));\n      });\n    }\n    subscribeNavigationEvents() {\n      this.subs.add(this.navigationService.navigate.subscribe(this.onArrowKeyNavigate.bind(this)));\n      this.subs.add(this.navigationService.enterup.subscribe(this.onNavigationEnterUp.bind(this)));\n      this.subs.add(this.navigationService.open.subscribe(this.onNavigationOpen.bind(this)));\n      this.subs.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this)));\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      if (this.disabled) {\n        return;\n      }\n      const value = open === undefined ? !this.openState : open;\n      this._toggle(value, false);\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(event, isHost) {\n      this.keyHandler(event, null, isHost);\n    }\n    /**\n     * @hidden\n     */\n    keyUpHandler(event) {\n      this.keyHandler(event, KeyEvents.keyup);\n    }\n    /**\n     * @hidden\n     */\n    keyHandler(event, keyEvent, isHost) {\n      if (this._disabled) {\n        return;\n      }\n      const eventData = event;\n      if (!isHost) {\n        eventData.stopImmediatePropagation();\n      }\n      const focused = this.focusService.focused || 0;\n      const action = this.navigationService.process({\n        altKey: eventData.altKey,\n        current: focused,\n        keyCode: eventData.keyCode,\n        keyEvent: keyEvent,\n        max: this._data ? this._data.length - 1 : 0,\n        min: 0,\n        target: event.target\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && (action !== NavigationAction.Enter || action === NavigationAction.Enter && this.openState)) {\n        if (!(event.keyCode === Keys.Space && action === NavigationAction.EnterUp)) {\n          eventData.preventDefault();\n        }\n      }\n    }\n    emitItemClickHandler(index) {\n      const dataItem = this._data[index];\n      if (this._itemClick && !dataItem.disabled) {\n        this._itemClick.emit(dataItem);\n      }\n      if (dataItem && dataItem.click && !dataItem.disabled) {\n        dataItem.click(dataItem);\n      }\n      this.focusService.focus(index);\n    }\n    focusWrapper() {\n      if (this.openState) {\n        this.togglePopupVisibility();\n        this.focusButton();\n      }\n    }\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element);\n    }\n    blurWrapper(emit = true) {\n      if (!this._isFocused) {\n        return;\n      }\n      if (this.openState) {\n        this.togglePopupVisibility();\n      }\n      this._isFocused = false;\n      if (emit) {\n        this._blur.emit();\n        this.cdr.markForCheck();\n      }\n    }\n    focusButton() {\n      if (this.button) {\n        this.button.nativeElement.focus();\n      }\n    }\n    handleTab() {\n      this.blurWrapper();\n    }\n    onNavigationEnterUp(_args) {\n      if (!this._disabled && !this.openState) {\n        this._active = false;\n      }\n      if (this.openState) {\n        const focused = this.focusService.focused;\n        if (isPresent(focused) && focused !== -1) {\n          this.emitItemClickHandler(focused);\n        }\n      }\n      this.togglePopupVisibility();\n      if (!this.openState && isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    onNavigationOpen() {\n      if (!this._disabled && !this.openState) {\n        this.togglePopupVisibility();\n      }\n    }\n    onNavigationClose(e) {\n      if (this.openState && !this.isClosePrevented) {\n        this.togglePopupVisibility();\n        if (isDocumentAvailable()) {\n          e?.esc && hasObservers(this.escape) && this.escape.emit();\n          this.button.nativeElement.focus();\n        }\n      }\n    }\n    onArrowKeyNavigate({\n      index\n    }) {\n      this.focusService.focus(index);\n    }\n    _toggle(open, emitEvent) {\n      if (this.openState === open) {\n        return;\n      }\n      const eventArgs = new PreventableEvent();\n      if (emitEvent) {\n        if (open && !this.openState) {\n          this.open.emit(eventArgs);\n        } else if (!open && this.openState) {\n          this.close.emit(eventArgs);\n        }\n        if (eventArgs.isDefaultPrevented()) {\n          this.isClosePrevented = true;\n          return;\n        }\n      }\n      this.openState = open;\n      this.destroyPopup();\n      if (this.openState) {\n        this.createPopup();\n      }\n    }\n    createPopup() {\n      this.popupRef = this.popupService.open({\n        anchor: this.elRef,\n        anchorAlign: this.anchorAlign,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.containerService.template,\n        popupAlign: this.popupAlign,\n        popupClass: this.popupClasses\n      });\n      this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.togglePopupVisibility();\n      });\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.popupSubs.unsubscribe();\n        this.isClosePrevented = false;\n      }\n    }\n  }\n  _class13 = ListButton;\n  _defineProperty(ListButton, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PopupContainerService));\n  });\n  _defineProperty(ListButton, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class13,\n    selectors: [[\"ng-component\"]],\n    viewQuery: function _class13_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5, ElementRef);\n        i0.ɵɵviewQuery(_c6, 5);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttonList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      tabIndex: \"tabIndex\",\n      buttonClass: \"buttonClass\",\n      popupSettings: \"popupSettings\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\",\n      escape: \"escape\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class13_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ListButton;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS$2 = {\n  useLeftRightArrows: true\n};\nconst NAVIGATION_SETTINGS_PROVIDER$2 = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS$2\n};\nconst DEFAULT_FILL_MODE$1 = 'solid';\n/**\n * Represents the Kendo UI DropDownButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownbutton [data]=\"data\">\n *    User Settings\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'My Profile'\n *   }, {\n *       text: 'Friend Requests'\n *   }, {\n *       text: 'Account Settings'\n *   }, {\n *       text: 'Support'\n *   }, {\n *       text: 'Log Out'\n *   }];\n * }\n * ```\n */\nlet DropDownButtonComponent = /*#__PURE__*/(() => {\n  var _class14;\n  class DropDownButtonComponent extends ListButton {\n    /**\n     * Sets or gets the data of the DropDownButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      return this._data;\n    }\n    /**\n     * The size property specifies the padding of the DropDownButton\n     * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n    /**\n     * The fillMode property specifies the background and border styles of the DropDownButton\n     * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-fillMode)).\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      this._fillMode = fillMode === 'clear' ? 'flat' : fillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The DropDownButton allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n     *\n     * The possible values are:\n     * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n     * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n     * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n     * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n     * * `info`&mdash;Applies coloring based on the `info` theme color.\n     * * `success`&mdash; Applies coloring based on the `success` theme color.\n     * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n     * * `error`&mdash; Applies coloring based on the `error` theme color.\n     * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n     * * `light`&mdash; Applies coloring based on the `light` theme color.\n     * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n     * * `none` &mdash;Removes the default CSS class (no class would be rendered).\n     */\n\n    /**\n     * Sets attributes to the main button.\n     */\n    set buttonAttributes(buttonAttributes) {\n      const newButtonAttributes = buttonAttributes ? buttonAttributes : null;\n      this.handleButtonAttributes(newButtonAttributes);\n      this._buttonAttributes = newButtonAttributes;\n    }\n    get buttonAttributes() {\n      return this._buttonAttributes;\n    }\n    /**\n     * Fires each time the user clicks on a drop-down list item. The event data contains the data item bound to the clicked list item.\n     */\n\n    get focused() {\n      return this._isFocused && !this._disabled;\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n      return this._active;\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n      this.keyDownHandler(event, true);\n      if (event.keyCode === Keys.Space || event.keyCode === Keys.Enter) {\n        this._active = true;\n      }\n      if (event.keyCode === Keys.Enter) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n      this.keyUpHandler(event);\n      this._active = false;\n    }\n    /**\n     * @hidden\n     */\n    mousedown(event) {\n      if (this._disabled) {\n        event.preventDefault();\n      } else {\n        this._active = true;\n      }\n    }\n    /**\n     * @hidden\n     */\n    mouseup(event) {\n      if (this._disabled) {\n        event.preventDefault();\n      }\n      this._active = false;\n    }\n    /**\n     * @hidden\n     */\n    openPopup() {\n      this._isFocused = true;\n      this.togglePopupVisibility();\n    }\n    /**\n     * @hidden\n     */\n    onButtonBlur() {\n      if (!this.openState) {\n        this.blurWrapper();\n      }\n    }\n    /**\n     * Focuses the DropDownButton component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownButton component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.blur();\n        this.blurWrapper();\n      }\n    }\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService, renderer) {\n      super(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService);\n      _defineProperty(this, \"containerService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      /**\n       * Allows showing the default arrow icon or providing alternative one instead.\n       * @default false\n       */\n      _defineProperty(this, \"arrowIcon\", false);\n      /**\n       * Defines the name of an existing icon in the Kendo UI theme.\n       */\n      _defineProperty(this, \"icon\", '');\n      /**\n       * Defines an [`SVGIcon`](slug:api_icons_svgicon) to be rendered within the button.\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Defines the list of CSS classes which are used for styling the Button with custom icons.\n       */\n      _defineProperty(this, \"iconClass\", '');\n      /**\n       * Defines a URL for styling the button with a custom image.\n       */\n      _defineProperty(this, \"imageUrl\", '');\n      /**\n       * Sets the data item field that represents the item text.\n       * If the data contains only primitive values, do not define it.\n       */\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"size\", 'medium');\n      /**\n       * The rounded property specifies the border radius of the DropDownButton\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-rounded)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `full`\n       * * `none`\n       */\n      _defineProperty(this, \"rounded\", 'medium');\n      _defineProperty(this, \"themeColor\", 'base');\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      /**\n       * Fires each time the DropDownButton gets focused.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the DropDownButton gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE$1);\n      _defineProperty(this, \"_buttonAttributes\", null);\n      _defineProperty(this, \"documentMouseUpSub\", void 0);\n      this.containerService = containerService;\n      this.renderer = renderer;\n      this._itemClick = this.itemClick;\n      this._blur = this.onBlur;\n      zone.runOutsideAngular(() => {\n        this.documentMouseUpSub = this.renderer.listen('document', 'mouseup', () => {\n          if (this.active) {\n            zone.run(() => this._active = false);\n          }\n        });\n      });\n    }\n    ngAfterViewInit() {\n      this.containerService.container = this.container;\n      this.containerService.template = this.popupTemplate;\n      this.handleButtonAttributes(this.buttonAttributes);\n      const arrowWrapper = this.button.nativeElement.querySelector('.k-button-arrow');\n      if (arrowWrapper) {\n        this.renderer.addClass(arrowWrapper, 'k-menu-button-arrow');\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(event) {\n      if (!this._disabled) {\n        // eslint-disable-next-line no-unused-expressions\n        !this._isFocused && this.onFocus.emit();\n        this._isFocused = true;\n        this.focusService.resetFocus();\n        const relatedTargetInList = event.relatedTarget && closest(event.relatedTarget, '.k-popup kendo-button-list');\n        if (this.openState && !relatedTargetInList) {\n          this.focusService.focus(0);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element) || this.popupRef && this.popupRef.popupElement.contains(element);\n    }\n    handleButtonAttributes(newButtonAttributes) {\n      const mainButton = this.button?.nativeElement;\n      if (isPresent$1(this.buttonAttributes) && isPresent$1(mainButton)) {\n        for (const attr in this.buttonAttributes) {\n          this.renderer.removeAttribute(mainButton, attr, this.buttonAttributes[attr]);\n        }\n      }\n      if (isPresent$1(newButtonAttributes) && isPresent$1(mainButton)) {\n        for (const attr in newButtonAttributes) {\n          this.renderer.setAttribute(mainButton, attr, newButtonAttributes[attr]);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      if (this.documentMouseUpSub) {\n        this.documentMouseUpSub();\n      }\n    }\n  }\n  _class14 = DropDownButtonComponent;\n  _defineProperty(DropDownButtonComponent, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PopupContainerService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(DropDownButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class14,\n    selectors: [[\"kendo-dropdownbutton\"]],\n    contentQueries: function _class14_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function _class14_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function _class14_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keyup\", function _class14_keyup_HostBindingHandler($event) {\n          return ctx.keyup($event);\n        })(\"mousedown\", function _class14_mousedown_HostBindingHandler($event) {\n          return ctx.mousedown($event);\n        })(\"mouseup\", function _class14_mouseup_HostBindingHandler($event) {\n          return ctx.mouseup($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-focus\", ctx.focused);\n      }\n    },\n    inputs: {\n      arrowIcon: \"arrowIcon\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      textField: \"textField\",\n      data: \"data\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      buttonAttributes: \"buttonAttributes\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoDropDownButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER$2, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdownbutton'\n    }, PopupContainerService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 18,\n    consts: [[\"kendoButton\", \"\", \"type\", \"button\", 1, \"k-menu-button\", 3, \"id\", \"tabindex\", \"disabled\", \"icon\", \"svgIcon\", \"arrowIcon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"click\", \"focus\", \"blur\"], [\"button\", \"\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"id\", \"data\", \"textField\", \"itemTemplate\", \"size\", \"onItemClick\", \"keydown\", \"keyup\"], [\"buttonList\", \"\"]],\n    template: function _class14_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class14_Template_button_click_0_listener() {\n          return ctx.openPopup();\n        })(\"focus\", function _class14_Template_button_focus_0_listener($event) {\n          return ctx.handleFocus($event);\n        })(\"blur\", function _class14_Template_button_blur_0_listener() {\n          return ctx.onButtonBlur();\n        });\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class14_ng_template_3_Template, 2, 7, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(5, null, 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-active\", ctx.active);\n        i0.ɵɵproperty(\"id\", ctx.buttonId)(\"tabindex\", ctx.componentTabIndex)(\"disabled\", ctx.disabled)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"arrowIcon\", ctx.arrowIcon)(\"iconClass\", ctx.iconClass)(\"imageUrl\", ctx.imageUrl)(\"ngClass\", ctx.buttonClass)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.fillMode ? ctx.themeColor : null);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.openState)(\"aria-controls\", ctx.listId);\n      }\n    },\n    dependencies: [ButtonComponent, NgClass, ListComponent],\n    encapsulation: 2\n  }));\n  return DropDownButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nfunction getAnchorAlign(fabAlign, rtl) {\n  const align = {\n    horizontal: rtl ? 'right' : 'left',\n    vertical: 'bottom'\n  };\n  if (fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n  }\n  if (fabAlign.vertical === 'bottom') {\n    align.vertical = 'top';\n  }\n  if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n    align.vertical = 'top';\n  }\n  return align;\n}\n/**\n * @hidden\n */\nfunction getPopupAlign(fabAlign, rtl) {\n  const align = {\n    horizontal: rtl ? 'right' : 'left',\n    vertical: 'top'\n  };\n  if (fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n  }\n  if (fabAlign.vertical === 'bottom') {\n    align.vertical = 'bottom';\n  }\n  if (fabAlign.vertical === 'bottom' && fabAlign.horizontal === 'end') {\n    align.horizontal = rtl ? 'left' : 'right';\n    align.vertical = 'bottom';\n  }\n  return align;\n}\n\n/**\n * @hidden\n */\nfunction openAnimation(animationSettings) {\n  const isBottom = animationSettings.align.vertical === 'bottom';\n  const duration = animationSettings.duration;\n  const gap = animationSettings.gap;\n  return sequence([query(`.k-fab-item`, [style({\n    opacity: 0,\n    transform: `translateY(${isBottom ? '8px' : '-8px'})`\n  }), stagger(gap, [animate(`${duration}ms ease-in`, style({\n    opacity: '*',\n    transform: 'translateY(0)'\n  }))])], {\n    optional: true\n  })]);\n}\n/**\n * @hidden\n */\nfunction closeAnimation(animationSettings) {\n  const isBottom = animationSettings.align.vertical === 'bottom';\n  const duration = animationSettings.duration;\n  const gap = animationSettings.gap;\n  return sequence([query(`.k-fab-item`, [style({\n    opacity: '*',\n    transform: 'translateY(0)'\n  }), stagger(-gap, [animate(`${duration}ms ease-in`, style({\n    opacity: 0,\n    transform: `translateY(${isBottom ? '8px' : '-8px'})`\n  }))])], {\n    optional: true\n  })]);\n}\n\n/**\n * Represents a template that defines the content of the whole dial item.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDialItemTemplate` directive inside the `<kendo-floatingactionbutton>` tag\n * ([see example]({% slug templates_floatingactionbutton %}#toc-dial-item-template)).\n */\nlet DialItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class15;\n  class DialItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class15 = DialItemTemplateDirective;\n  _defineProperty(DialItemTemplateDirective, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(DialItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class15,\n    selectors: [[\"\", \"kendoDialItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return DialItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents a template that defines the content of the FloatingActionButton.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoFloatingActionButtonTemplate` directive inside the `<kendo-floatingactionbutton>` tag\n * ([see example]({% slug templates_floatingactionbutton %}#toc-floatingactionbutton-template)).\n */\nlet FloatingActionButtonTemplateDirective = /*#__PURE__*/(() => {\n  var _class16;\n  class FloatingActionButtonTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class16 = FloatingActionButtonTemplateDirective;\n  _defineProperty(FloatingActionButtonTemplateDirective, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(FloatingActionButtonTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class16,\n    selectors: [[\"\", \"kendoFloatingActionButtonTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FloatingActionButtonTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DialItemComponent = /*#__PURE__*/(() => {\n  var _class17;\n  class DialItemComponent {\n    get disabledClass() {\n      return this.item.disabled;\n    }\n    get title() {\n      const label = this.item.label;\n      return label || this.itemTitle;\n    }\n    get indexAttr() {\n      return this.index;\n    }\n    constructor(element, renderer, localisationService) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localisationService\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"role\", 'menuitem');\n      _defineProperty(this, \"cssClass\", void 0);\n      _defineProperty(this, \"cssStyle\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"item\", void 0);\n      _defineProperty(this, \"dialItemTemplate\", void 0);\n      _defineProperty(this, \"align\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.localisationService = localisationService;\n    }\n    get iconClasses() {\n      const classes = [];\n      if (this.item.iconClass) {\n        classes.push(`${this.item.iconClass}`);\n      }\n      if (this.item.icon) {\n        classes.push(`k-fab-item-icon k-icon k-i-${this.item.icon}`);\n      }\n      return classes;\n    }\n    get itemTitle() {\n      const icon = this.item.icon;\n      const itemTitle = this.item.itemTitle;\n      return icon && itemTitle ? itemTitle : icon;\n    }\n    ngAfterViewInit() {\n      const element = this.element.nativeElement;\n      const rtl = this.localisationService.rtl;\n      const hAlign = this.align.horizontal;\n      this.renderer.addClass(element, this.getTextDirectionClass(rtl, hAlign));\n    }\n    getTextDirectionClass(rtl, hAlign) {\n      const dir = rtl ? 'rtl' : 'ltr';\n      const align = hAlign === 'end' ? 'end' : 'start';\n      const directions = {\n        rtl: {\n          end: 'k-text-left',\n          start: 'k-text-right'\n        },\n        ltr: {\n          start: 'k-text-left',\n          end: 'k-text-right'\n        }\n      };\n      return directions[dir][align];\n    }\n  }\n  _class17 = DialItemComponent;\n  _defineProperty(DialItemComponent, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(DialItemComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class17,\n    selectors: [[\"\", \"kendoDialItem\", \"\"]],\n    hostVars: 9,\n    hostBindings: function _class17_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-disabled\", ctx.disabledClass)(\"title\", ctx.title)(\"aria-label\", ctx.title)(\"data-fab-item-index\", ctx.indexAttr);\n        i0.ɵɵclassProp(\"k-fab-item\", ctx.hostClass)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\",\n      isFocused: \"isFocused\",\n      index: \"index\",\n      item: \"item\",\n      dialItemTemplate: \"dialItemTemplate\",\n      align: \"align\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c9,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-fab-item-text\", 4, \"ngIf\"], [\"innerCssClass\", \"k-fab-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [1, \"k-fab-item-text\"], [\"innerCssClass\", \"k-fab-item-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"]],\n    template: function _class17_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class17_0_Template, 1, 6, null, 0);\n        i0.ɵɵtemplate(1, _class17_ng_container_1_Template, 3, 2, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.dialItemTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.dialItemTemplate);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return DialItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DialListComponent = /*#__PURE__*/(() => {\n  var _class18;\n  class DialListComponent {\n    get bottomClass() {\n      return this.align.vertical === 'top' || this.align.vertical === 'middle';\n    }\n    get topClass() {\n      return this.align.vertical === 'bottom';\n    }\n    constructor(focusService, cdr) {\n      _defineProperty(this, \"focusService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"dialItems\", void 0);\n      _defineProperty(this, \"dialItemTemplate\", void 0);\n      _defineProperty(this, \"align\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.focusService = focusService;\n      this.cdr = cdr;\n      this.subscriptions.add(this.focusService.onFocus.subscribe(() => this.cdr.detectChanges()));\n    }\n    isFocused(index) {\n      return this.focusService.isFocused(index);\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  _class18 = DialListComponent;\n  _defineProperty(DialListComponent, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(DialListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class18,\n    selectors: [[\"\", \"kendoDialList\", \"\"]],\n    hostVars: 6,\n    hostBindings: function _class18_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-fab-items\", ctx.hostClass)(\"k-fab-items-bottom\", ctx.bottomClass)(\"k-fab-items-top\", ctx.topClass);\n      }\n    },\n    inputs: {\n      dialItems: \"dialItems\",\n      dialItemTemplate: \"dialItemTemplate\",\n      align: \"align\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c11,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoButtonFocusable\", \"\", \"kendoDialItem\", \"\", 3, \"item\", \"index\", \"dialItemTemplate\", \"isFocused\", \"ngClass\", \"ngStyle\", \"align\"]],\n    template: function _class18_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class18_ng_container_0_Template, 2, 7, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.dialItems);\n      }\n    },\n    dependencies: [NgFor, FocusableDirective, DialItemComponent, NgClass, NgStyle],\n    encapsulation: 2\n  }));\n  return DialListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS$1 = {\n  useLeftRightArrows: false\n};\nconst NAVIGATION_SETTINGS_PROVIDER$1 = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS$1\n};\nconst SIZE_CLASSES = {\n  small: 'k-fab-sm',\n  medium: 'k-fab-md',\n  large: 'k-fab-lg'\n};\nconst ROUNDED_CLASSES = {\n  small: 'k-rounded-sm',\n  medium: 'k-rounded-md',\n  large: 'k-rounded-lg',\n  full: 'k-rounded-full'\n};\nconst FILLMODE_CLASS = 'k-fab-solid';\nconst DEFAULT_DURATION = 180;\nconst DEFAULT_ITEM_GAP = 90;\nconst DEFAULT_OFFSET = '16px';\nconst DEFAULT_ROUNDED$1 = 'full';\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_THEME_COLOR = 'primary';\n/**\n *\n * Represents the [Kendo UI FloatingActionButton component for Angular]({% slug overview_floatingactionbutton %}).\n * Used to specify the primary or the most common action in an application.\n *\n */\nlet FloatingActionButtonComponent = /*#__PURE__*/(() => {\n  var _class19;\n  class FloatingActionButtonComponent {\n    get fixedClass() {\n      return this.positionMode === 'fixed';\n    }\n    get absoluteClass() {\n      return this.positionMode === 'absolute';\n    }\n    /**\n     * Specifies the theme color of the FloatingActionButton\n     * ([see example](slug:appearance_floatingactionbutton#toc-theme-colors)).\n     * The theme color will be applied as background color of the component.\n     *\n     * The possible values are:\n     * * `primary` (Default)&mdash;Applies coloring based on the `primary` theme color.\n     * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n     * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n     * * `info`&mdash;Applies coloring based on the `info` theme color.\n     * * `success`&mdash; Applies coloring based on the `success` theme color.\n     * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n     * * `error`&mdash; Applies coloring based on the `error` theme color.\n     * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n     * * `light`&mdash; Applies coloring based on the `light` theme color.\n     * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n     * * `none`&mdash; Removes the built in theme color.\n     */\n    set themeColor(themeColor) {\n      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;\n      this.handleClasses(newThemeColor, 'themeColor');\n      this._themeColor = newThemeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Specifies the size of the FloatingActionButton\n     * ([see example]({% slug appearance_floatingactionbutton %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the FloatingActionButton.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `full` (default)\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Specifies whether the FloatingActionButton is disabled.\n     */\n    set disabled(disabled) {\n      this._disabled = disabled;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Specifies the horizontal and vertical alignment of the FloatingActionButton\n     * ([see example](slug:positioning_floatingactionbutton#toc-alignment)).\n     *\n     * The possible values are:\n     * * `{ horizontal: 'start'|'center'|'end', vertical: 'top'|'middle'|'bottom' }`\n     *\n     * The default value is:\n     * * `{ horizontal: 'end', vertical: 'bottom' }`\n     *\n     */\n    set align(align) {\n      this._align = Object.assign(this._align, align);\n    }\n    get align() {\n      return this._align;\n    }\n    /**\n     * Specifies the horizontal and vertical offset position of the FloatingActionButton\n     * ([see example]({% slug positioning_floatingactionbutton %}#toc-offset)).\n     *\n     * * The default value is:\n     * * `{ x: '16px', y: '16px' }`\n     */\n    set offset(offset) {\n      this._offset = Object.assign(this._offset, offset);\n      this.offsetStyles();\n    }\n    get offset() {\n      return this._offset;\n    }\n    /**\n     * Specifies the positionMode of the FloatingActionButton\n     * ([see example](slug:positioning_floatingactionbutton#toc-position-mode)).\n     *\n     * * The possible values are:\n     * * `absolute`&mdash;Positions the FloatingActionButton absolutely to its first positioned parent element.\n     * * `fixed` (Default)&mdash;Positions the FloatingActionButton relative to the viewport. It always stays in the same place even if the page is scrolled.\n     */\n\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(renderer, element, focusService, navigationService, ngZone, popupService, builder, localizationService) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"focusService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"builder\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"button\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"dialItemTemplate\", void 0);\n      _defineProperty(this, \"fabTemplate\", void 0);\n      _defineProperty(this, \"positionMode\", 'fixed');\n      /**\n       * Defines the name of an existing icon in a Kendo UI theme.\n       * If provided, the icon will be rendered inside the FloatingActionButton by a `span.k-icon` element.\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * Defines an [`SVGIcon`](slug:api_icons_svgicon) to be rendered within the FloatingActionButton.\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Defines a CSS class or multiple classes separated by spaces which are applied to a `span` element.\n       * Allows the usage of custom icons, rendered inside the FloatingActionButton by a `span` element.\n       */\n      _defineProperty(this, \"iconClass\", void 0);\n      /**\n       * The CSS classes that will be rendered on the main button.\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"buttonClass\", void 0);\n      /**\n       * The CSS classes that will be rendered on the dial items `ul` element.\n       * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n       */\n      _defineProperty(this, \"dialClass\", void 0);\n      /**\n       * Specifies the text content of the FloatingActionButton.\n       */\n      _defineProperty(this, \"text\", void 0);\n      /**\n       * Specifies the animation settings of the FloatingActionButton dial items.\n       * ([see example]({% slug dialitems_floatingactionbutton %}#toc-animation)).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true`&mdash;Applies the default [`DialItemAnimation`]({% slug api_buttons_dialitemanimation %}) settings.\n       *    * `false`\n       * * `DialItemAnimation`\n       *    * `duration`&mdash;Specifies the animation duration in milliseconds for each dial item. Defaults to `180ms`.\n       *    * `gap`&mdash;Specifies the animation duration gap in milliseconds after each dial item is animated. Defaults to `90ms`.\n       */\n      _defineProperty(this, \"dialItemAnimation\", true);\n      /**\n       * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the FloatingActionButton.\n       */\n      _defineProperty(this, \"tabIndex\", 0);\n      /**\n       * Specifies the collection of the dial items that will be rendered in the FloatingActionButton popup.\n       */\n      _defineProperty(this, \"dialItems\", []);\n      /**\n       * Fires each time the FloatingActionButton gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the FloatingActionButton gets focused.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time a dial item is clicked.\n       */\n      _defineProperty(this, \"dialItemClick\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed\n       * ([more information and example](slug:events_floatingactionbutton)).\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open\n       * ([more information and example](slug:events_floatingactionbutton)).\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"id\", `k-${guid()}`);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dialListId\", `k-dial-list-${guid()}`);\n      _defineProperty(this, \"_themeColor\", DEFAULT_THEME_COLOR);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE);\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED$1);\n      _defineProperty(this, \"_disabled\", false);\n      _defineProperty(this, \"_align\", {\n        horizontal: 'end',\n        vertical: 'bottom'\n      });\n      _defineProperty(this, \"_offset\", {\n        x: DEFAULT_OFFSET,\n        y: DEFAULT_OFFSET\n      });\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"popupMouseDownListener\", void 0);\n      _defineProperty(this, \"rtl\", false);\n      _defineProperty(this, \"animationEnd\", new EventEmitter());\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"initialSetup\", true);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      this.renderer = renderer;\n      this.element = element;\n      this.focusService = focusService;\n      this.navigationService = navigationService;\n      this.ngZone = ngZone;\n      this.popupService = popupService;\n      this.builder = builder;\n      this.localizationService = localizationService;\n      validatePackage(packageMetadata);\n      this.subscribeNavigationEvents();\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      }));\n    }\n    ngAfterViewInit() {\n      ['size', 'rounded', 'themeColor'].forEach(option => this.handleClasses(this[option], option));\n      this.renderer.addClass(this.element.nativeElement, this.alignClass());\n      this.offsetStyles();\n      this.initialSetup = false;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.isOpen && this.toggleDial(false);\n    }\n    /**\n     * Indicates whether the FloatingActionButton is currently open.\n     */\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n    /**\n     * Focuses the FloatingActionButton.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.focusChangedProgrammatically = true;\n        this.button.nativeElement.focus();\n        this.focusChangedProgrammatically = false;\n      }\n    }\n    /**\n     * Blurs the FloatingActionButton.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.focusChangedProgrammatically = true;\n        this.button.nativeElement.blur();\n        this.focusChangedProgrammatically = false;\n      }\n    }\n    /**\n     * Toggles the visibility of the FloatingActionButton dial items popup.\n     *\n     * If you use the `toggleDial` method to open or close the dial items,\n     * the `open` and `close` events do not fire ([more information and examples](slug:openstate_floatingactionbutton)).\n     *\n     * @param open - The state of dial items popup.\n     */\n    toggleDial(open) {\n      if (this.disabled || !this.hasDialItems) {\n        return;\n      }\n      const shouldOpen = isPresent(open) ? open : !this.isOpen;\n      if (this.disabled || shouldOpen === this.isOpen) {\n        return;\n      }\n      if (shouldOpen) {\n        setTimeout(() => this.openDial());\n      } else {\n        this.closeDial();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get ariaExpanded() {\n      return this.hasDialItems ? this.isOpen : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get ariaHasPopup() {\n      return this.hasDialItems ? 'menu' : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get ariaControls() {\n      return this.hasDialItems ? this.isOpen ? this.dialListId : undefined : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get iconClasses() {\n      const classes = [];\n      if (this.iconClass) {\n        classes.push(`${this.iconClass}`);\n      }\n      if (this.icon) {\n        classes.push(`k-fab-icon k-icon k-i-${this.icon}`);\n      }\n      return classes;\n    }\n    /**\n     * @hidden\n     */\n    clickHandler() {\n      if (this.disabled || !this.hasDialItems) {\n        return;\n      }\n      this.ngZone.run(() => {\n        const shouldOpen = !this.isOpen;\n        this.toggleDialWithEvents(shouldOpen);\n      });\n    }\n    /**\n     * @hidden\n     */\n    pointerdownHandler(e) {\n      if (this.isOpen) {\n        e.preventDefault();\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(event) {\n      if (this.disabled) {\n        return;\n      }\n      const focused = this.focusService.focused || 0;\n      const keyCode = event.keyCode;\n      const action = this.navigationService.process({\n        altKey: event.altKey,\n        current: focused,\n        keyCode,\n        max: this.dialItems ? this.dialItems.length - 1 : 0,\n        min: 0,\n        flipNavigation: this.align.vertical === 'bottom'\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab) {\n        event.preventDefault();\n      }\n      if (action === NavigationAction.Tab && event.target.closest(`#${this.dialListId}`)) {\n        this.focus();\n      }\n      if (action === NavigationAction.EnterUp && !this.hasDialItems) {\n        this.button.nativeElement.click();\n      } else if (action === NavigationAction.Open || action === NavigationAction.Close) {\n        const toggleDial = action === NavigationAction.Open;\n        this.ngZone.run(() => {\n          this.toggleDialWithEvents(toggleDial);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(event) {\n      const item = closest(event.target, '.k-fab-item');\n      if (!item) {\n        return;\n      }\n      const index = parseInt(item.getAttribute('data-fab-item-index'));\n      this.emitItemClick(index);\n    }\n    /**\n     * @hidden\n     */\n    focusHandler() {\n      if (!this.disabled && !this.focusChangedProgrammatically) {\n        this.onFocus.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n    blurHandler(e) {\n      const focusInList = e.relatedTarget && e.relatedTarget.closest(`#${this.dialListId}`);\n      if (focusInList) {\n        return;\n      }\n      !this.focusChangedProgrammatically && this.onBlur.emit();\n      this.toggleDialWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n    focusOutHandler(e) {\n      const focusInList = e.relatedTarget && e.relatedTarget.closest(`#${this.dialListId}`);\n      const focusOnButton = e.relatedTarget === this.button.nativeElement;\n      const shouldClose = !focusInList && !focusOnButton;\n      if (shouldClose) {\n        this.toggleDialWithEvents(false);\n        !this.focusChangedProgrammatically && this.onBlur.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onNavigationEnterPress() {\n      this.ngZone.run(() => {\n        if (this.isOpen) {\n          const focusedIndex = this.focusService.focused;\n          const focusedItem = this.dialItems[focusedIndex];\n          if (focusedItem && focusedItem.disabled) {\n            return;\n          }\n          if (isPresent(focusedIndex) && focusedIndex !== -1) {\n            this.onEnterPressed();\n            return;\n          }\n        }\n        if (!this.isOpen && isDocumentAvailable()) {\n          this.toggleDialWithEvents(true);\n          this.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    onNavigationClose() {\n      if (this.isOpen) {\n        this.ngZone.run(() => {\n          this.toggleDialWithEvents(false);\n          this.focus();\n        });\n      }\n    }\n    handleClasses(inputValue, input) {\n      if (isPresent(this.button) && (this[input] !== inputValue || this.initialSetup)) {\n        const button = this.button.nativeElement;\n        const classesToRemove = {\n          themeColor: `${FILLMODE_CLASS}-${this.themeColor}`,\n          size: SIZE_CLASSES[this.size],\n          rounded: ROUNDED_CLASSES[this.rounded]\n        };\n        const classesToAdd = {\n          themeColor: inputValue !== 'none' ? `${FILLMODE_CLASS}-${inputValue}` : '',\n          size: SIZE_CLASSES[inputValue],\n          rounded: ROUNDED_CLASSES[inputValue]\n        };\n        this.renderer.removeClass(button, classesToRemove[input]);\n        if (classesToAdd[input]) {\n          this.renderer.addClass(button, classesToAdd[input]);\n        }\n      }\n    }\n    onEnterPressed() {\n      const index = this.focusService.focused;\n      this.emitItemClick(index);\n    }\n    emitItemClick(index) {\n      const item = this.dialItems[index];\n      if (item && !item.disabled) {\n        const clickEventArgs = {\n          item: item,\n          index: index\n        };\n        this.dialItemClick.emit(clickEventArgs);\n        this.toggleDialWithEvents(false);\n        this.focusService.focused = index;\n      }\n      this.focus();\n    }\n    subscribeNavigationEvents() {\n      this.subscriptions.add(this.navigationService.navigate.subscribe(this.onArrowKeyNavigate.bind(this)));\n      this.subscriptions.add(this.navigationService.enter.subscribe(this.onNavigationEnterPress.bind(this)));\n      this.subscriptions.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this)));\n    }\n    onArrowKeyNavigate({\n      index\n    }) {\n      this.focusService.focus(index);\n    }\n    alignClass() {\n      return `k-pos-${this.align.vertical}-${this.align.horizontal}`;\n    }\n    toggleDialWithEvents(open) {\n      if (open === this.isOpen) {\n        return;\n      }\n      const event = new PreventableEvent();\n      if (open) {\n        this.open.emit(event);\n      } else {\n        this.close.emit(event);\n      }\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      if (open) {\n        this.openDial();\n      } else {\n        this.closeDial();\n      }\n    }\n    openPopup() {\n      if (this.isOpen) {\n        return;\n      }\n      const isIconFab = this.icon && !this.text;\n      const rtl = this.rtl;\n      const align = this.align;\n      this.popupRef = this.popupService.open({\n        anchor: this.element.nativeElement,\n        animate: false,\n        content: this.popupTemplate,\n        anchorAlign: getAnchorAlign(align, rtl),\n        popupAlign: getPopupAlign(align, rtl),\n        popupClass: 'k-fab-popup k-popup-transparent'\n      });\n      const popupElement = this.popupRef.popupElement;\n      this.renderer.setStyle(popupElement, 'box-shadow', 'none');\n      if (isIconFab) {\n        this.subscriptions.add(this.popupRef.popupOpen.subscribe(() => this.positionPopup()));\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.popupMouseDownListener = this.renderer.listen(popupElement, 'mousedown', event => {\n          event.preventDefault();\n        });\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.toggleDialWithEvents(false));\n    }\n    closePopup() {\n      if (this.isOpen) {\n        if (this.popupMouseDownListener) {\n          this.popupMouseDownListener();\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    openDial() {\n      this.openPopup();\n      this.focusService.focus(0);\n      if (this.dialItemAnimation && this.isValidAnimation()) {\n        this.playAnimation(true);\n      }\n      this.renderer.setAttribute(this.button.nativeElement, 'aria-expanded', 'true');\n    }\n    closeDial() {\n      if (this.dialItemAnimation && this.isValidAnimation()) {\n        this.playAnimation(false);\n        this.animationEnd.pipe(take(1)).subscribe(() => this.closePopup());\n      } else {\n        this.closePopup();\n      }\n      this.renderer.setAttribute(this.button.nativeElement, 'aria-expanded', 'false');\n      this.focusService.resetFocus();\n    }\n    isValidAnimation() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean') {\n        return animation.duration !== 0;\n      }\n      return true;\n    }\n    positionPopup() {\n      if (this.dialItemTemplate) {\n        return;\n      }\n      if (!this.popupRef) {\n        return;\n      }\n      const fab = this.element.nativeElement;\n      const fabWidth = fab.getBoundingClientRect().width;\n      const popupEl = this.popupRef.popupElement;\n      const icon = popupEl.querySelector('.k-fab-item-icon');\n      if (!icon) {\n        return;\n      }\n      const iconWidth = icon.getBoundingClientRect().width;\n      const left = fabWidth / 2 - iconWidth / 2;\n      const popupLeft = popupEl.getBoundingClientRect().left;\n      const isEndAlign = this.align.horizontal === 'end';\n      const leftValue = isEndAlign ? popupLeft - left : left + popupLeft;\n      const rtlLeftValue = isEndAlign ? left + popupLeft : popupLeft - left;\n      popupEl.style.left = this.rtl ? `${rtlLeftValue}px` : `${leftValue}px`;\n    }\n    offsetStyles() {\n      const hostElement = this.element.nativeElement;\n      this.renderer.setStyle(hostElement, this.horizontalPosition, this.horizontalOffset);\n      this.renderer.setStyle(hostElement, this.verticalPosition, this.verticalOffset);\n    }\n    get hasDialItems() {\n      return isPresent(this.dialItems) && this.dialItems.length !== 0;\n    }\n    /**\n     * Gets the CSS prop name of the selected vertical position (`top`/`bottom`);\n     */\n    get verticalPosition() {\n      return {\n        top: 'top',\n        middle: 'top',\n        bottom: 'bottom'\n      }[this.align.vertical];\n    }\n    /**\n     * Gets the offset according to the selected vertical position.\n     */\n    get verticalOffset() {\n      if (this.align.vertical === 'middle') {\n        return this.offset.y === DEFAULT_OFFSET ? '50%' : `calc(50% + ${this.offset.y})`;\n      }\n      return this.offset.y;\n    }\n    /**\n     * Gets the CSS prop name of the selected horizontal position (`left`/`right`);\n     */\n    get horizontalPosition() {\n      const {\n        horizontal\n      } = this.align;\n      return {\n        end: this.rtl ? 'left' : 'right',\n        center: 'left',\n        start: this.rtl ? 'right' : 'left'\n      }[horizontal];\n    }\n    /**\n     * Gets the offset according to the selected horizontal position.\n     */\n    get horizontalOffset() {\n      if (this.align.horizontal === 'center') {\n        return this.offset.x === DEFAULT_OFFSET ? '50%' : `calc(50% + ${this.offset.x})`;\n      }\n      return this.offset.x;\n    }\n    playerFor(element, animation) {\n      const factory = this.builder.build(animation);\n      return factory.create(element);\n    }\n    playAnimation(open) {\n      const durationSettings = this.durationSettings();\n      const animationSettings = {\n        duration: durationSettings.duration,\n        gap: durationSettings.gap,\n        align: this.align\n      };\n      const animation = open ? openAnimation(animationSettings) : closeAnimation(animationSettings);\n      let player = this.playerFor(this.popupRef.popupElement, animation);\n      player.play();\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n    }\n    durationSettings() {\n      return {\n        duration: this.animationDuration(),\n        gap: this.animationGap()\n      };\n    }\n    animationGap() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean' && isPresent(animation.gap)) {\n        return animation.gap;\n      }\n      return DEFAULT_ITEM_GAP;\n    }\n    animationDuration() {\n      const animation = this.dialItemAnimation;\n      if (typeof animation !== 'boolean' && isPresent(animation.duration)) {\n        return animation.duration;\n      }\n      return DEFAULT_DURATION;\n    }\n  }\n  _class19 = FloatingActionButtonComponent;\n  _defineProperty(FloatingActionButtonComponent, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.PopupService), i0.ɵɵdirectiveInject(i4.AnimationBuilder), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(FloatingActionButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class19,\n    selectors: [[\"kendo-floatingactionbutton\"]],\n    contentQueries: function _class19_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DialItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FloatingActionButtonTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fabTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class19_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 7);\n        i0.ɵɵviewQuery(_c7, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function _class19_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-pos-fixed\", ctx.fixedClass)(\"k-pos-absolute\", ctx.absoluteClass);\n      }\n    },\n    inputs: {\n      themeColor: \"themeColor\",\n      size: \"size\",\n      rounded: \"rounded\",\n      disabled: \"disabled\",\n      align: \"align\",\n      offset: \"offset\",\n      positionMode: \"positionMode\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      buttonClass: \"buttonClass\",\n      dialClass: \"dialClass\",\n      text: \"text\",\n      dialItemAnimation: \"dialItemAnimation\",\n      tabIndex: \"tabIndex\",\n      dialItems: \"dialItems\"\n    },\n    outputs: {\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      dialItemClick: \"dialItemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER$1, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.floatingactionbutton'\n    }]), i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 18,\n    consts: [[\"type\", \"button\", 1, \"k-fab\", \"k-fab-solid\", 3, \"tabIndex\", \"ngClass\", \"disabled\", \"kendoEventsOutsideAngular\", \"scope\", \"focus\", \"blur\"], [\"button\", \"\"], [4, \"ngIf\"], [\"popupTemplate\", \"\"], [3, \"ngTemplateOutlet\"], [\"innerCssClass\", \"k-fab-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-fab-text\", 4, \"ngIf\"], [\"innerCssClass\", \"k-fab-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-fab-text\"], [\"kendoDialList\", \"\", \"role\", \"menu\", 3, \"id\", \"ngClass\", \"dialItems\", \"dialItemTemplate\", \"align\", \"kendoEventsOutsideAngular\", \"click\"]],\n    template: function _class19_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"focus\", function _class19_Template_button_focus_0_listener() {\n          return ctx.focusHandler();\n        })(\"blur\", function _class19_Template_button_blur_0_listener($event) {\n          return ctx.blurHandler($event);\n        });\n        i0.ɵɵtemplate(2, _class19_2_Template, 1, 1, null, 2);\n        i0.ɵɵtemplate(3, _class19_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, _class19_ng_template_4_Template, 1, 10, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabled);\n        i0.ɵɵproperty(\"tabIndex\", ctx.componentTabIndex)(\"ngClass\", ctx.buttonClass)(\"disabled\", ctx.disabled)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(14, _c13, ctx.keyDownHandler, ctx.clickHandler, ctx.pointerdownHandler))(\"scope\", ctx);\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-haspopup\", ctx.ariaHasPopup)(\"aria-controls\", ctx.ariaControls);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.fabTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.fabTemplate);\n      }\n    },\n    dependencies: [NgClass, EventsOutsideAngularDirective, NgIf, NgTemplateOutlet, IconWrapperComponent, DialListComponent],\n    encapsulation: 2\n  }));\n  return FloatingActionButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  var _class20;\n  class Messages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The text for the SplitButton aria-label.\n       *\n       * The text for the aria-label consists of a two-part message - the text of the SplitButton and a localizable string.\n       * For a SplitButton with text 'Reply', the default aria-label will be 'Reply splitbutton'.\n       *\n       * To allow reordering of the SplitButton text and the localizable part, the splitButtonLabel accepts a string with a\n       * placeholder for the button text - e.g. 'splitbutton for {buttonText}'. The '{buttonText}' placeholder will be replaced\n       * internally with the current SplitButton text, and the resulting aria-label will be rendered as 'splitbutton for Reply'.\n       *\n       * @example\n       *\n       * ```ts-no-run\n       *      <kendo-splitbutton>\n       *          <kendo-splitbutton-messages\n       *              splitButtonLabel=\"splitbutton for {buttonText}\"\n       *          >\n       *          </kendo-splitbutton-messages>\n       *      </kendo-splitbutton>\n       *  ```\n       */\n      _defineProperty(this, \"splitButtonLabel\", void 0);\n    }\n  }\n  _class20 = Messages;\n  _defineProperty(Messages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class20_BaseFactory;\n    return function _class20_Factory(t) {\n      return (ɵ_class20_BaseFactory || (ɵ_class20_BaseFactory = i0.ɵɵgetInheritedFactory(_class20)))(t || _class20);\n    };\n  }());\n  _defineProperty(Messages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class20,\n    selectors: [[\"kendo-splitbutton-messages-base\"]],\n    inputs: {\n      splitButtonLabel: \"splitButtonLabel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_buttons %}).\n */\nlet SplitButtonCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class21;\n  class SplitButtonCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class21 = SplitButtonCustomMessagesComponent;\n  _defineProperty(SplitButtonCustomMessagesComponent, \"\\u0275fac\", function _class21_Factory(t) {\n    return new (t || _class21)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(SplitButtonCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class21,\n    selectors: [[\"kendo-splitbutton-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class21)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class21_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SplitButtonCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedSplitButtonMessagesDirective = /*#__PURE__*/(() => {\n  var _class22;\n  class LocalizedSplitButtonMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class22 = LocalizedSplitButtonMessagesDirective;\n  _defineProperty(LocalizedSplitButtonMessagesDirective, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedSplitButtonMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class22,\n    selectors: [[\"\", \"kendoSplitButtonLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class22)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedSplitButtonMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAVIGATION_SETTINGS = {\n  useLeftRightArrows: true\n};\nconst NAVIGATION_SETTINGS_PROVIDER = {\n  provide: NAVIGATION_CONFIG,\n  useValue: NAVIGATION_SETTINGS\n};\nconst DEFAULT_ROUNDED = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Represents the Kendo UI SplitButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"data\" icon=\"clipboard\"\n *      (itemClick)=\"onSplitButtonItemClick($event)\"\n *      (buttonClick)=\"onSplitButtonClick()\">Paste</kendo-splitbutton>\n * `\n * })\n *\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'Keep Text Only',\n *       icon: 'clipboard-text',\n *       click: () => { console.log('Keep Text Only click handler'); }\n *   }, {\n *       text: 'Paste as HTML',\n *       icon: 'clipboard-code'\n *   }, {\n *       text: 'Paste Markdown',\n *       icon: 'clipboard-markdown'\n *   }, {\n *       text: 'Set Default Paste'\n *   }];\n *\n *   public onSplitButtonClick(dataItem: any): void {\n *       console.log('Paste');\n *   }\n *\n *   public onSplitButtonItemClick(dataItem: any): void {\n *       if (dataItem) {\n *           console.log(dataItem.text);\n *       }\n *   }\n * }\n * ```\n */\nlet SplitButtonComponent = /*#__PURE__*/(() => {\n  var _class23;\n  class SplitButtonComponent extends ListButton {\n    /**\n     * The rounded property specifies the border radius of the SplitButton\n     * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the SplitButton\n     * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-fillMode)).\n     *\n     * The available values are:\n     * * `solid` (default)\n     * * `flat`\n     * * `outline`\n     * * `link`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this._fillMode = fillMode === 'clear' ? 'flat' : newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The SplitButton allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color while also amending the text color accordingly\n     * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-themeColor)).\n     *\n     * The possible values are:\n     * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n     * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n     * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n     * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n     * * `info`&mdash;Applies coloring based on the `info` theme color.\n     * * `success`&mdash; Applies coloring based on the `success` theme color.\n     * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n     * * `error`&mdash; Applies coloring based on the `error` theme color.\n     * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n     * * `light`&mdash; Applies coloring based on the `light` theme color.\n     * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n     * * `none`&mdash; Removes the built in theme color.\n     */\n\n    /**\n     * When set to `true`, disables a SplitButton item\n     * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n     */\n    set disabled(value) {\n      if (this.isOpen) {\n        this.toggle(false);\n      }\n      this._disabled = value;\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Configures the popup of the SplitButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n    /**\n     * Sets the data of the SplitButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n      return this._data;\n    }\n    /**\n     * The CSS classes that will be rendered on the button which opens the popup.\n     * Supports the type of values that are supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).\n     */\n\n    /**\n     * Sets attributes to the main button.\n     */\n    set buttonAttributes(buttonAttributes) {\n      const newButtonAttributes = buttonAttributes ? buttonAttributes : null;\n      this.handleButtonAttributes(newButtonAttributes);\n      this._buttonAttributes = newButtonAttributes;\n    }\n    get buttonAttributes() {\n      return this._buttonAttributes;\n    }\n    /**\n     * Fires each time the user clicks the main button.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-splitbutton (buttonClick)=\"onSplitButtonClick()\" [data]=\"data\">\n     *            Reply\n     *        </kendo-splitbutton>\n     *    `\n     * })\n     * class AppComponent {\n     *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n     *\n     *    public onSplitButtonClick(): void {\n     *      console.log('SplitButton click');\n     *    }\n     * }\n     * ```\n     *\n     */\n\n    /**\n     * @hidden\n     */\n    get hasContent() {\n      return this.button?.nativeElement.childElementCount > 0;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n      return this._active;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n      return this.disabled ? -1 : this.tabIndex;\n    }\n    set isFocused(value) {\n      this._isFocused = value;\n    }\n    get isFocused() {\n      return this._isFocused && !this._disabled && isDocumentAvailable() && this.wrapperContains(document.activeElement);\n    }\n    get widgetClasses() {\n      return true;\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get ariaLabel() {\n      const localizationMsg = this.localization.get('splitButtonLabel') || '';\n      return replaceMessagePlaceholder(localizationMsg, 'buttonText', this.buttonText);\n    }\n    /**\n     * @hidden\n     */\n    onButtonFocus(event) {\n      if (!this._disabled) {\n        // eslint-disable-next-line no-unused-expressions\n        !this._isFocused && this.onFocus.emit();\n        this._isFocused = true;\n        this.focusService.resetFocus();\n        const relatedTargetInList = event.relatedTarget && closest(event.relatedTarget, '.k-popup kendo-button-list');\n        if (this.openState && !relatedTargetInList) {\n          this.focusService.focus(0);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onArrowButtonClick() {\n      this.togglePopupVisibility();\n      this.arrowButtonClicked = false;\n      if (!this.isOpen) {\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    toggleButtonActiveState(enable) {\n      this._active = enable;\n    }\n    /**\n     * @hidden\n     */\n    toggleArrowButtonActiveState(enable) {\n      this.arrowButtonClicked = true;\n      this.activeArrow = enable;\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick() {\n      this.buttonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    onButtonBlur() {\n      if (!this.isOpen && !this.arrowButtonClicked) {\n        this.blurWrapper();\n      }\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n      this.keyDownHandler(event, true);\n      if (event.keyCode === Keys.Space) {\n        this._active = true;\n      }\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n      this._active = false;\n      if (event.keyCode !== Keys.Space) {\n        this.keyUpHandler(event);\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n      this.containerService.container = this.container;\n      this.containerService.template = this.popupTemplate;\n      this.updateButtonText();\n      this.handleClasses(this.rounded, 'rounded');\n      this.handleButtonAttributes(this.buttonAttributes);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (changes.hasOwnProperty('text')) {\n        this.updateButtonText();\n      }\n      if (anyChanged(['text', 'icon', 'svgIcon', 'iconClass', 'imageUrl'], changes)) {\n        this.toggleButtonIconClass();\n      }\n      if (isChanged('popupSettings', changes) && isPresent(this.popupRef)) {\n        const popup = this.popupRef.popup.instance;\n        const newSettings = changes['popupSettings'].currentValue;\n        popup.popupClass = newSettings.popupClass;\n        popup.animate = newSettings.animate;\n        popup.popupAlign = this.popupAlign;\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      if (this.documentMouseUpSub) {\n        this.documentMouseUpSub();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onNavigationEnterUp(args) {\n      if (args.target !== this.button.nativeElement) {\n        super.onNavigationEnterUp(args);\n      }\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n      if (isDocumentAvailable() && this.wrapperContains(document.activeElement) && this.arrowButtonClicked) {\n        this.button.nativeElement.focus();\n      }\n      super.togglePopupVisibility();\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n      return this.wrapper === element || this.wrapper.contains(element);\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'bottom'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n      const align = {\n        horizontal: this.popupSettings.align || 'left',\n        vertical: 'top'\n      };\n      if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n        align.horizontal = 'right';\n      }\n      return align;\n    }\n    /**\n     * @hidden\n     */\n    get isIconButton() {\n      const hasIcon = this.icon || this.svgIcon || this.iconClass || this.imageUrl;\n      const hasTextContent = isDocumentAvailable() && this.button?.nativeElement.textContent.trim().length > 0;\n      return hasIcon && !hasTextContent;\n    }\n    /**\n     * Focuses the SplitButton component.\n     */\n    focus() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the SplitButton component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.button.nativeElement.blur();\n        this.blurWrapper();\n      }\n    }\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, renderer, containerService) {\n      super(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization, cdr, containerService);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      /**\n       * Sets the text of the SplitButton.\n       */\n      _defineProperty(this, \"text\", '');\n      /**\n       * Defines an icon to be rendered next to the button text.\n       * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n       */\n      _defineProperty(this, \"icon\", '');\n      /**\n       * Defines an SVGIcon to be rendered next to the button text.\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Defines an icon with a custom CSS class to be rendered next to the button text\n       * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n       */\n      _defineProperty(this, \"iconClass\", void 0);\n      /**\n       * Defines the type attribute of the main button\n       */\n      _defineProperty(this, \"type\", 'button');\n      /**\n       * Defines the location of an image to be displayed next to the button text\n       * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n       */\n      _defineProperty(this, \"imageUrl\", '');\n      /**\n       * The size property specifies the padding of the SplitButton\n       * ([see example]({% slug api_buttons_splitbuttoncomponent %}#toc-size)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `none`\n       */\n      _defineProperty(this, \"size\", 'medium');\n      _defineProperty(this, \"themeColor\", 'base');\n      _defineProperty(this, \"tabIndex\", 0);\n      /**\n       * Configures the text field of the button-list popup.\n       */\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"arrowButtonClass\", void 0);\n      /**\n       * Specifies the name of the [font icon](slug:icons#icons-list) that will\n       * be rendered for the button which opens the popup.\n       */\n      _defineProperty(this, \"arrowButtonIcon\", 'caret-alt-down');\n      /**\n       * Specifies the [`SVGIcon`](slug:api_icons_svgicon) that will\n       * be rendered for the button which opens the popup.\n       */\n      _defineProperty(this, \"arrowButtonSvgIcon\", caretAltDownIcon);\n      _defineProperty(this, \"buttonClick\", new EventEmitter());\n      /**\n       * Fires each time the user clicks on the drop-down list. The event data contains the data item bound to the clicked list item.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       *     selector: 'my-app',\n       *    template: `\n       *        <kendo-splitbutton (itemClick)=\"onSplitButtonItemClick($event)\" [data]=\"data\">\n       *          Reply\n       *      </kendo-splitbutton>\n       *    `\n       * })\n       * class AppComponent {\n       *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n       *\n       *   public onSplitButtonItemClick(dataItem?: string): void {\n       *        if (dataItem) {\n       *            console.log(dataItem);\n       *       }\n       *    }\n       * }\n       * ```\n       *\n       */\n      _defineProperty(this, \"itemClick\", new EventEmitter());\n      /**\n       * Fires each time the SplitButton gets focused.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the SplitButton gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * An item template that helps to customize the item content.\n       */\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"activeArrow\", false);\n      _defineProperty(this, \"listId\", guid());\n      _defineProperty(this, \"buttonText\", '');\n      _defineProperty(this, \"arrowButtonClicked\", false);\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE);\n      _defineProperty(this, \"_buttonAttributes\", null);\n      _defineProperty(this, \"documentMouseUpSub\", void 0);\n      this.localization = localization;\n      this.renderer = renderer;\n      this._itemClick = this.itemClick;\n      this._blur = this.onBlur;\n      zone.runOutsideAngular(() => {\n        this.documentMouseUpSub = this.renderer.listen('document', 'mouseup', () => {\n          if (this.active) {\n            zone.run(() => this._active = false);\n          }\n          if (this.activeArrow) {\n            zone.run(() => this.activeArrow = false);\n          }\n        });\n      });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n      return this.openState;\n    }\n    updateButtonText() {\n      if (isDocumentAvailable()) {\n        const innerText = this.wrapper.innerText.split('\\n').join('').trim();\n        //setTimeout is needed because of `Expression has changed after it was checked.` error;\n        setTimeout(() => this.buttonText = innerText, 0);\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.wrapperRef.nativeElement;\n      const classes = getStylingClasses('button', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    toggleButtonIconClass() {\n      this.button.nativeElement.classList[this.isIconButton ? 'add' : 'remove']('k-button-icon');\n    }\n    handleButtonAttributes(newButtonAttributes) {\n      const mainButton = this.button.nativeElement;\n      if (isPresent(this.buttonAttributes) && isPresent(mainButton)) {\n        for (const attr in this.buttonAttributes) {\n          this.renderer.removeAttribute(mainButton, attr, this.buttonAttributes[attr]);\n        }\n      }\n      if (isPresent(newButtonAttributes) && isPresent(mainButton)) {\n        for (const attr in newButtonAttributes) {\n          this.renderer.setAttribute(mainButton, attr, newButtonAttributes[attr]);\n        }\n      }\n    }\n  }\n  _class23 = SplitButtonComponent;\n  _defineProperty(SplitButtonComponent, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(FocusService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PopupContainerService));\n  });\n  _defineProperty(SplitButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class23,\n    selectors: [[\"kendo-splitbutton\"]],\n    contentQueries: function _class23_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ButtonItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function _class23_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function _class23_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keyup\", function _class23_keyup_HostBindingHandler($event) {\n          return ctx.keyup($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-focus\", ctx.isFocused)(\"k-split-button\", ctx.widgetClasses)(\"k-button-group\", ctx.widgetClasses);\n      }\n    },\n    inputs: {\n      text: \"text\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      iconClass: \"iconClass\",\n      type: \"type\",\n      imageUrl: \"imageUrl\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      disabled: \"disabled\",\n      popupSettings: \"popupSettings\",\n      tabIndex: \"tabIndex\",\n      textField: \"textField\",\n      data: \"data\",\n      arrowButtonClass: \"arrowButtonClass\",\n      arrowButtonIcon: \"arrowButtonIcon\",\n      arrowButtonSvgIcon: \"arrowButtonSvgIcon\",\n      buttonAttributes: \"buttonAttributes\"\n    },\n    outputs: {\n      buttonClick: \"buttonClick\",\n      itemClick: \"itemClick\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoSplitButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([FocusService, NavigationService, NAVIGATION_SETTINGS_PROVIDER, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.splitbutton'\n    }, PopupContainerService, {\n      provide: MultiTabStop,\n      useExisting: forwardRef(() => _class23)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 12,\n    vars: 30,\n    consts: function () {\n      let i18n_14;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the SplitButton aria-label\n         * @meaning kendo.splitbutton.splitButtonLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_BUTTONS_FESM2022_PROGRESS_KENDO_ANGULAR_BUTTONS_MJS_15 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ '{buttonText} splitbutton' }}\"\n          }\n        });\n        i18n_14 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_BUTTONS_FESM2022_PROGRESS_KENDO_ANGULAR_BUTTONS_MJS_15;\n      } else {\n        i18n_14 = $localize`:kendo.splitbutton.splitButtonLabel|The text for the SplitButton aria-label:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      return [[\"kendoSplitButtonLocalizedMessages\", \"\", 6, \"splitButtonLabel\"], [\"splitButtonLabel\", i18n_14], [\"kendoButton\", \"\", 3, \"type\", \"tabindex\", \"disabled\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"icon\", \"svgIcon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"focus\", \"click\", \"blur\", \"mousedown\", \"mouseup\"], [\"button\", \"\"], [\"class\", \"k-button-text\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"type\", \"button\", \"aria-hidden\", \"true\", 1, \"k-split-button-arrow\", 3, \"ngClass\", \"disabled\", \"icon\", \"svgIcon\", \"size\", \"rounded\", \"fillMode\", \"themeColor\", \"tabindex\", \"click\", \"mousedown\", \"mouseup\", \"keydown.enter\"], [\"arrowButton\", \"\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [1, \"k-button-text\"], [3, \"id\", \"data\", \"textField\", \"itemTemplate\", \"size\", \"onItemClick\", \"keydown\", \"keyup\"]];\n    },\n    template: function _class23_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵi18nAttributes(1, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(2, \"button\", 2, 3);\n        i0.ɵɵlistener(\"focus\", function _class23_Template_button_focus_2_listener($event) {\n          return ctx.onButtonFocus($event);\n        })(\"click\", function _class23_Template_button_click_2_listener() {\n          return ctx.onButtonClick();\n        })(\"blur\", function _class23_Template_button_blur_2_listener() {\n          return ctx.onButtonBlur();\n        })(\"mousedown\", function _class23_Template_button_mousedown_2_listener() {\n          return ctx.toggleButtonActiveState(true);\n        })(\"mouseup\", function _class23_Template_button_mouseup_2_listener() {\n          return ctx.toggleButtonActiveState(false);\n        });\n        i0.ɵɵtemplate(4, _class23_span_4_Template, 2, 1, \"span\", 4);\n        i0.ɵɵprojection(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"button\", 5, 6);\n        i0.ɵɵlistener(\"click\", function _class23_Template_button_click_6_listener() {\n          return ctx.onArrowButtonClick();\n        })(\"mousedown\", function _class23_Template_button_mousedown_6_listener() {\n          return ctx.toggleArrowButtonActiveState(true);\n        })(\"mouseup\", function _class23_Template_button_mouseup_6_listener() {\n          return ctx.toggleArrowButtonActiveState(false);\n        })(\"keydown.enter\", function _class23_Template_button_keydown_enter_6_listener($event) {\n          $event.stopImmediatePropagation();\n          return $event.preventDefault();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, _class23_ng_template_8_Template, 1, 6, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(10, null, 8);\n      }\n      if (rf & 2) {\n        i0.ɵɵi18nExp(\"{buttonText} splitbutton\");\n        i0.ɵɵi18nApply(1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"k-active\", ctx.active);\n        i0.ɵɵproperty(\"type\", ctx.type)(\"tabindex\", ctx.componentTabIndex)(\"disabled\", ctx.disabled)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.themeColor)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"iconClass\", ctx.iconClass)(\"imageUrl\", ctx.imageUrl)(\"ngClass\", ctx.buttonClass);\n        i0.ɵɵattribute(\"aria-expanded\", ctx.openState)(\"aria-controls\", ctx.listId)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.text);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"k-active\", ctx.activeArrow);\n        i0.ɵɵproperty(\"ngClass\", ctx.arrowButtonClass)(\"disabled\", ctx.disabled)(\"icon\", ctx.arrowButtonIcon)(\"svgIcon\", ctx.arrowButtonSvgIcon)(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"themeColor\", ctx.themeColor)(\"tabindex\", -1);\n      }\n    },\n    dependencies: [LocalizedSplitButtonMessagesDirective, ButtonComponent, NgClass, NgIf, ListComponent],\n    encapsulation: 2\n  }));\n  return SplitButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `Button` related components and directives\n */\nconst KENDO_BUTTON = [ButtonComponent];\n/**\n * Utility array that contains all `ButtonGroup` related components and directives\n */\nconst KENDO_BUTTONGROUP = [ButtonComponent, ButtonGroupComponent];\n/**\n * Utility array that contains all `DropDownButton` related components and directives\n */\nconst KENDO_DROPDOWNBUTTON = [DropDownButtonComponent, ButtonItemTemplateDirective];\n/**\n * Utility array that contains all `Chip` related components and directives\n */\nconst KENDO_CHIP = [ChipComponent];\n/**\n * Utility array that contains all `ChipList` related components and directives\n */\nconst KENDO_CHIPLIST = [ChipComponent, ChipListComponent];\n/**\n * Utility array that contains all `FloatingActionButton` related components and directives\n */\nconst KENDO_FLOATINGACTIONBUTTON = [FloatingActionButtonComponent, DialItemTemplateDirective, FloatingActionButtonTemplateDirective];\n/**\n * Utility array that contains all `SplitButton` related components and directives\n */\nconst KENDO_SPLITBUTTON = [SplitButtonComponent, SplitButtonCustomMessagesComponent, ToggleButtonTabStopDirective, ButtonItemTemplateDirective];\n/**\n * Utility array that contains all `@progress/kendo-angular-buttons` related components and directives\n */\nconst KENDO_BUTTONS = [...KENDO_BUTTON, ...KENDO_BUTTONGROUP, ...KENDO_DROPDOWNBUTTON, ...KENDO_CHIP, ...KENDO_CHIPLIST, ...KENDO_FLOATINGACTIONBUTTON, ...KENDO_SPLITBUTTON];\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `ButtonGroupComponent`&mdash;The ButtonGroup component class.\n * - `ButtonComponent`&mdash;The Button component class.\n */\nlet ButtonGroupModule = /*#__PURE__*/(() => {\n  var _class24;\n  class ButtonGroupModule {}\n  _class24 = ButtonGroupModule;\n  _defineProperty(ButtonGroupModule, \"\\u0275fac\", function _class24_Factory(t) {\n    return new (t || _class24)();\n  });\n  _defineProperty(ButtonGroupModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class24\n  }));\n  _defineProperty(ButtonGroupModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [ButtonComponent]\n  }));\n  return ButtonGroupModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Button directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Button module\n * import { ButtonModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonModule], // import Button module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet ButtonModule = /*#__PURE__*/(() => {\n  var _class25;\n  class ButtonModule {}\n  _class25 = ButtonModule;\n  _defineProperty(ButtonModule, \"\\u0275fac\", function _class25_Factory(t) {\n    return new (t || _class25)();\n  });\n  _defineProperty(ButtonModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class25\n  }));\n  _defineProperty(ButtonModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [ButtonComponent]\n  }));\n  return ButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmodules'])\n * definition for the Buttons components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Buttons module\n * import { ButtonsModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonsModule], // import Buttons module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet ButtonsModule = /*#__PURE__*/(() => {\n  var _class26;\n  class ButtonsModule {}\n  _class26 = ButtonsModule;\n  _defineProperty(ButtonsModule, \"\\u0275fac\", function _class26_Factory(t) {\n    return new (t || _class26)();\n  });\n  _defineProperty(ButtonsModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class26\n  }));\n  _defineProperty(ButtonsModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [ButtonComponent, ButtonComponent, DropDownButtonComponent, ChipComponent, ChipComponent, FloatingActionButtonComponent, SplitButtonComponent]\n  }));\n  return ButtonsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `SplitButtonComponent`&mdash;The SplitButton component class.\n * - `SplitButtonCustomMessagesComponent`&mdash;The SplitButton custom messages component class.\n */\nlet SplitButtonModule = /*#__PURE__*/(() => {\n  var _class27;\n  class SplitButtonModule {}\n  _class27 = SplitButtonModule;\n  _defineProperty(SplitButtonModule, \"\\u0275fac\", function _class27_Factory(t) {\n    return new (t || _class27)();\n  });\n  _defineProperty(SplitButtonModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class27\n  }));\n  _defineProperty(SplitButtonModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [SplitButtonComponent]\n  }));\n  return SplitButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownButtonComponent`&mdash;The DropDownButtonComponent component class.\n * - `ButtonItemTemplateDirective`&mdash;The Button item template directive.\n */\nlet DropDownButtonModule = /*#__PURE__*/(() => {\n  var _class28;\n  class DropDownButtonModule {}\n  _class28 = DropDownButtonModule;\n  _defineProperty(DropDownButtonModule, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)();\n  });\n  _defineProperty(DropDownButtonModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class28\n  }));\n  _defineProperty(DropDownButtonModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [DropDownButtonComponent]\n  }));\n  return DropDownButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Chip and ChipList components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Chip module\n * import { ChipModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ChipModule], // import Chip module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet ChipModule = /*#__PURE__*/(() => {\n  var _class29;\n  class ChipModule {}\n  _class29 = ChipModule;\n  _defineProperty(ChipModule, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)();\n  });\n  _defineProperty(ChipModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class29\n  }));\n  _defineProperty(ChipModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [ChipComponent]\n  }));\n  return ChipModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the FloatingActionButton component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the FloatingActionButton module\n * import { FloatingActionButtonModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, FloatingActionButtonModule], // import FloatingActionButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * ```\n */\nlet FloatingActionButtonModule = /*#__PURE__*/(() => {\n  var _class30;\n  class FloatingActionButtonModule {}\n  _class30 = FloatingActionButtonModule;\n  _defineProperty(FloatingActionButtonModule, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)();\n  });\n  _defineProperty(FloatingActionButtonModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class30\n  }));\n  _defineProperty(FloatingActionButtonModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [FloatingActionButtonComponent]\n  }));\n  return FloatingActionButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ButtonComponent as Button, ButtonComponent, ButtonComponent as ButtonDirective, ButtonGroupComponent as ButtonGroup, ButtonGroupComponent, ButtonGroupModule, ButtonItemTemplateDirective, ButtonModule, ButtonsModule, ChipComponent, ChipListComponent, ChipModule, DialItemTemplateDirective, DropDownButtonComponent as DropDownButton, DropDownButtonComponent, DropDownButtonModule, FloatingActionButtonComponent, FloatingActionButtonModule, FloatingActionButtonTemplateDirective, FocusableDirective, KENDO_BUTTON, KENDO_BUTTONGROUP, KENDO_BUTTONS, KENDO_CHIP, KENDO_CHIPLIST, KENDO_DROPDOWNBUTTON, KENDO_FLOATINGACTIONBUTTON, KENDO_SPLITBUTTON, ListComponent, LocalizedSplitButtonMessagesDirective, PreventableEvent, SplitButtonComponent as SplitButton, SplitButtonComponent, SplitButtonCustomMessagesComponent, SplitButtonModule };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}