{"ast":null,"code":"import Node from './node';\nimport { parseColor } from '../common';\nimport { isTransparent, valueOrDefault } from '../util';\nimport LinearGradient from '../gradients/linear-gradient';\nimport RadialGradient from '../gradients/radial-gradient';\nimport { DASH_ARRAYS, SOLID, BUTT, PATTERN } from '../core/constants';\nimport renderPath from './utils/render-path';\nfunction addGradientStops(gradient, stops) {\n  for (let idx = 0; idx < stops.length; idx++) {\n    let stop = stops[idx];\n    let color = parseColor(stop.color());\n    color.a *= stop.opacity();\n    gradient.addColorStop(stop.offset(), color.toCssRgba());\n  }\n}\nclass PathNode extends Node {\n  renderTo(ctx) {\n    ctx.save();\n    this.setTransform(ctx);\n    this.setClip(ctx);\n    this.setOpacity(ctx);\n    ctx.beginPath();\n    this.renderPoints(ctx, this.srcElement);\n    this.setLineDash(ctx);\n    this.setLineCap(ctx);\n    this.setLineJoin(ctx);\n    this.setFill(ctx);\n    this.setStroke(ctx);\n    ctx.restore();\n  }\n  setFill(ctx) {\n    const fill = this.srcElement.options.fill;\n    let hasFill = false;\n    if (fill) {\n      if (fill.nodeType === \"Gradient\") {\n        this.setGradientFill(ctx, fill);\n        hasFill = true;\n      } else if (fill.nodeType === PATTERN) {\n        this.setPatternFill(ctx, fill);\n        hasFill = true;\n      } else if (!isTransparent(fill.color)) {\n        ctx.fillStyle = fill.color;\n        ctx.save();\n        this.globalAlpha(ctx, fill.opacity);\n        ctx.fill();\n        ctx.restore();\n        hasFill = true;\n      }\n    }\n    return hasFill;\n  }\n  setGradientFill(ctx, fill) {\n    const bbox = this.srcElement.rawBBox();\n    let gradient;\n    if (fill instanceof LinearGradient) {\n      let start = fill.start();\n      let end = fill.end();\n      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n    } else if (fill instanceof RadialGradient) {\n      let center = fill.center();\n      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n    }\n    addGradientStops(gradient, fill.stops);\n    ctx.save();\n    if (!fill.userSpace()) {\n      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fill();\n    ctx.restore();\n  }\n  setPatternFill(ctx, pattern) {\n    const size = pattern.size();\n    const patternCanvas = document.createElement(\"canvas\");\n    const patternContext = patternCanvas.getContext(\"2d\");\n    patternCanvas.width = size.getWidth();\n    patternCanvas.height = size.getHeight();\n    this.childNodes.length = 0;\n    this.loadElements(pattern.children);\n    const childNodes = this.childNodes;\n    for (let i = 0; i < childNodes.length; i++) {\n      let child = childNodes[i];\n      child.renderTo(patternContext);\n    }\n    ctx.save();\n    ctx.fillStyle = ctx.createPattern(patternCanvas, \"repeat\");\n    ctx.fill();\n    ctx.restore();\n  }\n  setStroke(ctx) {\n    const stroke = this.srcElement.options.stroke;\n    if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\n      ctx.strokeStyle = stroke.color;\n      ctx.lineWidth = valueOrDefault(stroke.width, 1);\n      ctx.lineJoin = valueOrDefault(stroke.lineJoin, ctx.lineJoin);\n      ctx.save();\n      this.globalAlpha(ctx, stroke.opacity);\n      ctx.stroke();\n      ctx.restore();\n      return true;\n    }\n  }\n  dashType() {\n    const stroke = this.srcElement.options.stroke;\n    if (stroke && stroke.dashType) {\n      return stroke.dashType.toLowerCase();\n    }\n  }\n  setLineDash(ctx) {\n    const dashType = this.dashType();\n    if (dashType && dashType !== SOLID) {\n      const dashArray = DASH_ARRAYS[dashType];\n      if (ctx.setLineDash) {\n        ctx.setLineDash(dashArray);\n      } else {\n        ctx.mozDash = dashArray;\n        ctx.webkitLineDash = dashArray;\n      }\n    }\n  }\n  setLineCap(ctx) {\n    const dashType = this.dashType();\n    const stroke = this.srcElement.options.stroke;\n    if (dashType && dashType !== SOLID) {\n      ctx.lineCap = BUTT;\n    } else if (stroke && stroke.lineCap) {\n      ctx.lineCap = stroke.lineCap;\n    }\n  }\n  setLineJoin(ctx) {\n    const stroke = this.srcElement.options.stroke;\n    if (stroke && stroke.lineJoin) {\n      ctx.lineJoin = stroke.lineJoin;\n    }\n  }\n  renderPoints(ctx, path) {\n    renderPath(ctx, path);\n  }\n}\nexport default PathNode;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}