{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, HostBinding, Output, Directive, Injectable, HostListener, ViewChildren, ViewChild, forwardRef, isDevMode, ViewContainerRef, ContentChild, ContentChildren, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport * as i10 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, isObjectPresent, removeHTMLAttributes, parseAttributes, isSafari, Keys, setHTMLAttributes, EventsOutsideAngularDirective, isChanged, TemplateContextDirective, ResizeSensorComponent, closest as closest$1, isControlRequired, hasObservers, KendoInput, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, MultiTabStop, anyChanged, guid as guid$1, ToggleButtonTabStopDirective, ResizeBatchService, KENDO_ADORNMENTS, KENDO_TOGGLEBUTTONTABSTOP } from '@progress/kendo-angular-common';\nexport { PrefixTemplateDirective, SeparatorComponent, SuffixTemplateDirective, ToggleButtonTabStopDirective } from '@progress/kendo-angular-common';\nimport * as i7 from '@progress/kendo-angular-utils';\nimport { AdaptiveService } from '@progress/kendo-angular-utils';\nimport * as i8 from '@angular/forms';\nimport { NgControl, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormsModule } from '@angular/forms';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { getter as getter$1, touchEnabled, pointers } from '@progress/kendo-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { Subscription, merge, fromEvent, Subject, of, interval } from 'rxjs';\nimport * as i2 from '@progress/kendo-angular-popup';\nimport { PopupService } from '@progress/kendo-angular-popup';\nimport { map, switchMap, take, auditTime, tap, filter, partition, throttleTime, catchError, skipWhile, concatMap, takeUntil, debounceTime } from 'rxjs/operators';\nimport { NgIf, NgStyle, NgFor, NgClass, NgTemplateOutlet } from '@angular/common';\nimport { xIcon, caretAltDownIcon, searchIcon, xCircleIcon, plusIcon } from '@progress/kendo-svg-icons';\nimport { IconComponent, IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\nimport { ActionSheetComponent, ActionSheetTemplateDirective } from '@progress/kendo-angular-navigation';\nimport { TextBoxComponent, TextBoxPrefixTemplateDirective } from '@progress/kendo-angular-inputs';\nimport { ButtonComponent } from '@progress/kendo-angular-buttons';\nimport * as i1$1 from '@progress/kendo-angular-treeview';\nimport { DataBoundComponent, ExpandableComponent, TreeViewComponent, SelectDirective, FlatDataBindingDirective, HierarchyBindingDirective, ExpandDirective } from '@progress/kendo-angular-treeview';\nimport { DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';\n\n/**\n * @hidden\n */\nconst _c0 = [\"kendoSearchbar\", \"\"];\nconst _c1 = [\"content\"];\nconst _c2 = [\"list\"];\nconst _c3 = [\"virtualContainer\"];\nfunction _class17_div_0_1_ng_template_0_Template(rf, ctx) {}\nconst _c4 = function (a0, a1) {\n  return {\n    templateRef: a0,\n    $implicit: a1\n  };\n};\nfunction _class17_div_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_div_0_1_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r7.fixedGroupTemplate.templateRef, ctx_r7.currentGroup));\n  }\n}\nfunction _class17_div_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r8.listGroupStickyHeaderTextClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r8.currentGroup);\n  }\n}\nconst _c5 = function (a0, a1, a2) {\n  return {\n    \"height.px\": a0,\n    \"minHeight.px\": a1,\n    \"boxSizing\": a2\n  };\n};\nfunction _class17_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtemplate(1, _class17_div_0_1_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(2, _class17_div_0_ng_template_2_Template, 2, 3, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r0.listGroupStickyHeaderClass);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction3(5, _c5, ctx_r0.virtual == null ? null : ctx_r0.virtual.itemHeight, ctx_r0.virtual == null ? null : ctx_r0.virtual.itemHeight, ctx_r0.virtual ? \"border-box\" : \"inherit\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.fixedGroupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.fixedGroupTemplate);\n  }\n}\nfunction _class17_5_ng_template_0_input_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"input\", 14);\n    i0.ɵɵlistener(\"change\", function _class17_5_ng_template_0_input_1_Template_input_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const itemIndex_r12 = i0.ɵɵnextContext().index;\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r16.onCheckedChange($event, itemIndex_r12 + ctx_r16.startFrom));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const itemIndex_r12 = i0.ɵɵnextContext().index;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r13.checkboxClasses)(\"checked\", ctx_r13.isChecked(itemIndex_r12));\n  }\n}\nfunction _class17_5_ng_template_0_2_ng_template_0_Template(rf, ctx) {}\nfunction _class17_5_ng_template_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_5_ng_template_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const dataItem_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r14.template.templateRef, dataItem_r11));\n  }\n}\nfunction _class17_5_ng_template_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r15.getText(dataItem_r11));\n  }\n}\nconst _c6 = function (a0, a1) {\n  return {\n    \"k-disabled\": a0,\n    \"k-table-alt-row\": a1\n  };\n};\nfunction _class17_5_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 12);\n    i0.ɵɵtemplate(1, _class17_5_ng_template_0_input_1_Template, 1, 2, \"input\", 13);\n    i0.ɵɵtemplate(2, _class17_5_ng_template_0_2_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(3, _class17_5_ng_template_0_ng_template_3_Template, 2, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const itemIndex_r12 = ctx.index;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    let tmp_1_0;\n    i0.ɵɵclassMap(ctx_r10.listItemClass);\n    i0.ɵɵstyleProp(\"width\", (tmp_1_0 = ctx_r10.rowWidth) !== null && tmp_1_0 !== undefined ? tmp_1_0 : null, \"px\");\n    i0.ɵɵproperty(\"checkboxes\", ctx_r10.checkboxes)(\"height\", ctx_r10.virtual == null ? null : ctx_r10.virtual.itemHeight)(\"index\", itemIndex_r12 + ctx_r10.startFrom)(\"multipleSelection\", ctx_r10.multipleSelection)(\"ngClass\", i0.ɵɵpureFunction2(15, _c6, ctx_r10.isDisabled(itemIndex_r12), ctx_r10.isAltRow(itemIndex_r12)));\n    i0.ɵɵattribute(\"id\", ctx_r10.optionPrefix + \"-\" + itemIndex_r12)(\"tabIndex\", -1)(\"aria-selected\", ctx_r10.isItemSelected(itemIndex_r12));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.checkboxes.enabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r10.template);\n  }\n}\nfunction _class17_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_5_ng_template_0_Template, 4, 18, \"ng-template\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.data);\n  }\n}\nfunction _class17_6_ng_template_0_li_0_3_ng_template_0_Template(rf, ctx) {}\nfunction _class17_6_ng_template_0_li_0_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_6_ng_template_0_li_0_3_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r29.groupTemplate.templateRef, dataItem_r24.value));\n  }\n}\nfunction _class17_6_ng_template_0_li_0_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵtextInterpolate(dataItem_r24.value);\n  }\n}\nfunction _class17_6_ng_template_0_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 18, 19)(2, \"span\");\n    i0.ɵɵtemplate(3, _class17_6_ng_template_0_li_0_3_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(4, _class17_6_ng_template_0_li_0_ng_template_4_Template, 1, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r34 = i0.ɵɵnextContext();\n    const itemIndex_r25 = ctx_r34.index;\n    const dataItem_r24 = ctx_r34.$implicit;\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    let tmp_1_0;\n    i0.ɵɵclassMap(ctx_r26.listGroupItemClass);\n    i0.ɵɵstyleProp(\"width\", (tmp_1_0 = ctx_r26.rowWidth) !== null && tmp_1_0 !== undefined ? tmp_1_0 : null, \"px\");\n    i0.ɵɵclassProp(\"k-table-alt-row\", ctx_r26.isAltRow(itemIndex_r25 - 1));\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction3(14, _c5, ctx_r26.virtual == null ? null : ctx_r26.virtual.itemHeight, ctx_r26.virtual == null ? null : ctx_r26.virtual.itemHeight, ctx_r26.virtual ? \"border-box\" : \"inherit\"));\n    i0.ɵɵattribute(\"group-index\", dataItem_r24.index)(\"id\", ctx_r26.optionPrefix + \"-\" + dataItem_r24.groupIndex + \"-\" + dataItem_r24.value.split(\" \").join(\"\"))(\"tabIndex\", -1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassMap(ctx_r26.listGroupItemTextClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.groupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r26.groupTemplate);\n  }\n}\nfunction _class17_6_ng_template_0_li_1_2_ng_template_0_Template(rf, ctx) {}\nfunction _class17_6_ng_template_0_li_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_6_ng_template_0_li_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r36 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r36.template.templateRef, dataItem_r24.value));\n  }\n}\nfunction _class17_6_ng_template_0_li_1_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r37 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r37.getText(dataItem_r24.value));\n  }\n}\nfunction _class17_6_ng_template_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 20, 19);\n    i0.ɵɵtemplate(2, _class17_6_ng_template_0_li_1_2_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(3, _class17_6_ng_template_0_li_1_ng_template_3_Template, 2, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext();\n    const dataItem_r24 = ctx_r41.$implicit;\n    const itemIndex_r25 = ctx_r41.index;\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    let tmp_1_0;\n    i0.ɵɵclassMap(ctx_r27.listItemClass);\n    i0.ɵɵstyleProp(\"width\", (tmp_1_0 = ctx_r27.rowWidth) !== null && tmp_1_0 !== undefined ? tmp_1_0 : null, \"px\");\n    i0.ɵɵproperty(\"height\", ctx_r27.virtual == null ? null : ctx_r27.virtual.itemHeight)(\"index\", dataItem_r24.offsetIndex)(\"multipleSelection\", ctx_r27.multipleSelection)(\"ngClass\", i0.ɵɵpureFunction2(14, _c6, ctx_r27.isDisabled(dataItem_r24.offsetIndex), ctx_r27.isAltRow(itemIndex_r25 - 1)));\n    i0.ɵɵattribute(\"absolute-index\", dataItem_r24.index)(\"id\", ctx_r27.optionPrefix + \"-\" + (itemIndex_r25 - 1 - dataItem_r24.groupIndex))(\"tabIndex\", -1)(\"aria-selected\", ctx_r27.isItemSelected(dataItem_r24.offsetIndex));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r27.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r27.template);\n  }\n}\nfunction _class17_6_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_6_ng_template_0_li_0_Template, 5, 18, \"li\", 16);\n    i0.ɵɵtemplate(1, _class17_6_ng_template_0_li_1_Template, 4, 17, \"li\", 17);\n  }\n  if (rf & 2) {\n    const dataItem_r24 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", dataItem_r24.header);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !dataItem_r24.header);\n  }\n}\nfunction _class17_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_6_ng_template_0_Template, 2, 2, \"ng-template\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.data);\n  }\n}\nfunction _class17_kendo_resize_sensor_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r43 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 21);\n    i0.ɵɵlistener(\"resize\", function _class17_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const ctx_r42 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r42.listResize.emit());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class17_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r46 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 22, 23)(2, \"div\")(3, \"kendo-resize-sensor\", 21);\n    i0.ɵɵlistener(\"resize\", function _class17_div_8_Template_kendo_resize_sensor_resize_3_listener() {\n      i0.ɵɵrestoreView(_r46);\n      const ctx_r45 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r45.listResize.emit());\n    });\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"height\", ctx_r6.scrollHeight, \"px\");\n  }\n}\nconst _c7 = [\"actionSheetSearchBar\"];\nfunction _class18_ng_template_2_kendo_textbox_10_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon\", 19);\n  }\n}\nfunction _class18_ng_template_2_kendo_textbox_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-textbox\", 16, 17);\n    i0.ɵɵlistener(\"valueChange\", function _class18_ng_template_2_kendo_textbox_10_Template_kendo_textbox_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.onValueChange($event));\n    });\n    i0.ɵɵtemplate(2, _class18_ng_template_2_kendo_textbox_10_ng_template_2_Template, 1, 0, \"ng-template\", 18);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"value\", ctx_r2.searchBarValue)(\"size\", ctx_r2.size);\n  }\n}\nfunction _class18_ng_template_2_ng_container_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class18_ng_template_2_div_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 20)(1, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function _class18_ng_template_2_div_14_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r9.onCancel.emit());\n    })(\"keydown.enter\", function _class18_ng_template_2_div_14_Template_button_keydown_enter_1_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 22);\n    i0.ɵɵlistener(\"click\", function _class18_ng_template_2_div_14_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.onApply.emit());\n    })(\"keydown.enter\", function _class18_ng_template_2_div_14_Template_button_keydown_enter_3_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r4.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.messageFor(\"cancelButton\"), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r4.size);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.messageFor(\"applyButton\"), \" \");\n  }\n}\nfunction _class18_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 3)(1, \"div\", 4)(2, \"div\", 5)(3, \"div\", 6);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"div\", 7);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(7, \"div\", 8)(8, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function _class18_ng_template_2_Template_button_click_8_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.handleClose());\n    });\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(9, \"div\", 10);\n    i0.ɵɵtemplate(10, _class18_ng_template_2_kendo_textbox_10_Template, 3, 2, \"kendo-textbox\", 11);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"div\", 12)(12, \"div\", 13);\n    i0.ɵɵtemplate(13, _class18_ng_template_2_ng_container_13_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(14, _class18_ng_template_2_div_14_Template, 5, 4, \"div\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r1.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.subtitle);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.xIcon)(\"size\", ctx_r1.size)(\"tabIndex\", -1);\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showTextInput);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.sharedPopupActionSheetTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showActionButtons);\n  }\n}\nconst _c8 = function (a0) {\n  return {\n    duration: a0\n  };\n};\nconst _c9 = [\"container\"];\nconst _c10 = [\"popupTemplate\"];\nconst _c11 = [\"optionsList\"];\nfunction _class22_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class22_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵtemplate(1, _class22_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class22_kendo_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class22_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵlistener(\"click\", function _class22_span_5_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.clearValue($event));\n    })(\"mousedown\", function _class22_span_5_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r2.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r2.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xIcon);\n  }\n}\nfunction _class22_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 17);\n  }\n}\nfunction _class22_kendo_separator_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class22_span_8_ng_template_1_Template(rf, ctx) {}\nfunction _class22_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵtemplate(1, _class22_span_8_ng_template_1_Template, 0, 0, \"ng-template\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);\n  }\n}\nfunction _class22_ng_template_9_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class22_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class22_ng_template_9_ng_container_0_Template, 1, 0, \"ng-container\", 19);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r10 = i0.ɵɵreference(16);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n  }\n}\nfunction _class22_kendo_resize_sensor_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 20);\n    i0.ɵɵlistener(\"resize\", function _class22_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class22_ng_template_15_0_ng_template_0_Template(rf, ctx) {}\nconst _c18 = function (a0) {\n  return {\n    templateRef: a0\n  };\n};\nfunction _class22_ng_template_15_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class22_ng_template_15_0_ng_template_0_Template, 0, 0, \"ng-template\", 24);\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r20.headerTemplate.templateRef));\n  }\n}\nfunction _class22_ng_template_15_div_3_ng_template_1_Template(rf, ctx) {}\nfunction _class22_ng_template_15_div_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r26.messageFor(\"noDataText\"));\n  }\n}\nfunction _class22_ng_template_15_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25);\n    i0.ɵɵtemplate(1, _class22_ng_template_15_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 26);\n    i0.ɵɵtemplate(2, _class22_ng_template_15_div_3_ng_template_2_Template, 2, 1, \"ng-template\", 27);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r22.noDataTemplate == null ? null : ctx_r22.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r22.noDataTemplate);\n  }\n}\nfunction _class22_ng_template_15_4_ng_template_0_Template(rf, ctx) {}\nfunction _class22_ng_template_15_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class22_ng_template_15_4_ng_template_0_Template, 0, 0, \"ng-template\", 24);\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r23.footerTemplate.templateRef));\n  }\n}\nfunction _class22_ng_template_15_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class22_ng_template_15_0_Template, 1, 3, null, 3);\n    i0.ɵɵelementStart(1, \"kendo-list\", 21, 22);\n    i0.ɵɵlistener(\"pageChange\", function _class22_ng_template_15_Template_kendo_list_pageChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.pageChange($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class22_ng_template_15_div_3_Template, 3, 5, \"div\", 23);\n    i0.ɵɵtemplate(4, _class22_ng_template_15_4_Template, 1, 3, null, 3);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r11.size)(\"rounded\", ctx_r11.rounded)(\"id\", ctx_r11.listBoxId)(\"optionPrefix\", ctx_r11.optionPrefix)(\"data\", ctx_r11.data)(\"textField\", ctx_r11.valueField)(\"valueField\", ctx_r11.valueField)(\"template\", ctx_r11.template)(\"groupTemplate\", ctx_r11.groupTemplate)(\"fixedGroupTemplate\", ctx_r11.fixedGroupTemplate)(\"height\", ctx_r11.listHeight)(\"show\", ctx_r11.isOpen)(\"virtual\", ctx_r11.virtual)(\"showStickyHeader\", ctx_r11.showStickyHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.footerTemplate);\n  }\n}\nconst _c19 = [\"select\"];\nfunction _class23_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class23_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵtemplate(1, _class23_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class23_kendo_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nconst _c28 = function (a0) {\n  return {\n    mousedown: a0\n  };\n};\nfunction _class23_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵlistener(\"click\", function _class23_span_5_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.clearValue($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 19);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r2.clearButtonVisiblity);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(5, _c28, ctx_r2.preventEventDefault));\n    i0.ɵɵattribute(\"title\", ctx_r2.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xIcon);\n  }\n}\nfunction _class23_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n}\nfunction _class23_kendo_separator_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class23_span_8_ng_template_1_Template(rf, ctx) {}\nfunction _class23_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 21);\n    i0.ɵɵtemplate(1, _class23_span_8_ng_template_1_Template, 0, 0, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);\n  }\n}\nfunction _class23_ng_template_12_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class23_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class23_ng_template_12_ng_container_0_Template, 1, 0, \"ng-container\", 22);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r11 = i0.ɵɵreference(19);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r11);\n  }\n}\nfunction _class23_kendo_resize_sensor_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 23);\n    i0.ɵɵlistener(\"resize\", function _class23_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class23_ng_template_18_0_ng_template_0_Template(rf, ctx) {}\nfunction _class23_ng_template_18_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class23_ng_template_18_0_ng_template_0_Template, 0, 0, \"ng-template\", 27);\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r20.headerTemplate.templateRef));\n  }\n}\nfunction _class23_ng_template_18_div_3_ng_template_1_Template(rf, ctx) {}\nfunction _class23_ng_template_18_div_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r26.messageFor(\"noDataText\"));\n  }\n}\nfunction _class23_ng_template_18_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 28);\n    i0.ɵɵtemplate(1, _class23_ng_template_18_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 29);\n    i0.ɵɵtemplate(2, _class23_ng_template_18_div_3_ng_template_2_Template, 2, 1, \"ng-template\", 30);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r22.noDataTemplate ? ctx_r22.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r22.noDataTemplate);\n  }\n}\nfunction _class23_ng_template_18_4_ng_template_0_Template(rf, ctx) {}\nfunction _class23_ng_template_18_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class23_ng_template_18_4_ng_template_0_Template, 0, 0, \"ng-template\", 27);\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r23.footerTemplate.templateRef));\n  }\n}\nfunction _class23_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class23_ng_template_18_0_Template, 1, 3, null, 3);\n    i0.ɵɵelementStart(1, \"kendo-list\", 24, 25);\n    i0.ɵɵlistener(\"pageChange\", function _class23_ng_template_18_Template_kendo_list_pageChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.pageChange($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, _class23_ng_template_18_div_3_Template, 3, 5, \"div\", 26);\n    i0.ɵɵtemplate(4, _class23_ng_template_18_4_Template, 1, 3, null, 3);\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r12.size)(\"rounded\", ctx_r12.rounded)(\"id\", ctx_r12.listBoxId)(\"optionPrefix\", ctx_r12.optionPrefix)(\"data\", ctx_r12.data)(\"textField\", ctx_r12.textField)(\"valueField\", ctx_r12.valueField)(\"template\", ctx_r12.template)(\"groupTemplate\", ctx_r12.groupTemplate)(\"fixedGroupTemplate\", ctx_r12.fixedGroupTemplate)(\"height\", ctx_r12.listHeight)(\"show\", ctx_r12.isOpen)(\"virtual\", ctx_r12.virtual)(\"showStickyHeader\", ctx_r12.showStickyHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.footerTemplate);\n  }\n}\nfunction _class26_3_ng_template_0_Template(rf, ctx) {}\nfunction _class26_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class26_3_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r0.valueTemplate.templateRef, ctx_r0.dataItem));\n  }\n}\nfunction _class26_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r1.getText());\n  }\n}\nfunction _class26_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 14);\n  }\n}\nfunction _class26_ng_template_8_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class26_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class26_ng_template_8_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r7 = i0.ɵɵreference(15);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r7);\n  }\n}\nfunction _class26_kendo_resize_sensor_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 16);\n    i0.ɵɵlistener(\"resize\", function _class26_kendo_resize_sensor_10_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class26_ng_template_14_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 20);\n    i0.ɵɵlistener(\"click\", function _class26_ng_template_14_ng_template_0_Template_div_click_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵelementStart(1, \"span\", 21);\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 22);\n    i0.ɵɵelementStart(3, \"input\", 23, 24);\n    i0.ɵɵlistener(\"ngModelChange\", function _class26_ng_template_14_ng_template_0_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r22.filterText = $event);\n    })(\"keydown\", function _class26_ng_template_14_ng_template_0_Template_input_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const _r20 = i0.ɵɵreference(4);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r24.keydown($event, _r20));\n    })(\"input\", function _class26_ng_template_14_ng_template_0_Template_input_input_3_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r25.handleFilter($event));\n    })(\"focus\", function _class26_ng_template_14_ng_template_0_Template_input_focus_3_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r26.onFilterFocus());\n    })(\"blur\", function _class26_ng_template_14_ng_template_0_Template_input_blur_3_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r27.blurFilterInput());\n    })(\"click\", function _class26_ng_template_14_ng_template_0_Template_input_click_3_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r28.handleClick());\n    });\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r13.filterInputClasses);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r13.searchIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"filterInput\", ctx_r13.isFocused && !ctx_r13.touchEnabled)(\"dir\", ctx_r13.direction)(\"ngModel\", ctx_r13.filterText);\n    i0.ɵɵattribute(\"aria-controls\", ctx_r13.listBoxId)(\"aria-label\", ctx_r13.messageFor(\"filterInputLabel\"));\n  }\n}\nconst _c37 = function (a0) {\n  return {\n    \"k-disabled\": a0\n  };\n};\nfunction _class26_ng_template_14_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25)(1, \"div\", 26);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r14.optionLabelSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(4, _c37, ctx_r14.isDisabledDefaultItem))(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r14.getDefaultItemText(), \" \");\n  }\n}\nfunction _class26_ng_template_14_ng_template_2_ng_template_2_Template(rf, ctx) {}\nfunction _class26_ng_template_14_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25)(1, \"div\", 26);\n    i0.ɵɵtemplate(2, _class26_ng_template_14_ng_template_2_ng_template_2_Template, 0, 0, \"ng-template\", 13);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r15.optionLabelSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(4, _c37, ctx_r15.isDisabledDefaultItem))(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(6, _c4, ctx_r15.itemTemplate.templateRef, ctx_r15.defaultItem));\n  }\n}\nfunction _class26_ng_template_14_3_ng_template_0_Template(rf, ctx) {}\nfunction _class26_ng_template_14_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class26_ng_template_14_3_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r16.headerTemplate.templateRef));\n  }\n}\nfunction _class26_ng_template_14_div_6_ng_template_1_Template(rf, ctx) {}\nfunction _class26_ng_template_14_div_6_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r32 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r32.messageFor(\"noDataText\"));\n  }\n}\nfunction _class26_ng_template_14_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 27);\n    i0.ɵɵtemplate(1, _class26_ng_template_14_div_6_ng_template_1_Template, 0, 0, \"ng-template\", 28);\n    i0.ɵɵtemplate(2, _class26_ng_template_14_div_6_ng_template_2_Template, 2, 1, \"ng-template\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r18.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r18.noDataTemplate ? ctx_r18.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r18.noDataTemplate);\n  }\n}\nfunction _class26_ng_template_14_7_ng_template_0_Template(rf, ctx) {}\nfunction _class26_ng_template_14_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class26_ng_template_14_7_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r19.footerTemplate.templateRef));\n  }\n}\nfunction _class26_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class26_ng_template_14_ng_template_0_Template, 5, 7, \"ng-template\", 4);\n    i0.ɵɵtemplate(1, _class26_ng_template_14_ng_template_1_Template, 3, 6, \"ng-template\", 4);\n    i0.ɵɵtemplate(2, _class26_ng_template_14_ng_template_2_Template, 3, 9, \"ng-template\", 4);\n    i0.ɵɵtemplate(3, _class26_ng_template_14_3_Template, 1, 3, null, 3);\n    i0.ɵɵelementStart(4, \"kendo-list\", 17, 18);\n    i0.ɵɵlistener(\"pageChange\", function _class26_ng_template_14_Template_kendo_list_pageChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r34.pageChange($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, _class26_ng_template_14_div_6_Template, 3, 5, \"div\", 19);\n    i0.ɵɵtemplate(7, _class26_ng_template_14_7_Template, 1, 3, null, 3);\n  }\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.filterable && !ctx_r8.isActionSheetExpanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.defaultItem && !ctx_r8.itemTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.defaultItem && ctx_r8.itemTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r8.listBoxId)(\"size\", ctx_r8.size)(\"rounded\", ctx_r8.rounded)(\"optionPrefix\", ctx_r8.optionPrefix)(\"data\", ctx_r8.data)(\"textField\", ctx_r8.textField)(\"valueField\", ctx_r8.valueField)(\"template\", ctx_r8.itemTemplate)(\"groupTemplate\", ctx_r8.groupTemplate)(\"fixedGroupTemplate\", ctx_r8.fixedGroupTemplate)(\"height\", ctx_r8.listHeight)(\"show\", ctx_r8.isOpen)(\"virtual\", ctx_r8.virtual)(\"ariaLive\", ctx_r8.ariaLive)(\"showStickyHeader\", ctx_r8.showStickyHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.footerTemplate);\n  }\n}\nfunction _class31_div_0_2_ng_template_0_Template(rf, ctx) {}\nfunction _class31_div_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class31_div_0_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\nfunction _class31_div_0_ng_template_3_1_ng_template_0_Template(rf, ctx) {}\nfunction _class31_div_0_ng_template_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class31_div_0_ng_template_3_1_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r9.groupTemplate.templateRef, tag_r1));\n  }\n}\nfunction _class31_div_0_ng_template_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵtextInterpolate2(\"\", tag_r1.length, \" \", tag_r1.length === 1 ? \"item\" : \"items\", \" selected\");\n  }\n}\nfunction _class31_div_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, _class31_div_0_ng_template_3_1_Template, 1, 4, null, 10);\n    i0.ɵɵtemplate(2, _class31_div_0_ng_template_3_ng_template_2_Template, 1, 2, \"ng-template\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.groupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.groupTemplate);\n  }\n}\nfunction _class31_div_0_ng_template_5_1_ng_template_0_Template(rf, ctx) {}\nfunction _class31_div_0_ng_template_5_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class31_div_0_ng_template_5_1_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r14.template.templateRef, tag_r1));\n  }\n}\nfunction _class31_div_0_ng_template_5_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    const tag_r1 = ctx_r18.$implicit;\n    const index_r2 = ctx_r18.index;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r15.tagProp(tag_r1, ctx_r15.textField, index_r2));\n  }\n}\nfunction _class31_div_0_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, _class31_div_0_ng_template_5_1_Template, 1, 4, null, 10);\n    i0.ɵɵtemplate(2, _class31_div_0_ng_template_5_ng_template_2_Template, 1, 1, \"ng-template\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.template);\n  }\n}\nconst _c38 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n  return {\n    \"k-focus\": a0,\n    \"k-disabled\": a1,\n    \"k-chip-sm\": a2,\n    \"k-chip-md\": a3,\n    \"k-chip-lg\": a4,\n    \"k-rounded-sm\": a5,\n    \"k-rounded-md\": a6,\n    \"k-rounded-lg\": a7,\n    \"k-rounded-full\": a8,\n    \"k-chip-solid k-chip-solid-base\": a9,\n    \"k-chip-flat k-chip-flat-base\": a10,\n    \"k-chip-outline k-chip-outline-base\": a11\n  };\n};\nfunction _class31_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1)(1, \"span\", 2);\n    i0.ɵɵtemplate(2, _class31_div_0_2_Template, 1, 0, null, 3);\n    i0.ɵɵtemplate(3, _class31_div_0_ng_template_3_Template, 3, 2, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(5, _class31_div_0_ng_template_5_Template, 3, 2, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"span\", 6)(8, \"span\", 7)(9, \"kendo-icon-wrapper\", 8);\n    i0.ɵɵlistener(\"mousedown\", function _class31_div_0_Template_kendo_icon_wrapper_mousedown_9_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r20);\n      const tag_r1 = restoredCtx.$implicit;\n      const index_r2 = restoredCtx.index;\n      const ctx_r19 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r19.deleteTag($event, tag_r1, index_r2));\n    });\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const tag_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n    const _r4 = i0.ɵɵreference(4);\n    const _r6 = i0.ɵɵreference(6);\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunctionV(9, _c38, [index_r2 === ctx_r0.focused, ctx_r0.isTagDisabled(tag_r1, index_r2), ctx_r0.size === \"small\", ctx_r0.size === \"medium\", ctx_r0.size === \"large\", ctx_r0.rounded === \"small\", ctx_r0.rounded === \"medium\", ctx_r0.rounded === \"large\", ctx_r0.rounded === \"full\", ctx_r0.fillMode === \"solid\", ctx_r0.fillMode === \"flat\", ctx_r0.fillMode === \"outline\"]));\n    i0.ɵɵattribute(\"id\", ctx_r0.itemId(tag_r1, index_r2))(\"aria-selected\", true)(\"role\", \"option\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isGroupTag(tag_r1))(\"ngIfThen\", _r4)(\"ngIfElse\", _r6);\n    i0.ɵɵadvance(6);\n    i0.ɵɵattribute(\"aria-hidden\", index_r2 !== ctx_r0.focused);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r0.xCircleIcon);\n  }\n}\nconst _c39 = [\"*\"];\nfunction _class32_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class32_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtemplate(1, _class32_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class32_kendo_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class32_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 17);\n    i0.ɵɵlistener(\"mousedown\", function _class32_span_7_Template_span_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.clearAll($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 18);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r2.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r2.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xIcon);\n  }\n}\nfunction _class32_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 19);\n  }\n}\nfunction _class32_kendo_separator_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class32_span_10_ng_template_1_Template(rf, ctx) {}\nfunction _class32_span_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 20);\n    i0.ɵɵtemplate(1, _class32_span_10_ng_template_1_Template, 0, 0, \"ng-template\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);\n  }\n}\nfunction _class32_ng_template_11_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class32_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class32_ng_template_11_ng_container_0_Template, 1, 0, \"ng-container\", 21);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r10 = i0.ɵɵreference(18);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n  }\n}\nfunction _class32_kendo_resize_sensor_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 22);\n    i0.ɵɵlistener(\"resize\", function _class32_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r17.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class32_ng_template_17_0_ng_template_0_Template(rf, ctx) {}\nfunction _class32_ng_template_17_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class32_ng_template_17_0_ng_template_0_Template, 0, 0, \"ng-template\", 27);\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r19.headerTemplate.templateRef));\n  }\n}\nfunction _class32_ng_template_17_div_1_2_ng_template_0_Template(rf, ctx) {}\nfunction _class32_ng_template_17_div_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class32_ng_template_17_div_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 27);\n  }\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r25.customItemTemplate.templateRef, ctx_r25.text));\n  }\n}\nfunction _class32_ng_template_17_div_1_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(3);\n    i0.ɵɵtextInterpolate(ctx_r27.text);\n  }\n}\nfunction _class32_ng_template_17_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 28)(1, \"div\", 29);\n    i0.ɵɵtemplate(2, _class32_ng_template_17_div_1_2_Template, 1, 4, null, 30);\n    i0.ɵɵtemplate(3, _class32_ng_template_17_div_1_ng_template_3_Template, 1, 1, \"ng-template\", null, 31, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelement(5, \"kendo-icon-wrapper\", 32);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const _r26 = i0.ɵɵreference(4);\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r20.customItemSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"multipleSelection\", true)(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r20.customItemTemplate)(\"ngIfElse\", _r26);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r20.plusIcon);\n  }\n}\nfunction _class32_ng_template_17_div_4_ng_template_1_Template(rf, ctx) {}\nfunction _class32_ng_template_17_div_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r30 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r30.messageFor(\"noDataText\"));\n  }\n}\nfunction _class32_ng_template_17_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵtemplate(1, _class32_ng_template_17_div_4_ng_template_1_Template, 0, 0, \"ng-template\", 34);\n    i0.ɵɵtemplate(2, _class32_ng_template_17_div_4_ng_template_2_Template, 2, 1, \"ng-template\", 35);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r22.noDataTemplate ? ctx_r22.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r22.noDataTemplate);\n  }\n}\nfunction _class32_ng_template_17_5_ng_template_0_Template(rf, ctx) {}\nfunction _class32_ng_template_17_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class32_ng_template_17_5_ng_template_0_Template, 0, 0, \"ng-template\", 27);\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r23.footerTemplate.templateRef));\n  }\n}\nfunction _class32_ng_template_17_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class32_ng_template_17_0_Template, 1, 3, null, 3);\n    i0.ɵɵtemplate(1, _class32_ng_template_17_div_1_Template, 6, 6, \"div\", 23);\n    i0.ɵɵelementStart(2, \"kendo-list\", 24, 25);\n    i0.ɵɵlistener(\"pageChange\", function _class32_ng_template_17_Template_kendo_list_pageChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r32.pageChange($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, _class32_ng_template_17_div_4_Template, 3, 5, \"div\", 26);\n    i0.ɵɵtemplate(5, _class32_ng_template_17_5_Template, 1, 3, null, 3);\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.allowCustom && ctx_r11.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r11.size)(\"rounded\", ctx_r11.rounded)(\"id\", ctx_r11.listBoxId)(\"optionPrefix\", ctx_r11.optionPrefix)(\"data\", ctx_r11.data)(\"textField\", ctx_r11.textField)(\"valueField\", ctx_r11.valueField)(\"template\", ctx_r11.template)(\"groupTemplate\", ctx_r11.groupTemplate)(\"fixedGroupTemplate\", ctx_r11.fixedGroupTemplate)(\"height\", ctx_r11.listHeight)(\"show\", ctx_r11.isOpen)(\"multipleSelection\", true)(\"virtual\", ctx_r11.virtual)(\"checkboxes\", ctx_r11.checkboxes)(\"isMultiselect\", true)(\"isActionSheetExpanded\", ctx_r11.isActionSheetExpanded)(\"showStickyHeader\", ctx_r11.showStickyHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.footerTemplate);\n  }\n}\nconst _c50 = [\"header\"];\nconst _c51 = [\"headerTable\"];\nconst _c52 = [\"columnHeader\"];\nfunction _class36_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class36_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵtemplate(1, _class36_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class36_kendo_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class36_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵlistener(\"click\", function _class36_span_5_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.clearValue($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 19);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r2.clearButtonVisiblity);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(5, _c28, ctx_r2.preventEventDefault));\n    i0.ɵɵattribute(\"title\", ctx_r2.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xIcon);\n  }\n}\nfunction _class36_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n}\nfunction _class36_kendo_separator_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-separator\");\n  }\n}\nfunction _class36_span_8_ng_template_1_Template(rf, ctx) {}\nfunction _class36_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 21);\n    i0.ɵɵtemplate(1, _class36_span_8_ng_template_1_Template, 0, 0, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);\n  }\n}\nfunction _class36_ng_template_12_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class36_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class36_ng_template_12_ng_container_0_Template, 1, 0, \"ng-container\", 22);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r11 = i0.ɵɵreference(19);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r11);\n  }\n}\nfunction _class36_kendo_resize_sensor_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 23);\n    i0.ɵɵlistener(\"resize\", function _class36_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class36_ng_template_18_0_ng_template_0_Template(rf, ctx) {}\nfunction _class36_ng_template_18_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class36_ng_template_18_0_ng_template_0_Template, 0, 0, \"ng-template\", 38);\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r20.headerTemplate == null ? null : ctx_r20.headerTemplate.templateRef));\n  }\n}\nfunction _class36_ng_template_18_ng_container_9_col_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n  if (rf & 2) {\n    const column_r32 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵstyleProp(\"width\", column_r32.width, \"px\");\n  }\n}\nfunction _class36_ng_template_18_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class36_ng_template_18_ng_container_9_col_1_Template, 1, 2, \"col\", 39);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r32 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r32.hidden && column_r32.matchesMedia);\n  }\n}\nfunction _class36_ng_template_18_ng_container_12_th_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r35 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r35.title || column_r35.field, \" \");\n  }\n}\nfunction _class36_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template(rf, ctx) {}\nconst _c61 = function (a0, a1, a2) {\n  return {\n    templateRef: a0,\n    $implicit: a1,\n    column: a2\n  };\n};\nfunction _class36_ng_template_18_ng_container_12_th_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class36_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 38);\n  }\n  if (rf & 2) {\n    const column_r35 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction3(1, _c61, column_r35.headerTemplate == null ? null : column_r35.headerTemplate.templateRef, column_r35, column_r35));\n  }\n}\nfunction _class36_ng_template_18_ng_container_12_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 41, 42);\n    i0.ɵɵtemplate(2, _class36_ng_template_18_ng_container_12_th_1_ng_container_2_Template, 2, 1, \"ng-container\", 3);\n    i0.ɵɵtemplate(3, _class36_ng_template_18_ng_container_12_th_1_3_Template, 1, 5, null, 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const column_r35 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngStyle\", column_r35.headerStyle)(\"ngClass\", column_r35.headerClass);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !column_r35.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r35.headerTemplate);\n  }\n}\nfunction _class36_ng_template_18_ng_container_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class36_ng_template_18_ng_container_12_th_1_Template, 4, 4, \"th\", 40);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r35 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r35.hidden && column_r35.matchesMedia);\n  }\n}\nfunction _class36_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r46 = i0.ɵɵnextContext(2).$implicit;\n    const dataItem_r44 = i0.ɵɵnextContext().$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r49.textFrom(dataItem_r44, column_r46.field), \" \");\n  }\n}\nfunction _class36_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template(rf, ctx) {}\nconst _c62 = function (a0, a1, a2, a3) {\n  return {\n    templateRef: a0,\n    $implicit: a1,\n    dataItem: a2,\n    column: a3\n  };\n};\nfunction _class36_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class36_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 38);\n  }\n  if (rf & 2) {\n    const column_r46 = i0.ɵɵnextContext(2).$implicit;\n    const dataItem_r44 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(1, _c62, column_r46.cellTemplate == null ? null : column_r46.cellTemplate.templateRef, dataItem_r44, dataItem_r44, column_r46));\n  }\n}\nfunction _class36_ng_template_18_ng_template_13_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 44);\n    i0.ɵɵtemplate(1, _class36_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template, 2, 1, \"ng-container\", 3);\n    i0.ɵɵtemplate(2, _class36_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template, 1, 6, null, 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r56 = i0.ɵɵnextContext();\n    const i_r47 = ctx_r56.index;\n    const column_r46 = ctx_r56.$implicit;\n    const ctx_r48 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r48.getColumnWidth(i_r47), \"px\")(\"max-width\", ctx_r48.getColumnWidth(i_r47), \"px\");\n    i0.ɵɵproperty(\"ngClass\", column_r46.class)(\"ngStyle\", column_r46.style);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r46.cellTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r46.cellTemplate);\n  }\n}\nfunction _class36_ng_template_18_ng_template_13_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class36_ng_template_18_ng_template_13_ng_container_0_span_1_Template, 3, 8, \"span\", 43);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const column_r46 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r46.hidden && column_r46.matchesMedia);\n  }\n}\nfunction _class36_ng_template_18_ng_template_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class36_ng_template_18_ng_template_13_ng_container_0_Template, 2, 1, \"ng-container\", 31);\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r27.columns);\n  }\n}\nfunction _class36_ng_template_18_div_17_ng_template_1_Template(rf, ctx) {}\nfunction _class36_ng_template_18_div_17_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r58 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r58.messageFor(\"noDataText\"));\n  }\n}\nfunction _class36_ng_template_18_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 45);\n    i0.ɵɵtemplate(1, _class36_ng_template_18_div_17_ng_template_1_Template, 0, 0, \"ng-template\", 46);\n    i0.ɵɵtemplate(2, _class36_ng_template_18_div_17_ng_template_2_Template, 2, 1, \"ng-template\", 47);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r29.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r29.noDataTemplate == null ? null : ctx_r29.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r29.noDataTemplate);\n  }\n}\nfunction _class36_ng_template_18_ng_container_18_ng_template_6_Template(rf, ctx) {}\nfunction _class36_ng_template_18_ng_container_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 48)(2, \"table\", 49)(3, \"tfoot\", 50)(4, \"tr\", 33)(5, \"td\", 51);\n    i0.ɵɵtemplate(6, _class36_ng_template_18_ng_container_18_ng_template_6_Template, 0, 0, \"ng-template\", 38);\n    i0.ɵɵelementEnd()()()()();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r30 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(6);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r30.footerTemplate.templateRef));\n  }\n}\nfunction _class36_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r61 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class36_ng_template_18_0_Template, 1, 3, null, 3);\n    i0.ɵɵelementStart(1, \"div\", 24)(2, \"div\", 25, 26)(4, \"div\", 27, 28)(6, \"table\", 29, 30)(8, \"colgroup\");\n    i0.ɵɵtemplate(9, _class36_ng_template_18_ng_container_9_Template, 2, 1, \"ng-container\", 31);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"thead\", 32)(11, \"tr\", 33);\n    i0.ɵɵtemplate(12, _class36_ng_template_18_ng_container_12_Template, 2, 1, \"ng-container\", 31);\n    i0.ɵɵelementEnd()()()()();\n    i0.ɵɵtemplate(13, _class36_ng_template_18_ng_template_13_Template, 1, 1, \"ng-template\", null, 34, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementStart(15, \"kendo-list\", 35, 36);\n    i0.ɵɵlistener(\"pageChange\", function _class36_ng_template_18_Template_kendo_list_pageChange_15_listener($event) {\n      i0.ɵɵrestoreView(_r61);\n      const ctx_r60 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r60.pageChange($event));\n    })(\"listResize\", function _class36_ng_template_18_Template_kendo_list_listResize_15_listener() {\n      i0.ɵɵrestoreView(_r61);\n      const _r21 = i0.ɵɵreference(3);\n      const ctx_r62 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r62.updateHeaderPadding(_r21));\n    })(\"popupListScroll\", function _class36_ng_template_18_Template_kendo_list_popupListScroll_15_listener($event) {\n      i0.ɵɵrestoreView(_r61);\n      const _r22 = i0.ɵɵreference(5);\n      return i0.ɵɵresetView(_r22.scrollLeft = $event.target.scrollLeft);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(17, _class36_ng_template_18_div_17_Template, 3, 5, \"div\", 37);\n    i0.ɵɵtemplate(18, _class36_ng_template_18_ng_container_18_Template, 7, 3, \"ng-container\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const _r26 = i0.ɵɵreference(14);\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r12.tableSizeClass);\n    i0.ɵɵadvance(8);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r12.columns);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r12.columns);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"optionPrefix\", ctx_r12.optionPrefix)(\"data\", ctx_r12.data)(\"textField\", ctx_r12.textField)(\"valueField\", ctx_r12.valueField)(\"template\", i0.ɵɵpureFunction1(20, _c18, _r26))(\"groupTemplate\", ctx_r12.groupTemplate)(\"fixedGroupTemplate\", ctx_r12.fixedGroupTemplate)(\"height\", ctx_r12.listHeight)(\"show\", ctx_r12.isOpen)(\"id\", ctx_r12.listBoxId)(\"virtual\", ctx_r12.virtual)(\"type\", \"dropdowngrid\")(\"rowWidth\", ctx_r12.rowWidth)(\"showStickyHeader\", ctx_r12.showStickyHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.footerTemplate);\n  }\n}\nconst _c63 = [\"treeview\"];\nconst _c64 = [\"filterInput\"];\nfunction _class38_span_2_1_ng_template_0_Template(rf, ctx) {}\nfunction _class38_span_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_span_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c4, ctx_r9.valueTemplate.templateRef, ctx_r9.dataItem));\n  }\n}\nfunction _class38_span_2_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r10.text || ctx_r10.placeholder, \" \");\n  }\n}\nfunction _class38_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtemplate(1, _class38_span_2_1_Template, 1, 4, null, 13);\n    i0.ɵɵtemplate(2, _class38_span_2_ng_template_2_Template, 1, 1, \"ng-template\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.valueTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.valueTemplate);\n  }\n}\nfunction _class38_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵlistener(\"click\", function _class38_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.clearValue($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r1.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.xIcon);\n  }\n}\nfunction _class38_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 18);\n  }\n}\nfunction _class38_ng_template_7_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class38_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_ng_template_7_ng_container_0_Template, 1, 0, \"ng-container\", 19);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(13);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\nconst _c75 = function (a0) {\n  return {\n    blur: a0\n  };\n};\nfunction _class38_ng_template_12_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 23)(1, \"span\", 24)(2, \"span\", 25);\n    i0.ɵɵelement(3, \"kendo-icon-wrapper\", 26);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"input\", 27, 28);\n    i0.ɵɵlistener(\"input\", function _class38_ng_template_12_span_0_Template_input_input_4_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.handleFilterInputChange($event.target));\n    })(\"keydown.arrowdown\", function _class38_ng_template_12_span_0_Template_input_keydown_arrowdown_4_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const _r20 = i0.ɵɵreference(5);\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r23.handleKeydown($event, _r20));\n    })(\"keydown.alt.arrowup\", function _class38_ng_template_12_span_0_Template_input_keydown_alt_arrowup_4_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const _r20 = i0.ɵɵreference(5);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r24.handleKeydown($event, _r20));\n    })(\"keydown.escape\", function _class38_ng_template_12_span_0_Template_input_keydown_escape_4_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const _r20 = i0.ɵɵreference(5);\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r25.handleKeydown($event, _r20));\n    });\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r15.filterInputClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r15.searchIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"filterInput\", ctx_r15.filterable && !ctx_r15.touchEnabled)(\"value\", ctx_r15.filter)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(7, _c75, ctx_r15.handleBlur))(\"scope\", ctx_r15);\n    i0.ɵɵattribute(\"aria-label\", ctx_r15.messageFor(\"filterInputLabel\"));\n  }\n}\nfunction _class38_ng_template_12_1_ng_template_0_Template(rf, ctx) {}\nfunction _class38_ng_template_12_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_ng_template_12_1_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r16.headerTemplate == null ? null : ctx_r16.headerTemplate.templateRef));\n  }\n}\nfunction _class38_ng_template_12_kendo_treeview_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-treeview\", 29, 30);\n    i0.ɵɵlistener(\"selectedKeysChange\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectedKeysChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r28.selectedKeys = $event);\n    })(\"focusout\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_focusout_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r30.handleBlur($event));\n    })(\"keydown\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r31 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r31.handleKeydown($event));\n    })(\"selectionChange\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectionChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r32.onSelectionChange($event));\n    })(\"expand\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_expand_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r33 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r33.nodeExpand.emit($event));\n    })(\"collapse\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_collapse_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r34.nodeCollapse.emit($event));\n    })(\"childrenLoaded\", function _class38_ng_template_12_kendo_treeview_2_Template_kendo_treeview_childrenLoaded_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r35.onChildrenLoaded());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r17.listHeight, \"px\");\n    i0.ɵɵproperty(\"size\", ctx_r17.size)(\"nodes\", ctx_r17.data)(\"animate\", false)(\"selectedKeys\", ctx_r17.selectedKeys)(\"selectBy\", ctx_r17.selectBy)(\"textField\", ctx_r17.textField)(\"children\", ctx_r17.children)(\"hasChildren\", ctx_r17.hasChildren)(\"loadOnDemand\", ctx_r17.loadOnDemand)(\"isExpanded\", ctx_r17.isNodeExpanded)(\"isDisabled\", ctx_r17.itemDisabled)(\"nodeTemplate\", ctx_r17.nodeTemplate)(\"filter\", ctx_r17.filter)(\"isVisible\", ctx_r17.isNodeVisible);\n    i0.ɵɵattribute(\"id\", ctx_r17.treeViewId);\n  }\n}\nfunction _class38_ng_template_12_3_ng_template_0_Template(rf, ctx) {}\nfunction _class38_ng_template_12_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_ng_template_12_3_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r18.footerTemplate == null ? null : ctx_r18.footerTemplate.templateRef));\n  }\n}\nfunction _class38_ng_template_12_div_4_ng_template_1_Template(rf, ctx) {}\nfunction _class38_ng_template_12_div_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r38 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r38.messageFor(\"noDataText\"));\n  }\n}\nfunction _class38_ng_template_12_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 31);\n    i0.ɵɵtemplate(1, _class38_ng_template_12_div_4_ng_template_1_Template, 0, 0, \"ng-template\", 32);\n    i0.ɵɵtemplate(2, _class38_ng_template_12_div_4_ng_template_2_Template, 2, 1, \"ng-template\", 14);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r19.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r19.noDataTemplate == null ? null : ctx_r19.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r19.noDataTemplate);\n  }\n}\nfunction _class38_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class38_ng_template_12_span_0_Template, 6, 9, \"span\", 20);\n    i0.ɵɵtemplate(1, _class38_ng_template_12_1_Template, 1, 3, null, 13);\n    i0.ɵɵtemplate(2, _class38_ng_template_12_kendo_treeview_2_Template, 2, 17, \"kendo-treeview\", 21);\n    i0.ɵɵtemplate(3, _class38_ng_template_12_3_Template, 1, 3, null, 13);\n    i0.ɵɵtemplate(4, _class38_ng_template_12_div_4_Template, 3, 5, \"div\", 22);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.filterable && !ctx_r7.isActionSheetExpanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.data.length !== 0 && !ctx_r7.allNodesHidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.footerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.data.length === 0 || ctx_r7.allNodesHidden);\n  }\n}\nfunction _class38_kendo_resize_sensor_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r40 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 33);\n    i0.ɵɵlistener(\"resize\", function _class38_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r39 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r39.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c76 = [\"checkAllInput\"];\nfunction _class43_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.placeholder, \" \");\n  }\n}\nfunction _class43_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵlistener(\"click\", function _class43_span_4_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.clearAll($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.xIcon);\n  }\n}\nfunction _class43_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 14);\n  }\n}\nfunction _class43_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class43_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class43_ng_template_6_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(12);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\nfunction _class43_ng_template_11_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 22)(1, \"span\", 23)(2, \"span\", 24);\n    i0.ɵɵelement(3, \"kendo-icon-wrapper\", 25);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"input\", 26, 27);\n    i0.ɵɵlistener(\"input\", function _class43_ng_template_11_div_0_Template_input_input_4_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r19.handleFilterInputChange($event.target));\n    })(\"keydown\", function _class43_ng_template_11_div_0_Template_input_keydown_4_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const _r18 = i0.ɵɵreference(5);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.handleKeydown($event, _r18));\n    });\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r12.filterInputClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r12.searchIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"filterInput\", ctx_r12.filterable && !ctx_r12.touchEnabled)(\"value\", ctx_r12.filter)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(7, _c75, ctx_r12.handleBlur))(\"scope\", ctx_r12);\n    i0.ɵɵattribute(\"aria-label\", ctx_r12.messageFor(\"filterInputLabel\"));\n  }\n}\nfunction _class43_ng_template_11_1_ng_template_0_Template(rf, ctx) {}\nfunction _class43_ng_template_11_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class43_ng_template_11_1_ng_template_0_Template, 0, 0, \"ng-template\", 28);\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r13.headerTemplate == null ? null : ctx_r13.headerTemplate.templateRef));\n  }\n}\nfunction _class43_ng_template_11_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 29)(1, \"span\", 30)(2, \"input\", 31, 32);\n    i0.ɵɵlistener(\"checkedItemsChange\", function _class43_ng_template_11_div_2_Template_input_checkedItemsChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r24.handleCheckedItemsChange($event));\n    })(\"keydown\", function _class43_ng_template_11_div_2_Template_input_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r26.handleKeydown($event));\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(4, \"span\", 33);\n    i0.ɵɵlistener(\"click\", function _class43_ng_template_11_div_2_Template_span_click_4_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r27.toggleCheckAll());\n    })(\"mousedown\", function _class43_ng_template_11_div_2_Template_span_mousedown_4_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r15 = i0.ɵɵreference(4);\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"checkAll\", !ctx_r14.filterable && !ctx_r14.touchEnabled)(\"ngClass\", ctx_r14.checkAllCheckboxClasses)(\"treeview\", _r15)(\"checkedItems\", ctx_r14.checkedItems)(\"valueField\", ctx_r14.valueField)(\"lastAction\", ctx_r14.lastAction)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(9, _c75, ctx_r14.handleBlur))(\"scope\", ctx_r14);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r14.messageFor(\"checkAllText\"), \" \");\n  }\n}\nfunction _class43_ng_template_11_5_ng_template_0_Template(rf, ctx) {}\nfunction _class43_ng_template_11_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class43_ng_template_11_5_ng_template_0_Template, 0, 0, \"ng-template\", 28);\n  }\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c18, ctx_r16.footerTemplate == null ? null : ctx_r16.footerTemplate.templateRef));\n  }\n}\nfunction _class43_ng_template_11_div_6_ng_template_1_Template(rf, ctx) {}\nfunction _class43_ng_template_11_div_6_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r31.messageFor(\"noDataText\"));\n  }\n}\nfunction _class43_ng_template_11_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 34);\n    i0.ɵɵtemplate(1, _class43_ng_template_11_div_6_ng_template_1_Template, 0, 0, \"ng-template\", 35);\n    i0.ɵɵtemplate(2, _class43_ng_template_11_div_6_ng_template_2_Template, 2, 1, \"ng-template\", 36);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r17.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c18, ctx_r17.noDataTemplate == null ? null : ctx_r17.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r17.noDataTemplate);\n  }\n}\nconst _c91 = function (a0) {\n  return {\n    focusout: a0\n  };\n};\nfunction _class43_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵtemplate(0, _class43_ng_template_11_div_0_Template, 6, 9, \"div\", 16);\n    i0.ɵɵtemplate(1, _class43_ng_template_11_1_Template, 1, 3, null, 17);\n    i0.ɵɵtemplate(2, _class43_ng_template_11_div_2_Template, 6, 11, \"div\", 18);\n    i0.ɵɵelementStart(3, \"kendo-treeview\", 19, 20);\n    i0.ɵɵlistener(\"keydown\", function _class43_ng_template_11_Template_kendo_treeview_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r32.handleKeydown($event));\n    })(\"nodeClick\", function _class43_ng_template_11_Template_kendo_treeview_nodeClick_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r34.handleNodeClick($event));\n    })(\"expand\", function _class43_ng_template_11_Template_kendo_treeview_expand_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r35 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r35.nodeExpand.emit($event));\n    })(\"collapse\", function _class43_ng_template_11_Template_kendo_treeview_collapse_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r36 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r36.nodeCollapse.emit($event));\n    })(\"checkedItemsChange\", function _class43_ng_template_11_Template_kendo_treeview_checkedItemsChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r37 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r37.handleCheckedItemsChange($event));\n    })(\"childrenLoaded\", function _class43_ng_template_11_Template_kendo_treeview_childrenLoaded_3_listener() {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r38 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r38.onChildrenLoaded());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, _class43_ng_template_11_5_Template, 1, 3, null, 17);\n    i0.ɵɵtemplate(6, _class43_ng_template_11_div_6_Template, 3, 5, \"div\", 21);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.filterable && !ctx_r7.isActionSheetExpanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.checkAll);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r7.listHeight, \"px\");\n    i0.ɵɵproperty(\"size\", ctx_r7.size)(\"nodes\", ctx_r7.data)(\"animate\", false)(\"isHeterogeneous\", ctx_r7.isHeterogeneous)(\"checkable\", ctx_r7.checkableSettings)(\"checkedItems\", ctx_r7.checkedItems)(\"valueField\", ctx_r7.valueField)(\"textField\", ctx_r7.textField)(\"children\", ctx_r7.children)(\"hasChildren\", ctx_r7.hasChildren)(\"isExpanded\", ctx_r7.isNodeExpanded)(\"isDisabled\", ctx_r7.itemDisabled)(\"nodeTemplate\", ctx_r7.nodeTemplate)(\"loadOnDemand\", ctx_r7.loadOnDemand)(\"filter\", ctx_r7.filter)(\"isVisible\", ctx_r7.isNodeVisible)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(26, _c91, ctx_r7.handleBlur))(\"scope\", ctx_r7);\n    i0.ɵɵattribute(\"id\", ctx_r7.treeViewId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.footerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.data || (ctx_r7.data == null ? null : ctx_r7.data.length) === 0 || ctx_r7.allNodesHidden);\n  }\n}\nfunction _class43_kendo_resize_sensor_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r40 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 37);\n    i0.ɵɵlistener(\"resize\", function _class43_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r39 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r39.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dropdowns',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163700,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/* eslint-disable no-bitwise */\n/**\n * @hidden\n */\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isNumber = value => !isNaN(value);\n/**\n * @hidden\n */\nconst guid = () => {\n  let id = \"\";\n  let i;\n  let random;\n  for (i = 0; i < 32; i++) {\n    random = Math.random() * 16 | 0;\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      id += \"-\";\n    }\n    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n  return id;\n};\n/**\n * @hidden\n */\nconst combineStr = (begin, end) => {\n  return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => typeof window !== 'undefined';\n/**\n * @hidden\n */\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\nconst isObject = value => isPresent(value) && typeof value === 'object';\n/**\n * @hidden\n */\nconst isEmptyString = value => typeof value === 'string' && value.length === 0;\n/**\n * @hidden\n */\nconst resolveValuesInArray = (values, data = [], valueField) => values.map(value => {\n  return data.find(item => getter(item, valueField) === value);\n}).filter(value => value !== undefined);\n/**\n * @hidden\n */\nconst validateComplexValues = (values, valueField) => isArray(values) && values.filter(item => {\n  return isObject(item) && getter(item, valueField) !== undefined;\n});\n/**\n * @hidden\n */\nconst resolveAllValues = (value, data, valueField) => {\n  const customValues = validateComplexValues(value, valueField) || [];\n  const resolvedValues = resolveValuesInArray(value, data, valueField) || [];\n  return resolvedValues.concat(customValues);\n};\n/**\n * @hidden\n */\nconst isObjectArray = values => {\n  return isArray(values) && values.every(item => isObject(item));\n};\n/**\n * @hidden\n */\nconst selectedIndices = (values, data, valueField) => {\n  const extractedValues = data.map(item => {\n    return isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;\n  });\n  return values.reduce((arr, item) => {\n    const value = isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;\n    const index = extractedValues.indexOf(value);\n    if (index !== -1) {\n      arr.push(index);\n    }\n    return arr;\n  }, []);\n};\n/**\n * @hidden\n */\nconst getter = (dataItem, field) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n  if (!isPresent(field) || !isObject(dataItem)) {\n    return dataItem;\n  }\n  // creates a field accessor supporting nested fields processing\n  const valueFrom = getter$1(field);\n  return valueFrom(dataItem);\n};\n/**\n * @hidden\n */\nconst resolveValue = args => {\n  let dataItem;\n  if (isPresent(args.value)) {\n    const data = [args.defaultItem, ...args.data];\n    dataItem = data.find(element => getter(element, args.valueField) === args.value);\n    return {\n      dataItem: dataItem,\n      focused: args.data.indexOf(dataItem),\n      selected: args.data.indexOf(dataItem)\n    };\n  } else if (args.index) {\n    dataItem = args.data[args.index];\n    return {\n      dataItem: args.data[args.index],\n      focused: args.index,\n      selected: args.index\n    };\n  }\n  return {\n    dataItem: args.defaultItem,\n    focused: -1,\n    selected: -1\n  };\n};\n/**\n * @hidden\n */\nconst sameCharsOnly = (word, character) => {\n  for (let idx = 0; idx < word.length; idx++) {\n    if (word.charAt(idx) !== character) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @hidden\n */\nconst shuffleData = (data, splitIndex, defaultItem) => {\n  let result = data;\n  if (defaultItem) {\n    result = [defaultItem].concat(result);\n  }\n  return result.slice(splitIndex).concat(result.slice(0, splitIndex));\n};\n/**\n * @hidden\n */\nconst matchText = (text, word, ignoreCase) => {\n  if (!isPresent(text)) {\n    return false;\n  }\n  let temp = String(text);\n  if (ignoreCase) {\n    temp = temp.toLowerCase();\n  }\n  return temp.indexOf(word) === 0;\n};\n/**\n * @hidden\n */\nconst elementFromPoint = (x, y) => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n  return document.elementFromPoint(x, y);\n};\n/**\n * @hidden\n *\n * Checks whether the passed object has all of the listed properties.\n */\nconst hasProps = (obj, props) => {\n  if (!isPresent(obj)) {\n    return false;\n  }\n  return props.every(prop => obj.hasOwnProperty(prop));\n};\n/**\n * @hidden\n *\n * Checks whether an element is untouched by looking for the ng-untouched css class\n */\nconst isUntouched = element => element.className.includes('ng-untouched');\n/**\n * @hidden\n */\nconst noop = _ => {};\n/**\n * IE element `matches` polyfill.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\n */\nconst matches = (element, selector) => {\n  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;\n  if (!matcher) {\n    return false;\n  }\n  return matcher.call(element, selector);\n};\n/**\n * @hidden\n *\n * IE element `closest` polyfill.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n */\nconst closest = (element, selector) => {\n  let parent = element;\n  while (parent !== null && parent.nodeType === 1) {\n    if (matches(parent, selector)) {\n      return parent;\n    }\n    parent = parent.parentElement || parent.parentNode;\n  }\n  return null;\n};\n/**\n * @hidden\n *\n * Parses a provided value to its type 'number' representation.\n * If the parsed value (via Number(value)) is NaN, the provided default value is returned.\n * Uses 0 as default value if a second param is not provided.\n */\nconst parseNumber = (num, defaultValue = 0) => {\n  const normalizedValue = Number(num);\n  return isNaN(normalizedValue) ? defaultValue : normalizedValue;\n};\n/**\n * @hidden\n *\n * Checks whether the passed target element is inside the provided host or popupRef.\n */\nconst inDropDown = (host, target, popupRef) => {\n  return host.nativeElement.contains(target) || popupRef && popupRef.popupElement.contains(target);\n};\n/**\n * @hidden\n *\n * Calculates the hierarchical level of an item, based on the provided index.\n * The result level is zero-based (starts from 0).\n */\nconst getHierarchicalItemLevel = index => {\n  return (index || '').split('_').length - 1;\n};\n/**\n * @hidden\n *\n * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.\n */\nconst fetchDescendentNodes = (lookup, filterExpression) => {\n  if (!isPresent(lookup) || lookup.children.length === 0) {\n    return [];\n  }\n  let descendants = lookup.children;\n  if (isPresent(filterExpression)) {\n    descendants = descendants.filter(descendent => filterExpression(descendent.item));\n  }\n  descendants.forEach(child => descendants = descendants.concat(fetchDescendentNodes(child, filterExpression)));\n  return descendants;\n};\n/**\n * @hidden\n *\n * Retrieves the correct value based on the item's level and the provided value field/s.\n * Used in the MultiSelectTree component.\n */\nconst valueFrom = ({\n  dataItem,\n  index,\n  level\n}, valueField) => {\n  const fields = Array.isArray(valueField) ? valueField : [valueField];\n  // either use the explicitly provided value level, or infer it from the item index\n  const valueLevel = isPresent(level) ? level : getHierarchicalItemLevel(index);\n  // fall-back to the last available one, if the current node is in a deeper level\n  const normalizedLevel = Math.min(valueLevel, fields.length - 1);\n  const field = fields[normalizedLevel];\n  return getter$1(field)(dataItem);\n};\n/**\n * @hidden\n * Returns the size class based on the component and size input.\n */\nconst getSizeClass = (component, size) => {\n  const SIZE_CLASSES = {\n    'small': `k-${component}-sm`,\n    'medium': `k-${component}-md`,\n    'large': `k-${component}-lg`\n  };\n  return SIZE_CLASSES[size];\n};\n/**\n * @hidden\n * Returns the rounded class based on the rounded input.\n */\nconst getRoundedClass = rounded => {\n  const ROUNDED_CLASSES = {\n    'small': 'k-rounded-sm',\n    'medium': 'k-rounded-md',\n    'large': 'k-rounded-lg',\n    'full': 'k-rounded-full'\n  };\n  return ROUNDED_CLASSES[rounded];\n};\n/**\n * @hidden\n * Return the fillMode class based on the component and fillMode input.\n */\nconst getFillModeClass = (component, fillMode) => {\n  const FILLMODE_CLASSES = {\n    'solid': `k-${component}-solid`,\n    'flat': `k-${component}-flat`,\n    'outline': `k-${component}-outline`\n  };\n  return FILLMODE_CLASSES[fillMode];\n};\n/**\n * @hidden\n */\nconst filterAndMap = (arr, predicate, mapper) => arr.reduce((acc, curr) => predicate(curr) ? [...acc, mapper(curr)] : acc, []);\n/**\n * @hidden\n *\n * Checks if input is Japanese IME\n */\nconst isJapanese = input => {\n  const japaneseRegex = /[\\u3000-\\u303F]|[\\u3040-\\u309F]|[\\u30A0-\\u30FF]|[\\uFF00-\\uFFEF]|[\\u4E00-\\u9FAF]|[\\u2605-\\u2606]|[\\u2190-\\u2195]|\\u203B/g;\n  return japaneseRegex.test(input);\n};\n/**\n * @hidden\n */\nconst isLetter = text => {\n  const isLetter = /[a-zA-Z]/;\n  return isLetter.test(text) && text?.length === 1;\n};\n/**\n * @hidden\n */\nconst getTextField = (field, level) => {\n  if (isArray(field)) {\n    return field[level];\n  }\n  return field;\n};\n/**\n * @hidden\n */\nconst getSearchableItems = (treeViewId, element) => {\n  const nodeSeletor = `kendo-treeview[id='${treeViewId}'] li.k-treeview-item`;\n  const liElements = Array.from(element.querySelectorAll(nodeSeletor));\n  return liElements.map(liElement => {\n    return {\n      text: liElement.innerText,\n      index: liElement.getAttribute('data-treeindex')\n    };\n  });\n};\n/**\n * @hidden\n */\nconst isTruthy = value => !!value;\n/**\n * @hidden\n */\nconst updateActionSheetAdaptiveAppearance = (actionSheet, windowSize, renderer) => {\n  const element = actionSheet['element'].nativeElement.querySelector('.k-actionsheet');\n  const animationContainer = actionSheet['element'].nativeElement.querySelector('.k-child-animation-container');\n  if (windowSize === 'medium') {\n    renderer.removeClass(element, 'k-actionsheet-fullscreen');\n    renderer.addClass(element, 'k-actionsheet-bottom');\n    renderer.addClass(element, 'k-adaptive-actionsheet');\n    renderer.removeStyle(animationContainer, 'top');\n    renderer.removeStyle(animationContainer, 'height');\n    renderer.setStyle(animationContainer, 'bottom', '0px');\n  } else if (windowSize === 'small') {\n    renderer.removeClass(element, 'k-actionsheet-bottom');\n    renderer.addClass(element, 'k-actionsheet-fullscreen');\n    renderer.addClass(element, 'k-adaptive-actionsheet');\n    renderer.setStyle(animationContainer, 'bottom', '0px');\n    renderer.setStyle(animationContainer, 'height', '100%');\n  }\n};\n/**\n * @hidden\n */\nconst setListBoxAriaLabelledBy = (optionsList, element, renderer) => {\n  const listBox = optionsList.wrapper.nativeElement.querySelector('kendo-list ul');\n  const ariaLabel = element.nativeElement.getAttribute('aria-labelledby') || element.nativeElement.getAttribute('data-kendo-label-id');\n  if (ariaLabel) {\n    renderer.setAttribute(listBox, 'aria-labelledby', ariaLabel);\n  }\n};\n/**\n * @hidden\n */\nconst setActionSheetTitle = (element, actionSheetTitle) => {\n  const ariaLabel = element.nativeElement.getAttribute('aria-labelledby') || element.nativeElement.getAttribute('data-kendo-label-id');\n  if (!actionSheetTitle && ariaLabel) {\n    return document.getElementById(ariaLabel).innerText;\n  }\n  return actionSheetTitle;\n};\n/**\n * @hidden\n */\nconst animationDuration = 300;\n\n/**\n * @hidden\n */\nlet SearchBarComponent = /*#__PURE__*/(() => {\n  var _class;\n  class SearchBarComponent {\n    set readonly(readonly) {\n      this._readonly = readonly;\n      if (this._readonly) {\n        this.renderer.setAttribute(this.input.nativeElement, 'readonly', '');\n      } else {\n        this.renderer.removeAttribute(this.input.nativeElement, 'readonly');\n      }\n    }\n    get readonly() {\n      return this._readonly;\n    }\n    set disabled(disabled) {\n      this._disabled = disabled;\n      if (this._disabled) {\n        this.renderer.setAttribute(this.input.nativeElement, 'disabled', '');\n      } else {\n        this.renderer.removeAttribute(this.input.nativeElement, 'disabled');\n      }\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    set isRequired(isRequired) {\n      this._isRequired = isRequired;\n      if (this._isRequired) {\n        this.renderer.setAttribute(this.input.nativeElement, 'required', '');\n      } else {\n        this.renderer.removeAttribute(this.input.nativeElement, 'required');\n      }\n    }\n    get isRequired() {\n      return this._isRequired;\n    }\n    set isSuggestable(isSuggestable) {\n      this._isSuggestable = isSuggestable;\n      this.setAriaAutocomplete();\n    }\n    get isSuggestable() {\n      return this._isSuggestable;\n    }\n    set isFilterable(isFilterable) {\n      this._isFilterable = isFilterable;\n      this.setAriaAutocomplete();\n    }\n    get isFilterable() {\n      return this._isFilterable;\n    }\n    get userInput() {\n      return this._userInput;\n    }\n    set userInput(userInput) {\n      this._userInput = userInput || \"\";\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * @hidden\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    get attrAriaInvalid() {\n      return this.formControl?.invalid;\n    }\n    set placeholder(text) {\n      this._placeholder = text || '';\n      this.setInputSize();\n    }\n    get placeholder() {\n      return this._placeholder;\n    }\n    get dir() {\n      return this.direction;\n    }\n    get value() {\n      return this.input.nativeElement.value;\n    }\n    get defaultAttributes() {\n      return {\n        id: this.id,\n        disabled: this.disabled ? '' : null,\n        readonly: this.readonly ? '' : null,\n        placeholder: this.placeholder,\n        tabIndex: this.tabIndex,\n        tabindex: this.tabIndex,\n        dir: this.direction,\n        required: this.isRequired ? '' : null,\n        'aria-haspopup': 'listbox',\n        'aria-expanded': this.ariaExpanded,\n        'aria-controls': this.ariaControls,\n        'aria-activedescendant': this.activeDescendant,\n        'aria-busy': this.isLoading,\n        'aria-invalid': this.formControl?.invalid\n      };\n    }\n    get mutableAttributes() {\n      return {\n        autocomplete: 'off',\n        role: this.role,\n        'aria-describedby': this.tagListId\n      };\n    }\n    constructor(localization, renderer, injector, input, ngZone) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"input\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"tagListId\", void 0);\n      _defineProperty(this, \"suggestedText\", void 0);\n      _defineProperty(this, \"id\", void 0);\n      _defineProperty(this, \"activeDescendant\", void 0);\n      _defineProperty(this, \"tabIndex\", void 0);\n      _defineProperty(this, \"isLoading\", void 0);\n      _defineProperty(this, \"ariaControls\", void 0);\n      _defineProperty(this, \"ariaExpanded\", null);\n      _defineProperty(this, \"role\", 'combobox');\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      _defineProperty(this, \"onClick\", new EventEmitter());\n      _defineProperty(this, \"onNavigate\", new EventEmitter());\n      _defineProperty(this, \"_isRequired\", void 0);\n      _defineProperty(this, \"_readonly\", void 0);\n      _defineProperty(this, \"_disabled\", void 0);\n      _defineProperty(this, \"_userInput\", \"\");\n      _defineProperty(this, \"_previousValue\", \"\");\n      _defineProperty(this, \"_placeholder\", \"\");\n      _defineProperty(this, \"_isSuggestable\", false);\n      _defineProperty(this, \"_isFilterable\", false);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      this.localization = localization;\n      this.injector = injector;\n      this.input = input;\n      this.ngZone = ngZone;\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.renderer = renderer;\n      this.renderer.addClass(this.input.nativeElement, 'k-input-inner');\n      this.renderer.setAttribute(this.input.nativeElement, 'aria-haspopup', 'listbox');\n      this.renderer.setAttribute(this.input.nativeElement, 'autocomplete', 'off');\n    }\n    ngOnInit() {\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n    }\n    ngOnChanges(changes) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      let previousUserInput;\n      if (this.input && (changes.userInput || changes.suggestedText)) {\n        if (changes.userInput && changes.userInput.previousValue) {\n          if (this._previousValue === changes.userInput.previousValue) {\n            previousUserInput = this._previousValue;\n          } else {\n            previousUserInput = changes.userInput.currentValue || \"\";\n          }\n        } else {\n          previousUserInput = this._previousValue;\n        }\n        const caretStart = this.input.nativeElement.selectionStart;\n        const caretAtEnd = previousUserInput.length === caretStart;\n        this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);\n        if (this.suggestedText) {\n          this.setInputSelection(this.userInput.length, this.suggestedText.length);\n        } else if (isSafari(navigator.userAgent) && !caretAtEnd) {\n          this.setInputSelection(caretStart, this.userInput.length);\n        } else if (caretAtEnd) {\n          this.setInputSelection(this.userInput.length, this.userInput.length);\n        } else {\n          this.setInputSelection(caretStart, caretStart);\n        }\n        this._previousValue = this.userInput;\n      }\n    }\n    ngAfterViewInit() {\n      this.subs.add(this.input.nativeElement.addEventListener('input', event => this.handleInput(event)));\n      this.subs.add(this.input.nativeElement.addEventListener('focus', event => this.handleFocus(event)));\n      this.subs.add(this.input.nativeElement.addEventListener('blur', event => this.handleBlur(event)));\n      this.subs.add(this.input.nativeElement.addEventListener('keydown', event => this.handleKeydown(event)));\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    writeInputValue(text) {\n      if (isDocumentAvailable()) {\n        this.renderer.setProperty(this.input.nativeElement, 'value', text);\n      }\n    }\n    setInputSelection(start, end) {\n      if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {\n        try {\n          this.input.nativeElement.setSelectionRange(start, end);\n        } catch (e) {\n          //Make sure that the element is in the DOM before you invoke its methods\n        }\n      }\n    }\n    setAriaAutocomplete() {\n      if (this.isFilterable) {\n        this.renderer.setAttribute(this.input.nativeElement, 'aria-autocomplete', 'list');\n      }\n      if (this.isSuggestable) {\n        this.renderer.setAttribute(this.input.nativeElement, 'aria-autocomplete', 'inline');\n      }\n      if (this.isFilterable && this.isSuggestable) {\n        this.renderer.setAttribute(this.input.nativeElement, 'aria-autocomplete', 'both');\n      }\n      if (!this.isFilterable && !this.isSuggestable) {\n        this.renderer.removeAttribute(this.input.nativeElement, 'aria-autocomplete');\n      }\n    }\n    handleInput(event) {\n      const target = event.target;\n      const isBrowserSafari = isSafari(navigator.userAgent);\n      const value = isBrowserSafari && isJapanese(target.value) ? event.data : target.value;\n      if (value !== this.userInput) {\n        this._previousValue = value;\n        this.valueChange.emit(value);\n      }\n    }\n    handleFocus(event) {\n      this.onFocus.emit(event);\n    }\n    handleBlur(event) {\n      this.onBlur.emit(event);\n    }\n    handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const keys = [Keys.ArrowUp, Keys.ArrowDown, Keys.ArrowLeft, Keys.ArrowRight, Keys.Enter, Keys.Escape, Keys.Delete, Keys.Backspace, Keys.Home, Keys.End, Keys.PageDown, Keys.PageUp];\n      if (keys.indexOf(keyCode) > -1) {\n        this.onNavigate.emit(event);\n      }\n    }\n    focus() {\n      if (isDocumentAvailable()) {\n        this.input.nativeElement.focus();\n      }\n    }\n    blur() {\n      if (isDocumentAvailable()) {\n        this.input.nativeElement.blur();\n      }\n    }\n    setInputSize() {\n      const lengthOf = x => x ? x.length : 0;\n      const input = this.input.nativeElement;\n      const placeholderLength = lengthOf(this.placeholder);\n      const textLength = lengthOf(this.value);\n      const size = Math.max(placeholderLength, textLength, 1);\n      this.renderer.setAttribute(input, 'size', size.toString());\n    }\n    setInputAttributes() {\n      const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);\n      setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);\n    }\n  }\n  _class = SearchBarComponent;\n  _defineProperty(SearchBarComponent, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(SearchBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"input\", \"kendoSearchbar\", \"\"]],\n    hostVars: 10,\n    hostBindings: function _class_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-activedescendant\", ctx.activeDescendant)(\"tabindex\", ctx.tabIndex)(\"aria-busy\", ctx.isLoading)(\"aria-controls\", ctx.ariaControls)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-invalid\", ctx.attrAriaInvalid)(\"placeholder\", ctx.placeholder)(\"role\", ctx.role)(\"dir\", ctx.dir);\n      }\n    },\n    inputs: {\n      tagListId: \"tagListId\",\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      isRequired: \"isRequired\",\n      isSuggestable: \"isSuggestable\",\n      isFilterable: \"isFilterable\",\n      userInput: \"userInput\",\n      suggestedText: \"suggestedText\",\n      inputAttributes: \"inputAttributes\",\n      id: \"id\",\n      activeDescendant: \"activeDescendant\",\n      tabIndex: \"tabIndex\",\n      isLoading: \"isLoading\",\n      ariaControls: \"ariaControls\",\n      ariaExpanded: \"ariaExpanded\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onBlur: \"onBlur\",\n      onFocus: \"onFocus\",\n      onClick: \"onClick\",\n      onNavigate: \"onNavigate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c0,\n    decls: 0,\n    vars: 0,\n    template: function _class_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SearchBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the list item content. To define the item template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>ItemTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * - [Using `ItemTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-item-template)\n * - [Using `ItemTemplate` with the ComboBox]({% slug templates_combobox %}#toc-item-template)\n * - [Using `ItemTemplate` with the DropDownList]({% slug templates_ddl %}#toc-item-template)\n * - [Using `ItemTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-item-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet ItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class2;\n  class ItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class2 = ItemTemplateDirective;\n  _defineProperty(ItemTemplateDirective, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(ItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class2,\n    selectors: [[\"\", \"kendoDropDownListItemTemplate\", \"\"], [\"\", \"kendoComboBoxItemTemplate\", \"\"], [\"\", \"kendoAutoCompleteItemTemplate\", \"\"], [\"\", \"kendoMultiSelectItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the header content of the list. To define the header template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>HeaderTemplate` directive inside the component tag.\n *\n * - [Using `HeaderTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-header-template)\n * - [Using `HeaderTemplate` with the ComboBox]({% slug templates_combobox %}#toc-header-template)\n * - [Using `HeaderTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-header-template)\n * - [Using `HeaderTemplate` with the DropDownList]({% slug templates_ddl %}#toc-header-template)\n * - [Using `HeaderTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-header-template)\n * - [Using `HeaderTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-header-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxHeaderTemplate>\n *      <h4>Header template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet HeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class HeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class3 = HeaderTemplateDirective;\n  _defineProperty(HeaderTemplateDirective, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(HeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"\", \"kendoDropDownListHeaderTemplate\", \"\"], [\"\", \"kendoComboBoxHeaderTemplate\", \"\"], [\"\", \"kendoDropDownTreeHeaderTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxHeaderTemplate\", \"\"], [\"\", \"kendoAutoCompleteHeaderTemplate\", \"\"], [\"\", \"kendoMultiSelectHeaderTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return HeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the footer content of the list. To define the footer template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FooterTemplate` directive inside the component tag.\n *\n * - [Using `FooterTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-footer-template)\n * - [Using `FooterTemplate` with the ComboBox]({% slug templates_combobox %}#toc-footer-template)\n * - [Using `FooterTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-footer-template)\n * - [Using `FooterTemplate` with the DropDownList]({% slug templates_ddl %}#toc-footer-template)\n * - [Using `FooterTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-footer-template)\n * - [Using `FooterTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-footer-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxFooterTemplate>\n *      <h4>Footer template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet FooterTemplateDirective = /*#__PURE__*/(() => {\n  var _class4;\n  class FooterTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class4 = FooterTemplateDirective;\n  _defineProperty(FooterTemplateDirective, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(FooterTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class4,\n    selectors: [[\"\", \"kendoDropDownListFooterTemplate\", \"\"], [\"\", \"kendoComboBoxFooterTemplate\", \"\"], [\"\", \"kendoDropDownTreeFooterTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxFooterTemplate\", \"\"], [\"\", \"kendoAutoCompleteFooterTemplate\", \"\"], [\"\", \"kendoMultiSelectFooterTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeFooterTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FooterTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the group header content. To define the group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>GroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `GroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-group-header-template)\n * - [Using `GroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-group-header-template)\n * - [Using `GroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-group-header-template)\n * - [Using `GroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-group-header-template)\n * - [Using `GroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-group-header-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" textField=\"name\" valueField=\"name\">\n *    <ng-template kendoComboBoxGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\nlet GroupTemplateDirective = /*#__PURE__*/(() => {\n  var _class5;\n  class GroupTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class5 = GroupTemplateDirective;\n  _defineProperty(GroupTemplateDirective, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(GroupTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class5,\n    selectors: [[\"\", \"kendoDropDownListGroupTemplate\", \"\"], [\"\", \"kendoComboBoxGroupTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxGroupTemplate\", \"\"], [\"\", \"kendoAutoCompleteGroupTemplate\", \"\"], [\"\", \"kendoMultiSelectGroupTemplate\", \"\"]],\n    standalone: true\n  }));\n  return GroupTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the fixed group header content. To define the fixed group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FixedGroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `FixedGroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-fixed-group-header-template)\n * - [Using `FixedGroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-fixed-group-header-template)\n * - [Using `FixedGroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-fixed-group-header-template)\n * - [Using `FixedGroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-fixed-group-header-template)\n * - [Using `FixedGroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-fixed-group-header-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" textField=\"name\" valueField=\"name\">\n *    <ng-template kendoComboBoxFixedGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\nlet FixedGroupTemplateDirective = /*#__PURE__*/(() => {\n  var _class6;\n  class FixedGroupTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class6 = FixedGroupTemplateDirective;\n  _defineProperty(FixedGroupTemplateDirective, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(FixedGroupTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class6,\n    selectors: [[\"\", \"kendoDropDownListFixedGroupTemplate\", \"\"], [\"\", \"kendoComboBoxFixedGroupTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxFixedGroupTemplate\", \"\"], [\"\", \"kendoAutoCompleteFixedGroupTemplate\", \"\"], [\"\", \"kendoMultiSelectFixedGroupTemplate\", \"\"]],\n    standalone: true\n  }));\n  return FixedGroupTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DataService = /*#__PURE__*/(() => {\n  var _class7;\n  class DataService {\n    constructor() {\n      _defineProperty(this, \"grouped\", false);\n      _defineProperty(this, \"groupIndices\", []);\n      _defineProperty(this, \"view\", void 0);\n      _defineProperty(this, \"_data\", void 0);\n      _defineProperty(this, \"_flatData\", void 0);\n    }\n    set data(data) {\n      this._data = data;\n      this.grouped = this.isGrouped(data);\n      if (this.grouped) {\n        this.groupIndices = this.getGroupIndices(data);\n        this._flatData = this.flatten(data);\n      }\n    }\n    get data() {\n      if (this.grouped) {\n        return this._flatData;\n      }\n      return this._data;\n    }\n    /**\n     * @hidden\n     * Used to get the actual items count, i.e. excluding the header items in case of grouping.\n     */\n    get itemsCount() {\n      if (!isPresent(this.data) || this.data.length === 0) {\n        return 0;\n      }\n      const items = this.grouped ? this._flatData.filter(item => !item.header) : this.data;\n      return items.length;\n    }\n    /**\n     * @hidden\n     * Used to determine if the component received grouped data.\n     */\n    isGrouped(data) {\n      // GroupResult { aggregates: AggregateResult, field: string, items: object[], value: any }\n      // https://www.telerik.com/kendo-angular-ui/components/dataquery/api/GroupResult/\n      return isPresent(data) && data.length !== 0 && isPresent(data[0]) && hasProps(data[0], ['aggregates', 'field', 'items', 'value']);\n    }\n    /**\n     * @hidden\n     * Used to calculate the last item index of each group.\n     */\n    getGroupIndices(data) {\n      const groupIndices = [];\n      for (let i = 0; i <= data.length - 1; i++) {\n        groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;\n      }\n      return groupIndices;\n    }\n    /**\n     * @hidden\n     * Used to get a flat array containing all items matching certain criteria.\n     */\n    filter(predicate) {\n      let result = [];\n      if (this.isGrouped(this.data)) {\n        for (let i = 0; i <= this.groupIndices.length - 1; i++) {\n          const matches = this.data[i].items.filter(predicate);\n          if (matches) {\n            result = result.concat(matches);\n          }\n        }\n      } else {\n        result = this.data.filter(predicate);\n      }\n      return result;\n    }\n    /**\n     * @hidden\n     * Used to get the index of a given data item.\n     */\n    indexOf(item, startFrom = 0) {\n      let predicate = element => {\n        return element === item;\n      };\n      if (this.grouped) {\n        predicate = element => {\n          return element.value === item;\n        };\n      }\n      return this.findIndex(predicate, startFrom);\n    }\n    /**\n     * @hidden\n     * Used to get the index of a data item based on an expression.\n     */\n    findIndex(predicate, startFrom = 0) {\n      let index = -1;\n      if (this.grouped) {\n        const data = this._flatData.filter(item => !item.header && item.offsetIndex >= startFrom);\n        index = data.findIndex(predicate);\n        index = data[index] ? data[index].offsetIndex : -1;\n      } else {\n        const data = this.data.slice(startFrom);\n        const itemIndex = data.findIndex(predicate);\n        index = itemIndex !== -1 ? itemIndex + startFrom : -1;\n      }\n      return index;\n    }\n    /**\n     * @hidden\n     * Used to get the closest group header prior to an item index.\n     */\n    closestGroup(index) {\n      for (let i = index; i >= 0; i--) {\n        if (this._flatData[i].header) {\n          return this._flatData[i];\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Used to get the first item matching the criteria.\n     */\n    find(predicate) {\n      const index = this.findIndex(predicate);\n      return this.itemAt(index);\n    }\n    /**\n     * @hidden\n     * Used to get the true index in a flattened data array.\n     */\n    flatIndex(index) {\n      if (this.itemsCount === 0) {\n        return -1;\n      }\n      if (this.grouped) {\n        const match = this._flatData.find(item => !item.header && item.offsetIndex === index);\n        if (match) {\n          return match.index;\n        }\n      } else {\n        return index;\n      }\n      return -1;\n    }\n    /**\n     * @hidden\n     * Used to get the item at the provided index.\n     */\n    itemAt(index) {\n      let dataItem;\n      if (this.itemsCount === 0) {\n        return dataItem;\n      }\n      if (this.grouped) {\n        const match = this._flatData.find(item => !item.header && item.offsetIndex === index);\n        if (match) {\n          dataItem = match.value;\n        }\n      } else {\n        dataItem = this.data[index];\n      }\n      return dataItem;\n    }\n    /**\n     * @hidden\n     * Used to get the group at the provided index.\n     */\n    groupAt(index) {\n      if (this.itemsCount === 0 || !this.isGrouped) {\n        return;\n      }\n      return this._flatData.find(item => item.header && item.index === index);\n    }\n    /**\n     * @hidden\n     * Used to get all group items indices.\n     */\n    groupItemsIndices() {\n      if (this.isGrouped) {\n        return filterAndMap(this.data, item => item.header, mappedItem => mappedItem.index);\n      }\n      return [];\n    }\n    /**\n     * @hidden\n     * Used to get the field by which the data is grouped.\n     */\n    groupField() {\n      if (this.itemsCount === 0 || !this.isGrouped) {\n        return null;\n      }\n      return this._data[0].field;\n    }\n    /**\n     * @hidden\n     * Used to get the group to which a dataItem belongs.\n     */\n    itemGroup(item) {\n      if (!item || this.itemsCount === 0 || !this.isGrouped) {\n        return;\n      }\n      const fieldName = this.groupField();\n      if (fieldName) {\n        return getter(item, fieldName);\n      }\n    }\n    flatten(data, group = undefined, offset = 0, groupIndex = 0) {\n      let flat = [];\n      if (isPresent(group)) {\n        flat.push({\n          header: true,\n          groupIndex: groupIndex,\n          index: groupIndex + offset,\n          offsetIndex: groupIndex,\n          value: group\n        });\n      }\n      for (let i = 0; i < data.length; i++) {\n        let result = [];\n        if (data[i].items) {\n          result = this.flatten(data[i].items, data[i].value, offset, i);\n          offset = offset + data[i].items.length;\n        } else {\n          result.push({\n            header: false,\n            groupIndex: groupIndex,\n            index: groupIndex + offset + i + 1,\n            offsetIndex: offset + i,\n            value: data[i]\n          });\n        }\n        flat = flat.concat(result);\n      }\n      return flat;\n    }\n  }\n  _class7 = DataService;\n  _defineProperty(DataService, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)();\n  });\n  _defineProperty(DataService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac\n  }));\n  return DataService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DisabledItemsService = /*#__PURE__*/(() => {\n  var _class8;\n  class DisabledItemsService {\n    constructor(dataService) {\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"defaultItem\", void 0);\n      _defineProperty(this, \"itemDisabled\", null);\n      this.dataService = dataService;\n    }\n    isIndexDisabled(index) {\n      if (this.itemDisabled) {\n        const item = this.dataService.itemAt(index);\n        if (isPresent(item)) {\n          return this.itemDisabled({\n            dataItem: item,\n            index\n          });\n        } else if (isPresent(this.defaultItem)) {\n          return this.itemDisabled({\n            dataItem: this.defaultItem,\n            index: -1\n          });\n        }\n      }\n    }\n    isItemDisabled(item) {\n      if (this.itemDisabled) {\n        const index = this.dataService.indexOf(item);\n        if (index !== -1) {\n          return this.itemDisabled({\n            dataItem: item,\n            index\n          });\n        } else if (isPresent(this.defaultItem)) {\n          return this.itemDisabled({\n            dataItem: this.defaultItem,\n            index: -1\n          });\n        }\n      }\n    }\n  }\n  _class8 = DisabledItemsService;\n  _defineProperty(DisabledItemsService, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵinject(DataService));\n  });\n  _defineProperty(DisabledItemsService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class8,\n    factory: _class8.ɵfac\n  }));\n  return DisabledItemsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SelectionService = /*#__PURE__*/(() => {\n  var _class9;\n  class SelectionService {\n    constructor(disabledItemsService) {\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"onSelect\", new EventEmitter());\n      _defineProperty(this, \"onChange\", new EventEmitter());\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      _defineProperty(this, \"total\", 0);\n      _defineProperty(this, \"lastClickedIndex\", void 0);\n      _defineProperty(this, \"selectedIndices\", []);\n      _defineProperty(this, \"focusedIndex\", void 0);\n      _defineProperty(this, \"indicesToBeRemoved\", []);\n      _defineProperty(this, \"indicesToBeAdded\", []);\n      this.disabledItemsService = disabledItemsService;\n    }\n    getTotal() {\n      return this.total;\n    }\n    isSelected(index) {\n      return isPresent(this.selectedIndices.find(current => current === index));\n    }\n    isFocused(index) {\n      return index === this.focused;\n    }\n    focus(index) {\n      if (this.isFocused(index)) {\n        return;\n      }\n      this.focused = index;\n      this.onFocus.emit(index);\n    }\n    select(index) {\n      if (this.isSelected(index)) {\n        return;\n      }\n      this.selectedIndices = [index];\n      this.focused = index;\n      this.onSelect.emit({\n        indices: [index],\n        newSelection: isPresent(index)\n      });\n    }\n    add(index, preventClosingPopup) {\n      if (this.isSelected(index)) {\n        return;\n      }\n      this.selectedIndices.push(index);\n      this.focused = index;\n      this.onChange.emit({\n        added: index,\n        indices: this.selectedIndices.slice(),\n        preventClosingPopup: preventClosingPopup\n      });\n    }\n    emitMultipleAddedRemoved() {\n      this.onChange.emit({\n        added: this.indicesToBeAdded,\n        removed: this.indicesToBeRemoved,\n        indices: this.selectedIndices.slice(),\n        preventClosingPopup: true,\n        isMultipleSelection: true\n      });\n      this.indicesToBeAdded = [];\n      this.indicesToBeRemoved = [];\n    }\n    addMultiple(indices) {\n      this.indicesToBeAdded = indices.slice();\n      this.selectedIndices.push(...indices);\n    }\n    deselect(index, preventClosingPopup) {\n      if (!this.isSelected(index)) {\n        return;\n      }\n      const position = this.selectedIndices.indexOf(index);\n      this.selectedIndices.splice(position, 1);\n      this.focused = index;\n      if (this.selected.length === 0) {\n        this.lastClickedIndex = null;\n      }\n      this.onChange.emit({\n        indices: this.selectedIndices.slice(),\n        removed: index,\n        preventClosingPopup: preventClosingPopup\n      });\n    }\n    unselectMultiple(indices) {\n      indices.forEach(index => {\n        const position = this.selectedIndices.indexOf(index);\n        this.selectedIndices.splice(position, 1);\n      });\n      this.indicesToBeRemoved = indices.slice();\n    }\n    change(index) {\n      const newSelection = isPresent(index) && !this.isSelected(index);\n      this.selectedIndices = [index];\n      this.focused = index;\n      this.onChange.emit({\n        indices: [index],\n        newSelection: newSelection\n      });\n    }\n    resetSelection(index) {\n      this.selectedIndices = index instanceof Array ? index : [index];\n      this.focused = this.selectedIndices[this.selectedIndices.length - 1];\n    }\n    get selected() {\n      return this.selectedIndices.slice();\n    }\n    get focused() {\n      return this.focusedIndex;\n    }\n    set focused(index) {\n      if (this.focusedIndex !== index) {\n        this.focusedIndex = index;\n        this.onFocus.emit(index);\n      }\n    }\n    selectFromTo(from, to) {\n      const addedIndices = [];\n      for (let i = from; i <= to; i++) {\n        if (!this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {\n          addedIndices.push(i);\n        }\n      }\n      this.addMultiple(addedIndices);\n    }\n    unselectFromTo(from, to) {\n      const indicesToBeUnselected = [];\n      for (let i = from; i >= to; i--) {\n        if (this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {\n          indicesToBeUnselected.push(i);\n        }\n      }\n      this.unselectMultiple(indicesToBeUnselected);\n    }\n    unselectNotNeededIndices(startOfSelection, endOfSelection, totalItems) {\n      const indicesToBeUnselected = [];\n      for (let i = 0; i < startOfSelection; i++) {\n        if (this.isSelected(i)) {\n          indicesToBeUnselected.push(i);\n        }\n      }\n      for (let i = endOfSelection + 1; i < totalItems; i++) {\n        if (this.isSelected(i)) {\n          indicesToBeUnselected.push(i);\n        }\n      }\n      this.unselectMultiple(indicesToBeUnselected);\n    }\n  }\n  _class9 = SelectionService;\n  _defineProperty(SelectionService, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵinject(DisabledItemsService));\n  });\n  _defineProperty(SelectionService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class9,\n    factory: _class9.ɵfac\n  }));\n  return SelectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nvar NavigationAction = /*#__PURE__*/function (NavigationAction) {\n  // eslint-disable-next-line id-denylist\n  NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n  NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n  NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n  NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n  NavigationAction[NavigationAction[\"Tab\"] = 4] = \"Tab\";\n  NavigationAction[NavigationAction[\"Esc\"] = 5] = \"Esc\";\n  NavigationAction[NavigationAction[\"Delete\"] = 6] = \"Delete\";\n  NavigationAction[NavigationAction[\"Backspace\"] = 7] = \"Backspace\";\n  NavigationAction[NavigationAction[\"Home\"] = 8] = \"Home\";\n  NavigationAction[NavigationAction[\"End\"] = 9] = \"End\";\n  NavigationAction[NavigationAction[\"Up\"] = 10] = \"Up\";\n  NavigationAction[NavigationAction[\"Down\"] = 11] = \"Down\";\n  NavigationAction[NavigationAction[\"Left\"] = 12] = \"Left\";\n  NavigationAction[NavigationAction[\"Right\"] = 13] = \"Right\";\n  NavigationAction[NavigationAction[\"PageDown\"] = 14] = \"PageDown\";\n  NavigationAction[NavigationAction[\"PageUp\"] = 15] = \"PageUp\";\n  NavigationAction[NavigationAction[\"SelectPrevious\"] = 16] = \"SelectPrevious\";\n  NavigationAction[NavigationAction[\"SelectNext\"] = 17] = \"SelectNext\";\n  NavigationAction[NavigationAction[\"SelectAll\"] = 18] = \"SelectAll\";\n  NavigationAction[NavigationAction[\"SelectAllToBeginning\"] = 19] = \"SelectAllToBeginning\";\n  NavigationAction[NavigationAction[\"SelectAllToEnd\"] = 20] = \"SelectAllToEnd\";\n  return NavigationAction;\n}(NavigationAction || {});\nconst MIN_INDEX = 0;\n/**\n * @hidden\n */\nclass NavigationEvent {\n  /**\n   * The index of the item to which the user navigated.\n   */\n  constructor(index, originalEvent) {\n    _defineProperty(this, \"index\", void 0);\n    _defineProperty(this, \"originalEvent\", void 0);\n    this.index = index;\n    this.originalEvent = originalEvent;\n  }\n}\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class11;\n  class NavigationService {\n    constructor(disabledItemsService, selectionService) {\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"open\", new EventEmitter());\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"enter\", new EventEmitter());\n      _defineProperty(this, \"tab\", new EventEmitter());\n      _defineProperty(this, \"esc\", new EventEmitter());\n      _defineProperty(this, \"up\", new EventEmitter());\n      _defineProperty(this, \"right\", new EventEmitter());\n      _defineProperty(this, \"down\", new EventEmitter());\n      _defineProperty(this, \"left\", new EventEmitter());\n      _defineProperty(this, \"delete\", new EventEmitter());\n      _defineProperty(this, \"backspace\", new EventEmitter());\n      _defineProperty(this, \"home\", new EventEmitter());\n      _defineProperty(this, \"end\", new EventEmitter());\n      _defineProperty(this, \"pagedown\", new EventEmitter());\n      _defineProperty(this, \"pageup\", new EventEmitter());\n      _defineProperty(this, \"selectnext\", new EventEmitter());\n      _defineProperty(this, \"selectprevious\", new EventEmitter());\n      _defineProperty(this, \"selectall\", new EventEmitter());\n      _defineProperty(this, \"selectalltobeginning\", new EventEmitter());\n      _defineProperty(this, \"selectalltoend\", new EventEmitter());\n      this.disabledItemsService = disabledItemsService;\n      this.selectionService = selectionService;\n    }\n    process(args) {\n      const keyCode = args.originalEvent.keyCode;\n      const altKey = args.originalEvent.altKey;\n      const shiftKey = args.originalEvent.shiftKey;\n      const ctrlKey = args.originalEvent.ctrlKey || args.originalEvent.metaKey;\n      const openOnSpace = args.openOnSpace;\n      const closeOnSpace = args.closeOnSpace;\n      let index;\n      let action = NavigationAction.Undefined;\n      if (altKey && keyCode === Keys.ArrowDown) {\n        action = NavigationAction.Open;\n      } else if (openOnSpace && keyCode === Keys.Space) {\n        action = NavigationAction.Open;\n      } else if (altKey && keyCode === Keys.ArrowUp) {\n        action = NavigationAction.Close;\n      } else if (closeOnSpace && keyCode === Keys.Space) {\n        action = NavigationAction.Close;\n      } else if (shiftKey && keyCode === Keys.ArrowUp) {\n        action = NavigationAction.SelectPrevious;\n      } else if (shiftKey && keyCode === Keys.ArrowDown) {\n        action = NavigationAction.SelectNext;\n      } else if (ctrlKey && keyCode === Keys.KeyA) {\n        action = NavigationAction.SelectAll;\n      } else if (ctrlKey && shiftKey && keyCode === Keys.Home) {\n        action = NavigationAction.SelectAllToBeginning;\n      } else if (ctrlKey && shiftKey && keyCode === Keys.End) {\n        action = NavigationAction.SelectAllToEnd;\n      } else if (keyCode === Keys.Enter) {\n        action = NavigationAction.Enter;\n      } else if (keyCode === Keys.Escape) {\n        action = NavigationAction.Esc;\n      } else if (keyCode === Keys.Tab) {\n        action = NavigationAction.Tab;\n      } else if (keyCode === Keys.ArrowUp) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: -1\n        });\n        action = NavigationAction.Up;\n      } else if (keyCode === Keys.ArrowLeft) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: -1\n        });\n        action = NavigationAction.Left;\n      } else if (keyCode === Keys.ArrowDown) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: 1\n        });\n        action = NavigationAction.Down;\n      } else if (keyCode === Keys.ArrowRight) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: 1\n        });\n        action = NavigationAction.Right;\n      } else if (keyCode === Keys.Home) {\n        index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;\n        action = NavigationAction.Home;\n      } else if (keyCode === Keys.End) {\n        index = this.isDisabled(args.max) ? args.current : args.max;\n        action = NavigationAction.End;\n      } else if (keyCode === Keys.Delete) {\n        action = NavigationAction.Delete;\n      } else if (keyCode === Keys.Backspace) {\n        action = NavigationAction.Backspace;\n      } else if (keyCode === Keys.PageDown) {\n        action = NavigationAction.PageDown;\n      } else if (keyCode === Keys.PageUp) {\n        action = NavigationAction.PageUp;\n      }\n      const eventData = new NavigationEvent(index, args.originalEvent);\n      if (action !== NavigationAction.Undefined) {\n        this[NavigationAction[action].toLowerCase()].emit(eventData);\n      }\n      return action;\n    }\n    next(args) {\n      const {\n        current,\n        start,\n        end,\n        step\n      } = args;\n      const nextIndex = !isPresent(current) ? start : this.clampIndex(current + step, start, end);\n      const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);\n      if (isPresent(firstFocusableIndex)) {\n        return firstFocusableIndex;\n      }\n      if (this.selectionService.isSelected(current) && current >= start) {\n        return current;\n      }\n      const inversedStep = -1 * step;\n      return this.firstFocusableIndex(nextIndex, start, end, inversedStep);\n    }\n    clampIndex(index, min, max) {\n      if (!isPresent(index) || index < min) {\n        return min;\n      }\n      if (index > max) {\n        return max;\n      }\n      return index;\n    }\n    firstFocusableIndex(startIndex, min, max, step) {\n      while (min <= startIndex && startIndex <= max) {\n        if (!this.isDisabled(startIndex)) {\n          return startIndex;\n        }\n        startIndex += step;\n      }\n      return undefined;\n    }\n    isDisabled(index) {\n      if (this.disabledItemsService) {\n        return this.disabledItemsService.isIndexDisabled(index);\n      }\n    }\n  }\n  _class11 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class11_Factory(t) {\n    return new (t || _class11)(i0.ɵɵinject(DisabledItemsService), i0.ɵɵinject(SelectionService));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class11,\n    factory: _class11.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders content when no data is available. To define the no-data template, nest a `<ng-template>` tag\n * with the `kendo<ComponentName>NoDataTemplate` directive inside the component tag.\n *\n * - [Using `NoDataTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the ComboBox]({% slug templates_combobox %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the DropDownList]({% slug templates_ddl %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-no-data-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxNoDataTemplate>\n *      <h4>No data!</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [];\n * }\n * ```\n */\nlet NoDataTemplateDirective = /*#__PURE__*/(() => {\n  var _class12;\n  class NoDataTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class12 = NoDataTemplateDirective;\n  _defineProperty(NoDataTemplateDirective, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(NoDataTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class12,\n    selectors: [[\"\", \"kendoDropDownListNoDataTemplate\", \"\"], [\"\", \"kendoDropDownTreeNoDataTemplate\", \"\"], [\"\", \"kendoComboBoxNoDataTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxNoDataTemplate\", \"\"], [\"\", \"kendoAutoCompleteNoDataTemplate\", \"\"], [\"\", \"kendoMultiSelectNoDataTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeNoDataTemplate\", \"\"]],\n    standalone: true\n  }));\n  return NoDataTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * Defines the mandatory properties of the `kendoDropDownFilter` directive\n * so that `kendoDropDownFilter` can be used with any of the DropDowns components\n * which implement the `FilterableDropDownComponentBase` class.\n *\n * @hidden\n */\nclass FilterableComponent {\n  constructor() {\n    /**\n     * Sets the data of the component.\n     */\n    _defineProperty(this, \"data\", void 0);\n    /**\n     * Explicitly enables the emitting of the `filterChange` event.\n     */\n    _defineProperty(this, \"filterable\", void 0);\n    /**\n     * Hooks to the `filter` event.\n     */\n    _defineProperty(this, \"filterChange\", void 0);\n    /**\n     * Reads the data from the components with complex data.\n     */\n    _defineProperty(this, \"textField\", void 0);\n    /**\n     * Reads the data from the components with complex data which use `valueField` instead of\n     * `textField`&mdash;for example, the AutoComplete.\n     */\n    _defineProperty(this, \"valueField\", void 0);\n  }\n}\n\n/**\n * @hidden\n */\nlet ListItemDirective = /*#__PURE__*/(() => {\n  var _class15;\n  class ListItemDirective {\n    constructor(element) {\n      _defineProperty(this, \"element\", void 0);\n      this.element = element;\n    }\n  }\n  _class15 = ListItemDirective;\n  _defineProperty(ListItemDirective, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(ListItemDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class15,\n    selectors: [[\"li\", \"role\", \"option\"], [\"li\", \"role\", \"group\"]],\n    standalone: true\n  }));\n  return ListItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SelectableDirective = /*#__PURE__*/(() => {\n  var _class16;\n  class SelectableDirective {\n    constructor(selectionService) {\n      _defineProperty(this, \"index\", void 0);\n      _defineProperty(this, \"checkboxes\", {\n        enabled: false\n      });\n      _defineProperty(this, \"height\", void 0);\n      _defineProperty(this, \"isMultiselect\", void 0);\n      _defineProperty(this, \"multipleSelection\", false);\n      _defineProperty(this, \"selectionService\", void 0);\n      this.selectionService = selectionService;\n    }\n    get focusedClassName() {\n      return this.selectionService.isFocused(this.index);\n    }\n    get selectedClassName() {\n      return !this.checkboxes.enabled && this.selectionService.isSelected(this.index);\n    }\n    onClick(event) {\n      event.stopPropagation();\n      this.selectionService.lastClickedIndex = this.index;\n      if (this.checkboxes.enabled && !this.checkboxes.checkOnClick) {\n        return;\n      }\n      if (this.multipleSelection) {\n        if (this.selectionService.isSelected(this.index)) {\n          this.selectionService.deselect(this.index);\n        } else {\n          this.selectionService.add(this.index);\n        }\n      } else {\n        this.selectionService.change(this.index);\n      }\n    }\n  }\n  _class16 = SelectableDirective;\n  _defineProperty(SelectableDirective, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(SelectionService));\n  });\n  _defineProperty(SelectableDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class16,\n    selectors: [[\"\", \"kendoDropDownsSelectable\", \"\"]],\n    hostVars: 9,\n    hostBindings: function _class16_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class16_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"index\", ctx.index);\n        i0.ɵɵstyleProp(\"height\", ctx.height, \"px\")(\"min-height\", ctx.height, \"px\");\n        i0.ɵɵclassProp(\"k-focus\", ctx.focusedClassName)(\"k-selected\", ctx.selectedClassName);\n      }\n    },\n    inputs: {\n      index: \"index\",\n      checkboxes: \"checkboxes\",\n      height: \"height\",\n      isMultiselect: \"isMultiselect\",\n      multipleSelection: \"multipleSelection\"\n    },\n    standalone: true\n  }));\n  return SelectableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ListComponent = /*#__PURE__*/(() => {\n  var _class17;\n  class ListComponent {\n    set data(data) {\n      this._data = data[0] && data[0].header ? data.slice(0) : data;\n    }\n    get data() {\n      return this._data;\n    }\n    set size(size) {\n      if (this.type === 'list') {\n        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('list', this.size));\n        if (size) {\n          this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('list', size));\n        }\n        this._size = size;\n      }\n    }\n    get size() {\n      return this._size;\n    }\n    get pageSize() {\n      if (this.virtual.pageSize) {\n        return this.virtual.pageSize;\n      }\n      const size = Math.round(this.height / this.virtual.itemHeight);\n      return size;\n    }\n    get scrollHeight() {\n      return this.virtual.total * this.virtual.itemHeight;\n    }\n    get overflowY() {\n      if (isPresent(this.virtual)) {\n        const overflow = this.hasVirtualScrollbar() ? 'scroll' : 'hidden';\n        return overflow;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get checkboxClasses() {\n      return `${this.size ? getSizeClass('checkbox', this.size) : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    /* tslint:disable:member-ordering */\n    constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"selected\", []);\n      _defineProperty(this, \"focused\", -1);\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"valueField\", void 0);\n      _defineProperty(this, \"height\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"fixedGroupTemplate\", void 0);\n      _defineProperty(this, \"show\", true);\n      _defineProperty(this, \"id\", void 0);\n      _defineProperty(this, \"optionPrefix\", void 0);\n      _defineProperty(this, \"multipleSelection\", false);\n      _defineProperty(this, \"virtual\", void 0);\n      _defineProperty(this, \"type\", 'list');\n      _defineProperty(this, \"checkboxes\", {\n        enabled: false\n      });\n      _defineProperty(this, \"ariaLive\", void 0);\n      _defineProperty(this, \"isMultiselect\", void 0);\n      _defineProperty(this, \"isActionSheetExpanded\", void 0);\n      _defineProperty(this, \"showStickyHeader\", void 0);\n      _defineProperty(this, \"rowWidth\", void 0);\n      _defineProperty(this, \"rounded\", 'medium');\n      _defineProperty(this, \"onClick\", new EventEmitter());\n      _defineProperty(this, \"pageChange\", new EventEmitter());\n      _defineProperty(this, \"listResize\", new EventEmitter());\n      _defineProperty(this, \"popupListScroll\", new EventEmitter());\n      _defineProperty(this, \"items\", void 0);\n      _defineProperty(this, \"content\", void 0);\n      _defineProperty(this, \"list\", void 0);\n      _defineProperty(this, \"virtualContainer\", void 0);\n      _defineProperty(this, \"currentGroup\", void 0);\n      _defineProperty(this, \"startFrom\", 0);\n      _defineProperty(this, \"lastLoaded\", 0);\n      _defineProperty(this, \"lastScrollTop\", 0);\n      _defineProperty(this, \"listContentClass\", void 0);\n      _defineProperty(this, \"listClass\", void 0);\n      _defineProperty(this, \"listItemClass\", void 0);\n      _defineProperty(this, \"listVirtualClass\", void 0);\n      _defineProperty(this, \"listGroupStickyHeaderClass\", void 0);\n      _defineProperty(this, \"listGroupStickyHeaderTextClass\", void 0);\n      _defineProperty(this, \"listGroupItemClass\", void 0);\n      _defineProperty(this, \"listGroupItemTextClass\", void 0);\n      _defineProperty(this, \"scrollToFocused\", false);\n      _defineProperty(this, \"_data\", void 0);\n      _defineProperty(this, \"scrollSubscription\", void 0);\n      _defineProperty(this, \"selectSubscription\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      this.dataService = dataService;\n      this.wrapper = wrapper;\n      this.selectionService = selectionService;\n      this.disabledItemsService = disabledItemsService;\n      this.cdr = cdr;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.selectSubscription = merge(this.selectionService.onSelect.pipe(map(args => args.indices[0])), this.selectionService.onFocus).pipe(\n      // handle only the very last onSelect/onFocus emission\n      switchMap(event => this.zone.onStable.pipe(take(1), map(() => event)))).subscribe(this.scrollToItem.bind(this));\n      this.prepareClasses();\n    }\n    ngOnChanges(changes) {\n      if (isChanged('data', changes, false)) {\n        if (this.lastLoaded <= 0) {\n          this.lastLoaded = this.data.length - 1;\n          this.scrollToFocused = !changes['data'].isFirstChange();\n        }\n        this.setOverflow();\n        this.zone.onStable.pipe(take(1)).subscribe(() => {\n          this.setGroupAttributes();\n        });\n      }\n      if (isChanged('virtual', changes, false)) {\n        this.setOverflow();\n      }\n      if (isChanged('type', changes, false)) {\n        this.prepareClasses();\n      }\n    }\n    ngAfterViewInit() {\n      this.setComponentClasses();\n      this.zone.runOutsideAngular(() => {\n        this.scrollSubscription = fromEvent(this.content.nativeElement, \"scroll\").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {\n          this.lastScrollTop = this.content.nativeElement.scrollTop;\n        });\n      });\n      this.setGroupAttributes();\n      this.setOverflow();\n    }\n    setGroupAttributes() {\n      const liItems = document.querySelectorAll('li');\n      let isGroup;\n      let childrenliItemsIds = [];\n      let firstGroupReached = false;\n      let previousGroup;\n      liItems.forEach((li, idx) => {\n        isGroup = li.getAttribute('role') === 'group';\n        if (!isGroup && firstGroupReached) {\n          this.renderer.setAttribute(li, 'aria-describedby', previousGroup.getAttribute('id'));\n          childrenliItemsIds.push(li.getAttribute('id'));\n          if (idx + 1 >= liItems.length || liItems[idx + 1]?.getAttribute('role') === 'group') {\n            this.renderer.setAttribute(previousGroup, 'aria-owns', childrenliItemsIds.join(' '));\n            childrenliItemsIds = [];\n          }\n        }\n        if (isGroup) {\n          firstGroupReached = true;\n          previousGroup = li;\n        }\n      });\n    }\n    ngAfterViewChecked() {\n      if (this.virtual) {\n        this.positionItems();\n      }\n      if (this.items && this.scrollToFocused) {\n        this.scrollToFocused = false;\n        const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;\n        this.scrollToItem(scrollTarget);\n      }\n      if (this.dataService.grouped) {\n        this.findCurrentGroup();\n      }\n    }\n    ngOnDestroy() {\n      this.selectSubscription.unsubscribe();\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n    }\n    onCheckedChange(e, index) {\n      const isChecked = e.target['checked'];\n      if (isChecked && !this.selectionService.isSelected(index)) {\n        this.selectionService.add(index);\n      }\n      if (!isChecked && this.selectionService.isSelected(index)) {\n        this.selectionService.deselect(index);\n      }\n    }\n    prepareClasses() {\n      if (this.type === 'list') {\n        this.listContentClass = 'k-list-content';\n        this.listClass = 'k-list-ul';\n        this.listItemClass = 'k-list-item';\n        this.listVirtualClass = 'k-virtual-list';\n        this.listGroupStickyHeaderClass = 'k-list-group-sticky-header';\n        this.listGroupStickyHeaderTextClass = 'k-list-header-text';\n        this.listGroupItemClass = 'k-list-group-item';\n        this.listGroupItemTextClass = 'k-list-item-text';\n      } else {\n        this.listContentClass = 'k-table-body k-table-scroller';\n        this.listClass = 'k-table k-table-list';\n        this.listItemClass = 'k-table-row';\n        this.listVirtualClass = 'k-virtual-table';\n        this.listGroupStickyHeaderClass = 'k-table-group-sticky-header';\n        this.listGroupStickyHeaderTextClass = 'k-table-th';\n        this.listGroupItemClass = 'k-table-group-row';\n        this.listGroupItemTextClass = 'k-table-th';\n      }\n    }\n    isChecked(index) {\n      const normalizedIndex = this.virtual ? index + this.virtual.skip : index;\n      return this.selectionService.isSelected(normalizedIndex);\n    }\n    firstVisibleItem() {\n      const content = this.content.nativeElement;\n      const rect = content.getBoundingClientRect();\n      // IE9 hack\n      const disabled = Array.prototype.slice.call(content.querySelectorAll(\".k-disabled\"));\n      // This is a workaround for finding elements with pointer-events: none;\n      disabled.forEach(el => this.renderer.setStyle(el, \"pointer-events\", \"auto\"));\n      const item = document.elementFromPoint(rect.left + 1, rect.top + 1);\n      disabled.forEach(el => this.renderer.setStyle(el, \"pointer-events\", \"none\"));\n      // return the closest `li` item to cover the custom template scenario\n      return closest(item, 'li');\n    }\n    findCurrentGroup() {\n      if (!this.dataService.grouped) {\n        this.currentGroup = undefined;\n        return;\n      }\n      const item = this.firstVisibleItem();\n      if (item) {\n        let index;\n        if (item.getAttribute(\"role\") === \"group\") {\n          index = parseInt(item.getAttribute(\"group-index\"), 10);\n          this.currentGroup = this.dataService.groupAt(index)?.value;\n        } else {\n          index = parseInt(item.getAttribute(\"index\"), 10);\n          this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));\n        }\n      } else {\n        this.currentGroup = undefined;\n      }\n      this.cdr.detectChanges();\n    }\n    prefetchData() {\n      if (!this.virtual) {\n        return;\n      }\n      const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);\n      const offsetY = this.content.nativeElement.scrollTop;\n      const start = Math.trunc(offsetY / this.virtual.itemHeight);\n      const down = offsetY > this.lastScrollTop;\n      const nextPage = start + visibleItems >= this.lastLoaded && this.lastLoaded < this.virtual.total - 1;\n      const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);\n      const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;\n      if (down && nextPage) {\n        this.changePage(start);\n      }\n      if (!down && prevPage) {\n        this.changePage(start - this.pageSize + visibleItems + 1);\n      }\n    }\n    changePage(start) {\n      this.zone.run(() => {\n        let end = this.pageSize + start;\n        if (end > this.virtual.total) {\n          start--;\n          end = this.virtual.total;\n        }\n        if (start < 0) {\n          start = 0;\n        }\n        this.startFrom = start;\n        this.lastLoaded = end;\n        this.pageChange.emit({\n          skip: start,\n          take: this.pageSize\n        });\n      });\n      this.setGroupAttributes();\n    }\n    index(groupIndex, itemIndex) {\n      return groupIndex > 0 ? this.dataService.groupIndices[groupIndex - 1] + itemIndex : itemIndex;\n    }\n    getText(dataItem) {\n      return getter(dataItem, this.textField);\n    }\n    getValue(dataItem) {\n      return getter(dataItem, this.valueField);\n    }\n    isDisabled(index) {\n      if (isPresent(this.virtual) && !this.dataService.grouped) {\n        index += this.virtual.skip;\n      }\n      return this.disabledItemsService.isIndexDisabled(index);\n    }\n    isAltRow(index) {\n      return this.type === 'dropdowngrid' && index % 2 !== 0;\n    }\n    scrollToItem(index) {\n      let flatIndex = index;\n      if (this.dataService.grouped) {\n        // takes into account the group header items\n        flatIndex = this.dataService.flatIndex(index);\n      }\n      if (this.virtual && flatIndex > -1) {\n        this.scrollToIndex(flatIndex);\n        return;\n      }\n      const items = this.items.toArray();\n      if (isPresent(items[flatIndex]) && flatIndex !== -1) {\n        this.scroll(items[flatIndex].element);\n      }\n    }\n    scrollWithOnePage(action) {\n      const content = this.content.nativeElement;\n      const contentOffsetHeight = content.clientHeight;\n      if (action === NavigationAction.PageDown) {\n        content.scrollTop += contentOffsetHeight;\n      } else if (action === NavigationAction.PageUp) {\n        content.scrollTop -= contentOffsetHeight;\n      }\n    }\n    scrollToIndex(index) {\n      const content = this.content.nativeElement;\n      let contentScrollTop = content.scrollTop;\n      const itemOffsetTop = index * this.virtual.itemHeight;\n      const itemOffsetHeight = this.virtual.itemHeight;\n      const contentOffsetHeight = content.clientHeight;\n      const bottomDistance = itemOffsetTop + itemOffsetHeight;\n      if (contentScrollTop > itemOffsetTop) {\n        contentScrollTop = itemOffsetTop;\n      } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {\n        contentScrollTop = bottomDistance - contentOffsetHeight;\n      }\n      content.scrollTop = contentScrollTop;\n    }\n    scroll(item) {\n      if (!item) {\n        return;\n      }\n      const nativeElement = item.nativeElement;\n      const content = this.content.nativeElement;\n      const itemOffsetTop = nativeElement.offsetTop;\n      const itemOffsetHeight = nativeElement.offsetHeight;\n      let contentScrollTop = content.scrollTop;\n      const contentOffsetHeight = content.clientHeight;\n      const bottomDistance = itemOffsetTop + itemOffsetHeight;\n      if (contentScrollTop > itemOffsetTop) {\n        contentScrollTop = itemOffsetTop;\n      } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {\n        contentScrollTop = bottomDistance - contentOffsetHeight;\n      }\n      content.scrollTop = contentScrollTop;\n    }\n    /**\n     * Indicates whether a scrollbar is currently rendered in the list.\n     */\n    hasScrollbar() {\n      if (!(isPresent(this.items) && this.items.length && isPresent(this.list) && isPresent(this.content))) {\n        return false;\n      }\n      const hasVirtualScroll = isPresent(this.virtual) && this.hasVirtualScrollbar();\n      return hasVirtualScroll || this.list.nativeElement.scrollHeight > this.content.nativeElement.offsetHeight;\n    }\n    isItemSelected(index) {\n      return this.selectionService.isSelected(index) || null;\n    }\n    /**\n     * Sets the list's content overflow (hides/shows scrollbar)\n     */\n    setOverflow() {\n      if (this.virtual) {\n        const overflow = this.hasVirtualScrollbar() ? 'scroll' : 'hidden';\n        this.renderer.setStyle(this.content.nativeElement, 'overflow-y', overflow);\n      }\n    }\n    /**\n     * Indicates whether the scrollbar should be visible in virtual mode.\n     */\n    hasVirtualScrollbar() {\n      const contentOffsetHeight = this.content.nativeElement.offsetHeight;\n      const virtualOffsetHeight = this.virtualContainer && this.virtualContainer.nativeElement.offsetHeight;\n      return this.virtualContainer && virtualOffsetHeight > contentOffsetHeight;\n    }\n    positionItems() {\n      this.items.forEach((item, index) => {\n        const offsetY = (index + this.startFrom) * this.virtual.itemHeight;\n        this.renderer.setStyle(item.element.nativeElement, \"transform\", `translateY(${offsetY}px`);\n      });\n    }\n    /**\n     * Indicates whether the first group header from the data set is in the targeted virtual page.\n     */\n    firstGroupHeaderInTargetedPage(itemIndex) {\n      if (!isPresent(this.virtual)) {\n        return true;\n      }\n      return this.virtual.skip === 0 && this.virtual.pageSize > itemIndex;\n    }\n    setComponentClasses() {\n      if (this.type === 'list') {\n        this.renderer.addClass(this.wrapper.nativeElement, 'k-list');\n        if (this.size) {\n          this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('list', this.size));\n        }\n      }\n      if (this.type === 'dropdowngrid') {\n        this.renderer.setStyle(this.wrapper.nativeElement, 'overflow-y', 'scroll');\n      }\n      if (isPresent(this.virtual)) {\n        this.renderer.addClass(this.wrapper.nativeElement, this.listVirtualClass);\n      }\n    }\n  }\n  _class17 = ListComponent;\n  _defineProperty(ListComponent, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(ListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class17,\n    selectors: [[\"kendo-list\"]],\n    viewQuery: function _class17_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n        i0.ɵɵviewQuery(_c3, 5);\n        i0.ɵɵviewQuery(ListItemDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    inputs: {\n      selected: \"selected\",\n      focused: \"focused\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      height: \"height\",\n      template: \"template\",\n      groupTemplate: \"groupTemplate\",\n      fixedGroupTemplate: \"fixedGroupTemplate\",\n      show: \"show\",\n      id: \"id\",\n      optionPrefix: \"optionPrefix\",\n      multipleSelection: \"multipleSelection\",\n      virtual: \"virtual\",\n      type: \"type\",\n      checkboxes: \"checkboxes\",\n      ariaLive: \"ariaLive\",\n      isMultiselect: \"isMultiselect\",\n      isActionSheetExpanded: \"isActionSheetExpanded\",\n      showStickyHeader: \"showStickyHeader\",\n      rowWidth: \"rowWidth\",\n      data: \"data\",\n      size: \"size\",\n      rounded: \"rounded\"\n    },\n    outputs: {\n      onClick: \"onClick\",\n      pageChange: \"pageChange\",\n      listResize: \"listResize\",\n      popupListScroll: \"popupListScroll\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 9,\n    vars: 17,\n    consts: [[3, \"class\", \"ngStyle\", 4, \"ngIf\"], [\"unselectable\", \"on\", 3, \"scroll\"], [\"content\", \"\"], [\"role\", \"listbox\"], [\"list\", \"\"], [4, \"ngIf\"], [3, \"resize\", 4, \"ngIf\"], [\"class\", \"k-height-container\", \"role\", \"presentation\", 4, \"ngIf\"], [3, \"ngStyle\"], [3, \"ngIf\"], [3, \"templateContext\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"checkboxes\", \"height\", \"index\", \"multipleSelection\", \"ngClass\"], [\"type\", \"checkbox\", \"class\", \"k-checkbox\", \"role\", \"presentation\", \"tabindex\", \"-1\", \"aria-hidden\", \"true\", 3, \"ngClass\", \"checked\", \"change\", 4, \"ngIf\"], [\"type\", \"checkbox\", \"role\", \"presentation\", \"tabindex\", \"-1\", \"aria-hidden\", \"true\", 1, \"k-checkbox\", 3, \"ngClass\", \"checked\", \"change\"], [1, \"k-list-item-text\"], [\"role\", \"group\", 3, \"class\", \"k-table-alt-row\", \"ngStyle\", \"width\", 4, \"ngIf\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"height\", \"index\", \"multipleSelection\", \"class\", \"ngClass\", \"width\", 4, \"ngIf\"], [\"role\", \"group\", 3, \"ngStyle\"], [\"li\", \"\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"height\", \"index\", \"multipleSelection\", \"ngClass\"], [3, \"resize\"], [\"role\", \"presentation\", 1, \"k-height-container\"], [\"virtualContainer\", \"\"]],\n    template: function _class17_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class17_div_0_Template, 3, 9, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵlistener(\"scroll\", function _class17_Template_div_scroll_1_listener($event) {\n          return ctx.popupListScroll.emit($event);\n        });\n        i0.ɵɵelementStart(3, \"ul\", 3, 4);\n        i0.ɵɵtemplate(5, _class17_5_Template, 1, 1, null, 5);\n        i0.ɵɵtemplate(6, _class17_6_Template, 1, 1, null, 5);\n        i0.ɵɵtemplate(7, _class17_kendo_resize_sensor_7_Template, 1, 0, \"kendo-resize-sensor\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, _class17_div_8_Template, 4, 2, \"div\", 7);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.dataService.grouped && ctx.showStickyHeader);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMap(ctx.listContentClass);\n        i0.ɵɵstyleProp(\"overscroll-behavior\", \"none\")(\"max-height\", ctx.height, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassMap(ctx.listClass);\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-live\", ctx.ariaLive)(\"aria-multiselectable\", ctx.isMultiselect)(\"aria-hidden\", !ctx.show);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.dataService.grouped && ctx.show);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.dataService.grouped);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.virtual);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.virtual);\n      }\n    },\n    dependencies: [NgIf, NgStyle, TemplateContextDirective, NgFor, ListItemDirective, SelectableDirective, NgClass, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return ListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst DEFAULTS = {\n  pageSize: 50,\n  itemHeight: 28\n};\n/**\n * @hidden\n */\nconst normalizeVirtualizationSettings = (settings, defaultOverrides) => {\n  const defaults = Object.assign({}, DEFAULTS, defaultOverrides);\n  if (settings === true) {\n    return defaults;\n  }\n  if (!settings) {\n    return null;\n  }\n  return {\n    pageSize: DEFAULTS.pageSize,\n    ...settings\n  };\n};\n\n/**\n * @hidden\n */\nlet ResponsiveRendererComponent = /*#__PURE__*/(() => {\n  var _class18;\n  class ResponsiveRendererComponent {\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"showActionButtons\", void 0);\n      _defineProperty(this, \"subtitle\", void 0);\n      _defineProperty(this, \"size\", void 0);\n      _defineProperty(this, \"showTextInput\", void 0);\n      _defineProperty(this, \"sharedPopupActionSheetTemplate\", void 0);\n      _defineProperty(this, \"isActionSheetExpanded\", void 0);\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"placeholder\", void 0);\n      _defineProperty(this, \"closePopup\", new EventEmitter());\n      _defineProperty(this, \"textInputChange\", new EventEmitter());\n      _defineProperty(this, \"navigate\", new EventEmitter());\n      _defineProperty(this, \"onExpand\", new EventEmitter());\n      _defineProperty(this, \"onCollapse\", new EventEmitter());\n      _defineProperty(this, \"onApply\", new EventEmitter());\n      _defineProperty(this, \"onCancel\", new EventEmitter());\n      _defineProperty(this, \"actionSheet\", void 0);\n      _defineProperty(this, \"actionSheetSearchBar\", void 0);\n      _defineProperty(this, \"searchBarValue\", '');\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      _defineProperty(this, \"xIcon\", xIcon);\n      _defineProperty(this, \"expanded\", false);\n      this.localization = localization;\n    }\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    onValueChange(value) {\n      this.searchBarValue = value;\n      this.textInputChange.emit(value);\n    }\n    onOverlayClick() {\n      if (this.expanded) {\n        this.handleClose();\n      }\n    }\n    handleExpand() {\n      this.onExpand.emit();\n      this.expanded = true;\n    }\n    handleClose() {\n      this.closePopup.emit();\n      this.expanded = false;\n    }\n  }\n  _class18 = ResponsiveRendererComponent;\n  _defineProperty(ResponsiveRendererComponent, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ResponsiveRendererComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class18,\n    selectors: [[\"responsive-renderer\"]],\n    viewQuery: function _class18_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ActionSheetComponent, 5);\n        i0.ɵɵviewQuery(_c7, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionSheet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      showActionButtons: \"showActionButtons\",\n      subtitle: \"subtitle\",\n      size: \"size\",\n      showTextInput: \"showTextInput\",\n      sharedPopupActionSheetTemplate: \"sharedPopupActionSheetTemplate\",\n      isActionSheetExpanded: \"isActionSheetExpanded\",\n      text: \"text\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      closePopup: \"closePopup\",\n      textInputChange: \"textInputChange\",\n      navigate: \"navigate\",\n      onExpand: \"onExpand\",\n      onCollapse: \"onCollapse\",\n      onApply: \"onApply\",\n      onCancel: \"onCancel\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 4,\n    consts: [[3, \"animation\", \"expanded\", \"overlayClick\", \"keydown\", \"expand\", \"collapse\"], [\"actionSheet\", \"\"], [\"kendoActionSheetTemplate\", \"\"], [1, \"k-text-center\", \"k-actionsheet-titlebar\"], [1, \"k-actionsheet-titlebar-group\", \"k-hbox\"], [1, \"k-actionsheet-title\"], [1, \"k-text-center\"], [1, \"k-actionsheet-subtitle\", \"k-text-center\"], [1, \"k-actionsheet-actions\"], [\"kendoButton\", \"\", \"icon\", \"x\", \"type\", \"button\", \"fillMode\", \"flat\", \"aria-hidden\", \"true\", \"innerCssClass\", \"k-button-icon\", 3, \"svgIcon\", \"size\", \"tabIndex\", \"click\"], [1, \"k-actionsheet-titlebar-group\", \"k-actionsheet-filter\"], [\"placeholder\", \"Filter\", \"class\", \"k-searchbox\", \"autocomplete\", \"off\", 3, \"value\", \"size\", \"valueChange\", 4, \"ngIf\"], [1, \"k-actionsheet-content\", \"!k-overflow-hidden\"], [1, \"k-list-container\"], [4, \"ngTemplateOutlet\"], [\"class\", \"k-actionsheet-footer k-actions k-actions-stretched\", 4, \"ngIf\"], [\"placeholder\", \"Filter\", \"autocomplete\", \"off\", 1, \"k-searchbox\", 3, \"value\", \"size\", \"valueChange\"], [\"actionSheetSearchBar\", \"\"], [\"kendoTextBoxPrefixTemplate\", \"\"], [\"name\", \"search\"], [1, \"k-actionsheet-footer\", \"k-actions\", \"k-actions-stretched\"], [\"kendoButton\", \"\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"type\", \"button\", \"themeColor\", \"base\", 3, \"size\", \"click\", \"keydown.enter\"], [\"kendoButton\", \"\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"type\", \"button\", \"themeColor\", \"primary\", 3, \"size\", \"click\", \"keydown.enter\"]],\n    template: function _class18_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-actionsheet\", 0, 1);\n        i0.ɵɵlistener(\"overlayClick\", function _class18_Template_kendo_actionsheet_overlayClick_0_listener() {\n          return ctx.onOverlayClick();\n        })(\"keydown\", function _class18_Template_kendo_actionsheet_keydown_0_listener($event) {\n          return ctx.navigate.emit($event);\n        })(\"expand\", function _class18_Template_kendo_actionsheet_expand_0_listener() {\n          return ctx.handleExpand();\n        })(\"collapse\", function _class18_Template_kendo_actionsheet_collapse_0_listener() {\n          return ctx.onCollapse.emit();\n        });\n        i0.ɵɵtemplate(2, _class18_ng_template_2_Template, 15, 9, \"ng-template\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"animation\", i0.ɵɵpureFunction1(2, _c8, ctx.animationDuration))(\"expanded\", ctx.isActionSheetExpanded);\n      }\n    },\n    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconComponent, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return ResponsiveRendererComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SharedDropDownEventsDirective = /*#__PURE__*/(() => {\n  var _class19;\n  class SharedDropDownEventsDirective {\n    constructor(ngZone, renderer, cdr) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"clearButtonClicked\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"isFocusedChange\", new EventEmitter());\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      _defineProperty(this, \"handleBlur\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n    }\n    ngAfterViewInit() {\n      const hostElement = this.hostElement.nativeElement;\n      let cursorInsideWrapper = false;\n      let tabbing = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          this.cdr.detectChanges();\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              this.onFocus.emit();\n              this.isFocused = true;\n              this.isFocusedChange.emit(this.isFocused);\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n          if (tabbing) {\n            const closestTextbox = closest$1(args.relatedTarget, element => element === hostElement);\n            if (!closestTextbox) {\n              this.handleBlur.emit();\n            }\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur.emit();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  _class19 = SharedDropDownEventsDirective;\n  _defineProperty(SharedDropDownEventsDirective, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(SharedDropDownEventsDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class19,\n    selectors: [[\"\", \"kendoDropDownSharedEvents\", \"\"]],\n    inputs: {\n      hostElement: \"hostElement\",\n      clearButtonClicked: \"clearButtonClicked\",\n      isFocused: \"isFocused\"\n    },\n    outputs: {\n      isFocusedChange: \"isFocusedChange\",\n      onFocus: \"onFocus\",\n      handleBlur: \"handleBlur\"\n    },\n    standalone: true\n  }));\n  return SharedDropDownEventsDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  var _class20;\n  class Messages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The text displayed in the popup when there are no items.\n       */\n      _defineProperty(this, \"noDataText\", void 0);\n      /**\n       * The title of the clear button.\n       */\n      _defineProperty(this, \"clearTitle\", void 0);\n      /**\n       * The text displayed for the check-all checkbox.\n       */\n      _defineProperty(this, \"checkAllText\", void 0);\n      /**\n       * The text set as aria-label on the select button.\n       */\n      _defineProperty(this, \"selectButtonText\", void 0);\n      /**\n       * The text set as aria-label on the list filter input.\n       */\n      _defineProperty(this, \"filterInputLabel\", void 0);\n      /**\n       * The text set as aria-label on the popup containing the list of options when its role is `region`.\n       */\n      _defineProperty(this, \"popupLabel\", void 0);\n      /**\n       * The text of the Apply button in the MultiSelect action sheet.\n       */\n      _defineProperty(this, \"applyButton\", void 0);\n      /**\n       * The text of the Cancel button in the MultiSelect action sheet.\n       */\n      _defineProperty(this, \"cancelButton\", void 0);\n    }\n  }\n  _class20 = Messages;\n  _defineProperty(Messages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class20_BaseFactory;\n    return function _class20_Factory(t) {\n      return (ɵ_class20_BaseFactory || (ɵ_class20_BaseFactory = i0.ɵɵgetInheritedFactory(_class20)))(t || _class20);\n    };\n  }());\n  _defineProperty(Messages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class20,\n    inputs: {\n      noDataText: \"noDataText\",\n      clearTitle: \"clearTitle\",\n      checkAllText: \"checkAllText\",\n      selectButtonText: \"selectButtonText\",\n      filterInputLabel: \"filterInputLabel\",\n      popupLabel: \"popupLabel\",\n      applyButton: \"applyButton\",\n      cancelButton: \"cancelButton\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  var _class21;\n  class LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class21 = LocalizedMessagesDirective;\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275fac\", function _class21_Factory(t) {\n    return new (t || _class21)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class21,\n    selectors: [[\"\", \"kendoDropDownListLocalizedMessages\", \"\"], [\"\", \"kendoDropDownTreeLocalizedMessages\", \"\"], [\"\", \"kendoComboBoxLocalizedMessages\", \"\"], [\"\", \"kendoMultiColumnComboBoxLocalizedMessages\", \"\"], [\"\", \"kendoAutoCompleteLocalizedMessages\", \"\"], [\"\", \"kendoMultiSelectLocalizedMessages\", \"\"], [\"\", \"kendoMultiSelectTreeLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class21)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NO_VALUE = \"\";\nconst DEFAULT_SIZE$5 = 'medium';\nconst DEFAULT_ROUNDED$5 = 'medium';\nconst DEFAULT_FILL_MODE$5 = 'solid';\n/**\n * @hidden\n */\nconst AUTOCOMPLETE_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => AutoCompleteComponent)\n};\n/**\n * Represents the [Kendo UI AutoComplete component for Angular]({% slug overview_autocomplete %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"listItems\"\n *      [placeholder]=\"placeholder\"\n *  >\n * `\n * })\n * class AppComponent {\n *   public placeholder: string = 'Type \"it\" for suggestions';\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet AutoCompleteComponent = /*#__PURE__*/(() => {\n  var _class22;\n  class AutoCompleteComponent {\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    get width() {\n      let wrapperOffsetWidth = 0;\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.offsetWidth;\n      }\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-autocomplete-popup'];\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n      return containerClasses;\n    }\n    get suggestion() {\n      if (!this.text || !this.suggestedText) {\n        this.suggestedText = undefined;\n        return;\n      }\n      const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());\n      const shouldSuggest = this.suggest && !this.backspacePressed;\n      if (shouldSuggest && hasMatch) {\n        return this.suggestedText;\n      }\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    get clearButtonVisiblity() {\n      if (touchEnabled) {\n        return 'visible';\n      }\n    }\n    get ariaControls() {\n      return this.isOpen ? this.listBoxId : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.formControl);\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet.\n     * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n        this._toggle(shouldOpen);\n      });\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(this._open || this.isActionSheetExpanded);\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.togglePopup(true);\n      }\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      if (isDisabled || sameState) {\n        return;\n      }\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n    get activeDescendant() {\n      if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n        return null;\n      }\n      return this.optionPrefix + \"-\" + this.selectionService.focused;\n    }\n    /**\n     * Defines whether the first match from the suggestions list will be automatically focused.\n     * By default, `highlightFirst` is set to `true`.\n     */\n\n    /**\n     * Sets the data of the AutoComplete.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this.dataService.data = data || [];\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      if (this.filterable) {\n        this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;\n      }\n      if (this.suggest && this.dataService.itemsCount > 0) {\n        this.suggestedText = getter(this.dataService.itemAt(0), this.valueField);\n      }\n    }\n    get data() {\n      const virtual = this.virtual;\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize;\n        // Use length instead of itemsCount because of the grouping.\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the AutoComplete.\n     */\n    set value(newValue) {\n      this.verifySettings(newValue);\n      this._value = newValue || NO_VALUE;\n      this.text = this.value;\n      this.cdr.markForCheck();\n    }\n    get value() {\n      return this._value || NO_VALUE;\n    }\n    /**\n     * Specifies the `string` property of the data item that represents the item value.\n     * If the data contains only primitive values, do not define it.\n     *\n     * > The `valueField` property can be set to point to a nested property value - e.g. `category.name`.\n     */\n\n    /**\n     * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n     * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n    */\n    set subtitle(_subtitle) {\n      this._subtitle = _subtitle;\n    }\n    get subtitle() {\n      return this._subtitle || this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n     * Configures the popup of the AutoComplete.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_autocomplete %})).\n     * Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Sets the read-only state of the component.\n     *\n     * @default false\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.\n     * If set to `true`, the component emits the `filterChange` event.\n     */\n\n    /**\n     * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.\n     */\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$5;\n      this.renderer.removeClass(this.wrapper, getSizeClass('input', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper, getSizeClass('input', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;\n      this.renderer.removeClass(this.wrapper, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper, getRoundedClass(newRounded));\n      }\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$5;\n      this.renderer.removeClass(this.wrapper, getFillModeClass('input', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper, getFillModeClass('input', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n\n    get isFocused() {\n      return this._isFocused;\n    }\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper, \"k-focus\");\n      this._isFocused = isFocused;\n    }\n    get isDisabled() {\n      return this.disabled;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get isActionSheetExpanded() {\n      return this.actionSheet?.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, hostElement, injector, adaptiveService) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"highlightFirst\", true);\n      /**\n       * Shows or hides the current group sticky header when using grouped data.\n       * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).\n       */\n      _defineProperty(this, \"showStickyHeader\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n      _defineProperty(this, \"placeholder\", \"\");\n      /**\n       * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n       */\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      _defineProperty(this, \"_listHeight\", 200);\n      /**\n       * Sets and gets the loading state of the AutoComplete.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      /**\n       * @hidden\n       *\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n      _defineProperty(this, \"clearButton\", true);\n      /**\n       * Enables the auto-completion of the text based on the first data item.\n       */\n      _defineProperty(this, \"suggest\", void 0);\n      /**\n       * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_autocomplete#toc-managing-the-autocomplete-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"filterable\", false);\n      _defineProperty(this, \"inputAttributes\", void 0);\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example](slug:events_autocomplete)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value\n       * ([see example](slug:events_autocomplete)).\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the AutoComplete.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the AutoComplete gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"fixedGroupTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"searchbar\", void 0);\n      _defineProperty(this, \"optionsList\", void 0);\n      _defineProperty(this, \"widgetClasses\", true);\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"listBoxId\", `k-${guid()}`);\n      _defineProperty(this, \"optionPrefix\", `k-${guid()}`);\n      _defineProperty(this, \"popupRef\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"windowSize\", 'large');\n      _defineProperty(this, \"onChangeCallback\", noop);\n      _defineProperty(this, \"onTouchedCallback\", noop);\n      _defineProperty(this, \"popupMouseDownHandler\", event => event.preventDefault());\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true\n      });\n      _defineProperty(this, \"_virtualSettings\", void 0);\n      _defineProperty(this, \"_open\", false);\n      _defineProperty(this, \"_value\", \"\");\n      _defineProperty(this, \"suggestedText\", void 0);\n      _defineProperty(this, \"backspacePressed\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"valueChangeSubject\", new Subject());\n      _defineProperty(this, \"touchstartDisposeHandler\", void 0);\n      _defineProperty(this, \"_subtitle\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      this.localization = localization;\n      this.dataService = dataService;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this._zone = _zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.injector = injector;\n      this.adaptiveService = adaptiveService;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.wrapper = this.hostElement.nativeElement;\n      this.data = [];\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.selectionService.resetSelection([-1]);\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      }));\n      this.setComponentClasses();\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      this.cdr.detectChanges();\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.subs.unsubscribe();\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes['data'] && changes['data'].isFirstChange();\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n    }\n    /**\n     * Resets the value of the AutoComplete.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n      this.value = NO_VALUE;\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    onAdaptiveTextBoxChange(text) {\n      this.search(text);\n    }\n    /**\n     * @hidden\n     */\n    clearValue(event) {\n      event.stopImmediatePropagation();\n      this.focus();\n      this.change(NO_VALUE);\n      if (this.filterable) {\n        this.filterChange.emit('');\n      }\n      this.selectionService.resetSelection([]);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * Focuses a specific item of the AutoComplete based on a provided index.\n     * If null or invalid index is provided the focus will be removed.\n     */\n    focusItemAt(index) {\n      const isInRange = index >= 0 && index < this.data.length;\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(-1);\n      }\n    }\n    /**\n     * Focuses the AutoComplete.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * Blurs the AutoComplete.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n        this.cdr.detectChanges();\n      }\n      if (this._open && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    emitChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n    verifySettings(newValue) {\n      if (!isDevMode()) {\n        return;\n      }\n      if (isPresent(newValue) && typeof newValue !== \"string\") {\n        throw new Error(\"Expected value of type string. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/value-binding/\");\n      }\n    }\n    search(text, startFrom = 0) {\n      const index = this.findIndex(text, startFrom);\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        if (index + 1 < this.dataService.itemsCount) {\n          this.search(text, index + 1);\n        } else {\n          this.selectionService.focus(-1);\n        }\n      } else {\n        this.selectionService.focus(index);\n        if (this.suggest) {\n          this.suggestedText = getter(this.dataService.itemAt(index), this.valueField);\n        }\n      }\n    }\n    navigate(index) {\n      if (!this.isOpen) {\n        return;\n      }\n      this.selectionService.focus(index);\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n      const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n      if (this.disabled || this.readonly || isNaN(focused)) {\n        return;\n      }\n      const action = this.navigationService.process({\n        current: focused,\n        max: this.dataService.itemsCount - 1,\n        min: 0,\n        originalEvent: event\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.Home && action !== NavigationAction.End && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {\n        event.preventDefault();\n      }\n      if (action === NavigationAction.Tab && this.isActionSheetExpanded) {\n        event.stopImmediatePropagation();\n        this.togglePopup(false);\n      }\n    }\n    handleEnter(event) {\n      const focused = this.selectionService.focused;\n      let value;\n      if (this.isOpen) {\n        event.originalEvent.preventDefault();\n      }\n      if (focused >= 0) {\n        value = getter(this.dataService.itemAt(focused), this.valueField);\n      } else {\n        const match = this.suggest && this.suggestedText && this.data.length && getter(this.dataService.itemAt(0), this.valueField).toLowerCase() === this.searchbar.value.toLowerCase();\n        if (this.isOpen && match) {\n          value = this.suggestedText;\n        } else {\n          value = this.searchbar.value;\n        }\n      }\n      if (this.isActionSheetExpanded && focused >= 0) {\n        this.togglePopup(false);\n      }\n      this.change(value);\n    }\n    handleEscape() {\n      if (this.isOpen) {\n        this.togglePopup(false);\n      } else {\n        this.value = '';\n      }\n      this.selectionService.focused = -1;\n      this.suggestedText = null;\n    }\n    /**\n     * @hidden\n     */\n    searchBarChange(text) {\n      const currentTextLength = isPresent(this.text) ? this.text.length : 0;\n      this.backspacePressed = text.length < currentTextLength ? true : false;\n      this.text = text;\n      this.togglePopup(text.length > 0);\n      if (!this.highlightFirst) {\n        this.selectionService.focused = -1;\n      }\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      } else if (this.highlightFirst) {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onFilterChange(text) {\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      } else if (this.highlightFirst) {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputFocus() {\n      this.handleFocus();\n      if (hasObservers(this.inputFocus)) {\n        this._zone.run(() => {\n          this.inputFocus.emit();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this._zone.run(() => {\n        if (!this.isFocused && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      if (!this.isActionSheetExpanded) {\n        this.isFocused = false;\n        const valueHasChanged = this.value !== this.text;\n        const runInZone = hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper) || valueHasChanged;\n        if (runInZone) {\n          this._zone.run(() => {\n            if (valueHasChanged) {\n              this.change(this.searchbar.value);\n            }\n            this.onBlur.emit();\n            this.onTouchedCallback();\n            this.togglePopup(false);\n          });\n        } else {\n          this.togglePopup(false);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputBlur() {\n      if (!this.isActionSheetExpanded) {\n        const focused = this.filterable ? this.selectionService.focused : -1;\n        this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers\n        let dataItem;\n        let text;\n        if (focused !== -1) {\n          dataItem = this.dataService.itemAt(focused);\n          text = getter(dataItem, this.valueField) || \"\";\n        } else {\n          text = this.searchbar.value;\n        }\n        const exactMatch = text === this.searchbar.value;\n        const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();\n        if (!exactMatch && insensitiveMatch) {\n          this.selectionService.resetSelection([]);\n        }\n        const valueHasChanged = this.value !== this.text;\n        const runInZone = hasObservers(this.inputBlur) || hasObservers(this.close) || isUntouched(this.wrapper) || valueHasChanged || this.formControl?.updateOn === 'blur';\n        if (runInZone) {\n          this._zone.run(() => {\n            if (valueHasChanged) {\n              this.change(this.searchbar.value);\n            }\n            this.inputBlur.emit();\n            this.onTouchedCallback();\n            this.togglePopup(false);\n          });\n        } else {\n          this.togglePopup(false);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n    change(value) {\n      this.togglePopup(false);\n      this.valueChangeSubject.next(value);\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subs.add(this.valueChangeSubject.subscribe(value => {\n        const hasChange = this.value !== value;\n        const index = this.findIndex(value);\n        this.selectionService.focused = index;\n        this.value = value;\n        this.text = value;\n        // emit change after assigning `this.value` => allows the user to modify the component value on `valueChange`\n        if (hasChange) {\n          this.emitChange(value);\n        }\n      }));\n      this.subs.add(this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)));\n      this.subs.add(this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this)));\n      this.subs.add(merge(this.navigationService.up, this.navigationService.down).subscribe(event => this.navigate(event.index)));\n      this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));\n      this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));\n      this.subs.add(this.navigationService.enter.subscribe(this.handleEnter.bind(this)));\n      this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));\n      this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n          this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);\n        }\n      }));\n    }\n    findIndex(value, startFrom = 0) {\n      let index;\n      if (value && value.length && this.dataService.itemsCount) {\n        index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);\n      } else {\n        index = -1;\n      }\n      return index;\n    }\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !touchEnabled) {\n        return;\n      }\n      this._zone.runOutsideAngular(() =>\n      // Roll up AutoComplete on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        if (this.isFocused && !inDropDown(this.hostElement, target, this.popupRef)) {\n          this._zone.run(() => this.blur());\n        }\n      }));\n    }\n    handleItemChange(event) {\n      const index = event.indices.length ? event.indices[0] : undefined;\n      this.selectionService.resetSelection([-1]);\n      if (!isPresent(index)) {\n        return;\n      }\n      const text = getter(this.dataService.itemAt(index), this.valueField);\n      this.change(text);\n      if (this.isActionSheetExpanded) {\n        this.togglePopup(false);\n      }\n    }\n    handleItemFocus(_event) {\n      const focused = this.selectionService.focused;\n      const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);\n      if (shouldSuggest) {\n        this.suggestedText = getter(this.dataService.itemAt(focused), this.valueField);\n      }\n    }\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupClass: this.listContainerClasses,\n        positionMode: appendToComponent ? 'fixed' : 'absolute',\n        popupAlign: popupPosition,\n        anchorAlign: anchorPosition\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute('dir', this.direction);\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      this.subs.add(this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.selectionService.focus(this.selectionService.focused);\n        this.opened.emit();\n      }));\n      this.subs.add(this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      }));\n      this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      }\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    firstFocusableIndex(index) {\n      const maxIndex = this.data.length - 1;\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n    findIndexPredicate(text) {\n      if (this.dataService.grouped) {\n        return item => {\n          let itemText = getter(item.value, this.valueField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      } else {\n        return item => {\n          let itemText = getter(item, this.valueField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      }\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper, getSizeClass('input', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper, getFillModeClass('input', this.fillMode));\n      }\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      this.actionSheetSearchBar.value = '';\n      this.filterable && this.filterChange.emit('');\n      this.searchbar.input.nativeElement.focus();\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.actionSheet.toggle(true);\n      this.cdr.detectChanges();\n      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n      this.title = setActionSheetTitle(this.searchbar.input, this.title);\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.optionsList.scrollToItem(this.selectionService.focused);\n      this.selectionService.focus(this.selectionService.focused);\n      this.actionSheetSearchBar.focus();\n    }\n  }\n  _class22 = AutoCompleteComponent;\n  _defineProperty(AutoCompleteComponent, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(AutoCompleteComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class22,\n    selectors: [[\"kendo-autocomplete\"]],\n    contentQueries: function _class22_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class22_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(_c11, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class22_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-autocomplete\", ctx.widgetClasses)(\"k-input\", ctx.widgetClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      highlightFirst: \"highlightFirst\",\n      showStickyHeader: \"showStickyHeader\",\n      focusableId: \"focusableId\",\n      data: \"data\",\n      value: \"value\",\n      valueField: \"valueField\",\n      placeholder: \"placeholder\",\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      loading: \"loading\",\n      clearButton: \"clearButton\",\n      suggest: \"suggest\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\"\n    },\n    exportAs: [\"kendoAutoComplete\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.autocomplete'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => _class22)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class22)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 17,\n    vars: 30,\n    consts: function () {\n      let i18n_12;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.autocomplete.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_12 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13;\n      } else {\n        i18n_12 = $localize`:kendo.autocomplete.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_14;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.autocomplete.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15 = goog.getMsg(\"clear\");\n        i18n_14 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15;\n      } else {\n        i18n_14 = $localize`:kendo.autocomplete.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_16;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.autocomplete.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17 = goog.getMsg(\"Options list\");\n        i18n_16 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17;\n      } else {\n        i18n_16 = $localize`:kendo.autocomplete.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      return [[\"kendoAutoCompleteLocalizedMessages\", \"\", \"noDataText\", i18n_12, \"clearTitle\", i18n_14, \"popupLabel\", i18n_16], [\"kendoDropDownSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [\"kendoSearchbar\", \"\", 3, \"ariaExpanded\", \"isSuggestable\", \"isFilterable\", \"isLoading\", \"ariaControls\", \"id\", \"activeDescendant\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"isRequired\", \"placeholder\", \"inputAttributes\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\", \"click\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"visibility\", \"click\", \"mousedown\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"resize\", 4, \"ngIf\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"subtitle\", \"placeholder\", \"closePopup\", \"textInputChange\", \"navigate\"], [\"sharedPopupActionSheetTemplate\", \"\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"click\", \"mousedown\"], [\"name\", \"x\", 3, \"svgIcon\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"], [4, \"ngTemplateOutlet\"], [3, \"resize\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"showStickyHeader\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"]];\n    },\n    template: function _class22_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class22_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class22_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class22_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class22_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class22_kendo_separator_3_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵelementStart(4, \"input\", 4);\n        i0.ɵɵlistener(\"onNavigate\", function _class22_Template_input_onNavigate_4_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function _class22_Template_input_valueChange_4_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function _class22_Template_input_onBlur_4_listener() {\n          return ctx.handleInputBlur();\n        })(\"onFocus\", function _class22_Template_input_onFocus_4_listener() {\n          return ctx.handleInputFocus();\n        })(\"click\", function _class22_Template_input_click_4_listener() {\n          return ctx.handleClick();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, _class22_span_5_Template, 2, 4, \"span\", 5);\n        i0.ɵɵtemplate(6, _class22_span_6_Template, 1, 0, \"span\", 6);\n        i0.ɵɵtemplate(7, _class22_kendo_separator_7_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵtemplate(8, _class22_span_8_Template, 2, 1, \"span\", 7);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(9, _class22_ng_template_9_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(11, null, 9);\n        i0.ɵɵtemplate(13, _class22_kendo_resize_sensor_13_Template, 1, 0, \"kendo-resize-sensor\", 10);\n        i0.ɵɵelementStart(14, \"responsive-renderer\", 11);\n        i0.ɵɵlistener(\"closePopup\", function _class22_Template_responsive_renderer_closePopup_14_listener() {\n          return ctx.togglePopup(false);\n        })(\"textInputChange\", function _class22_Template_responsive_renderer_textInputChange_14_listener($event) {\n          return ctx.onFilterChange($event);\n        })(\"navigate\", function _class22_Template_responsive_renderer_navigate_14_listener($event) {\n          return ctx.handleNavigate($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(15, _class22_ng_template_15_Template, 5, 17, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r10 = i0.ɵɵreference(16);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ariaExpanded\", ctx.isOpen)(\"isSuggestable\", ctx.suggest)(\"isFilterable\", ctx.filterable)(\"isLoading\", ctx.isLoading)(\"ariaControls\", ctx.ariaControls)(\"id\", ctx.focusableId)(\"activeDescendant\", ctx.activeDescendant)(\"userInput\", ctx.text)(\"suggestedText\", ctx.suggestion)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.isAdaptive)(\"tabIndex\", ctx.tabIndex)(\"isRequired\", ctx.isControlRequired)(\"placeholder\", ctx.placeholder)(\"inputAttributes\", ctx.inputAttributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r10)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", true)(\"subtitle\", ctx.subtitle)(\"placeholder\", ctx.placeholder);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent],\n    encapsulation: 2\n  }));\n  return AutoCompleteComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst MultiselectMessages = {\n  'array': 'Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding',\n  'object': 'Expected values of Object type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-object-values',\n  'primitive': 'Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-primitive-values',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/data-binding/#toc-arrays-of-complex-data'\n};\n/**\n * @hidden\n */\nconst MultiSelectTreeMessages = {\n  'array': 'Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding',\n  'primitive': 'Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-primitive-values',\n  'object': 'Expected values of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-object-values',\n  'dataItems': 'Expected dataItems of type Object[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',\n  'dataItemsLength': 'Expected dataItems length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding',\n  'valueDepth': 'Expected valueDepth of type number[] to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth',\n  'valueDepthLength': 'Expected valueDepth length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth'\n};\n/**\n * @hidden\n */\nconst ComboBoxMessages = {\n  'object': 'Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-object-values',\n  'primitive': 'Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-primitive-values',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/data-binding/#toc-arrays-of-complex-data',\n  'noItemHeight': 'Expected virtual.itemHeight of type number.'\n};\n/**\n * @hidden\n */\nconst MultiColumnComboBoxMessages = {\n  'data': 'Provided data must consist only of objects. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/#toc-fields-configuration'\n};\n/**\n * @hidden\n */\nconst DropDownListMessages = {\n  'defaultItem': 'defaultItem and data items must be of same type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem',\n  'object': 'Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-object-values',\n  'primitive': 'Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-primitive-values',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/data-binding/#toc-arrays-of-complex-data'\n};\n/**\n * @hidden\n */\nconst DropDownTreeMessages = {\n  'primitive': 'Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-primitive-values',\n  'object': 'Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-object-values',\n  'dataItem': 'Expected dataItem of type Object to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-dataitem',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding',\n  'valueDepth': 'Expected valueDepth to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/DropDownTreeComponent/#toc-valuedepth'\n};\n\n/**\n * @hidden\n */\nconst COMBOBOX_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => ComboBoxComponent)\n};\nconst DEFAULT_SIZE$4 = 'medium';\nconst DEFAULT_ROUNDED$4 = 'medium';\nconst DEFAULT_FILL_MODE$4 = 'solid';\n/**\n * Represents the [Kendo UI ComboBox component for Angular]({% slug overview_combobox %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet ComboBoxComponent = /*#__PURE__*/(() => {\n  var _class23;\n  class ComboBoxComponent extends MultiTabStop {\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    /**\n     * @hidden\n     */\n\n    set text(text) {\n      this._text = isPresent(text) ? text.toString() : \"\";\n    }\n    get text() {\n      return this._text;\n    }\n    /**\n     * @hidden\n     */\n    get ariaControls() {\n      return this.isOpen ? this.listBoxId : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.formControl);\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      if (isDisabled || sameState) {\n        return;\n      }\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n    get activeDescendant() {\n      if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n        return null;\n      }\n      return this.optionPrefix + \"-\" + this.selectionService.focused;\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the ComboBox.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this.dataService.data = data || [];\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.setState();\n      if (this._filtering) {\n        const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;\n        const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;\n        this.selectionService.focused = index;\n      }\n      if (this.suggest && this.dataService.itemsCount && this.text) {\n        this.suggestedText = getter(this.dataService.itemAt(0), this.textField);\n      }\n    }\n    get data() {\n      const virtual = this.virtual;\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize;\n        // Use length instead of itemsCount because of the grouping.\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the ComboBox.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the dataset are considered custom values.\n     * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.\n     */\n    set value(newValue) {\n      this._value = newValue;\n      this.setState();\n      this.cdr.markForCheck();\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the data item field that represents the item text.\n     * If the data contains only primitive values, do not define it.\n     *\n     * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.\n     */\n\n    /**\n     * Specifies the type of the selected value.\n     * If set to `true`, the selected value has to be of the primitive type\n     * ([more information and example]({% slug valuebinding_combobox %}#toc-primitive-values-from-object-fields)).\n     */\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n      return this._valuePrimitive;\n    }\n    /**\n     * A user-defined callback which returns normalized custom values.\n     * Typically used when the data items are different from type `string`.\n     * @param { Any } value - The custom value defined by the user.\n     * @returns { Any }\n     *\n     * @example\n     * ```ts\n     * import { map } from 'rxjs/operators';\n     *\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *   <kendo-combobox\n     *       [allowCustom]=\"true\"\n     *       [data]=\"listItems\"\n     *       textField=\"text\"\n     *       valueField=\"value\"\n     *       [valueNormalizer]=\"valueNormalizer\"\n     *       (valueChange)=\"onValueChange($event)\"\n     *   >\n     *   </kendo-combobox>\n     * `\n     * })\n     *\n     * class AppComponent {\n     *   public listItems: Array<{ text: string, value: number }> = [\n     *       { text: \"Small\", value: 1 },\n     *       { text: \"Medium\", value: 2 },\n     *       { text: \"Large\", value: 3 }\n     *   ];\n     *\n     *   public onValueChange(value) {\n     *       console.log(\"valueChange : \", value);\n     *   }\n     *\n     *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n     *      return { ProductID: null, ProductName: text };\n     *   }));\n     *\n     * }\n     * ```\n     */\n\n    /**\n     * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n     * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n    */\n    set subtitle(_subtitle) {\n      this._subtitle = _subtitle;\n    }\n    get subtitle() {\n      return this._subtitle || this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n     * Configures the popup of the ComboBox.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Sets the read-only state of the component.\n     *\n     * @default false\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Enables the [filtering]({% slug filtering_combobox %}) functionality.\n     * If set to `true`, the component emits the `filterChange` event.\n     */\n\n    /**\n     * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.\n     */\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings, {\n        itemHeight: this.defaultVirtualItemHeight,\n        pageSize: this.defaultVirtualPageSize\n      });\n    }\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Fires each time the value is changed&mdash;\n     * when the component is blurred or the value is cleared through the **Clear** button\n     * ([see example](slug:events_combobox)).\n     * When the value of the component is programmatically changed to `ngModel` or `formControl`\n     * through its API or form binding, the `valueChange` event is not triggered because it\n     * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n     */\n\n    get isDisabled() {\n      return this.disabled;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    get dir() {\n      return this.direction;\n    }\n    get isFocused() {\n      return this._isFocused;\n    }\n    set isFocused(value) {\n      this.renderer[value ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, \"k-focus\");\n      this._isFocused = value;\n    }\n    get clearButtonVisiblity() {\n      if (touchEnabled) {\n        return 'visible';\n      }\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get isActionSheetExpanded() {\n      return this.actionSheet?.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    get popupWidth() {\n      let wrapperOffsetWidth = 0;\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      }\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get popupHeight() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, cdr, renderer, injector, hostElement, adaptiveService) {\n      super();\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n       */\n      _defineProperty(this, \"inputAttributes\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"selected\", []);\n      /**\n       * Shows or hides the current group sticky header when using grouped data.\n       * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).\n       */\n      _defineProperty(this, \"showStickyHeader\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Specifies whether the ComboBox allows user-defined values that are not present in the dataset\n       * ([more information and examples]({% slug custom_values_combobox %})).\n       * Defaults to `false`.\n       *\n       * The feature is not available when using adaptive mode.\n       */\n      _defineProperty(this, \"allowCustom\", false);\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * Sets the data item field that represents the item value.\n       * If the data contains only primitive values, do not define it.\n       *\n       * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      _defineProperty(this, \"valueNormalizer\", text => text.pipe(map(userInput => userInput)));\n      /**\n       * The hint that is displayed when the component is empty.\n       *\n       */\n      _defineProperty(this, \"placeholder\", \"\");\n      /**\n       * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n       */\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      _defineProperty(this, \"_listHeight\", 200);\n      /**\n       * Sets and gets the loading state of the ComboBox.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      /**\n       * Enables the auto-completion of the text based on the first data item.\n       */\n      _defineProperty(this, \"suggest\", false);\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n      _defineProperty(this, \"clearButton\", true);\n      /**\n       * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the articles on [ComboBox Forms Support](slug:formssupport_combobox#toc-managing-the-combobox-disabled-state-in-reactive-forms) and [MultiColumnComboBox Forms Support](slug:formssupport_multicolumncombobox#toc-managing-the-multicolumncombobox-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"filterable\", false);\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time an item selection is changed\n       * ([see example](slug:events_combobox)).\n       */\n      _defineProperty(this, \"selectionChange\", new EventEmitter());\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value\n       * ([see example](slug:events_combobox)).\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the ComboBox.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the ComboBox gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"escape\", new EventEmitter());\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"fixedGroupTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"searchbar\", void 0);\n      _defineProperty(this, \"optionsList\", void 0);\n      _defineProperty(this, \"select\", void 0);\n      _defineProperty(this, \"widgetClasses\", true);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"windowSize\", 'large');\n      _defineProperty(this, \"listBoxId\", `k-${guid()}`);\n      _defineProperty(this, \"optionPrefix\", `k-${guid()}`);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"onChangeCallback\", _ => {});\n      _defineProperty(this, \"onTouchedCallback\", _ => {});\n      /**\n       * Used for the default virtualization settings config.\n       */\n      _defineProperty(this, \"defaultVirtualItemHeight\", 28);\n      /**\n       * Used for the default virtualization settings config.\n       */\n      _defineProperty(this, \"defaultVirtualPageSize\", 50);\n      _defineProperty(this, \"valueSubscription\", void 0);\n      _defineProperty(this, \"_filtering\", false);\n      _defineProperty(this, \"_text\", '');\n      _defineProperty(this, \"filterText\", '');\n      _defineProperty(this, \"_open\", false);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_valuePrimitive\", void 0);\n      _defineProperty(this, \"_previousDataItem\", void 0);\n      _defineProperty(this, \"suggestedText\", void 0);\n      _defineProperty(this, \"backspacePressed\", void 0);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true\n      });\n      _defineProperty(this, \"_virtualSettings\", void 0);\n      _defineProperty(this, \"_subtitle\", void 0);\n      _defineProperty(this, \"popupMouseDownHandler\", event => event.preventDefault());\n      _defineProperty(this, \"customValueSubject\", new Subject());\n      _defineProperty(this, \"valueSubject\", new Subject());\n      _defineProperty(this, \"clearValueSubject\", new Subject());\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"touchstartDisposeHandler\", void 0);\n      _defineProperty(this, \"selectClickDisposeHandler\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.dataService = dataService;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      this.adaptiveService = adaptiveService;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.data = [];\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.attachStreams();\n      this.createValueStream();\n      this.subscribeTouchEvents();\n      this.attachSelectClickHandler();\n      this.setComponentClasses();\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      this.cdr.detectChanges();\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    createValueStream() {\n      const valueStream = this.valueSubject.pipe(filter(candidate => {\n        const current = getter(this.value, this.valueField);\n        const newValue = getter(candidate, this.valueField);\n        let newText = getter(candidate, this.textField);\n        if (!isPresent(this.value) && !isPresent(newValue)) {\n          return false;\n        }\n        if (isPresent(newText)) {\n          newText = newText.toString();\n        }\n        if (current === newValue && this.text === newText) {\n          this.clearFilter();\n          return false;\n        } else {\n          return true;\n        }\n      }), map(candidate => {\n        const newValue = getter(candidate, this.valueField);\n        const newText = getter(candidate, this.textField);\n        return {\n          dataItem: candidate,\n          text: newText,\n          value: this.valuePrimitive ? newValue : candidate\n        };\n      }));\n      const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));\n      const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {\n        this.loading = true;\n        this.disabled = true;\n        this.cdr.detectChanges();\n      }), filter(() => {\n        const hasChange = this.text !== getter(this.value, this.valueField);\n        this.loading = hasChange;\n        this.disabled = hasChange;\n        if (!hasChange) {\n          this.clearFilter();\n        }\n        return hasChange;\n      }), this.valueNormalizer, map(normalizedValue => {\n        return {\n          custom: true,\n          dataItem: normalizedValue,\n          text: this.text,\n          value: normalizedValue\n        };\n      }));\n      const disableCustomValueStream = customValueStreams[1].pipe(map(() => {\n        return {\n          custom: true,\n          dataItem: undefined,\n          text: undefined,\n          value: undefined\n        };\n      }));\n      const clearValueStream = this.clearValueSubject.pipe(map(() => ({\n        dataItem: undefined,\n        text: undefined,\n        value: undefined\n      })));\n      if (this.valueSubscription) {\n        this.valueSubscription.unsubscribe();\n      }\n      const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);\n      this.valueSubscription = merged.pipe(catchError(() => {\n        const selectionChanged = getter(this.dataItem, this.valueField) !== undefined;\n        this.dataItem = undefined;\n        this.value = undefined;\n        this.text = undefined;\n        this.loading = false;\n        this.disabled = false;\n        if (selectionChanged) {\n          this.selectionChange.emit(undefined);\n        }\n        this.emitValueChange();\n        this.createValueStream();\n        return of(null);\n      })).subscribe(state => {\n        const selectionChanged = getter(this.dataItem, this.valueField) !== getter(state.dataItem, this.valueField);\n        this.dataItem = state.dataItem;\n        this.value = state.value;\n        this.text = state.text;\n        this.loading = false;\n        this.disabled = false;\n        this.clearFilter();\n        if (state.custom) {\n          this.selectionService.focused = -1;\n        }\n        if (selectionChanged) {\n          const selectionArgs = state.custom ? undefined : this.dataItem;\n          this.selectionChange.emit(selectionArgs);\n        }\n        this.emitValueChange();\n      });\n    }\n    attachStreams() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      }));\n      this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end).pipe(filter(event => isPresent(event.index))).subscribe(event => this.navigate(event.index)));\n      this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));\n      this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));\n      this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n          this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);\n        }\n      }));\n      this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));\n      this.subs.add(this.navigationService.enter.pipe(tap(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n        }\n      })).subscribe(this.handleEnter.bind(this)));\n      this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(() => !this.isOpen))).pipe(tap(() => {\n        this._filtering = false;\n        this.togglePopup(false);\n      }), map(event => this.dataService.itemAt(event.indices[0]))).subscribe(dataItem => {\n        this.change(dataItem);\n      }));\n      this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), tap(() => this._filtering = false), map(event => this.dataService.itemAt(event.indices[0]))).subscribe(dataItem => {\n        const selectionChanged = getter(dataItem, this.valueField) !== getter(this.dataItem, this.valueField);\n        this.updateState({\n          dataItem\n        });\n        if (selectionChanged) {\n          this.selectionChange.emit(dataItem);\n        }\n      }));\n    }\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.subs.unsubscribe();\n      if (isPresent(this.valueSubscription)) {\n        this.valueSubscription.unsubscribe();\n      }\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n      if (this.selectClickDisposeHandler) {\n        this.selectClickDisposeHandler();\n      }\n    }\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes['data'] && changes['data'].isFirstChange();\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n      if (isChanged('valueNormalizer', changes)) {\n        this.createValueStream();\n      }\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.setState();\n      }\n    }\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * Focuses a specific item of the ComboBox based on a provided index.\n     * If null or invalid index is provided the focus will be removed.\n     */\n    focusItemAt(index) {\n      const isInRange = index >= 0 && index < this.data.length;\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(-1);\n      }\n    }\n    /**\n     * Focuses the ComboBox.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * Blurs the ComboBox.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet. If you use the `toggle` method to open or close the popup or actionSheet,\n     * the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n        this._toggle(shouldOpen);\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(this._open || this.isActionSheetExpanded);\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.togglePopup(true);\n      }\n    }\n    /**\n     * Resets the value of the ComboBox.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n      this.value = undefined;\n      this.clearState();\n      this.resetSelection();\n    }\n    /**\n     * @hidden\n     *\n     * Used by the TextBoxContainer to determine if the floating label\n     * should be rendered in the input when the component is not focused.\n     */\n    isEmpty() {\n      const textEmpty = !isPresent(this.text) || isEmptyString(this.text);\n      const valueEmpty = !isPresent(this.value) || isEmptyString(this.value);\n      return textEmpty && valueEmpty;\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    clearValue(event) {\n      event?.stopImmediatePropagation();\n      if (event) {\n        this.focus();\n      }\n      this._previousDataItem = undefined;\n      this.selectionService.resetSelection([]);\n      this.clearValueSubject.next();\n      this._filtering = false;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value === null ? undefined : value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}\n        `;\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n        this.cdr.detectChanges();\n      }\n      if (this.isOpen && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.popupWidth;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(ComboBoxMessages.primitive);\n      }\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(ComboBoxMessages.object);\n      }\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n      if (valueOrText) {\n        throw new Error(ComboBoxMessages.textAndValue);\n      }\n      if (this.virtual && isNaN(this.virtual.itemHeight)) {\n        throw new Error(ComboBoxMessages.noItemHeight);\n      }\n    }\n    setState() {\n      // Filtering in process, do nothing.\n      if (this._filtering) {\n        return;\n      }\n      const value = this.value;\n      const valueField = this.valueField;\n      const resolved = this.findDataItem({\n        valueField,\n        value\n      });\n      if (isPresent(resolved.index) && resolved.index !== -1) {\n        this.updateState({\n          dataItem: resolved.dataItem,\n          confirm: true\n        });\n        this.resetSelection(resolved.index);\n      } else if (isPresent(value) && this.allowCustom) {\n        this.updateState({\n          dataItem: value\n        });\n        this.resetSelection(-1);\n      } else if (this._previousDataItem && this.value) {\n        this.updateState({\n          dataItem: this._previousDataItem\n        });\n        this.resetSelection();\n      } else {\n        this.clearState();\n        this.resetSelection(-1);\n      }\n    }\n    updateState({\n      dataItem,\n      confirm = false\n    }) {\n      this.dataItem = dataItem;\n      this.text = getter(dataItem, this.textField);\n      if (confirm) {\n        this._previousDataItem = dataItem;\n      }\n    }\n    clearState() {\n      this.text = undefined;\n      this.dataItem = undefined;\n    }\n    resetSelection(index) {\n      const clear = !isPresent(index) || index < 0;\n      this.selectionService.resetSelection(clear ? [] : [index]);\n      this.selectionService.focused = index;\n    }\n    firstFocusableIndex(index) {\n      const maxIndex = this.data.length - 1;\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n    findIndexPredicate(text) {\n      if (this.dataService.grouped) {\n        return item => {\n          let itemText = getter(item.value, this.textField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      } else {\n        return item => {\n          let itemText = getter(item, this.textField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      }\n    }\n    findDataItem({\n      valueField,\n      value\n    }) {\n      const result = {\n        dataItem: null,\n        index: -1\n      };\n      const comparer = element => {\n        const dataItem = this.dataService.grouped ? element.value : element;\n        return getter(dataItem, valueField) === getter(value, valueField);\n      };\n      const index = this.dataService.findIndex(comparer);\n      result.dataItem = this.dataService.itemAt(index);\n      result.index = index;\n      return result;\n    }\n    search(text, startFrom = 0) {\n      const index = this.findIndex(text, startFrom);\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        if (index + 1 < this.dataService.itemsCount) {\n          this.search(text, index + 1);\n        } else {\n          this.selectionService.focus(-1);\n        }\n      } else {\n        this.selectionService.focus(index);\n        if (this.suggest) {\n          this.suggestedText = getter(this.dataService.itemAt(index), this.textField);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onAdaptiveTextBoxChange(text) {\n      if (this.filterable && this.filterText !== text) {\n        this.filterText = text;\n        this.filterChange.emit(text);\n      } else {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    getSuggestion() {\n      const hasSelected = !!this.selectionService.selected.length;\n      const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;\n      if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {\n        return this.suggestedText;\n      } else {\n        this.suggestedText = undefined;\n      }\n    }\n    navigate(index) {\n      if (this.dataService.itemsCount === 0) {\n        return;\n      }\n      this.text = getter(this.dataService.itemAt(index), this.textField);\n      this.selectionService.select(index);\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n      const hasSelected = isPresent(this.selectionService.selected[0]);\n      const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n      let offset = 0;\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      if (event.keyCode === Keys.Home || event.keyCode === Keys.End) {\n        return;\n      }\n      if (!hasSelected) {\n        if (event.keyCode === Keys.ArrowDown) {\n          offset = -1;\n        } else if (event.keyCode === Keys.ArrowUp) {\n          offset = 1;\n        }\n      }\n      const action = this.navigationService.process({\n        current: offset + focused,\n        max: this.dataService.itemsCount - 1,\n        min: 0,\n        originalEvent: event\n      });\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {\n        event.preventDefault();\n      }\n      if (action === NavigationAction.Tab && this.isActionSheetExpanded) {\n        event.stopImmediatePropagation();\n        this.togglePopup(false);\n      }\n    }\n    handleEnter() {\n      const text = this.text;\n      const focused = this.selectionService.focused;\n      const hasFocused = isPresent(focused) && focused !== -1;\n      const previousText = getter(this._previousDataItem, this.textField) || \"\";\n      const focusedItemText = getter(this.dataService.itemAt(focused), this.textField);\n      const textHasChanged = text !== previousText;\n      this.togglePopup(false);\n      this._filtering = false;\n      if (this.allowCustom && textHasChanged) {\n        if (text === focusedItemText || this.useSuggestion()) {\n          this.selectionService.change(focused);\n        } else {\n          this.change(text, true);\n        }\n      }\n      if (!this.allowCustom) {\n        if (hasFocused) {\n          this.selectionService.change(focused);\n        } else if (textHasChanged) {\n          this.change(text, true);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.zone.run(() => {\n        if (!this.isFocused && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      if (!this.isActionSheetExpanded) {\n        this._filtering = false;\n        this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers\n        this.isFocused = false;\n        const unresolvedSelection = getter(this.dataItem, this.valueField) !== getter(this.value, this.valueField);\n        const currentText = this.searchbar.value;\n        const textHasChanged = currentText !== (getter(this.dataItem, this.textField) || '');\n        const valueHasChanged = unresolvedSelection || textHasChanged;\n        const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement);\n        if (runInZone) {\n          this.zone.run(() => {\n            if (valueHasChanged) {\n              const lowerCaseMatch = isPresent(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();\n              if (lowerCaseMatch || unresolvedSelection) {\n                this.selectionService.change(this.selectionService.focused);\n              } else {\n                this.change(currentText, true);\n              }\n            }\n            this.onBlur.emit();\n            this.onTouchedCallback();\n            this.togglePopup(false);\n          });\n        } else {\n          this.togglePopup(false);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputBlur() {\n      if (!this.isActionSheetExpanded) {\n        this._filtering = false;\n        this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers\n        const unresolvedSelection = getter(this.dataItem, this.valueField) !== getter(this.value, this.valueField);\n        const currentText = this.searchbar.value;\n        const textHasChanged = currentText !== (getter(this.dataItem, this.textField) || '');\n        const valueHasChanged = unresolvedSelection || textHasChanged;\n        const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement) || this.formControl?.updateOn === 'blur';\n        if (runInZone) {\n          this.zone.run(() => {\n            if (valueHasChanged) {\n              const lowerCaseMatch = isPresent(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();\n              if (lowerCaseMatch || unresolvedSelection) {\n                this.selectionService.change(this.selectionService.focused);\n              } else {\n                this.change(currentText, true);\n              }\n            }\n            this.inputBlur.emit();\n            this.onTouchedCallback();\n            this.togglePopup(false);\n          });\n        } else {\n          this.togglePopup(false);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleEscape() {\n      this.isOpen ? this.togglePopup(false) : this.clearValue();\n      // clear the focus only if the focused item is not selected\n      const hasSelected = this.selectionService.selected.length > 0;\n      if (!hasSelected) {\n        this.suggestedText = null;\n        this.selectionService.focused = -1;\n      }\n      hasObservers(this.escape) && this.escape.emit();\n    }\n    /**\n     * @hidden\n     */\n    handleNavigationOpen() {\n      this.restoreItemFocus();\n      this.togglePopup(true);\n    }\n    /**\n     * @hidden\n     */\n    searchBarChange(text) {\n      const currentTextLength = this.text ? this.text.length : 0;\n      this.backspacePressed = text.length < currentTextLength ? true : false;\n      this.text = text;\n      // Reset the selection prior to filter. If a match is present, it will be resolved. If a match is not present, it is not needed.\n      this.selectionService.resetSelection([]);\n      this.togglePopup(true);\n      this._filtering = true;\n      if (this.filterable && this.filterText !== text) {\n        this.filterText = text;\n        this.filterChange.emit(text);\n      } else {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputFocus() {\n      this.handleFocus();\n      if (hasObservers(this.inputFocus)) {\n        this.zone.run(() => this.inputFocus.emit());\n      }\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n    change(candidate, isCustom = false) {\n      if (isCustom) {\n        this.customValueSubject.next(candidate);\n      } else {\n        this.valueSubject.next(candidate);\n        if (this.isActionSheetExpanded) {\n          this.togglePopup(false);\n        }\n      }\n    }\n    emitValueChange() {\n      this.onChangeCallback(this.value);\n      this.valueChange.emit(this.value);\n      this._previousDataItem = this.dataItem;\n    }\n    /**\n     * @hidden\n     */\n    selectClick() {\n      if (!touchEnabled) {\n        this.searchbar.focus();\n        this.isFocused = true;\n      }\n      if (!this.isOpen) {\n        this.restoreItemFocus();\n      }\n      this.togglePopup(!this.isOpen);\n    }\n    get listContainerClasses() {\n      return ['k-list-container', 'k-combobox-popup'].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n    preventEventDefault(event) {\n      event.preventDefault();\n    }\n    get focusedItemText() {\n      const focused = this.selectionService.focused;\n      if (!isPresent(focused) || focused === -1) {\n        return null;\n      }\n      const itemText = getter(this.dataService.itemAt(focused), this.textField);\n      return !isPresent(itemText) ? \"\" : itemText.toString();\n    }\n    /**\n     * Focuses the first match when there's text in the input field, but no focused item.\n     */\n    restoreItemFocus() {\n      const hasFocus = isPresent(this.selectionService.focused) && this.selectionService.focused > -1;\n      if (!hasFocus && this.text && this.dataService.itemsCount) {\n        if (this.filterable) {\n          this.selectionService.focused = this.firstFocusableIndex(0);\n        } else {\n          this.search(this.text);\n        }\n      }\n    }\n    useSuggestion() {\n      if (!(this.suggest && isPresent(this.searchbar.value))) {\n        return false;\n      }\n      const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);\n      const focusedItemText = getter(focusedDataItem, this.textField);\n      if (!isPresent(focusedItemText)) {\n        return false;\n      }\n      return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupClass: this.listContainerClasses,\n        positionMode: appendToComponent ? 'fixed' : 'absolute',\n        anchorAlign: anchorPosition,\n        popupAlign: popupPosition\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.popupWidth;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.popupHeight;\n      popupWrapper.setAttribute('dir', this.direction);\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.selectionService.focus(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n    }\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      }\n      if (this._open) {\n        this.windowSize = this.adaptiveService.size;\n        this.createPopup();\n      }\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    clearFilter() {\n      if (!(this.filterable && this.filterText)) {\n        return;\n      }\n      this.filterText = '';\n      this.filterChange.emit(this.filterText);\n    }\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !touchEnabled) {\n        return;\n      }\n      this.zone.runOutsideAngular(() =>\n      // Roll up ComboBox on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        const isInDropDown = inDropDown(this.wrapper, target, this.popupRef);\n        if (this.isFocused && !isInDropDown) {\n          // Close popup and mobile keyboard if searchbar is focused\n          this.zone.run(() => this.blur());\n        } else if (this.isOpen && !isInDropDown) {\n          // Close popup if the popup is opened via the select click\n          this.zone.run(() => this.togglePopup(false));\n        }\n      }));\n    }\n    attachSelectClickHandler() {\n      const selectElement = this.select.nativeElement;\n      const event = pointers ? 'pointerdown' : 'click';\n      this.selectClickDisposeHandler = this.renderer.listen(selectElement, event, this.selectClick.bind(this));\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n    findIndex(value, startFrom = 0) {\n      let index;\n      if (value && value.length && this.dataService.itemsCount) {\n        index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);\n      } else {\n        index = -1;\n      }\n      return index;\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      this.actionSheetSearchBar.value = '';\n      this.filterable && this.filterChange.emit('');\n      this.searchbar.input.nativeElement.focus();\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.actionSheet.toggle(true);\n      this.cdr.detectChanges();\n      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n      this.title = setActionSheetTitle(this.searchbar.input, this.title);\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.optionsList.scrollToItem(this.selectionService.focused);\n      this.selectionService.focus(this.selectionService.focused);\n      this.actionSheetSearchBar.focus();\n    }\n  }\n  _class23 = ComboBoxComponent;\n  _defineProperty(ComboBoxComponent, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(ComboBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class23,\n    selectors: [[\"kendo-combobox\"]],\n    contentQueries: function _class23_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class23_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(_c11, 5);\n        i0.ɵɵviewQuery(_c19, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.select = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class23_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-combobox\", ctx.widgetClasses)(\"k-input\", ctx.widgetClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      inputAttributes: \"inputAttributes\",\n      showStickyHeader: \"showStickyHeader\",\n      focusableId: \"focusableId\",\n      allowCustom: \"allowCustom\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valuePrimitive: \"valuePrimitive\",\n      valueNormalizer: \"valueNormalizer\",\n      placeholder: \"placeholder\",\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      loading: \"loading\",\n      suggest: \"suggest\",\n      clearButton: \"clearButton\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      selectionChange: \"selectionChange\",\n      filterChange: \"filterChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\",\n      escape: \"escape\"\n    },\n    exportAs: [\"kendoComboBox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.combobox'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => _class23)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class23)\n    }, {\n      provide: MultiTabStop,\n      useExisting: forwardRef(() => _class23)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 20,\n    vars: 38,\n    consts: function () {\n      let i18n_20;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.combobox.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_20 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21;\n      } else {\n        i18n_20 = $localize`:kendo.combobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_22;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.combobox.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23 = goog.getMsg(\"clear\");\n        i18n_22 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23;\n      } else {\n        i18n_22 = $localize`:kendo.combobox.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_24;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.combobox.selectButtonText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25 = goog.getMsg(\"Select\");\n        i18n_24 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25;\n      } else {\n        i18n_24 = $localize`:kendo.combobox.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n      let i18n_26;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.combobox.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27 = goog.getMsg(\"Options list\");\n        i18n_26 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27;\n      } else {\n        i18n_26 = $localize`:kendo.combobox.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      return [[\"kendoComboBoxLocalizedMessages\", \"\", \"noDataText\", i18n_20, \"clearTitle\", i18n_22, \"selectButtonText\", i18n_24, \"popupLabel\", i18n_26], [\"kendoDropDownSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [\"kendoSearchbar\", \"\", 3, \"ariaExpanded\", \"ariaControls\", \"id\", \"isLoading\", \"isSuggestable\", \"isFilterable\", \"activeDescendant\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"isRequired\", \"placeholder\", \"inputAttributes\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\", \"click\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"kendoEventsOutsideAngular\", \"click\", 4, \"ngIf\"], [\"class\", \"k-i-loading k-input-loading-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\", \"keydown.enter\"], [\"select\", \"\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [\"popupTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"subtitle\", \"placeholder\", \"closePopup\", \"textInputChange\", \"navigate\"], [\"sharedPopupActionSheetTemplate\", \"\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"kendoEventsOutsideAngular\", \"click\"], [\"name\", \"x\", 3, \"svgIcon\"], [1, \"k-i-loading\", \"k-input-loading-icon\", \"k-icon\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"], [4, \"ngTemplateOutlet\"], [3, \"resize\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"showStickyHeader\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"]];\n    },\n    template: function _class23_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class23_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class23_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class23_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class23_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class23_kendo_separator_3_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵelementStart(4, \"input\", 4);\n        i0.ɵɵlistener(\"onNavigate\", function _class23_Template_input_onNavigate_4_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function _class23_Template_input_valueChange_4_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function _class23_Template_input_onBlur_4_listener() {\n          return ctx.handleInputBlur();\n        })(\"onFocus\", function _class23_Template_input_onFocus_4_listener() {\n          return ctx.handleInputFocus();\n        })(\"click\", function _class23_Template_input_click_4_listener() {\n          return ctx.handleClick();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, _class23_span_5_Template, 2, 7, \"span\", 5);\n        i0.ɵɵtemplate(6, _class23_span_6_Template, 1, 0, \"span\", 6);\n        i0.ɵɵtemplate(7, _class23_kendo_separator_7_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵtemplate(8, _class23_span_8_Template, 2, 1, \"span\", 7);\n        i0.ɵɵelementStart(9, \"button\", 8, 9);\n        i0.ɵɵlistener(\"keydown.enter\", function _class23_Template_button_keydown_enter_9_listener($event) {\n          return $event.stopImmediatePropagation();\n        });\n        i0.ɵɵelement(11, \"kendo-icon-wrapper\", 10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(12, _class23_ng_template_12_Template, 1, 1, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, _class23_kendo_resize_sensor_14_Template, 1, 0, \"kendo-resize-sensor\", 12);\n        i0.ɵɵelementContainer(15, null, 13);\n        i0.ɵɵelementStart(17, \"responsive-renderer\", 14);\n        i0.ɵɵlistener(\"closePopup\", function _class23_Template_responsive_renderer_closePopup_17_listener() {\n          return ctx.togglePopup(false);\n        })(\"textInputChange\", function _class23_Template_responsive_renderer_textInputChange_17_listener($event) {\n          return ctx.onAdaptiveTextBoxChange($event);\n        })(\"navigate\", function _class23_Template_responsive_renderer_navigate_17_listener($event) {\n          return ctx.handleNavigate($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(18, _class23_ng_template_18_Template, 5, 17, \"ng-template\", null, 15, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r11 = i0.ɵɵreference(19);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ariaExpanded\", ctx.isOpen)(\"ariaControls\", ctx.ariaControls)(\"id\", ctx.focusableId)(\"isLoading\", ctx.loading)(\"isSuggestable\", ctx.suggest)(\"isFilterable\", ctx.filterable)(\"activeDescendant\", ctx.activeDescendant)(\"userInput\", ctx.text)(\"suggestedText\", ctx.getSuggestion())(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.isAdaptive)(\"tabIndex\", ctx.tabIndex)(\"isRequired\", ctx.isControlRequired)(\"placeholder\", ctx.placeholder)(\"inputAttributes\", ctx.inputAttributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton && !ctx.loading && !ctx.disabled && !ctx.readonly && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(36, _c28, ctx.preventEventDefault));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"))(\"disabled\", ctx.disabled ? \"\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"name\", ctx.icon || \"caret-alt-down\")(\"svgIcon\", ctx.svgIcon || ctx.caretAltDownIcon);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r11)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", true)(\"subtitle\", ctx.subtitle)(\"placeholder\", ctx.placeholder);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, ListComponent],\n    encapsulation: 2\n  }));\n  return ComboBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the selected value of the dropdown. To define the header template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>ValueTemplate` directive inside the component tag.\n *\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `ValueTemplate` directive can only be used with the DropDownList and DropDownTree components.\n *\n * - [Using `ValueTemplate` with the DropDownList]({% slug templates_ddl %}#toc-value-template)\n * - [Using `ValueTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-value-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *    <ng-template kendoDropDownListValueTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet ValueTemplateDirective = /*#__PURE__*/(() => {\n  var _class24;\n  class ValueTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class24 = ValueTemplateDirective;\n  _defineProperty(ValueTemplateDirective, \"\\u0275fac\", function _class24_Factory(t) {\n    return new (t || _class24)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(ValueTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class24,\n    selectors: [[\"\", \"kendoDropDownListValueTemplate\", \"\"], [\"\", \"kendoDropDownTreeValueTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ValueTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FilterInputDirective = /*#__PURE__*/(() => {\n  var _class25;\n  class FilterInputDirective {\n    constructor(element, zone) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"focused\", void 0);\n      this.element = element;\n      this.zone = zone;\n    }\n    ngOnChanges() {\n      if (this.focused) {\n        this.nextTick(() => this.element.nativeElement.focus());\n      }\n    }\n    nextTick(fn) {\n      this.zone.runOutsideAngular(() => setTimeout(fn));\n    }\n  }\n  _class25 = FilterInputDirective;\n  _defineProperty(FilterInputDirective, \"\\u0275fac\", function _class25_Factory(t) {\n    return new (t || _class25)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(FilterInputDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class25,\n    selectors: [[\"\", \"filterInput\", \"\"]],\n    inputs: {\n      focused: [\"filterInput\", \"focused\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return FilterInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst DROPDOWNLIST_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DropDownListComponent)\n};\nconst DEFAULT_SIZE$3 = 'medium';\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * Represents the [Kendo UI DropDownList component for Angular]({% slug overview_ddl %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet DropDownListComponent = /*#__PURE__*/(() => {\n  var _class26;\n  class DropDownListComponent {\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    get width() {\n      const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get widgetTabIndex() {\n      if (this.disabled) {\n        return undefined;\n      }\n      const providedTabIndex = Number(this.tabIndex);\n      const defaultTabIndex = 0;\n      return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n    get ariaActivedescendant() {\n      if (!isPresent(this.dataItem) || !this.isOpen) {\n        return;\n      }\n      return this.optionPrefix + \"-\" + this.selectionService.focused;\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n    onFilterChange(text) {\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    get ariaLive() {\n      return this.filterable ? 'polite' : 'off';\n    }\n    /**\n     * Shows or hides the current group sticky header when using grouped data.\n     * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).\n     */\n\n    /**\n     * Sets the data of the DropDownList.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n      this.dataService.data = data || [];\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.setState();\n    }\n    get data() {\n      const virtual = this.virtual;\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize;\n        // Use length instead of itemsCount because of the grouping.\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the DropDownList.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n    set value(newValue) {\n      if (!isPresent(newValue)) {\n        this._previousDataItem = undefined;\n      }\n      this._value = newValue;\n      this.setState();\n      this.cdr.markForCheck();\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the data item field that represents the item text.\n     * If the data contains only primitive values, do not define it.\n     *\n     * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.\n     */\n\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n    * @hidden\n    */\n\n    /**\n     * @hidden\n     */\n    get isActionSheetExpanded() {\n      return this.actionSheet?.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    /**\n     * Configures the popup of the DropDownList.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Sets the read-only state of the component.\n     *\n     * @default false\n     */\n\n    /**\n     * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.\n     */\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Enables a case-insensitive search. When filtration is disabled, use this option.\n     */\n\n    /**\n     * Specifies the type of the selected value\n     * ([more information and example]({% slug valuebinding_ddl %}#toc-primitive-values-from-object-fields)).\n     * If set to `true`, the selected value has to be of a primitive value.\n     */\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n      return this._valuePrimitive;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n      this._rounded = rounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Toggles the left and right arrow keys navigation functionality.\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    blurComponent(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      this.hostElementBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n    blurFilterInput() {\n      this.filterBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n    focusComponent(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      this.hostElementFocused.emit();\n      if (!this.isFocused) {\n        this.isFocused = true;\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n      }\n      if (this.isOpen && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    get isDisabledClass() {\n      return this.disabled || null;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    /**\n     * @hidden\n     */\n\n    get dir() {\n      return this.direction;\n    }\n    get hostTabIndex() {\n      return this.widgetTabIndex;\n    }\n    get readonlyClass() {\n      return this.readonly;\n    }\n    get readonlyAttr() {\n      return this.readonly ? '' : null;\n    }\n    get isBusy() {\n      return this.isLoading;\n    }\n    get hostAriaInvalid() {\n      return this.formControl ? this.formControl?.invalid.toString() : null;\n    }\n    /**\n     * @hidden\n     */\n    keydown(event, input) {\n      if (input) {\n        event.stopPropagation();\n      }\n      const firstIndex = isPresent(this.defaultItem) ? -1 : 0;\n      const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;\n      let offset = 0;\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      const isHomeEnd = event.keyCode === Keys.Home || event.keyCode === Keys.End;\n      const isFilterFocused = this.filterable && this.isFocused && this.isOpen;\n      if (isFilterFocused && isHomeEnd) {\n        return;\n      }\n      const hasSelected = isPresent(this.selectionService.selected[0]);\n      const focusedItemNotSelected = isPresent(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);\n      if (!hasSelected || focusedItemNotSelected) {\n        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowRight && this.leftRightArrowsNavigation) {\n          offset = -1;\n        } else if (event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowLeft && this.leftRightArrowsNavigation) {\n          offset = 1;\n        }\n      }\n      const eventData = event;\n      const action = this.navigationService.process({\n        current: focused + offset,\n        max: this.dataService.itemsCount - 1,\n        min: this.defaultItem ? -1 : 0,\n        originalEvent: eventData,\n        openOnSpace: !this.isOpen,\n        closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)\n      });\n      const leftRightKeys = action === NavigationAction.Left || action === NavigationAction.Right && this.leftRightArrowsNavigation;\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && action !== NavigationAction.SelectAll && !(leftRightKeys && this.filterable) && action !== NavigationAction.Enter //enter when popup is opened is handled before `handleEnter`\n      ) {\n        eventData.preventDefault();\n      }\n      if (action === NavigationAction.Tab && this.isActionSheetExpanded) {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n    keypress(event) {\n      if (this.disabled || this.readonly || this.filterable) {\n        return;\n      }\n      this.onKeyPress(event);\n    }\n    /**\n     * @hidden\n     */\n    click() {\n      if (!this.isActionSheetExpanded) {\n        this.focus();\n        this.togglePopup(!this.isOpen);\n      }\n    }\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n    get isFocused() {\n      return this._isFocused;\n    }\n    constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, cdr, injector, adaptiveService) {\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"touchEnabled\", touchEnabled);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"searchIcon\", searchIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"caretAltDownSVGIcon\", caretAltDownIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"customIconClass\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"showStickyHeader\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * Sets and gets the loading state of the DropDownList.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * Sets the data item field that represents the item value.\n       * If the data contains only primitive values, do not define it.\n       *\n       * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n       */\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      /**\n       * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n      */\n      _defineProperty(this, \"subtitle\", '');\n      _defineProperty(this, \"windowSize\", 'large');\n      _defineProperty(this, \"_listHeight\", 200);\n      /**\n       * Sets the text of the default empty item. The type of the defined value has to match the data type.\n       */\n      _defineProperty(this, \"defaultItem\", void 0);\n      /**\n       * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_ddl#toc-managing-the-dropdownlist-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.\n       */\n      _defineProperty(this, \"filterable\", false);\n      _defineProperty(this, \"ignoreCase\", true);\n      /**\n       * Sets the delay before an item search is performed. When filtration is disabled, use this option.\n       */\n      _defineProperty(this, \"delay\", 500);\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"leftRightArrowsNavigation\", true);\n      /**\n       * Fires each time the value is changed ([see example](slug:events_ddl)).\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user types in the input field\n       * ([see example](slug:events_ddl)).\n       * You can filter the source based on the passed filtration value.\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires each time the item selection is changed\n       * ([see example](slug:events_ddl)).\n       */\n      _defineProperty(this, \"selectionChange\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the DropDownList.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the DropDownList gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"fixedGroupTemplate\", void 0);\n      _defineProperty(this, \"valueTemplate\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"optionsList\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      _defineProperty(this, \"role\", 'combobox');\n      _defineProperty(this, \"haspopup\", 'listbox');\n      _defineProperty(this, \"groupIndices\", []);\n      _defineProperty(this, \"optionPrefix\", `k-${guid()}`);\n      _defineProperty(this, \"valueLabelId\", void 0);\n      _defineProperty(this, \"filterText\", '');\n      _defineProperty(this, \"listBoxId\", `k-${guid()}`);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"dataItem\", void 0);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"onTouchedCallback\", _ => {});\n      _defineProperty(this, \"onChangeCallback\", _ => {});\n      _defineProperty(this, \"popupMouseDownHandler\", void 0);\n      _defineProperty(this, \"word\", \"\");\n      _defineProperty(this, \"last\", \"\");\n      _defineProperty(this, \"typingTimeout\", void 0);\n      _defineProperty(this, \"filterFocused\", new EventEmitter());\n      _defineProperty(this, \"filterBlurred\", new EventEmitter());\n      _defineProperty(this, \"hostElementFocused\", new EventEmitter());\n      _defineProperty(this, \"hostElementBlurred\", new EventEmitter());\n      _defineProperty(this, \"touchstartDisposeHandler\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_open\", false);\n      _defineProperty(this, \"_previousDataItem\", void 0);\n      _defineProperty(this, \"_valuePrimitive\", void 0);\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true\n      });\n      _defineProperty(this, \"_virtualSettings\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.dataService = dataService;\n      this._zone = _zone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.injector = injector;\n      this.adaptiveService = adaptiveService;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.data = [];\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.subscribeFocusEvents();\n      this.popupMouseDownHandler = this.onMouseDown.bind(this);\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, \"tabindex\");\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n      if (this.ariaActivedescendant) {\n        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-activedescendant', this.ariaActivedescendant);\n      }\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      }));\n      this.assignAriaDescribedBy();\n      this.setComponentClasses();\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n      const value = this.value;\n      return !(value === 0 || value === false || value || this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n    onFilterFocus() {\n      this.filterFocused.emit();\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.subs.unsubscribe();\n      this.unSubscribeFocusEvents();\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes['data'] && changes['data'].isFirstChange();\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n      if (isChanged('defaultItem', changes, false)) {\n        this.disabledItemsService.defaultItem = this.defaultItem;\n      }\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive', 'defaultItem', 'itemDisabled'], changes, false)) {\n        this.setState();\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * Focuses a specific item of the DropDownList based on a provided index.\n     * If there is a default item it is positioned at index -1.\n     * If null or invalid index is provided the focus will be removed.\n     */\n    focusItemAt(index) {\n      const minIndex = isPresent(this.defaultItem) ? -1 : 0;\n      const isInRange = minIndex <= index && index < this.data.length;\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(null);\n      }\n    }\n    /**\n     * Focuses the DropDownList.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownList.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet\n     * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"Expression has changed...\" type error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n        this._toggle(shouldOpen);\n      });\n    }\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      }\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      if (isDisabled || sameState) {\n        return;\n      }\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n      if (!isDefaultPrevented) {\n        if (!open && this.filterable && this.isFocused) {\n          this.focus();\n        }\n        this._toggle(open);\n      }\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(this._open || this.isActionSheetExpanded);\n    }\n    /**\n     * Resets the value of the DropDownList.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n      this.value = undefined;\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value === null ? undefined : value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get optionLabelSizeClass() {\n      return `${this.size ? getSizeClass('list', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-dropdownlist-popup'];\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n    get isDisabledDefaultItem() {\n      return this.disabledItemsService.isItemDisabled(this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n    getText() {\n      return this.text;\n    }\n    /**\n     * @hidden\n     */\n    getDefaultItemText() {\n      return getter(this.defaultItem, this.textField);\n    }\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        popupClass: this.listContainerClasses,\n        positionMode: appendToComponent ? 'fixed' : 'absolute'\n      });\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-controls', this.listBoxId);\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute('dir', this.direction);\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      const listBox = popupWrapper.querySelector('ul.k-list-ul');\n      const ariaLabel = this.wrapper.nativeElement.getAttribute('aria-labelledby');\n      if (ariaLabel) {\n        listBox.setAttribute('aria-labelledby', ariaLabel);\n      }\n      this.subs.add(this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);\n        this.setAriaactivedescendant();\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.selectionService.focus(this.selectionService.focused);\n        this.opened.emit();\n      }));\n      this.subs.add(this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      }));\n      if (!this.filterable) {\n        this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));\n      }\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'aria-controls');\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'aria-activedescendant');\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    updateState({\n      dataItem,\n      confirm = false\n    }) {\n      this.dataItem = dataItem;\n      this.text = getter(dataItem, this.textField);\n      if (confirm) {\n        this._previousDataItem = dataItem;\n      }\n    }\n    clearState() {\n      this.text = undefined;\n      this.dataItem = undefined;\n    }\n    resetSelection(index) {\n      const clear = !isPresent(index);\n      this.selectionService.resetSelection(clear ? [] : [index]);\n      this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;\n    }\n    onSelectionChange({\n      dataItem\n    }) {\n      this.updateState({\n        dataItem\n      });\n      this.selectionChange.emit(dataItem);\n      // reassigning the value label ID as aria-deascibedby forces firefox/nvda, forefox/jaws to read\n      // the new value when the popup is closed and the value is changed with the arrow keys (up/down)\n      this.assignAriaDescribedBy();\n      this.setAriaactivedescendant();\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      // Item selection when the popup is open.\n      this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), map(this.itemFromEvent.bind(this))).subscribe(this.onSelectionChange.bind(this)));\n      // Item selection when the popup is closed | clicked | enter, and so on.\n      this.subs.add(merge(this.selectionService.onSelect.pipe(filter(() => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(() => this.togglePopup(false))).subscribe(({\n        dataItem,\n        value: newValue,\n        newSelection\n      }) => {\n        if (newSelection) {\n          this.onSelectionChange({\n            dataItem\n          });\n        }\n        const shouldUsePrevious = !isPresent(dataItem) && this._previousDataItem;\n        const shouldUseNewValue = newValue !== getter(this.value, this.valueField);\n        if (shouldUsePrevious) {\n          this.updateState({\n            dataItem: this._previousDataItem\n          });\n          this.resetSelection();\n        } else if (shouldUseNewValue) {\n          this.value = this.valuePrimitive ? newValue : dataItem;\n          this._previousDataItem = dataItem;\n          this.emitChange(this.value);\n        }\n        this.clearFilter();\n      }));\n      this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.right.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end).pipe(filter(event => !isNaN(event.index))).subscribe(event => this.selectionService.select(event.index)));\n      this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n          this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);\n        }\n      }));\n      this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));\n      this.subs.add(this.navigationService.close.subscribe(() => {\n        this.togglePopup(false);\n        this.focus();\n      }));\n      this.subs.add(this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(this.handleEnter.bind(this)));\n      this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));\n      this.subs.add(this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.hostElementFocused)))).subscribe(() => {\n        this.hostElementBlurred.emit();\n      }));\n      this._zone.runOutsideAngular(() => {\n        this.subs.add(merge(this.hostElementBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap(event => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused)).subscribe(() => this.componentBlur()));\n      });\n    }\n    setAriaactivedescendant() {\n      if (this.ariaActivedescendant) {\n        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-activedescendant', this.ariaActivedescendant);\n        const searchInput = this.popupRef?.popupElement.querySelector('input[role=\"searchbox\"]') || this.actionSheetSearchBar?.input.nativeElement;\n        if (searchInput) {\n          this.renderer.setAttribute(searchInput, 'aria-activedescendant', this.ariaActivedescendant);\n        }\n      }\n    }\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n      this._zone.runOutsideAngular(() =>\n      // Roll up DropDownList on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            if (this.filterFocused) {\n              // Close popup if filter is focused\n              this.togglePopup(false);\n            }\n            this.blur();\n          });\n        }\n      }));\n    }\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.focusComponent = this.focusComponent.bind(this);\n        this.blurComponent = this.blurComponent.bind(this);\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.focusComponent, useCapture);\n          document.addEventListener('blur', this.blurComponent, useCapture);\n        });\n      }\n    }\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.focusComponent, useCapture);\n        document.removeEventListener('blur', this.blurComponent, useCapture);\n      }\n    }\n    itemFromEvent(event) {\n      const index = event.indices[0];\n      let dataItem = this.dataService.itemAt(index);\n      dataItem = isPresent(dataItem) ? dataItem : this.currentOrDefault(index);\n      const value = getter(dataItem, this.valueField);\n      const newSelection = event.newSelection;\n      return {\n        dataItem,\n        index,\n        newSelection,\n        value\n      };\n    }\n    currentOrDefault(selectedIndex) {\n      const defaultItemIndex = -1;\n      if (isPresent(this.dataItem) && selectedIndex !== defaultItemIndex) {\n        return this.dataItem;\n      } else {\n        return this.defaultItem;\n      }\n    }\n    firstFocusableIndex(index) {\n      const maxIndex = this.dataService.itemsCount - 1;\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n    handleEnter() {\n      if (this.isOpen) {\n        this.selectionService.change(this.selectionService.focused);\n        this.focus();\n      } else {\n        this.togglePopup(true);\n      }\n    }\n    handleEscape() {\n      if (isPresent(this.selectionService.selected[0])) {\n        this.selectionService.change(this.selectionService.selected[0]);\n      } else {\n        this.togglePopup(false);\n        this.clearFilter();\n      }\n      this.focus();\n    }\n    clearFilter() {\n      if (!(this.filterable && this.filterText)) {\n        return;\n      }\n      this.filterText = \"\";\n      this.cdr.markForCheck();\n      this.filterChange.emit(this.filterText);\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (this.defaultItem && this.valueField && typeof this.defaultItem !== \"object\") {\n        throw new Error(DropDownListMessages.defaultItem);\n      }\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(DropDownListMessages.primitive);\n      }\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(DropDownListMessages.object);\n      }\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n      if (valueOrText) {\n        throw new Error(DropDownListMessages.textAndValue);\n      }\n    }\n    componentBlur() {\n      if (!this.isActionSheetExpanded) {\n        this.isFocused = false;\n        const selectionPresent = isPresent(this.selectionService.selected[0]);\n        const valueHasChanged = selectionPresent && getter(this.value, this.valueField) !== getter(this.dataService.itemAt(this.selectionService.selected[0]), this.valueField);\n        if (valueHasChanged || hasObservers(this.close) || hasObservers(this.onBlur) || hasObservers(this.filterChange) || isUntouched(this.wrapper.nativeElement) || this.formControl?.updateOn === 'blur') {\n          this._zone.run(() => {\n            if (valueHasChanged) {\n              this.selectionService.change(this.selectionService.selected[0]);\n            }\n            this.togglePopup(false);\n            this.clearFilter();\n            this.onBlur.emit();\n            this.onTouchedCallback();\n          });\n        } else {\n          this.togglePopup(false);\n          //this is needed for Ang 18 not to throw ng0100 error when closing the popup\n          //the component could be refactored using kendoDropDownSharedEvents directive\n          //once we are able to debug against Angular 18\n          this.cdr.markForCheck();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onMouseDown(event) {\n      const tagName = event.target.tagName.toLowerCase();\n      if (tagName !== \"input\") {\n        event.preventDefault();\n      }\n    }\n    onKeyPress(event) {\n      if (event.which === 0 || event.keyCode === Keys.Enter) {\n        return;\n      }\n      let character = String.fromCharCode(event.charCode || event.keyCode);\n      if (this.ignoreCase) {\n        character = character.toLowerCase();\n      }\n      if (character === \" \") {\n        event.preventDefault();\n      }\n      this.word += character;\n      this.last = character;\n      this.search();\n    }\n    search() {\n      clearTimeout(this.typingTimeout);\n      if (!this.filterable) {\n        this.typingTimeout = setTimeout(() => {\n          this.word = \"\";\n        }, this.delay);\n        this.selectNext();\n      }\n    }\n    selectNext() {\n      let data = this.dataService.filter(item => isPresent(item) && !item.header && !this.disabledItemsService.isItemDisabled(item)).map(item => {\n        if (this.dataService.grouped) {\n          return {\n            item: item.value,\n            itemIndex: item.offsetIndex\n          };\n        }\n        return {\n          item: item,\n          itemIndex: this.dataService.indexOf(item)\n        };\n      });\n      const isInLoop = sameCharsOnly(this.word, this.last);\n      let dataLength = data.length;\n      const hasSelected = !isNaN(this.selectionService.selected[0]);\n      let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];\n      let text, index, defaultItem;\n      if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {\n        defaultItem = {\n          item: this.defaultItem,\n          itemIndex: -1\n        };\n        dataLength += 1;\n        startIndex += 1;\n      }\n      startIndex += isInLoop && hasSelected ? 1 : 0;\n      data = shuffleData(data, startIndex, defaultItem);\n      index = 0;\n      for (; index < dataLength; index++) {\n        text = getter(data[index].item, this.textField);\n        const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));\n        const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));\n        if (loopMatch || nextMatch) {\n          index = data[index].itemIndex;\n          break;\n        }\n      }\n      if (index !== dataLength) {\n        this.navigate(index);\n      }\n    }\n    emitChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n    navigate(index) {\n      this.selectionService.select(index);\n    }\n    findDataItem({\n      valueField,\n      value\n    }) {\n      const result = {\n        dataItem: null,\n        index: -1\n      };\n      const prop = dataItem => getter(dataItem, valueField);\n      let comparer;\n      if (this.dataService.grouped) {\n        comparer = element => {\n          return prop(element.value) === prop(value);\n        };\n      } else {\n        comparer = element => {\n          return prop(element) === prop(value);\n        };\n      }\n      const index = this.dataService.findIndex(comparer);\n      result.dataItem = this.dataService.itemAt(index);\n      result.index = index;\n      return result;\n    }\n    setState() {\n      const value = this.value;\n      const valueField = this.valueField;\n      const textField = this.textField;\n      const primitive = this.valuePrimitive;\n      if (this.defaultItem) {\n        const defaultValue = getter(this.defaultItem, valueField);\n        const currentValue = getter(value, valueField);\n        if (!isPresent(value) || currentValue === defaultValue) {\n          this.updateState({\n            dataItem: this.defaultItem,\n            confirm: true\n          });\n          this.resetSelection(-1);\n          if (this.filterable && this.filterText && this.dataService.itemsCount) {\n            this.selectionService.focused = this.firstFocusableIndex(0);\n          }\n          return;\n        }\n      }\n      const resolved = this.findDataItem({\n        valueField,\n        value\n      });\n      // The data and value are of same shape,\n      // for example, value: 'foo', data: ['foo', 'bar']\n      // or value: { value: 1, text: 'foo' }, data: [{ value: 1, text: 'foo' }].\n      const ofSameType = !(primitive && textField);\n      if (resolved.dataItem) {\n        this.updateState({\n          dataItem: resolved.dataItem,\n          confirm: true\n        });\n        this.resetSelection(resolved.index);\n      } else if (isPresent(value) && ofSameType) {\n        this.updateState({\n          dataItem: value\n        });\n        this.resetSelection();\n      } else if (this._previousDataItem) {\n        this.updateState({\n          dataItem: this._previousDataItem\n        });\n        this.resetSelection();\n      } else {\n        this.clearState();\n        this.resetSelection();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFilter(event) {\n      this.filterChange.emit(event.target.value);\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.togglePopup(true);\n      }\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n    assignAriaDescribedBy() {\n      const currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || '';\n      const trimmed = currentValue.replace(this.valueLabelId, '').trim();\n      // reset the value label ID to force readers to read the new value\n      this.valueLabelId = `k-${guid()}`;\n      // add to the current value - don't replace it\n      const newValue = `${this.valueLabelId} ${trimmed}`.trim();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      }\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'aria-controls');\n      if (this.filterable) {\n        this.actionSheetSearchBar.value = '';\n        this.filterChange.emit('');\n      }\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.actionSheet.toggle(true);\n      this.cdr.detectChanges();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-controls', this.listBoxId);\n      setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);\n      this.setAriaactivedescendant();\n      this.title = setActionSheetTitle(this.wrapper, this.title);\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.optionsList.scrollToItem(this.selectionService.focused);\n      this.selectionService.focus(this.selectionService.focused);\n      if (this.filterable) {\n        this.actionSheetSearchBar.focus();\n      }\n    }\n  }\n  _class26 = DropDownListComponent;\n  _defineProperty(DropDownListComponent, \"\\u0275fac\", function _class26_Factory(t) {\n    return new (t || _class26)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(DropDownListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class26,\n    selectors: [[\"kendo-dropdownlist\"]],\n    contentQueries: function _class26_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class26_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(_c11, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 19,\n    hostBindings: function _class26_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function _class26_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keypress\", function _class26_keypress_HostBindingHandler($event) {\n          return ctx.keypress($event);\n        })(\"click\", function _class26_click_HostBindingHandler() {\n          return ctx.click();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabledClass)(\"id\", ctx.focusableId)(\"dir\", ctx.dir)(\"tabindex\", ctx.hostTabIndex)(\"readonly\", ctx.readonlyAttr)(\"aria-busy\", ctx.isBusy)(\"role\", ctx.role)(\"aria-haspopup\", ctx.haspopup)(\"aria-invalid\", ctx.hostAriaInvalid);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-dropdownlist\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabledClass)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      customIconClass: \"customIconClass\",\n      showStickyHeader: \"showStickyHeader\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      loading: \"loading\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      defaultItem: \"defaultItem\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      ignoreCase: \"ignoreCase\",\n      delay: \"delay\",\n      valuePrimitive: \"valuePrimitive\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      leftRightArrowsNavigation: \"leftRightArrowsNavigation\",\n      focusableId: [\"id\", \"focusableId\"]\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\",\n      selectionChange: \"selectionChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoDropDownList\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdownlist'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => _class26)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class26)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 16,\n    vars: 19,\n    consts: function () {\n      let i18n_29;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.dropdownlist.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_29 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30;\n      } else {\n        i18n_29 = $localize`:kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_31;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.dropdownlist.selectButtonText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_32 = goog.getMsg(\"Select\");\n        i18n_31 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_32;\n      } else {\n        i18n_31 = $localize`:kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n      let i18n_33;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the filter input\n         * @meaning kendo.dropdownlist.filterInputLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_34 = goog.getMsg(\"Filter\");\n        i18n_33 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_34;\n      } else {\n        i18n_33 = $localize`:kendo.dropdownlist.filterInputLabel|The text set as aria-label on the filter input:Filter`;\n      }\n      let i18n_35;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.dropdownlist.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_36 = goog.getMsg(\"Options list\");\n        i18n_35 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_36;\n      } else {\n        i18n_35 = $localize`:kendo.dropdownlist.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      return [[\"kendoDropDownListLocalizedMessages\", \"\", \"noDataText\", i18n_29, \"selectButtonText\", i18n_31, \"filterInputLabel\", i18n_33, \"popupLabel\", i18n_35], [\"unselectable\", \"on\", 1, \"k-input-inner\", 3, \"id\", \"click\"], [1, \"k-input-value-text\"], [4, \"ngIf\"], [3, \"ngIf\"], [\"class\", \"k-i-loading k-input-loading-icon k-icon\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [\"unselectable\", \"on\", \"innerCssClass\", \"k-button-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [\"popupTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"subtitle\", \"closePopup\", \"textInputChange\"], [\"sharedPopupActionSheetTemplate\", \"\"], [3, \"templateContext\"], [1, \"k-i-loading\", \"k-input-loading-icon\", \"k-icon\"], [4, \"ngTemplateOutlet\"], [3, \"resize\"], [3, \"id\", \"size\", \"rounded\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"ariaLive\", \"showStickyHeader\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\", 3, \"click\"], [1, \"k-searchbox\", \"k-input\", 3, \"ngClass\"], [\"innerCssClass\", \"k-input-icon\", \"name\", \"search\", 1, \"k-icon\", 3, \"svgIcon\"], [\"role\", \"searchbox\", \"aria-autocomplete\", \"list\", \"aria-haspopup\", \"listbox\", \"tabindex\", \"-1\", 1, \"k-input-inner\", 3, \"filterInput\", \"dir\", \"ngModel\", \"ngModelChange\", \"keydown\", \"input\", \"focus\", \"blur\", \"click\"], [\"searchInput\", \"\"], [1, \"k-list\", 3, \"ngClass\"], [\"kendoDropDownsSelectable\", \"\", 1, \"k-list-optionlabel\", 3, \"ngClass\", \"index\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"]];\n    },\n    template: function _class26_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵlistener(\"click\", function _class26_Template_span_click_1_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelementStart(2, \"span\", 2);\n        i0.ɵɵtemplate(3, _class26_3_Template, 1, 4, null, 3);\n        i0.ɵɵtemplate(4, _class26_ng_template_4_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(5, _class26_span_5_Template, 1, 0, \"span\", 5);\n        i0.ɵɵelementStart(6, \"button\", 6);\n        i0.ɵɵelement(7, \"kendo-icon-wrapper\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, _class26_ng_template_8_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, _class26_kendo_resize_sensor_10_Template, 1, 0, \"kendo-resize-sensor\", 9);\n        i0.ɵɵelementContainer(11, null, 10);\n        i0.ɵɵelementStart(13, \"responsive-renderer\", 11);\n        i0.ɵɵlistener(\"closePopup\", function _class26_Template_responsive_renderer_closePopup_13_listener() {\n          return ctx.togglePopup(false);\n        })(\"textInputChange\", function _class26_Template_responsive_renderer_textInputChange_13_listener($event) {\n          return ctx.onFilterChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(14, _class26_ng_template_14_Template, 8, 21, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r7 = i0.ɵɵreference(15);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.valueLabelId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(17, _c28, ctx.onMouseDown));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"))(\"disabled\", ctx.disabled ? \"\" : null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"name\", ctx.icon || \"caret-alt-down\")(\"customFontClass\", ctx.customIconClass)(\"svgIcon\", ctx.svgIcon || ctx.caretAltDownSVGIcon);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r7)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", ctx.filterable)(\"subtitle\", ctx.subtitle);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgIf, TemplateContextDirective, NgClass, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ResponsiveRendererComponent, ReactiveFormsModule, i8.DefaultValueAccessor, i8.NgControlStatus, FilterInputDirective, FormsModule, i8.NgModel, SelectableDirective, ListComponent],\n    encapsulation: 2\n  }));\n  return DropDownListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the content of the custom list item in the MultiSelect\n * ([see example](slug:templates_multiselect#toc-rendering-custom-item-content)).\n * The template context is set to the current component.\n * To get a reference to the current text that is typed by the\n * user, use the `let-customItem` directive.\n *\n * > The `CustomItemTemplate` directive can only be used with the MultiSelect component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\" [allowCustom]=\"true\">\n *    <ng-template kendoMultiSelectCustomItemTemplate let-customItem>\n *      <span>New Item: {{customItem}}</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n *\n */\nlet CustomItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class27;\n  class CustomItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class27 = CustomItemTemplateDirective;\n  _defineProperty(CustomItemTemplateDirective, \"\\u0275fac\", function _class27_Factory(t) {\n    return new (t || _class27)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(CustomItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class27,\n    selectors: [[\"\", \"kendoMultiSelectCustomItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return CustomItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the selected tag value of the MultiSelect\n * ([see example]({% slug templates_multiselect %}#toc-tag-template)).\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `TagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"items\">\n *    <ng-template kendoMultiSelectTagTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet TagTemplateDirective = /*#__PURE__*/(() => {\n  var _class28;\n  class TagTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class28 = TagTemplateDirective;\n  _defineProperty(TagTemplateDirective, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(TagTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class28,\n    selectors: [[\"\", \"kendoMultiSelectTagTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeTagTemplate\", \"\"]],\n    standalone: true\n  }));\n  return TagTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the grouped tag values in the MultiSelect\n * ([see example]({% slug summarytagmode_multiselect %})).\n * The template context is set to the current component.\n * To get a reference to the current grouped\n * data items collection, use the `let-dataItems` directive.\n *\n * > The `GroupTagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"items\">\n *    <ng-template kendoMultiSelectGroupTagTemplate let-dataItems>\n *      <span>{{dataItems.length}} item(s) selected</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet GroupTagTemplateDirective = /*#__PURE__*/(() => {\n  var _class29;\n  class GroupTagTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class29 = GroupTagTemplateDirective;\n  _defineProperty(GroupTagTemplateDirective, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(GroupTagTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class29,\n    selectors: [[\"\", \"kendoMultiSelectGroupTagTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeGroupTagTemplate\", \"\"]],\n    standalone: true\n  }));\n  return GroupTagTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `removeTag` event. The `removeTag` event fires when a tag is about\n * to the removed. If you cancel the event, the removal is prevented.\n */\nclass RemoveTagEvent extends PreventableEvent {\n  /**\n   * Constructs the event arguments for the `remove` event.\n   * @param dataItem - The data item or an array of data items that will be removed.\n   */\n  constructor(dataItem) {\n    super();\n    /**\n     * The data item or an array of data items that will be removed.\n     */\n    _defineProperty(this, \"dataItem\", void 0);\n    this.dataItem = dataItem;\n  }\n}\n\n/**\n * @hidden\n */\nconst normalizeCheckboxesSettings = settings => {\n  if (isObject(settings)) {\n    const defaultSettings = {\n      enabled: true,\n      checkOnClick: true\n    };\n    return Object.assign({}, defaultSettings, settings);\n  }\n  return {\n    enabled: Boolean(settings),\n    checkOnClick: true\n  };\n};\n\n/**\n * @hidden\n */\nlet TagListComponent = /*#__PURE__*/(() => {\n  var _class31;\n  class TagListComponent {\n    set size(size) {\n      this.renderer.removeClass(this.hostElement.nativeElement, getSizeClass('chip-list', this.size));\n      if (size) {\n        this.renderer.addClass(this.hostElement.nativeElement, getSizeClass('chip-list', size));\n      }\n      this._size = size;\n    }\n    get size() {\n      return this._size;\n    }\n    get hostId() {\n      return this.id;\n    }\n    constructor(renderer, hostElement) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xCircleIcon\", xCircleIcon);\n      _defineProperty(this, \"tags\", void 0);\n      _defineProperty(this, \"textField\", void 0);\n      _defineProperty(this, \"valueField\", void 0);\n      _defineProperty(this, \"valueDepth\", void 0);\n      _defineProperty(this, \"focused\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"disabled\", void 0);\n      _defineProperty(this, \"tagPrefix\", void 0);\n      _defineProperty(this, \"id\", void 0);\n      _defineProperty(this, \"rounded\", 'medium');\n      _defineProperty(this, \"fillMode\", 'solid');\n      /**\n       * A collection with the disabled tags' indices.\n       */\n      _defineProperty(this, \"disabledIndices\", new Set());\n      _defineProperty(this, \"removeTag\", new EventEmitter());\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"taglistRole\", 'listbox');\n      _defineProperty(this, \"multiselectable\", true);\n      _defineProperty(this, \"_size\", 'medium');\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n    }\n    tagProp(tag, prop, index) {\n      const propField = prop && this.getPropField(tag, prop, index);\n      return getter(tag, propField);\n    }\n    isTagDisabled(tag, positionIndex) {\n      if (this.isGroupTag(tag)) {\n        /** The `positionIndex` is used to determine after how many single tags is the group tag displayed =>\n         * => it is used to increment the indices inside the group tag so that we determine the actual position index\n         * of each group tag item as they appear in the `value` (important to check against `disabledIndices`)\n         * e.g. `disabledIndices = [0, 1]` && `tags = ['Small', ['Medium', 'Large']]` => without the incrementation with\n         * `positionIndex`, the group tag would yield [0, 1] as indices, while it should yield [1, 2]\n         */\n        return tag.every((_tag, index) => this.disabledIndices.has(index + positionIndex));\n      }\n      return this.disabledIndices.has(positionIndex);\n    }\n    deleteTag(event, tag, index) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      if (!this.disabled && event.which === 1) {\n        this.removeTag.emit({\n          tag,\n          index\n        });\n      }\n    }\n    itemId(tag, index) {\n      if (tag) {\n        //because of custom values\n        return this.tagPrefix + \"-\" + index;\n      }\n    }\n    isGroupTag(tag) {\n      return tag instanceof Array;\n    }\n    tagAriaHidden(index) {\n      return isPresent(this.focused) && this.focused !== index;\n    }\n    getPropField(tag, prop, index) {\n      // Needed for MultiSelectTree value binding (Heterogeneous Data)\n      const fieldsCount = prop.length - 1;\n      if (typeof prop === 'string') {\n        return prop;\n      } else if (this.valueDepth) {\n        const depth = this.valueDepth[index];\n        return fieldsCount < depth ? prop[fieldsCount] : prop[depth];\n      } else {\n        return prop.find(item => item in tag);\n      }\n    }\n  }\n  _class31 = TagListComponent;\n  _defineProperty(TagListComponent, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(TagListComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class31,\n    selectors: [[\"kendo-taglist\"]],\n    hostVars: 5,\n    hostBindings: function _class31_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.hostId)(\"role\", ctx.taglistRole)(\"aria-multiselectable\", ctx.multiselectable);\n        i0.ɵɵclassProp(\"k-chip-list\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      tags: \"tags\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      focused: \"focused\",\n      template: \"template\",\n      groupTemplate: \"groupTemplate\",\n      disabled: \"disabled\",\n      tagPrefix: \"tagPrefix\",\n      id: \"id\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      disabledIndices: \"disabledIndices\"\n    },\n    outputs: {\n      removeTag: \"removeTag\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c39,\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"k-chip\", 3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-chip\", 3, \"ngClass\"], [1, \"k-chip-content\"], [4, \"ngIf\", \"ngIfThen\", \"ngIfElse\"], [\"groupTag\", \"\"], [\"singleTag\", \"\"], [1, \"k-chip-actions\"], [\"aria-label\", \"delete\", 1, \"k-chip-action\", \"k-chip-remove-action\"], [\"name\", \"x-circle\", 3, \"svgIcon\", \"mousedown\"], [1, \"k-chip-label\", \"k-text-ellipsis\"], [4, \"ngIf\"], [3, \"ngIf\"], [3, \"templateContext\"]],\n    template: function _class31_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class31_div_0_Template, 10, 22, \"div\", 0);\n        i0.ɵɵprojection(1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.tags);\n      }\n    },\n    dependencies: [NgFor, NgClass, NgIf, TemplateContextDirective, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return TagListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MULTISELECT_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MultiSelectComponent)\n};\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_FILL_MODE$2 = 'solid';\n/**\n * Represents the [Kendo UI MultiSelect component for Angular]({% slug overview_multiselect %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\">\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nlet MultiSelectComponent = /*#__PURE__*/(() => {\n  var _class32;\n  class MultiSelectComponent {\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    /**\n     * @hidden\n     */\n    get ariaControls() {\n      return this.isOpen ? this.listBoxId : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.formControl);\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * Focuses a specific item of the MultiSelect based on a provided index.\n     * If there is a custom item it is positioned at index -1.\n     * If null or invalid index is provided the focus will be removed.\n     */\n    focusItemAt(index) {\n      const minIndex = this.allowCustom ? -1 : 0;\n      const isInRange = minIndex <= 0 && index < this.data.length;\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(null);\n      }\n    }\n    /**\n     * Focuses the MultiSelect.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputFocus() {\n      this.handleFocus();\n      if (hasObservers(this.inputFocus)) {\n        this._zone.run(() => {\n          this.inputFocus.emit();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onAdaptiveTextBoxChange(text) {\n      if (this.filterable) {\n        this.filterChange.emit(text);\n        return;\n      }\n      this.searchTextAndFocus(text);\n    }\n    /**\n     * Blurs the MultiSelect.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this._zone.run(() => {\n        if (!this.isFocused && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      if (!this.isActionSheetExpanded) {\n        if (!this.isFocused) {\n          return;\n        }\n        this.isFocused = false;\n        if (hasObservers(this.onBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement)) {\n          this._zone.run(() => {\n            this.closePopup();\n            if (!(this.isOpen && this.allowCustom)) {\n              this.clearFilter();\n            }\n            this.onBlur.emit();\n            this.onTouchedCallback();\n          });\n        } else {\n          if (!this.allowCustom) {\n            this.clearFilter();\n          }\n          this.closePopup();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputBlur() {\n      if (!this.isActionSheetExpanded) {\n        if (!this.isFocused) {\n          return;\n        }\n        if (hasObservers(this.inputBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement) || this.formControl?.updateOn === 'blur') {\n          this._zone.run(() => {\n            this.closePopup();\n            if (!(this.isOpen && this.allowCustom)) {\n              this.clearFilter();\n            }\n            this.inputBlur.emit();\n            this.onTouchedCallback();\n          });\n        } else {\n          if (!this.allowCustom) {\n            this.clearFilter();\n          }\n          this.closePopup();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    onMouseDown(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n        this.cdr.detectChanges();\n      }\n      if (this.isOpen && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Shows or hides the current group sticky header when using grouped data.\n     * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).\n     */\n\n    /**\n     * Sets the data of the MultiSelect.\n     *\n     * > The data has to be provided in an array-like list of items.\n     */\n    set data(data) {\n      this.dataService.data = data || [];\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      if (this.initialized) {\n        this.setState(this.value);\n      }\n    }\n    get data() {\n      const virtual = this.virtual;\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize;\n        //Use length instead of itemsCount because of grouping\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n    set value(values) {\n      this._value = values ? values : [];\n      if (!this.differ && this.value) {\n        this.differ = this.differs.find(this.value).create();\n      }\n      this.valueChangeDetected = true;\n      if (this.initialized) {\n        this.setState(this.value);\n      }\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the data item field that represents the item value.\n     * If the data contains only primitive values, do not define it.\n     *\n     * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The hint which is displayed when the component is empty.\n     * When the values are selected, it disappears.\n     */\n    set placeholder(text) {\n      this._placeholder = text || '';\n    }\n    get placeholder() {\n      return this.selectedDataItems.length ? '' : this._placeholder;\n    }\n    /**\n     * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n     */\n\n    /**\n     * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n     * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n    */\n    set subtitle(_subtitle) {\n      this._subtitle = _subtitle;\n    }\n    get subtitle() {\n      return this._subtitle || this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n     * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiselect#toc-managing-the-multiselect-disabled-state-in-reactive-forms).\n     */\n\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Specifies whether checkboxes will be rendered before each item in the popup list.\n     */\n    set checkboxes(settings) {\n      this._checkboxes = normalizeCheckboxesSettings(settings);\n    }\n    get checkboxes() {\n      return this._checkboxes;\n    }\n    /**\n     * Sets the read-only state of the component.\n     *\n     * @default false\n     */\n\n    /**\n     * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.\n     */\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Configures the popup of the MultiSelect.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * Specifies the type of the selected value.\n     * If set to `true`, the selected value has to be of the primitive type\n     * ([more information and example]({% slug valuebinding_multiselect %}#toc-primitive-values-from-object-fields)).\n     */\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n      return this._valuePrimitive;\n    }\n    /**\n     * If set to `true`, renders a button on hovering over the component.\n     * Clicking this button resets the value of the component to an empty array and triggers the `change` event.\n     */\n\n    get dir() {\n      return this.direction;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get isActionSheetExpanded() {\n      return this.actionSheet?.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    constructor(wrapper, localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, _zone, injector, hostElement, adaptiveService) {\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"dataService\", void 0);\n      _defineProperty(this, \"selectionService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"disabledItemsService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"differs\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"plusIcon\", plusIcon);\n      _defineProperty(this, \"listBoxId\", `k-${guid()}`);\n      _defineProperty(this, \"tagListId\", `k-${guid()}`);\n      _defineProperty(this, \"tagPrefix\", \"tag-\" + guid());\n      _defineProperty(this, \"optionPrefix\", \"option-\" + guid());\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"tags\", void 0);\n      _defineProperty(this, \"focusedTagIndex\", undefined);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"showStickyHeader\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Determines whether to close the options list of the MultiSelect after the item selection is finished\n       * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).\n       * @default true\n       */\n      _defineProperty(this, \"autoClose\", true);\n      /**\n       * Sets and gets the loading state of the MultiSelect.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * Sets the data item field that represents the item text.\n       * If the data contains only primitive values, do not define it.\n       *\n       * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.\n       */\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      _defineProperty(this, \"disabled\", false);\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.\n       */\n      _defineProperty(this, \"filterable\", false);\n      _defineProperty(this, \"_listHeight\", 200);\n      _defineProperty(this, \"clearButton\", true);\n      /**\n       * A user-defined callback function which receives an array of selected data items and maps them to an array of tags\n       * ([see examples]({% slug summarytagmode_multiselect %}#toc-rendering-of-tags)).\n       *\n       * @param { Any[] } dataItems - The selected data items from the list.\n       * @returns { Any[] } - The tags that will be rendered by the component.\n       */\n      _defineProperty(this, \"tagMapper\", tags => tags || []);\n      /**\n       * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset\n       * ([more information and examples]({% slug custom_values_multiselect %})).\n       * Defaults to `false`.\n       *\n       * The feature is not available when using adaptive mode.\n       */\n      _defineProperty(this, \"allowCustom\", false);\n      /**\n       * A user-defined callback function which returns normalized custom values.\n       * Typically used when the data items are different from type `string`.\n       *\n       * @param { Any } value - The custom value that is defined by the user.\n       * @returns { Any }\n       *\n       * @example\n       * ```ts\n       * import { map } from 'rxjs/operators';\n       *\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *   <kendo-multiselect\n       *       [allowCustom]=\"true\"\n       *       [data]=\"listItems\"\n       *       textField=\"text\"\n       *       valueField=\"value\"\n       *       [valueNormalizer]=\"valueNormalizer\"\n       *       (valueChange)=\"onValueChange($event)\"\n       *   >\n       *   </kendo-multiselect>\n       * `\n       * })\n       *\n       * class AppComponent {\n       *   public listItems: Array<{ text: string, value: number }> = [\n       *       { text: \"Small\", value: 1 },\n       *       { text: \"Medium\", value: 2 },\n       *       { text: \"Large\", value: 3 }\n       *   ];\n       *\n       *   public onValueChange(value) {\n       *       console.log(\"valueChange : \", value);\n       *   }\n       *\n       *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n       *      return {\n       *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField\n       *         text: text };\n       *   }));\n       *\n       * }\n       * ```\n       */\n      _defineProperty(this, \"valueNormalizer\", text => text.pipe(map(userInput => {\n        const comparer = item => typeof item === 'string' && userInput.toLowerCase() === item.toLowerCase();\n        const matchingValue = this.value.find(comparer);\n        if (matchingValue) {\n          return matchingValue;\n        }\n        const matchingItem = this.dataService.find(comparer);\n        return matchingItem ? matchingItem : userInput;\n      })));\n      /**\n       * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n       */\n      _defineProperty(this, \"inputAttributes\", void 0);\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example](slug:events_multiselect)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the MultiSelect.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the MultiSelect gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselecttree %}#toc-notifying-on-removing-group-tags)).\n       * This event is preventable. If you cancel it, the tag will not be removed.\n       */\n      _defineProperty(this, \"removeTag\", new EventEmitter());\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"searchbar\", void 0);\n      _defineProperty(this, \"tagList\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"optionsList\", void 0);\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"customItemTemplate\", void 0);\n      _defineProperty(this, \"groupTemplate\", void 0);\n      _defineProperty(this, \"fixedGroupTemplate\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"tagTemplate\", void 0);\n      _defineProperty(this, \"groupTagTemplate\", void 0);\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"windowSize\", 'large');\n      _defineProperty(this, \"disabledIndices\", void 0);\n      _defineProperty(this, \"initialized\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_subtitle\", void 0);\n      _defineProperty(this, \"_valueHolder\", []);\n      _defineProperty(this, \"onChangeCallback\", _ => {});\n      _defineProperty(this, \"onTouchedCallback\", _ => {});\n      _defineProperty(this, \"_placeholder\", '');\n      _defineProperty(this, \"_open\", false);\n      _defineProperty(this, \"_value\", []);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true\n      });\n      _defineProperty(this, \"_virtualSettings\", void 0);\n      _defineProperty(this, \"_valuePrimitive\", void 0);\n      _defineProperty(this, \"_checkboxes\", {\n        enabled: false\n      });\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"selectedDataItems\", []);\n      _defineProperty(this, \"popupMouseDownHandler\", void 0);\n      _defineProperty(this, \"isOpenPrevented\", false);\n      _defineProperty(this, \"customValueSubject\", new Subject());\n      _defineProperty(this, \"customValueSubscription\", void 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"touchstartDisposeHandler\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"differ\", void 0);\n      _defineProperty(this, \"valueChangeDetected\", void 0);\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.dataService = dataService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.cdr = cdr;\n      this.differs = differs;\n      this.renderer = renderer;\n      this._zone = _zone;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      this.adaptiveService = adaptiveService;\n      validatePackage(packageMetadata);\n      this.popupMouseDownHandler = this.onMouseDown.bind(this);\n      this.data = [];\n      this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n    }\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-multiselect-popup'];\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n    get customItemSizeClass() {\n      return `${this.size ? getSizeClass('list', this.size) : ''}`;\n    }\n    get width() {\n      let wrapperOffsetWidth = 0;\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      }\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get activeDescendant() {\n      const focusedTagIndex = this.focusedTagIndex;\n      const focusedListIndex = this.selectionService.focused;\n      let prefix;\n      let focusedIndex;\n      if (isPresent(focusedTagIndex) && !this.isOpen) {\n        focusedIndex = focusedTagIndex;\n        prefix = this.tagPrefix;\n      } else if (isPresent(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {\n        focusedIndex = focusedListIndex;\n        prefix = this.optionPrefix;\n      } else {\n        return null;\n      }\n      return prefix + \"-\" + focusedIndex;\n    }\n    get clearButtonVisiblity() {\n      if (touchEnabled) {\n        return 'visible';\n      }\n    }\n    /**\n     * @hidden\n     */\n    applyValue() {\n      this.value = this._valueHolder;\n      this._valueHolder = [];\n      this.emitValueChange();\n      this.togglePopup(false);\n    }\n    /**\n     * @hidden\n     */\n    cancelValue() {\n      this._valueHolder = [];\n      this.togglePopup(false);\n    }\n    /**\n     * @hidden\n     */\n    verifySettings() {\n      if (!isDevMode() || this.value.length === 0) {\n        return;\n      }\n      if (!isArray(this.value)) {\n        throw new Error(MultiselectMessages.array);\n      }\n      if (this.valuePrimitive === true && isObjectArray(this.value)) {\n        throw new Error(MultiselectMessages.primitive);\n      }\n      if (this.valuePrimitive === false && !isObjectArray(this.value)) {\n        throw new Error(MultiselectMessages.object);\n      }\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n      if (valueOrText) {\n        throw new Error(MultiselectMessages.textAndValue);\n      }\n    }\n    /**\n     * @hidden\n     */\n    change(event) {\n      if (event.isMultipleSelection) {\n        // Existing items.\n        if (isPresent(event.added) && event.added.length > 0) {\n          event.added.forEach(itemIndex => {\n            const dataItem = this.dataService.itemAt(itemIndex);\n            const newItem = this.valuePrimitive && isPresent(dataItem) && isPresent(getter(dataItem, this.valueField)) ? getter(dataItem, this.valueField) : dataItem;\n            if (newItem) {\n              if (!this.isAdaptive || !this.isActionSheetExpanded) {\n                this.value = [...this.value, newItem];\n              } else {\n                this._valueHolder = [...this._valueHolder, newItem];\n              }\n            }\n          });\n        }\n        if (isPresent(event.removed) && event.removed.length > 0) {\n          event.removed.forEach(itemIndex => {\n            const dataItem = this.dataService.itemAt(itemIndex);\n            const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);\n            if (!this.isAdaptive || !this.isActionSheetExpanded) {\n              this.value = this.value.filter(filter);\n            } else {\n              this._valueHolder = this._valueHolder.filter(filter);\n            }\n          });\n          this.cdr.detectChanges();\n        }\n      } else {\n        const isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);\n        if (isCustomItem) {\n          this.addCustomValue(this.text);\n          return; // The change is emited asynchronosly.\n        }\n        // Existing items.\n        if (isPresent(event.added)) {\n          const dataItem = this.dataService.itemAt(event.added);\n          const newItem = this.valuePrimitive && isPresent(dataItem) && isPresent(getter(dataItem, this.valueField)) ? getter(dataItem, this.valueField) : dataItem;\n          if (!this.isAdaptive || !this.isActionSheetExpanded) {\n            this.value = [...this.value, newItem];\n          } else {\n            this._valueHolder = [...this._valueHolder, newItem];\n          }\n        }\n        if (isPresent(event.removed)) {\n          const dataItem = this.dataService.itemAt(event.removed);\n          const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);\n          if (!this.isAdaptive || !this.isActionSheetExpanded) {\n            this.value = this.value.filter(filter);\n          } else {\n            this._valueHolder = this._valueHolder.filter(filter);\n          }\n          this.selectionService.focused = event.removed;\n          this.cdr.detectChanges();\n        }\n      }\n      if (!this.isAdaptive || !this.isActionSheetExpanded) {\n        this.emitValueChange();\n      }\n    }\n    /**\n     * @hidden\n     */\n    setState(value) {\n      let data = this.dataService.data;\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n      const selection = selectedIndices(this.value, data, this.valueField);\n      this.selectionService.resetSelection(selection);\n      if (this.disabledItemsService.isIndexDisabled(this.selectionService.focused)) {\n        this.selectionService.focused = this.firstFocusableIndex(0);\n      }\n      if (this.isOpen && this.selectionService.focused === undefined) {\n        if (this.dataService.itemsCount > 0) {\n          this.selectionService.focused = this.firstFocusableIndex(0);\n        } else if (this.allowCustom) {\n          this.selectionService.focused = -1;\n        }\n      }\n      if (this.valuePrimitive && !this.valueField) {\n        this.selectedDataItems = value.slice();\n      }\n      if (isObjectArray(value) || this.valuePrimitive && this.valueField) {\n        this.selectedDataItems = resolveAllValues(value, data, this.valueField);\n      }\n      if (this.selectedDataItems.length < value.length) {\n        this.selectedDataItems = value.map(current => {\n          const dataItem = this.selectedDataItems.find(item => getter(item, this.valueField) === getter(current, this.valueField));\n          return isPresent(dataItem) ? dataItem : this.resolveDataItemFromTags(current);\n        }).filter(dataItem => isPresent(dataItem));\n      }\n      this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n      this.disabledIndices = this.disabledItemsMapper();\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleFilter(text) {\n      this.text = text;\n      if (text && !this.isOpen) {\n        this.openPopup();\n      }\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      } else {\n        this.searchTextAndFocus(text);\n      }\n      this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n    /**\n     * @hidden\n     */\n    clearFilter() {\n      if (this.filterable && this.text) {\n        this.filterChange.emit(\"\");\n      }\n      this.text = \"\";\n      /* Clearing the value from the input as the setInputSize calculation will be incorrect otherwise.\n       Calling cdr.detectChanges to clear the input value as a result of property binding\n       causes JAWS to read outdated tag values in IE upon tag selection for some reason. */\n      this.searchbar.input.nativeElement.value = \"\";\n      this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n      const navigateInput = this.text && event.keyCode !== Keys.ArrowDown && event.keyCode !== Keys.ArrowUp;\n      const selectValue = this.text && event.keyCode === Keys.Enter || event.keyCode === Keys.Escape;\n      const deleteTag = !this.text && event.keyCode === Keys.Backspace && this.tags.length > 0;\n      if (event.keyCode === Keys.Backspace && this.isActionSheetExpanded) {\n        return;\n      }\n      if (deleteTag) {\n        this.handleBackspace();\n        return;\n      }\n      if (this.disabled || navigateInput && !selectValue) {\n        return;\n      }\n      const eventData = event;\n      const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;\n      const action = this.navigationService.process({\n        current: focused,\n        max: this.dataService.itemsCount - 1,\n        min: this.allowCustom && this.text ? -1 : 0,\n        open: this.isOpen,\n        originalEvent: eventData\n      });\n      if (action !== NavigationAction.Undefined && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter) && !this.isActionSheetExpanded && action === NavigationAction.Tab) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleRemoveTag({\n      tag\n    }) {\n      const eventArgs = new RemoveTagEvent(tag);\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      this.focus();\n      this.removeTag.emit(eventArgs);\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      }\n      if (tag instanceof Array) {\n        this.removeGroupTag(tag);\n      } else {\n        this.removeSingleTag(tag);\n      }\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    clearAll(event) {\n      event?.stopImmediatePropagation();\n      event?.preventDefault();\n      this.focus();\n      this.clearFilter();\n      this.selectionService.lastClickedIndex = null;\n      const selected = this.selectionService.selected;\n      this.value = this.value.filter((_item, index) => this.disabledItemsService.isIndexDisabled(selected[index]));\n      this.emitValueChange();\n    }\n    /**\n     * @hidden\n     */\n    addCustomValue(text) {\n      this.customValueSubject.next(text);\n    }\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    ngDoCheck() {\n      const valueChanges = this.differ && this.differ.diff(this.value);\n      if (valueChanges && !this.valueChangeDetected) {\n        this.setState(this.value);\n      }\n      this.valueChangeDetected = false;\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, \"tabindex\");\n      this.createCustomValueStream();\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      }));\n      this.setState(this.value);\n      this.setComponentClasses();\n      this.initialized = true;\n    }\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n      if (isChanged('valueNormalizer', changes)) {\n        this.createCustomValueStream();\n      }\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes)) {\n        this.setState(this.value);\n      }\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      this.cdr.detectChanges();\n      this.searchbar.setInputSize();\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'mousedown', this.handleMousedown.bind(this)));\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n      this._zone.onStable.pipe(take(1)).subscribe(() => {\n        const ariaLabel = this.searchbar.input.nativeElement.getAttribute('aria-labelledby') || this.searchbar.input.nativeElement.getAttribute('data-kendo-label-id');\n        if (ariaLabel) {\n          this.renderer.setAttribute(this.tagList.hostElement.nativeElement, 'aria-labelledby', ariaLabel);\n        }\n      });\n    }\n    ngOnDestroy() {\n      this._toggle(false);\n      this.unsubscribeEvents();\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet\n     * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup or actionSheet, the respective `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      // The Promise is required for opening the popup on load.\n      // Otherwise, the \"Expression has changed...\" type error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n        this._toggle(shouldOpen);\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(this._open || this.isActionSheetExpanded);\n    }\n    /**\n     * Resets the value of the MultiSelect.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n      this.text = \"\";\n      this.value = [];\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    // NG MODEL BINDINGS\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value || [];\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    onTagMapperChange() {\n      this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.togglePopup(true);\n      }\n    }\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n    get isFocused() {\n      return this._isFocused;\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const isOpen = () => this.isOpen;\n      const isClosed = () => !this.isOpen;\n      const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== undefined;\n      [this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)), this.navigationService.esc.subscribe(this.closePopup.bind(this)), this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)), this.navigationService.open.subscribe(this.openPopup.bind(this)), this.navigationService.close.subscribe(this.handleClose.bind(this)), this.navigationService.up.pipe(filter(isOpen)).subscribe(event => this.handleUp(event.index)), this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)), this.navigationService.left.subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.down.subscribe(event => this.handleDownKey(event.index)), this.navigationService.selectprevious.pipe(filter(isOpen)).subscribe(event => this.handleSelectUpDown(event)), this.navigationService.selectnext.pipe(filter(isOpen)).subscribe(event => this.handleSelectUpDown(event)), this.navigationService.selectalltobeginning.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToBeginning()), this.navigationService.selectalltoend.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToEnd()), merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n          this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);\n        }\n      })].forEach(s => this.subs.add(s));\n    }\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !touchEnabled) {\n        return;\n      }\n      this._zone.runOutsideAngular(() =>\n      // Roll up MultiSelect on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        if ((this.isFocused || this.isOpen) && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            this.blur();\n            if (this.isOpen) {\n              this.togglePopup(false);\n            }\n          });\n        }\n      }));\n    }\n    unsubscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.subs.unsubscribe();\n      if (this.customValueSubscription) {\n        this.customValueSubscription.unsubscribe();\n      }\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n    removeGroupTag(dataItems) {\n      let data = this.dataService.data;\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n      const dataItemValues = new Set(dataItems.map(item => getter(item, this.valueField)));\n      this.value = this.value.filter(value => {\n        const index = selectedIndices([value], data, this.valueField)[0];\n        const isDataItemDisabled = this.disabledItemsService.isIndexDisabled(index);\n        return !dataItemValues.has(getter(value, this.valueField)) || isDataItemDisabled;\n      });\n      this.emitValueChange();\n    }\n    removeSingleTag(dataItem) {\n      let data = this.dataService.data;\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n      const index = selectedIndices([dataItem], data, this.valueField)[0];\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return;\n      }\n      if (isNumber(index)) {\n        this.selectionService.deselect(index);\n        this.selectionService.focused = index;\n        this.togglePopup(false);\n      } else {\n        // the deleted item is not present in the source\n        const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);\n        this.value = this.value.filter(filter);\n        this.emitValueChange();\n      }\n    }\n    /**\n     * @hidden\n     *\n     * Determines which of the provided tags should be disabled and stores their position indices\n     */\n    disabledItemsMapper() {\n      const {\n        selected\n      } = this.selectionService;\n      return new Set(this.selectedDataItems.reduce((indices, _item, index) => {\n        if (this.disabledItemsService.isIndexDisabled(selected[index])) {\n          indices.push(index);\n        }\n        return indices;\n      }, []));\n    }\n    createCustomValueStream() {\n      if (this.customValueSubscription) {\n        this.customValueSubscription.unsubscribe();\n      }\n      this.customValueSubscription = this.customValueSubject.pipe(tap(() => {\n        this.loading = true;\n        this.disabled = true;\n        this.cdr.detectChanges();\n      }), this.valueNormalizer, catchError(() => {\n        this.loading = false;\n        this.disabled = false;\n        if (this.autoClose) {\n          this.togglePopup(false);\n        }\n        if (this.autoClose || !this.filterable) {\n          this.clearFilter();\n        }\n        this.nextTick(() => {\n          this.searchbar.focus();\n        });\n        this.createCustomValueStream();\n        return of(null);\n      })).subscribe(normalizedValue => {\n        this.loading = false;\n        this.disabled = false;\n        if (isPresent(normalizedValue)) {\n          // if valueNormalizer returns `null` or `undefined` custom value is discarded\n          const newValue = this.valuePrimitive ? getter(normalizedValue, this.valueField) : normalizedValue;\n          const itemIndex = this.dataService.indexOf(newValue);\n          const customItem = itemIndex === -1;\n          if (this.value.indexOf(newValue) === -1) {\n            this.tags = this.tagMapper([...this.selectedDataItems, normalizedValue]);\n            if (!customItem) {\n              this.selectionService.add(itemIndex);\n            } else {\n              this.value = [...this.value, newValue];\n            }\n          } else {\n            if (!customItem && this.selectionService.isSelected(itemIndex)) {\n              this.selectionService.deselect(itemIndex);\n              this.selectionService.focused = itemIndex;\n            } else {\n              this.value = this.value.filter(item => getter(item, this.valueField) !== newValue);\n            }\n          }\n          this.emitValueChange();\n        }\n        if (this.autoClose) {\n          this.togglePopup(false);\n        }\n        if (this.autoClose || !this.filterable) {\n          this.clearFilter();\n        }\n        this.nextTick(() => {\n          this.searchbar.focus();\n        });\n      });\n    }\n    handleItemChange(event) {\n      this.change(event);\n      if (this.autoClose && !event.preventClosingPopup && !this.isActionSheetExpanded) {\n        this.togglePopup(false);\n      }\n      if (this.autoClose || !this.filterable) {\n        this.clearFilter();\n      }\n    }\n    handleMousedown(event) {\n      if (event.target.closest('.k-input-prefix') || event.target.closest('.k-input-suffix')) {\n        return;\n      }\n      if (!this.isActionSheetExpanded) {\n        const inputElement = this.searchbar.input.nativeElement;\n        if (event.button === 0) {\n          if (this.isFocused && (this.isOpen || this.isOpenPrevented) && event.target === inputElement) {\n            return;\n          }\n          if (!touchEnabled || touchEnabled && event.target.tagName !== 'SPAN') {\n            this.searchbar.focus();\n          }\n          // The check is needed otherwise when appended to the component, the popup reopens on click\n          // https://github.com/telerik/kendo-angular/issues/3738\n          if (this.popupRef && this.popupRef.popupElement.contains(event.target)) {\n            return;\n          }\n          event.preventDefault();\n          this.togglePopup(!this.isOpen);\n        }\n      }\n    }\n    handleKeydown(event) {\n      if (this.isFocused && this.isOpen && (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyA) {\n        event.preventDefault();\n        this.handleSelectAll();\n      }\n    }\n    handleEnter(event) {\n      const service = this.selectionService;\n      const focusedIndex = this.selectionService.focused;\n      this.selectionService.lastClickedIndex = focusedIndex;\n      if (this.isOpen) {\n        event.originalEvent.preventDefault();\n      }\n      if (focusedIndex === -1) {\n        if (this.allowCustom && this.text) {\n          this.addCustomValue(this.text);\n        }\n        return; // Clear filter & close are done at customValueSubscription due to race conditions.\n      }\n\n      if (service.isSelected(focusedIndex)) {\n        service.deselect(focusedIndex);\n        service.focused = focusedIndex;\n      } else {\n        service.add(focusedIndex);\n      }\n      if (this.autoClose && !this.isActionSheetExpanded) {\n        this.togglePopup(false);\n      }\n      if (this.autoClose || !this.filterable) {\n        this.clearFilter();\n      }\n    }\n    handleClose() {\n      this.closePopup();\n      this.searchbar.focus();\n    }\n    handleEnd() {\n      this.focusedTagIndex = this.tags.length - 1;\n    }\n    handleHome() {\n      this.focusedTagIndex = 0;\n    }\n    sortSelectionAscending() {\n      return this.selectionService.selected.sort((a, b) => a - b);\n    }\n    handleSelectAll() {\n      const selectedItemsCount = this.selectionService.selected.length;\n      const dataItemsCount = this.dataService.data.length;\n      const dataItemsWithoutHeadersCount = this.dataService.data.filter(i => !i.header).length;\n      if (!this.dataService.grouped && selectedItemsCount === dataItemsCount || this.dataService.grouped && selectedItemsCount === dataItemsWithoutHeadersCount) {\n        this.clearAll();\n      } else {\n        this.selectionService.selectFromTo(0, dataItemsCount - 1);\n        this.selectionService.emitMultipleAddedRemoved();\n      }\n    }\n    handleSelectAllToBeginning() {\n      const selectedItemsCount = this.selectionService.selected.length;\n      const dataItemsCount = this.dataService.data.length;\n      const focusedItem = this.selectionService.focused;\n      const largestIndex = this.sortSelectionAscending()[selectedItemsCount - 1];\n      if (selectedItemsCount !== dataItemsCount) {\n        this.selectionService.unselectFromTo(largestIndex, focusedItem + 1);\n        this.selectionService.selectFromTo(0, focusedItem);\n      }\n      this.nextTick(() => this.selectionService.focus(0));\n      this.selectionService.emitMultipleAddedRemoved();\n    }\n    handleSelectAllToEnd() {\n      const selectedItemsCount = this.selectionService.selected.length;\n      const dataItemsCount = this.dataService.data.length;\n      const focusedItem = this.selectionService.focused;\n      if (selectedItemsCount !== dataItemsCount) {\n        this.selectionService.unselectFromTo(focusedItem - 1, 0);\n        this.selectionService.selectFromTo(focusedItem, dataItemsCount - 1);\n      }\n      if (this.dataService.grouped) {\n        const lastItemIndex = this.dataService.groupIndices[this.dataService.groupIndices.length - 1] - 1;\n        this.nextTick(() => this.selectionService.focus(lastItemIndex));\n      } else {\n        this.nextTick(() => this.selectionService.focus(dataItemsCount - 1));\n      }\n      this.selectionService.emitMultipleAddedRemoved();\n    }\n    handleSelectUpDown(event) {\n      const focusedIndex = this.selectionService.focused;\n      if (!isPresent(focusedIndex)) {\n        return;\n      }\n      let indexToSelect;\n      if (event.originalEvent.key === 'ArrowUp') {\n        indexToSelect = focusedIndex > 0 ? focusedIndex - 1 : focusedIndex;\n      } else {\n        indexToSelect = focusedIndex < this.dataService.data.length - 1 ? focusedIndex + 1 : focusedIndex;\n      }\n      if (!isPresent(this.selectionService.lastClickedIndex)) {\n        this.selectionService.lastClickedIndex = focusedIndex;\n      }\n      this.selectRangeFromTo(indexToSelect);\n    }\n    /**\n     * Selects all items between the focused item and the last clicked item (index). Also removes all other selected items.\n     */\n    selectRangeFromTo(indexToSelect) {\n      const lastClickedIndex = this.selectionService.lastClickedIndex;\n      if (lastClickedIndex > indexToSelect) {\n        this.selectionService.unselectNotNeededIndices(indexToSelect, lastClickedIndex, this.dataService.data.length);\n        this.selectionService.selectFromTo(indexToSelect, this.selectionService.lastClickedIndex);\n        this.selectionService.emitMultipleAddedRemoved();\n      } else {\n        this.selectionService.unselectNotNeededIndices(lastClickedIndex, indexToSelect, this.dataService.data.length);\n        this.selectionService.selectFromTo(lastClickedIndex, indexToSelect);\n        this.selectionService.emitMultipleAddedRemoved();\n      }\n      this.nextTick(() => this.selectionService.focus(indexToSelect));\n    }\n    handleUp(index) {\n      this.selectionService.focused = index;\n    }\n    handleBackspace() {\n      if (this.focusedTagIndex !== undefined) {\n        this.handleDelete();\n      } else {\n        this.handleRemoveTag({\n          tag: this.tags[this.tags.length - 1]\n        });\n        this.searchbar.focus();\n      }\n    }\n    handleDelete() {\n      this.handleRemoveTag({\n        tag: this.tags[this.focusedTagIndex]\n      });\n      if (this.focusedTagIndex === this.tags.length) {\n        this.focusedTagIndex = undefined;\n      }\n    }\n    handleLeftKey() {\n      if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {\n        this.focusedTagIndex = this.tags.length - 1;\n      } else if (this.focusedTagIndex !== 0) {\n        this.focusedTagIndex--;\n      }\n    }\n    handleDownKey(index) {\n      if (this.isOpen) {\n        this.selectionService.focused = index || this.firstFocusableIndex(0);\n      } else {\n        this.openPopup();\n      }\n    }\n    handleRightKey() {\n      const last = this.tags.length - 1;\n      if (this.focusedTagIndex === last) {\n        this.focusedTagIndex = undefined;\n      } else if (this.focusedTagIndex < last) {\n        this.focusedTagIndex++;\n      }\n    }\n    findIndex(text, startsFrom = 0) {\n      let itemText;\n      text = text.toLowerCase();\n      const index = this.dataService.findIndex(item => {\n        if (this.dataService.grouped) {\n          itemText = getter(item.value, this.textField);\n        } else {\n          itemText = getter(item, this.textField);\n        }\n        itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n        return text && itemText.startsWith(text);\n      }, startsFrom);\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index + 1 > this.dataService.itemsCount ? -1 : this.findIndex(text, index + 1);\n      } else {\n        return index;\n      }\n    }\n    searchTextAndFocus(text) {\n      const index = this.findIndex(text);\n      this.selectionService.focused = index;\n    }\n    closePopup() {\n      this.togglePopup(false);\n      this.focusedTagIndex = undefined;\n    }\n    openPopup() {\n      this.togglePopup(true);\n      this.focusedTagIndex = undefined;\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      if (isDisabled || sameState) {\n        return;\n      }\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n      if (open) {\n        this.isOpenPrevented = isDefaultPrevented;\n      }\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n        this.focus();\n      }\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        popupClass: this.listContainerClasses,\n        positionMode: appendToComponent ? 'fixed' : 'absolute'\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.selectionService.focus(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.togglePopup(false);\n      });\n    }\n    emitValueChange() {\n      this.onChangeCallback(this.value);\n      this.valueChange.emit(this.value);\n    }\n    resolveDataItemFromTags(value) {\n      if (!(this.tags && this.tags.length && isPresent(value))) {\n        return undefined;\n      }\n      // Flattening the tags array in case of a summary tag occurrence.\n      const tags = this.tags.reduce((acc, tag) => {\n        const items = isArray(tag) ? tag : [tag];\n        acc.push(...items);\n        return acc;\n      }, []);\n      return tags.find(tag => getter(tag, this.valueField) === getter(value, this.valueField));\n    }\n    firstFocusableIndex(index) {\n      const maxIndex = this.dataService.itemsCount;\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        const nextIndex = index + 1;\n        return nextIndex < maxIndex ? this.firstFocusableIndex(nextIndex) : undefined;\n      } else {\n        return index;\n      }\n    }\n    nextTick(f) {\n      this._zone.runOutsideAngular(() => {\n        // Use `setTimeout` instead of a resolved promise\n        // because the latter does not wait long enough.\n        setTimeout(() => this._zone.run(f));\n      });\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      this.actionSheetSearchBar.value = '';\n      this.filterable && this.filterChange.emit('');\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.actionSheet.toggle(true);\n      // Stores the current value state until the user either accepts or cancels it\n      this._valueHolder = [...this.value];\n      this.cdr.detectChanges();\n      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);\n      this.title = setActionSheetTitle(this.searchbar.input, this.title);\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.optionsList.scrollToItem(this.selectionService.focused);\n      this.selectionService.focus(this.selectionService.focused);\n      this.actionSheetSearchBar.focus();\n    }\n  }\n  _class32 = MultiSelectComponent;\n  _defineProperty(MultiSelectComponent, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(MultiSelectComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class32,\n    selectors: [[\"kendo-multiselect\"]],\n    contentQueries: function _class32_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CustomItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class32_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(TagListComponent, 7);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(_c11, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class32_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-multiselect\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      showStickyHeader: \"showStickyHeader\",\n      focusableId: \"focusableId\",\n      autoClose: \"autoClose\",\n      loading: \"loading\",\n      data: \"data\",\n      value: \"value\",\n      valueField: \"valueField\",\n      textField: \"textField\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      placeholder: \"placeholder\",\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      checkboxes: \"checkboxes\",\n      readonly: \"readonly\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      valuePrimitive: \"valuePrimitive\",\n      clearButton: \"clearButton\",\n      tagMapper: \"tagMapper\",\n      allowCustom: \"allowCustom\",\n      valueNormalizer: \"valueNormalizer\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      filterChange: \"filterChange\",\n      valueChange: \"valueChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\",\n      removeTag: \"removeTag\"\n    },\n    exportAs: [\"kendoMultiSelect\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiselect'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => _class32)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class32)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 19,\n    vars: 43,\n    consts: function () {\n      let i18n_40;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multiselect.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_41 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_40 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_41;\n      } else {\n        i18n_40 = $localize`:kendo.multiselect.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_42;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multiselect.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_43 = goog.getMsg(\"clear\");\n        i18n_42 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_43;\n      } else {\n        i18n_42 = $localize`:kendo.multiselect.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_44;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.multiselect.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_45 = goog.getMsg(\"Options list\");\n        i18n_44 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_45;\n      } else {\n        i18n_44 = $localize`:kendo.multiselect.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      let i18n_46;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Apply button in the action sheet\n         * @meaning kendo.multiselect.applyButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_47 = goog.getMsg(\"Apply\");\n        i18n_46 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_47;\n      } else {\n        i18n_46 = $localize`:kendo.multiselect.applyButton|The text of the Apply button in the action sheet:Apply`;\n      }\n      let i18n_48;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Cancel button in the action sheet\n         * @meaning kendo.multiselect.cancelButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_49 = goog.getMsg(\"Cancel\");\n        i18n_48 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_49;\n      } else {\n        i18n_48 = $localize`:kendo.multiselect.cancelButton|The text of the Cancel button in the action sheet:Cancel`;\n      }\n      return [[\"kendoMultiSelectLocalizedMessages\", \"\", \"noDataText\", i18n_40, \"clearTitle\", i18n_42, \"popupLabel\", i18n_44, \"applyButton\", i18n_46, \"cancelButton\", i18n_48], [\"kendoDropDownSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-input-values\"], [3, \"size\", \"rounded\", \"fillMode\", \"id\", \"tags\", \"textField\", \"valueField\", \"focused\", \"disabled\", \"template\", \"groupTemplate\", \"tagPrefix\", \"disabledIndices\", \"removeTag\"], [\"kendoSearchbar\", \"\", 3, \"ariaControls\", \"ariaExpanded\", \"id\", \"tagListId\", \"isLoading\", \"isFilterable\", \"activeDescendant\", \"userInput\", \"disabled\", \"readonly\", \"tabIndex\", \"isRequired\", \"placeholder\", \"inputAttributes\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\", \"click\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"visibility\", \"mousedown\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"showActionButtons\", \"subtitle\", \"placeholder\", \"closePopup\", \"textInputChange\", \"navigate\", \"onApply\", \"onCancel\"], [\"sharedPopupActionSheetTemplate\", \"\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"mousedown\"], [\"name\", \"x\", 1, \"k-icon\", 3, \"svgIcon\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"], [4, \"ngTemplateOutlet\"], [3, \"resize\"], [\"class\", \"k-list\", 3, \"ngClass\", 4, \"ngIf\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"multipleSelection\", \"virtual\", \"checkboxes\", \"isMultiselect\", \"isActionSheetExpanded\", \"showStickyHeader\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-list\", 3, \"ngClass\"], [\"kendoDropDownsSelectable\", \"\", 1, \"k-list-item\", \"k-custom-item\", 3, \"multipleSelection\", \"index\"], [4, \"ngIf\", \"ngIfElse\"], [\"default_custom_item_template\", \"\"], [\"name\", \"plus\", 1, \"k-icon\", 3, \"svgIcon\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"]];\n    },\n    template: function _class32_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class32_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class32_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class32_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class32_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class32_kendo_separator_3_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵelementStart(4, \"div\", 4)(5, \"kendo-taglist\", 5);\n        i0.ɵɵlistener(\"removeTag\", function _class32_Template_kendo_taglist_removeTag_5_listener($event) {\n          return ctx.handleRemoveTag($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"input\", 6);\n        i0.ɵɵlistener(\"onNavigate\", function _class32_Template_input_onNavigate_6_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function _class32_Template_input_valueChange_6_listener($event) {\n          return ctx.handleFilter($event);\n        })(\"onBlur\", function _class32_Template_input_onBlur_6_listener() {\n          return ctx.handleInputBlur();\n        })(\"onFocus\", function _class32_Template_input_onFocus_6_listener() {\n          return ctx.handleInputFocus();\n        })(\"click\", function _class32_Template_input_click_6_listener() {\n          return ctx.handleClick();\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(7, _class32_span_7_Template, 2, 4, \"span\", 7);\n        i0.ɵɵtemplate(8, _class32_span_8_Template, 1, 0, \"span\", 8);\n        i0.ɵɵtemplate(9, _class32_kendo_separator_9_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵtemplate(10, _class32_span_10_Template, 2, 1, \"span\", 9);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(11, _class32_ng_template_11_Template, 1, 1, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, _class32_kendo_resize_sensor_13_Template, 1, 0, \"kendo-resize-sensor\", 11);\n        i0.ɵɵelementContainer(14, null, 12);\n        i0.ɵɵelementStart(16, \"responsive-renderer\", 13);\n        i0.ɵɵlistener(\"closePopup\", function _class32_Template_responsive_renderer_closePopup_16_listener() {\n          return ctx.togglePopup(false);\n        })(\"textInputChange\", function _class32_Template_responsive_renderer_textInputChange_16_listener($event) {\n          return ctx.onAdaptiveTextBoxChange($event);\n        })(\"navigate\", function _class32_Template_responsive_renderer_navigate_16_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"onApply\", function _class32_Template_responsive_renderer_onApply_16_listener() {\n          return ctx.applyValue();\n        })(\"onCancel\", function _class32_Template_responsive_renderer_onCancel_16_listener() {\n          return ctx.cancelValue();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(17, _class32_ng_template_17_Template, 6, 22, \"ng-template\", null, 14, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r10 = i0.ɵɵreference(18);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"id\", ctx.tagListId)(\"tags\", ctx.tags)(\"textField\", ctx.textField)(\"valueField\", ctx.valueField)(\"focused\", ctx.focusedTagIndex)(\"disabled\", ctx.disabled)(\"template\", ctx.tagTemplate)(\"groupTemplate\", ctx.groupTagTemplate)(\"tagPrefix\", ctx.tagPrefix)(\"disabledIndices\", ctx.disabledIndices);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ariaControls\", ctx.ariaControls)(\"ariaExpanded\", ctx.isOpen)(\"id\", ctx.focusableId)(\"tagListId\", ctx.tagListId)(\"isLoading\", ctx.loading)(\"isFilterable\", ctx.filterable)(\"activeDescendant\", ctx.activeDescendant)(\"userInput\", ctx.text)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.isAdaptive)(\"tabIndex\", ctx.tabIndex)(\"isRequired\", ctx.isControlRequired)(\"placeholder\", ctx.placeholder)(\"inputAttributes\", ctx.inputAttributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && ((ctx.tags == null ? null : ctx.tags.length) || (ctx.text == null ? null : ctx.text.length)));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r10)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", true)(\"showActionButtons\", true)(\"subtitle\", ctx.subtitle)(\"placeholder\", ctx.placeholder);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, TagListComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgClass, SelectableDirective, ListComponent],\n    encapsulation: 2\n  }));\n  return MultiSelectComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the column cell content of the MultiColumnComboBox. To define a column cell template, nest an `<ng-template>` tag\n * with the `kendoMultiColumnComboBoxColumnCellTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag\n * ([see example]({% slug templates_multicolumncombobox %})).\n *\n * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) and data item are available as context variables:\n *\n * - `let-dataItem=\"dataItem\"` (`any`) - The current data item. Also available as implicit context variable.\n * - `let-column=\"column\"` ([`ColumnComponent`]({% slug api_dropdowns_comboboxcolumncomponent %})) - The current column configuration obejct.\n */\nlet ColumnCellTemplateDirective = /*#__PURE__*/(() => {\n  var _class33;\n  class ColumnCellTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class33 = ColumnCellTemplateDirective;\n  _defineProperty(ColumnCellTemplateDirective, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(ColumnCellTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class33,\n    selectors: [[\"\", \"kendoMultiColumnComboBoxColumnCellTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ColumnCellTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the column header content of the MultiColumnComboBox. To define a column header template, nest an `<ng-template>` tag\n * with the `kendoMultiColumnComboBoxColumnHeaderTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag\n * ([see example]({% slug templates_multicolumncombobox %})).\n *\n * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) is available as implicit context variable.\n */\nlet ColumnHeaderTemplateDirective = /*#__PURE__*/(() => {\n  var _class34;\n  class ColumnHeaderTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class34 = ColumnHeaderTemplateDirective;\n  _defineProperty(ColumnHeaderTemplateDirective, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(ColumnHeaderTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class34,\n    selectors: [[\"\", \"kendoMultiColumnComboBoxColumnHeaderTemplate\", \"\"]],\n    standalone: true\n  }));\n  return ColumnHeaderTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the column definition of the [MultiColumnComboBox]({% slug overview_multicolumncombobox %})\n * ([see example]({% slug columns_multicolumncombobox %})).\n */\nlet ComboBoxColumnComponent = /*#__PURE__*/(() => {\n  var _class35;\n  class ComboBoxColumnComponent {\n    constructor() {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"cellTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerTemplate\", void 0);\n      /**\n       * The field to which the column is bound.\n       *\n       * > The `field` property can be set to point to a nested property value - e.g. `category.name`.\n       */\n      _defineProperty(this, \"field\", void 0);\n      /**\n       * The title of the column.\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * The width of the column (in pixels).\n       */\n      _defineProperty(this, \"width\", void 0);\n      /**\n       * Sets the visibility of the column.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"hidden\", false);\n      /**\n       * Sets the custom styles for the table cells (excluding the header ones) of the column.\n       * Under the hood, to apply the property, the style option uses the NgStyle directive.\n       */\n      _defineProperty(this, \"style\", void 0);\n      /**\n       * Sets the custom styles for the header cell of the column.\n       * Under the hood, to apply the property, the headerStyle option uses the NgStyle directive.\n       */\n      _defineProperty(this, \"headerStyle\", void 0);\n      /**\n       * Sets the custom CSS classes to the column cells.\n       * Under the hood, to apply the property, the class option uses the NgClass directive.\n       */\n      _defineProperty(this, \"class\", void 0);\n      /**\n       * Sets the custom CSS classes to the column header cell.\n       * Under the hood, to apply the property, the headerClass option uses the NgClass directive.\n       */\n      _defineProperty(this, \"headerClass\", void 0);\n      /**\n       * Sets the condition that needs to be satisfied for a column to remain visible.\n       * If you set the [`hidden`]({% slug api_dropdowns_comboboxcolumncomponent %}#toc-hidden) property, the behavior of `media` is overridden.\n       */\n      _defineProperty(this, \"media\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"matchesMedia\", true);\n    }\n  }\n  _class35 = ComboBoxColumnComponent;\n  _defineProperty(ComboBoxColumnComponent, \"\\u0275fac\", function _class35_Factory(t) {\n    return new (t || _class35)();\n  });\n  _defineProperty(ComboBoxColumnComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class35,\n    selectors: [[\"kendo-combobox-column\"]],\n    contentQueries: function _class35_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ColumnHeaderTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n      }\n    },\n    inputs: {\n      field: \"field\",\n      title: \"title\",\n      width: \"width\",\n      hidden: \"hidden\",\n      style: \"style\",\n      headerStyle: \"headerStyle\",\n      class: \"class\",\n      headerClass: \"headerClass\",\n      media: \"media\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class35_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ComboBoxColumnComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Persists the intially resolved scrollbar width value.\n */\nlet SCROLLBAR_WIDTH;\n/**\n * @hidden\n *\n * Gets the default scrollbar width accoring to the current environment.\n */\nconst scrollbarWidth = () => {\n  // calculate scrollbar width only once, then return the memoized value\n  if (isNaN(SCROLLBAR_WIDTH)) {\n    const div = document.createElement('div');\n    div.style.cssText = 'overflow: scroll; overflow-x: hidden; zoom: 1; clear: both; display: block;';\n    div.innerHTML = '&nbsp;';\n    document.body.appendChild(div);\n    SCROLLBAR_WIDTH = div.offsetWidth - div.scrollWidth;\n    document.body.removeChild(div);\n  }\n  return SCROLLBAR_WIDTH;\n};\n/**\n * Checks if all columns have a valid user-defined width.\n */\nconst allColumnsWidthsSet = columns => {\n  if (!isPresent(columns) || columns.length === 0) {\n    return false;\n  }\n  return columns.toArray().every(column => !isNaN(column.width) && column.width > 0);\n};\n/**\n * @hidden\n *\n * Calculates the row width according to the passed columns width configuration.\n * Hidden columns and such that don't match the provided media query are ignored.\n * If some of the columns don't have a preset width or have an invalid width value, the function returns `null`.\n */\nconst getRowWidthFromColumnsMeta = columns => {\n  if (!allColumnsWidthsSet(columns)) {\n    return null;\n  }\n  const bordersWidth = 2;\n  const initialRowWidht = scrollbarWidth() + bordersWidth;\n  return columns.reduce((totalWidth, column) => {\n    if (!column.hidden && column.matchesMedia) {\n      totalWidth += parseInt(column.width, 10);\n    }\n    return totalWidth;\n  }, initialRowWidht);\n};\n\n/**\n * Represents the [Kendo UI MultiColumnComboBox component for Angular]({% slug overview_multicolumncombobox %}).\n */\nlet MultiColumnComboBoxComponent = /*#__PURE__*/(() => {\n  var _class36;\n  class MultiColumnComboBoxComponent extends ComboBoxComponent {\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n      return this.disabled;\n    }\n    /**\n     * A query list of all declared columns.\n     */\n\n    /**\n     * @hidden\n     */\n    set header(header) {\n      // updates the header padding on initial render as the resize senzor doesn't kick in as early\n      this.updateHeaderPadding(header && header.nativeElement);\n    }\n    /**\n     * @hidden\n     */\n    set headerTable(headerTable) {\n      this._headerTable = headerTable;\n      if (this.headerTable) {\n        this.rowWidth = this.calculateRowWidth();\n      }\n    }\n    get headerTable() {\n      return this._headerTable;\n    }\n    /**\n     * @hidden\n     */\n    set headerColumns(columns) {\n      this.headerColumnWidths = columns.map(column => column.nativeElement.offsetWidth);\n    }\n    /**\n     * @hidden\n     */\n\n    get popupWidth() {\n      const wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      const min = `${wrapperOffsetWidth}px`;\n      const width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;\n      const max = isNaN(width) ? width : `${width}px`;\n      return {\n        min,\n        max\n      };\n    }\n    /**\n     * @hidden\n     */\n    get tableSizeClass() {\n      return `${this.size ? getSizeClass('table', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get listContainerClasses() {\n      return ['k-popup', 'k-dropdowngrid-popup'].concat(this.popupSettings.popupClass || []);\n    }\n    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, wrapper, injector, hostElement, adaptiveService) {\n      super(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, injector, hostElement, adaptiveService);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"columns\", void 0);\n      _defineProperty(this, \"rowWidth\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"headerColumnWidths\", []);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"totalColumnsWidth\", void 0);\n      _defineProperty(this, \"_headerTable\", void 0);\n      _defineProperty(this, \"removeWindowResizeListener\", noop);\n      _defineProperty(this, \"columnsChangeSubscription\", new Subscription());\n      this.hostElement = hostElement;\n      // the row height in @progress/kendo-theme-default\n      this.defaultVirtualItemHeight = 36;\n      // use a smaller virtual page size as columns with multiple cells can cause poor performance\n      this.defaultVirtualPageSize = 30;\n    }\n    ngAfterViewInit() {\n      this.updateColumnsMediaState();\n      this.addWindowResizeListener();\n      this.windowSize = this.adaptiveService.size;\n      this.rowWidth = this.calculateRowWidth();\n      this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);\n      this.columnsChangeSubscription = this.columns.changes.subscribe(() => {\n        this.rowWidth = this.calculateRowWidth();\n        this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);\n      });\n      this.cdr.detectChanges();\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.removeWindowResizeListener();\n      if (this.columnsChangeSubscription) {\n        this.columnsChangeSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    textFrom(dataItem, field) {\n      return getter(dataItem, field);\n    }\n    /**\n     * @hidden\n     *\n     * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.\n     * As when the items container has a scrollbar, the column headers and the cells are misaligned.\n     * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.\n     */\n    updateHeaderPadding(header) {\n      if (!isPresent(header)) {\n        return;\n      }\n      // the scrollbar is rendered on the left in rtl\n      const headerPaddingPosition = this.localization.rtl ? 'padding-left' : 'padding-right';\n      if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {\n        this.renderer.setStyle(header, headerPaddingPosition, `${scrollbarWidth()}px`);\n      } else {\n        this.renderer.removeStyle(header, headerPaddingPosition);\n      }\n    }\n    /**\n     *\n     * @hidden\n     */\n    getColumnWidth(index) {\n      if (!this.virtual) {\n        return this.columns.get(index).width;\n      }\n      return this.headerColumnWidths[index];\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (isPresent(this.data) && this.data.length > 0 && this.data.some(item => !isObject(item))) {\n        throw new Error(MultiColumnComboBoxMessages.data);\n      }\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(MultiColumnComboBoxMessages.textAndValue);\n      }\n      super.verifySettings();\n    }\n    addWindowResizeListener() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.zone.runOutsideAngular(() => this.removeWindowResizeListener = this.renderer.listen(window, 'resize', this.updateColumnsMediaState.bind(this)));\n    }\n    updateColumnsMediaState() {\n      if (!(isPresent(this.columns) && isDocumentAvailable()) || this.isActionSheetExpanded) {\n        return;\n      }\n      this.columns.forEach(column => {\n        const matchesMedia = !column.media || window.matchMedia(column.media).matches;\n        if (column.matchesMedia !== matchesMedia) {\n          column.matchesMedia = matchesMedia;\n          if (this.isOpen) {\n            // enter the zone only if the popup is actually open\n            // update its width in case it's dependent on the columns' width\n            this.zone.run(() => this.popupRef.popupElement.style.width = this.popupWidth.max);\n          }\n        }\n      });\n    }\n    calculateRowWidth() {\n      if (this.isActionSheetExpanded || !this.virtual) {\n        return;\n      }\n      return this.headerTable?.nativeElement.offsetWidth;\n    }\n  }\n  _class36 = MultiColumnComboBoxComponent;\n  _defineProperty(MultiColumnComboBoxComponent, \"\\u0275fac\", function _class36_Factory(t) {\n    return new (t || _class36)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(MultiColumnComboBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class36,\n    selectors: [[\"kendo-multicolumncombobox\"]],\n    contentQueries: function _class36_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ComboBoxColumnComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    viewQuery: function _class36_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c50, 5);\n        i0.ɵɵviewQuery(_c51, 5);\n        i0.ɵɵviewQuery(_c52, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTable = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerColumns = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class36_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-dropdowngrid\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled);\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([SelectionService, DataService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multicolumncombobox'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class36)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class36)\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => _class36)\n    }, {\n      provide: MultiTabStop,\n      useExisting: forwardRef(() => _class36)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 20,\n    vars: 38,\n    consts: function () {\n      let i18n_53;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multicolumncombobox.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_54 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_53 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_54;\n      } else {\n        i18n_53 = $localize`:kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_55;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multicolumncombobox.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_56 = goog.getMsg(\"clear\");\n        i18n_55 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_56;\n      } else {\n        i18n_55 = $localize`:kendo.multicolumncombobox.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_57;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the select button\n         * @meaning kendo.multicolumncombobox.selectButtonText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_58 = goog.getMsg(\"Select\");\n        i18n_57 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_58;\n      } else {\n        i18n_57 = $localize`:kendo.multicolumncombobox.selectButtonText|The title of the select button:Select`;\n      }\n      let i18n_59;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options\n         *                 when its role is 'region'\n         * @meaning kendo.multicolumncombobox.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_60 = goog.getMsg(\"Options list\");\n        i18n_59 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_60;\n      } else {\n        i18n_59 = $localize`:kendo.multicolumncombobox.popupLabel|The label of the popup element that contains the list of options\n                when its role is 'region':Options list`;\n      }\n      return [[\"kendoMultiColumnComboBoxLocalizedMessages\", \"\", \"noDataText\", i18n_53, \"clearTitle\", i18n_55, \"selectButtonText\", i18n_57, \"popupLabel\", i18n_59], [\"kendoDropDownSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [\"kendoSearchbar\", \"\", 3, \"ariaControls\", \"ariaExpanded\", \"id\", \"isLoading\", \"isSuggestable\", \"isFilterable\", \"activeDescendant\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"isRequired\", \"placeholder\", \"inputAttributes\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\", \"click\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"kendoEventsOutsideAngular\", \"click\", 4, \"ngIf\"], [\"class\", \"k-i-loading k-input-loading-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"aria-hidden\", \"true\", \"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [\"select\", \"\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [\"popupTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"subtitle\", \"placeholder\", \"closePopup\", \"textInputChange\", \"navigate\"], [\"sharedPopupActionSheetTemplate\", \"\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"kendoEventsOutsideAngular\", \"click\"], [\"name\", \"x\", 3, \"svgIcon\"], [1, \"k-i-loading\", \"k-input-loading-icon\", \"k-icon\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"], [4, \"ngTemplateOutlet\"], [3, \"resize\"], [1, \"k-data-table\", 3, \"ngClass\"], [1, \"k-table-header\"], [\"header\", \"\"], [1, \"k-table-header-wrap\"], [\"headerWrap\", \"\"], [\"role\", \"presentation\", 1, \"k-table\"], [\"headerTable\", \"\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-table-thead\"], [1, \"k-table-row\"], [\"rowTemplate\", \"\"], [3, \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"id\", \"virtual\", \"type\", \"rowWidth\", \"showStickyHeader\", \"pageChange\", \"listResize\", \"popupListScroll\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [3, \"width\", 4, \"ngIf\"], [\"class\", \"k-table-th\", 3, \"ngStyle\", \"ngClass\", 4, \"ngIf\"], [1, \"k-table-th\", 3, \"ngStyle\", \"ngClass\"], [\"columnHeader\", \"\"], [\"class\", \"k-table-td\", 3, \"ngClass\", \"width\", \"max-width\", \"ngStyle\", 4, \"ngIf\"], [1, \"k-table-td\", 3, \"ngClass\", \"ngStyle\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"], [1, \"k-table-footer\"], [1, \"k-table\"], [1, \"k-table-tfoot\"], [1, \"k-table-td\"]];\n    },\n    template: function _class36_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class36_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class36_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class36_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class36_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class36_kendo_separator_3_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵelementStart(4, \"input\", 4);\n        i0.ɵɵlistener(\"onNavigate\", function _class36_Template_input_onNavigate_4_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function _class36_Template_input_valueChange_4_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function _class36_Template_input_onBlur_4_listener() {\n          return ctx.handleInputBlur();\n        })(\"onFocus\", function _class36_Template_input_onFocus_4_listener() {\n          return ctx.handleInputFocus();\n        })(\"click\", function _class36_Template_input_click_4_listener() {\n          return ctx.handleClick();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, _class36_span_5_Template, 2, 7, \"span\", 5);\n        i0.ɵɵtemplate(6, _class36_span_6_Template, 1, 0, \"span\", 6);\n        i0.ɵɵtemplate(7, _class36_kendo_separator_7_Template, 1, 0, \"kendo-separator\", 3);\n        i0.ɵɵtemplate(8, _class36_span_8_Template, 2, 1, \"span\", 7);\n        i0.ɵɵelementStart(9, \"button\", 8, 9);\n        i0.ɵɵelement(11, \"kendo-icon-wrapper\", 10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(12, _class36_ng_template_12_Template, 1, 1, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, _class36_kendo_resize_sensor_14_Template, 1, 0, \"kendo-resize-sensor\", 12);\n        i0.ɵɵelementContainer(15, null, 13);\n        i0.ɵɵelementStart(17, \"responsive-renderer\", 14);\n        i0.ɵɵlistener(\"closePopup\", function _class36_Template_responsive_renderer_closePopup_17_listener() {\n          return ctx.togglePopup(false);\n        })(\"textInputChange\", function _class36_Template_responsive_renderer_textInputChange_17_listener($event) {\n          return ctx.onAdaptiveTextBoxChange($event);\n        })(\"navigate\", function _class36_Template_responsive_renderer_navigate_17_listener($event) {\n          return ctx.handleNavigate($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(18, _class36_ng_template_18_Template, 19, 22, \"ng-template\", null, 15, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r11 = i0.ɵɵreference(19);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ariaControls\", ctx.ariaControls)(\"ariaExpanded\", ctx.isOpen)(\"id\", ctx.focusableId)(\"isLoading\", ctx.loading)(\"isSuggestable\", ctx.suggest)(\"isFilterable\", ctx.filterable)(\"activeDescendant\", ctx.activeDescendant)(\"userInput\", ctx.text)(\"suggestedText\", ctx.getSuggestion())(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"tabIndex\", ctx.tabIndex)(\"isRequired\", ctx.isControlRequired)(\"placeholder\", ctx.placeholder)(\"inputAttributes\", ctx.inputAttributes);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton && !ctx.loading && !ctx.disabled && (!ctx.readonly || ctx.readonly && ctx.isAdaptiveModeEnabled && ctx.windowSize !== \"large\") && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(36, _c28, ctx.preventEventDefault));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"))(\"disabled\", ctx.disabled ? \"\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"name\", ctx.icon || \"caret-alt-down\")(\"svgIcon\", ctx.svgIcon || ctx.caretAltDownIcon);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r11)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", true)(\"subtitle\", ctx.subtitle)(\"placeholder\", ctx.placeholder);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, ResponsiveRendererComponent, TemplateContextDirective, NgFor, NgStyle, ListComponent],\n    encapsulation: 2\n  }));\n  return MultiColumnComboBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the content of each node in the DropDownTree. To define a node template, nest an `<ng-template>` tag\n * with the `kendoDropDownTreeNodeTemplate` directive inside the `<kendo-dropdowntree>` tag.\n *\n * The current data item and hierarchical index are available as context variables:\n *\n * - `let-dataItem` (`any`) - The current data item. Available as implicit context variable.\n * - `let-index=\"index\"` (`string`) - The current item hierarchical index.\n */\nlet NodeTemplateDirective = /*#__PURE__*/(() => {\n  var _class37;\n  class NodeTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class37 = NodeTemplateDirective;\n  _defineProperty(NodeTemplateDirective, \"\\u0275fac\", function _class37_Factory(t) {\n    return new (t || _class37)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(NodeTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class37,\n    selectors: [[\"\", \"kendoDropDownTreeNodeTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeNodeTemplate\", \"\"]],\n    standalone: true\n  }));\n  return NodeTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_POPUP_SETTINGS$1 = {\n  animate: true\n};\nconst hasChildren$1 = () => false;\nconst fetchChildren$1 = () => of([]);\nconst itemDisabled$1 = () => false;\nconst isNodeVisible$1 = () => true;\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED$1 = 'medium';\nconst DEFAULT_FILL_MODE$1 = 'solid';\nconst stopPropagation = event => event.stopImmediatePropagation();\n/**\n * Represents the [Kendo UI DropDownTree component for Angular]({% slug overview_ddt %}).\n */\nlet DropDownTreeComponent = /*#__PURE__*/(() => {\n  var _class38;\n  class DropDownTreeComponent {\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    get isReadonly() {\n      return this.readonly ? '' : null;\n    }\n    get hostAriaInvalid() {\n      return this.formControl ? this.formControl.invalid.toString() : null;\n    }\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    get isBusy() {\n      return this.loading ? 'true' : null;\n    }\n    get hostAriaControls() {\n      return this.isOpen ? this.treeViewId : undefined;\n    }\n    get id() {\n      return this.focusableId;\n    }\n    get hostTabIndex() {\n      return this.tabindex;\n    }\n    get isAriaExpanded() {\n      return this.isOpen;\n    }\n    get hostAriaAutocomplete() {\n      return this.filterable ? 'list' : null;\n    }\n    set treeview(treeview) {\n      if (treeview) {\n        if (this.isFocused && !this.filterable || this.touchEnabled) {\n          treeview.focus();\n        }\n        // the treeview animations are initially disabled (we don't want expand animations during popup opening)\n        // re-enables the animations for user interaction\n        treeview.animate = true;\n        this._treeview = treeview;\n      }\n    }\n    get treeview() {\n      return this._treeview;\n    }\n    /**\n     * Sets the data of the DropDownTree.\n     *\n     * > The data has to be provided in an array-like list with objects.\n     */\n    set data(data) {\n      this._nodes = data;\n      this.setState();\n    }\n    get data() {\n      return this._nodes;\n    }\n    /**\n     * Sets the value of the DropDownTree.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     */\n    set value(newValue) {\n      this._value = newValue;\n      this.setState();\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * The fields of the data item that provide the text content of the nodes inside the\n     * DropDownTree ([see example]({% slug databinding_ddt %})). If the `textField`\n     * input is set to an array, each hierarchical level uses the field that corresponds\n     * to the same index in the array, or the last item in the array.\n     *\n     * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.\n     */\n\n    /**\n     * Configures the popup of the DropDownTree.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS$1, settings);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Keeps the current `dataItem` object in order to resolve selection.\n     * Needs to be provided when `value` is bound in and `valuePrimitive` is set to true.\n     */\n    set dataItem(item) {\n      this._dataItem = item;\n      this.setState();\n    }\n    get dataItem() {\n      return this._dataItem ? this._dataItem : this.value;\n    }\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n      const providedTabIndex = Number(value);\n      const defaultTabIndex = 0;\n      this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n    get tabindex() {\n      return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * A function that is executed for each data item and determines if a specific item is disabled.\n     */\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n    get isFocused() {\n      return this._isFocused;\n    }\n    get width() {\n      const wrapperWidth = this.wrapper.nativeElement.offsetWidth;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(isPresent(this.popupRef) || this.isActionSheetExpanded);\n    }\n    get clearButtonVisiblity() {\n      if (this.touchEnabled) {\n        return 'visible';\n      }\n    }\n    get isFilterActive() {\n      return this.filterInput && document.activeElement === this.filterInput.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    onFilterChange(text) {\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      }\n    }\n    /**\n     * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n     */\n\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n    * @hidden\n    */\n\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    set isExpanded(callback) {\n      this.isNodeExpanded = callback;\n    }\n    get isExpanded() {\n      return this.isNodeExpanded;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    get expand() {\n      return this.nodeExpand;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    get collapse() {\n      return this.nodeCollapse;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives.\n     */\n    set nodes(nodes) {\n      this.data = nodes;\n    }\n    get nodes() {\n      return this.data;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives\n     */\n    set children(callback) {\n      this.fetchChildren = callback;\n    }\n    get children() {\n      return this.fetchChildren;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.\n     * The `DataBoundComponent` interface is used in the data-binding directives.\n     */\n    set isVisible(callback) {\n      this.isNodeVisible = callback;\n    }\n    get isVisible() {\n      return this.isNodeVisible;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    constructor(injector, wrapper, popupService, navigationService, renderer, _zone, cdr, localization, adaptiveService) {\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"svgIcon\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"touchEnabled\", touchEnabled);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"searchIcon\", searchIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"caretAltDownIcon\", caretAltDownIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"role\", 'combobox');\n      _defineProperty(this, \"ariaHasPopup\", 'tree');\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"nodeTemplate\", void 0);\n      _defineProperty(this, \"valueTemplate\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"filterInput\", void 0);\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_ddt %})).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_ddt %})).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires when the user expands a node in the popup TreeView.\n       */\n      _defineProperty(this, \"nodeExpand\", new EventEmitter());\n      /**\n       * Fires when the user collapses a node in the popup TreeView.\n       */\n      _defineProperty(this, \"nodeCollapse\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the DropDownTree.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the DropDownTree gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the value is changed\n       * ([see example](slug:events_ddt)).\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      /**\n       * Sets and gets the loading state of the DropDownTree.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n      _defineProperty(this, \"clearButton\", true);\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * The fields of the data item that provide the value of the nodes inside the\n       * DropDownTree ([see example]({% slug databinding_ddt %})). If the `valueField`\n       * input is set to an array, each hierarchical level uses the field that corresponds\n       * to the same index in the array, or the last item in the array.\n       *\n       * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * Sets the level in the data set where the value can be found when `valueField` is an Array.\n       * The field serves to correctly allocate a data item used when the DropDownTree is initialized with a value.\n       */\n      _defineProperty(this, \"valueDepth\", void 0);\n      /**\n       * A function which determines if a specific node has child nodes.\n       */\n      _defineProperty(this, \"hasChildren\", hasChildren$1);\n      /**\n       * A function which provides the child nodes for a given parent node.\n       */\n      _defineProperty(this, \"fetchChildren\", fetchChildren$1);\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n      _defineProperty(this, \"placeholder\", \"\");\n      _defineProperty(this, \"_listHeight\", 200);\n      /**\n       * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_ddt#toc-managing-the-dropdowntree-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the component.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the type of the selected value\n       * ([more information and example]({% slug valuebinding_ddt %}#toc-primitive-values)).\n       * If set to `true`, the selected value has to be of a primitive value.\n       */\n      _defineProperty(this, \"valuePrimitive\", false);\n      _defineProperty(this, \"itemDisabled\", itemDisabled$1);\n      /**\n       * A function that is executed for each data item and determines if a specific node is expanded.\n       */\n      _defineProperty(this, \"isNodeExpanded\", void 0);\n      /**\n       * A callback which determines whether a tree node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n      _defineProperty(this, \"isNodeVisible\", isNodeVisible$1);\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default true\n       */\n      _defineProperty(this, \"loadOnDemand\", true);\n      /**\n       * Renders the built-in input element for filtering the DropDownTree.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the DropDownTree manually]({% slug filtering_ddt %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoDropDownTreeHierarchyBinding`]({% slug api_dropdowns_dropdowntreehierarchybindingdirective %}) and [`kendoDropDownTreeFlatBinding`]({% slug api_dropdowns_dropdowntreeflatbindingdirective %}) directives.\n       */\n      _defineProperty(this, \"filterable\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"filter\", '');\n      /**\n       * @hidden\n       *\n       * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid$1()}`);\n      _defineProperty(this, \"popupRef\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"selectedKeys\", []);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"selectBy\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      /**\n       * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n      */\n      _defineProperty(this, \"subtitle\", '');\n      _defineProperty(this, \"windowSize\", 'large');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isActionSheetExpanded\", false);\n      _defineProperty(this, \"filterStateChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"allNodesHidden\", false);\n      /**\n       * @hidden\n       *\n       * Used to associate the value label with the wrapper via aria-describedby.\n       */\n      _defineProperty(this, \"valueLabelId\", `k-${guid$1()}`);\n      _defineProperty(this, \"treeViewId\", `k-${guid$1()}`);\n      _defineProperty(this, \"_nodes\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_popupSettings\", DEFAULT_POPUP_SETTINGS$1);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"_dataItem\", void 0);\n      _defineProperty(this, \"_treeview\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_searchableNodes\", []);\n      _defineProperty(this, \"_typedValue\", '');\n      _defineProperty(this, \"printableCharacters\", new Subject());\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"touchstartDisposeHandler\", void 0);\n      // Keep an instance of the last focused node for when the popup close is prevented\n      // in order to be able to properly restore the focus\n      _defineProperty(this, \"lastNodeOnFocus\", void 0);\n      _defineProperty(this, \"onTouchedCallback\", noop);\n      _defineProperty(this, \"onChangeCallback\", noop);\n      this.injector = injector;\n      this.wrapper = wrapper;\n      this.popupService = popupService;\n      this.navigationService = navigationService;\n      this.renderer = renderer;\n      this._zone = _zone;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.adaptiveService = adaptiveService;\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.subscribeFocusEvents();\n    }\n    ngOnInit() {\n      this.subs.add(this.printableCharacters.pipe(tap(char => {\n        this._typedValue += char;\n        const itemToFocus = this._searchableNodes.find(node => {\n          return node.text.toLowerCase().indexOf(this._typedValue) === 0;\n        });\n        this.treeview.focus(itemToFocus?.index);\n      }), debounceTime(1000)).subscribe(() => {\n        this._typedValue = '';\n      }));\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.assignAriaDescribedBy();\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      }));\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.setState();\n      }\n      if (isChanged('value', changes, false)) {\n        if (changes['value'] && !changes['dataItem'] && !this.valuePrimitive) {\n          // Update the dataItem if the value is updated programmatically (non-primitive values only)\n          this.dataItem = this.value;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentChecked() {\n      this.verifySettings();\n      if (this.data?.length > 0 && this.popupRef) {\n        this.allNodesHidden = this.areNodesHidden(this.data);\n      }\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'click', this.handleClick.bind(this)));\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n      }\n      if (this.isOpen && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    /**\n     * @hidden\n     *\n     * Used by the kendo-floatinglabel component to determine if the floating label\n     * should be rendered inside the input when the component is not focused.\n     */\n    isEmpty() {\n      return !this.text && !this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      if (isDisabled || sameState) {\n        return;\n      }\n      const togglePrevented = this.triggerPopupEvents(open);\n      if (!togglePrevented) {\n        if (open) {\n          this.createPopup();\n        } else {\n          this.destroyPopup();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      if (!this.isFocused) {\n        this.isFocused = true;\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleBlur(e) {\n      if (!this.isActionSheetExpanded) {\n        const relatedTarget = e && e.relatedTarget;\n        if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {\n          return;\n        }\n        this.isFocused = false;\n        this.togglePopup(false);\n        if (hasObservers(this.onBlur) || isUntouched(this.wrapper.nativeElement) || this.formControl?.updateOn === 'blur') {\n          this._zone.run(() => {\n            this.onBlur.emit();\n            this.onTouchedCallback();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event, input) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      if (event.keyCode === Keys.Tab && this.isActionSheetExpanded) {\n        this.togglePopup(false);\n        return;\n      }\n      if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {\n        this.printableCharacters.next(event.key);\n      }\n      const eventData = event;\n      this.navigationService.process({\n        originalEvent: eventData,\n        openOnSpace: !this.isOpen,\n        closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)\n      });\n    }\n    /**\n     * Focuses a specific item of the DropDownTree based on a provided index in the format of `1_1`.\n     * The targeted item should be expanded in order for it to be focused.\n     * If null or invalid index is provided the focus will be set on the first item.\n     */\n    focusItemAt(index) {\n      if (this.treeview) {\n        const lookup = this.treeview.itemLookup(index);\n        const isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);\n        if (!isItemDisabled) {\n          this.treeview.focus(index);\n        }\n      }\n    }\n    /**\n     * Focuses the DropDownTree.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownTree.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n      }\n    }\n    /**\n     * Resets the value of the DropDownTree.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `valueChange` event will not be fired.\n     */\n    reset() {\n      this.value = undefined;\n      this.dataItem = undefined;\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet.\n     * ([see example]({% slug openstate_ddt %})).\n     * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"ViewContainerRef not found...\" error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !isPresent(this.popupRef);\n        this.destroyPopup();\n        if (shouldOpen) {\n          this.createPopup();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    get popupContainerClasses() {\n      const containerClasses = ['k-dropdowntree-popup'];\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n    onSelectionChange({\n      dataItem,\n      index\n    }) {\n      this.valueDepth = index.split('_').length - 1;\n      const valueField = this.getField(this.valueField, dataItem);\n      const newValue = this.valuePrimitive ? getter$1(valueField)(dataItem) : dataItem;\n      const shouldUpdateValue = newValue !== this.value;\n      if (shouldUpdateValue) {\n        this.value = newValue;\n        this.dataItem = dataItem;\n        this.emitValueChange(this.value);\n      }\n      this.togglePopup(false);\n      this.focus();\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    clearValue(event) {\n      event.stopImmediatePropagation();\n      this.focus();\n      this.value = undefined;\n      this.dataItem = undefined;\n      this.clearState();\n      this.valueChange.emit(undefined);\n      this.emitValueChange();\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n    preventEventDefault(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      // If the user resets the value by providing null/undefined we need to reset the `dataItem`\n      // Because upon initialization of the component the `writeValue` is being called twice -\n      // first time with `null` value regardless of sync/async value - an extra check is added to\n      // distinguish between client reset and initial phantom 'null' value\n      if (!isPresent(value) && isPresent(this.value)) {\n        this.dataItem = null;\n      }\n      this.value = value === null ? undefined : value;\n      // Update the dataItem if the value is updated programmatically via a form control (non-primitive values only)\n      if (isPresent(this.value) && !this.valuePrimitive) {\n        this.dataItem = this.value;\n      }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleFilterInputChange(input) {\n      const value = typeof input === 'string' ? input : input.value;\n      this.filter = value;\n      this.filterChange.next(value);\n      this.allNodesHidden = this.areNodesHidden(this.nodes);\n      this._zone.onStable.pipe(take(1)).subscribe(() => {\n        if (this.data.length === 0 || this.allNodesHidden || this.filter === '') {\n          this.filterInput?.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(DropDownTreeMessages.primitive);\n      }\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.dataItem !== \"object\") {\n        throw new Error(DropDownTreeMessages.dataItem);\n      }\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(DropDownTreeMessages.object);\n      }\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(DropDownTreeMessages.textAndValue);\n      }\n      if ((isArray(this.valueField) || isArray(this.textField)) && isPresent(this.value) && !isPresent(this.valueDepth)) {\n        throw new Error(DropDownTreeMessages.valueDepth);\n      }\n    }\n    emitValueChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n    getText(textField, dataItem) {\n      if (isPresent(dataItem) && isPresent(textField)) {\n        const field = this.getField(textField, dataItem);\n        return getter$1(field)(dataItem);\n      }\n      return null;\n    }\n    /**\n     * @hidden\n     */\n    onChildrenLoaded() {\n      setTimeout(() => {\n        if (this.popupRef) {\n          this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);\n        }\n        if (this.isActionSheetExpanded) {\n          this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    onExpand() {\n      this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);\n      this.isActionSheetExpanded = true;\n    }\n    /**\n     * @hidden\n     */\n    onCollapse() {\n      this.isActionSheetExpanded = false;\n    }\n    /**\n     * @hidden\n     *\n     * Determines the `valueField` and `textField` for a specific level in the data set\n     *  @param field - the field value (string | string[])\n     *  @param value - current value\n     */\n    getField(field, value) {\n      const fieldsCount = field.length - 1;\n      if (typeof field === 'string') {\n        // If the `valueField` | `textField` is the same for all levels\n        return field;\n      } else if (isPresent(this.valueDepth)) {\n        // When `valueDepth` can be defined from the index on selectionChange or provided by the user\n        return fieldsCount < this.valueDepth ? field[fieldsCount] : field[this.valueDepth];\n      } else {\n        // Fallback: Look to find a match of each field in the current data item\n        // Side effect may occur if all of the listed fields are present in the data item\n        return field.find(item => item in value);\n      }\n    }\n    areNodesHidden(nodes) {\n      return nodes.every((node, index) => !this.isVisible(node, String(index)));\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    createPopup() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        this.cdr.detectChanges();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'bottom'\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'top'\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        appendTo: this.appendTo,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        positionMode: appendToComponent ? 'fixed' : 'absolute',\n        popupClass: this.popupContainerClasses\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      this.renderer.setStyle(popupWrapper, 'minWidth', min);\n      this.renderer.setStyle(popupWrapper, 'width', max);\n      this.renderer.setStyle(popupWrapper, 'height', this.height);\n      this.renderer.setAttribute(popupWrapper, 'dir', this.direction);\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      this.popupRef.popupOpen.subscribe(() => {\n        this.allNodesHidden = this.areNodesHidden(this.data);\n        this.popupRef.popupElement.addEventListener('click', event => stopPropagation(event));\n        this.cdr.detectChanges();\n        this.opened.emit();\n        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n    }\n    destroyPopup() {\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      }\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('click', event => stopPropagation(event));\n        this.popupRef.close();\n        this.popupRef = null;\n        if (this.filter !== \"\") {\n          this.filter = \"\";\n          this.allNodesHidden = false;\n          if (hasObservers(this.filterChange)) {\n            this._zone.run(() => {\n              this.filterChange.emit(\"\");\n            });\n          }\n        }\n      }\n    }\n    handleClick(e) {\n      // The check is needed otherwise when appended to the component, the popup reopens on click\n      // https://github.com/telerik/kendo-angular/issues/3738\n      this.windowSize = this.adaptiveService.size;\n      if (!this.isActionSheetExpanded) {\n        if (this.popupRef && !this.popupRef.popupElement.contains(e.target) || !this.popupRef && !e.target.className.includes('k-treeview-leaf')) {\n          this.togglePopup(!this.isOpen);\n        }\n      }\n    }\n    handleEscape() {\n      this.togglePopup(false);\n      this.focus();\n    }\n    setState() {\n      if (isPresent(this.value) && isPresent(this.dataItem) && isPresent(this.valueField)) {\n        this.text = this.getText(this.textField, this.dataItem);\n        const valueField = this.getField(this.valueField, this.dataItem);\n        this.selectBy = valueField;\n        this.selectedKeys = [getter$1(valueField)(this.dataItem)];\n      } else {\n        this.clearState();\n      }\n      this.cdr.markForCheck();\n    }\n    clearState() {\n      this.text = undefined;\n      this.selectedKeys = [];\n    }\n    subscribeEvents() {\n      [this.navigationService.open.subscribe(event => {\n        event.originalEvent.preventDefault();\n        this.togglePopup(true);\n      }), this.navigationService.close.subscribe(event => {\n        event.originalEvent.preventDefault();\n        this.togglePopup(false);\n        this.focus();\n      }), this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(e => {\n        // The check is needed otherwise when appended to the component, the popup reopens on click\n        // https://github.com/telerik/kendo-angular/issues/3738\n        if (e.originalEvent.target === this.wrapper.nativeElement) {\n          this.togglePopup(true);\n        }\n        if (!this.isOpen) {\n          this.focus();\n        }\n      }), this.navigationService.esc.subscribe(() => this.handleEscape()), this.navigationService.tab.subscribe(() => {\n        this.focus();\n        if (this.isOpen) {\n          this.treeview.blur();\n          this.removeTreeViewFromTabOrder();\n        }\n      }), this.navigationService.down.subscribe(event => {\n        if (!this.treeview) {\n          return;\n        }\n        event.originalEvent.preventDefault();\n        if (!this.treeview.isActive) {\n          this.treeview.focus();\n        }\n      }), this.navigationService.up.subscribe(event => {\n        if (!this.treeview) {\n          return;\n        }\n        event.originalEvent.preventDefault();\n        if (this.filterable && this.treeview['navigationService']['activeIndex'] === '0') {\n          if (this.isActionSheetExpanded) {\n            this.actionSheetSearchBar.focus();\n          } else {\n            this.filterInput.nativeElement.focus();\n          }\n        }\n      })].forEach(sub => this.subs.add(sub));\n    }\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n      this._zone.runOutsideAngular(() =>\n      // Roll up DropDownTree on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            if (this.isOpen) {\n              this.treeview.blur();\n            }\n            this.blur();\n          });\n        }\n      }));\n    }\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.handleFocus = this.handleFocus.bind(this);\n        this.handleDocumentBlur = this.handleDocumentBlur.bind(this);\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.handleFocus, useCapture);\n          document.addEventListener('blur', this.handleDocumentBlur, useCapture);\n        });\n      }\n    }\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.handleFocus, useCapture);\n        document.removeEventListener('blur', this.handleDocumentBlur, useCapture);\n      }\n    }\n    unsubscribeEvents() {\n      this.subs.unsubscribe();\n      this.unSubscribeFocusEvents();\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n    handleDocumentBlur(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      this.handleBlur(event);\n    }\n    assignAriaDescribedBy() {\n      const currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || '';\n      // add to the current value - don't replace it (the aria-describedby is used by the FormField component as well)\n      const newValue = `${this.valueLabelId} ${currentValue.trim()}`.trim();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      }\n    }\n    /**\n     * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur\n     * and the user will not be able to tab to the rest of the browser elements\n     */\n    removeTreeViewFromTabOrder() {\n      const nodes = this.treeview.element.nativeElement.querySelectorAll('li');\n      nodes.forEach(item => {\n        if (item.getAttribute('tabindex') === '0') {\n          this.lastNodeOnFocus = item;\n          this.lastNodeOnFocus.setAttribute('tabindex', '-1');\n        }\n      });\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      if (this.filterable) {\n        this.actionSheetSearchBar.value = '';\n        this.filterChange.emit('');\n      }\n      this.wrapper.nativeElement.focus();\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.isActionSheetExpanded = true;\n      this.actionSheet.toggle(true);\n      this.title = setActionSheetTitle(this.wrapper, this.title);\n      this.cdr.detectChanges();\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.removeTreeViewFromTabOrder();\n      this.filterable && this.actionSheetSearchBar.focus();\n    }\n  }\n  _class38 = DropDownTreeComponent;\n  _defineProperty(DropDownTreeComponent, \"\\u0275fac\", function _class38_Factory(t) {\n    return new (t || _class38)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(DropDownTreeComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class38,\n    selectors: [[\"kendo-dropdowntree\"]],\n    contentQueries: function _class38_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class38_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c63, 5);\n        i0.ɵɵviewQuery(_c64, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeview = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);\n      }\n    },\n    hostVars: 22,\n    hostBindings: function _class38_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"readonly\", ctx.isReadonly)(\"aria-invalid\", ctx.hostAriaInvalid)(\"aria-disabled\", ctx.isDisabled)(\"aria-busy\", ctx.isBusy)(\"aria-controls\", ctx.hostAriaControls)(\"id\", ctx.id)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabIndex)(\"role\", ctx.role)(\"aria-haspopup\", ctx.ariaHasPopup)(\"aria-expanded\", ctx.isAriaExpanded)(\"aria-autocomplete\", ctx.hostAriaAutocomplete);\n        i0.ɵɵclassProp(\"k-dropdowntree\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading)(\"k-readonly\", ctx.readonly);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      loading: \"loading\",\n      clearButton: \"clearButton\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      hasChildren: \"hasChildren\",\n      fetchChildren: \"fetchChildren\",\n      placeholder: \"placeholder\",\n      popupSettings: \"popupSettings\",\n      dataItem: \"dataItem\",\n      listHeight: \"listHeight\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      valuePrimitive: \"valuePrimitive\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      itemDisabled: \"itemDisabled\",\n      isNodeExpanded: \"isNodeExpanded\",\n      isNodeVisible: \"isNodeVisible\",\n      loadOnDemand: \"loadOnDemand\",\n      filterable: \"filterable\",\n      filter: \"filter\",\n      focusableId: \"focusableId\",\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\"\n    },\n    outputs: {\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      nodeExpand: \"nodeExpand\",\n      nodeCollapse: \"nodeCollapse\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\"\n    },\n    exportAs: [\"kendoDropDownTree\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdowntree'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class38)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class38)\n    }, {\n      provide: DataBoundComponent,\n      useExisting: forwardRef(() => _class38)\n    }, {\n      provide: ExpandableComponent,\n      useExisting: forwardRef(() => _class38)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 15,\n    vars: 15,\n    consts: function () {\n      let i18n_65;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.dropdowntree.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_66 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_65 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_66;\n      } else {\n        i18n_65 = $localize`:kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_67;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.dropdowntree.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_68 = goog.getMsg(\"clear\");\n        i18n_67 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_68;\n      } else {\n        i18n_67 = $localize`:kendo.dropdowntree.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_69;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.dropdowntree.selectButtonText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_70 = goog.getMsg(\"Select\");\n        i18n_69 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_70;\n      } else {\n        i18n_69 = $localize`:kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n      let i18n_71;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the filter input\n         * @meaning kendo.dropdowntree.filterInputLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_72 = goog.getMsg(\"Filter\");\n        i18n_71 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_72;\n      } else {\n        i18n_71 = $localize`:kendo.dropdowntree.filterInputLabel|The text set as aria-label on the filter input:Filter`;\n      }\n      let i18n_73;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.dropdowntree.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_74 = goog.getMsg(\"Options list\");\n        i18n_73 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_74;\n      } else {\n        i18n_73 = $localize`:kendo.dropdowntree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      return [[\"kendoDropDownTreeLocalizedMessages\", \"\", \"noDataText\", i18n_65, \"clearTitle\", i18n_67, \"selectButtonText\", i18n_69, \"filterInputLabel\", i18n_71, \"popupLabel\", i18n_73], [1, \"k-input-inner\", 3, \"click\"], [\"class\", \"k-input-value-text\", 4, \"ngIf\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"click\", 4, \"ngIf\"], [\"class\", \"k-i-loading k-input-loading-icon k-icon\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"type\", \"button\", \"aria-hidden\", \"true\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\"], [\"innerCssClass\", \"k-button-icon\", 3, \"name\", \"svgIcon\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"subtitle\", \"closePopup\", \"onExpand\", \"onCollapse\", \"textInputChange\"], [\"sharedPopupActionSheetTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [1, \"k-input-value-text\"], [4, \"ngIf\"], [3, \"ngIf\"], [3, \"templateContext\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"click\"], [\"name\", \"x\", 3, \"svgIcon\"], [1, \"k-i-loading\", \"k-input-loading-icon\", \"k-icon\"], [4, \"ngTemplateOutlet\"], [\"class\", \"k-list-filter\", 4, \"ngIf\"], [\"kendoTreeViewSelectable\", \"\", 3, \"size\", \"nodes\", \"maxHeight\", \"animate\", \"selectedKeys\", \"selectBy\", \"textField\", \"children\", \"hasChildren\", \"loadOnDemand\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"filter\", \"isVisible\", \"selectedKeysChange\", \"focusout\", \"keydown\", \"selectionChange\", \"expand\", \"collapse\", \"childrenLoaded\", 4, \"ngIf\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\"], [1, \"k-textbox\", \"k-input\", 3, \"ngClass\"], [1, \"k-input-prefix\"], [\"name\", \"search\", 1, \"k-icon\", 3, \"svgIcon\"], [\"role\", \"textbox\", 1, \"k-input-inner\", 3, \"filterInput\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"input\", \"keydown.arrowdown\", \"keydown.alt.arrowup\", \"keydown.escape\"], [\"filterInput\", \"\"], [\"kendoTreeViewSelectable\", \"\", 3, \"size\", \"nodes\", \"animate\", \"selectedKeys\", \"selectBy\", \"textField\", \"children\", \"hasChildren\", \"loadOnDemand\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"filter\", \"isVisible\", \"selectedKeysChange\", \"focusout\", \"keydown\", \"selectionChange\", \"expand\", \"collapse\", \"childrenLoaded\"], [\"treeview\", \"\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"resize\"]];\n    },\n    template: function _class38_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵlistener(\"click\", function _class38_Template_span_click_1_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵtemplate(2, _class38_span_2_Template, 3, 2, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class38_span_3_Template, 2, 4, \"span\", 3);\n        i0.ɵɵtemplate(4, _class38_span_4_Template, 1, 0, \"span\", 4);\n        i0.ɵɵelementStart(5, \"button\", 5);\n        i0.ɵɵelement(6, \"kendo-icon-wrapper\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, _class38_ng_template_7_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(9, null, 8);\n        i0.ɵɵelementStart(11, \"responsive-renderer\", 9);\n        i0.ɵɵlistener(\"closePopup\", function _class38_Template_responsive_renderer_closePopup_11_listener() {\n          return ctx.togglePopup(false);\n        })(\"onExpand\", function _class38_Template_responsive_renderer_onExpand_11_listener() {\n          return ctx.onExpand();\n        })(\"onCollapse\", function _class38_Template_responsive_renderer_onCollapse_11_listener() {\n          return ctx.onCollapse();\n        })(\"textInputChange\", function _class38_Template_responsive_renderer_textInputChange_11_listener($event) {\n          return ctx.handleFilterInputChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, _class38_ng_template_12_Template, 5, 5, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, _class38_kendo_resize_sensor_14_Template, 1, 0, \"kendo-resize-sensor\", 11);\n      }\n      if (rf & 2) {\n        const _r6 = i0.ɵɵreference(13);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"id\", ctx.valueLabelId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.valueTemplate || ctx.text || ctx.placeholder);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length) && !ctx.disabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses);\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"))(\"disabled\", ctx.disabled ? \"\" : null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"name\", ctx.icon || \"caret-alt-down\")(\"svgIcon\", ctx.svgIcon || ctx.caretAltDownIcon);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r6)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", ctx.filterable)(\"subtitle\", ctx.subtitle);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgIf, TemplateContextDirective, IconWrapperComponent, NgClass, NgTemplateOutlet, ResponsiveRendererComponent, FilterInputDirective, EventsOutsideAngularDirective, TreeViewComponent, SelectDirective, ResizeSensorComponent],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return DropDownTreeComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst nodeIndex = item => (item || {}).key;\n/**\n * @hidden\n */\nconst buildTreeIndex = (parentIndex, itemIndex) => {\n  return [parentIndex, itemIndex].filter(part => isPresent(part)).join('_');\n};\n/**\n * @hidden\n */\nconst buildTreeItem = (dataItem, valueField, currentLevelIndex) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n  return {\n    dataItem,\n    key: valueFrom({\n      dataItem,\n      level: currentLevelIndex\n    }, valueField) + '_' + currentLevelIndex\n  };\n};\n/**\n * @hidden\n */\nlet MultiSelectTreeLookupService = /*#__PURE__*/(() => {\n  var _class39;\n  class MultiSelectTreeLookupService {\n    constructor() {\n      _defineProperty(this, \"map\", new Map());\n    }\n    reset() {\n      this.map.clear();\n    }\n    registerChildren(index, children) {\n      const item = this.item(index);\n      if (!item) {\n        return;\n      }\n      item.children = children;\n    }\n    item(index) {\n      return this.map.get(index) || null;\n    }\n    registerItem(item, parent) {\n      const currentLookup = {\n        children: [],\n        item,\n        parent: this.item(nodeIndex(parent))\n      };\n      this.map.set(item.key, currentLookup);\n    }\n    itemLookup(index) {\n      const item = this.item(index);\n      if (!item) {\n        return null;\n      }\n      return {\n        children: this.mapChildren(item.children),\n        item: item.item,\n        parent: item.parent\n      };\n    }\n    mapChildren(children = []) {\n      return children.map(c => {\n        const {\n          item,\n          parent,\n          children\n        } = this.item(c.key);\n        return {\n          children: this.mapChildren(children),\n          item,\n          parent\n        };\n      });\n    }\n  }\n  _class39 = MultiSelectTreeLookupService;\n  _defineProperty(MultiSelectTreeLookupService, \"\\u0275fac\", function _class39_Factory(t) {\n    return new (t || _class39)();\n  });\n  _defineProperty(MultiSelectTreeLookupService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class39,\n    factory: _class39.ɵfac\n  }));\n  return MultiSelectTreeLookupService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\nlet BaseCheckDirective = /*#__PURE__*/(() => {\n  var _class40;\n  class BaseCheckDirective {\n    constructor() {\n      /**\n       * @hidden\n       * The flag is needed in order to determine how to construct the items map keys.\n       * If `true`, then the key consists of the item's value and level (depth),\n       * else the key consists of the item's value and 0 (no leveling required)\n       */\n      _defineProperty(this, \"isHeterogeneous\", void 0);\n    }\n    addItem(item) {\n      if (this.isItemChecked(item)) {\n        return;\n      }\n      const level = getHierarchicalItemLevel(item.index);\n      const key = this.getKey(item, level);\n      const candidate = {\n        ...item,\n        level,\n        key\n      };\n      this.checkedItems.push(candidate);\n      this.checkedKeys.add(key);\n    }\n    removeItem(item) {\n      if (!this.isItemChecked(item)) {\n        return;\n      }\n      const level = getHierarchicalItemLevel(item.index);\n      const key = this.getKey(item, level);\n      const candidate = {\n        ...item,\n        level,\n        key\n      };\n      this.checkedItems = this.checkedItems.filter(item => {\n        const valueMatch = valueFrom(item, this.valueField) === valueFrom(candidate, this.valueField);\n        const levelMatch = item.level === candidate.level;\n        return this.isHeterogeneous ? !(valueMatch && levelMatch) : !valueMatch;\n      });\n      this.checkedKeys.delete(key);\n    }\n    isItemChecked(item) {\n      const level = item.index.split('_').length - 1;\n      item.level = level;\n      const key = this.getKey(item, level);\n      return this.checkedKeys.has(key);\n    }\n    updateItems() {\n      this.checkedItems = this.checkedItems || [];\n      this.checkedKeys = new Set(this.checkedItems.map(item => item.key));\n    }\n    /**\n     * Adds the item's depth to the item's value to allow duplicate values on different levels.\n     *\n     * @param item - The checked key.\n     * @returns { string } - A string key consisting of the item's `valueField` value and its depth (depth is 0 if data is homogeneous).\n     */\n    getKey(item, level) {\n      return valueFrom(item, this.valueField) + '_' + (this.isHeterogeneous ? level : 0);\n    }\n  }\n  _class40 = BaseCheckDirective;\n  _defineProperty(BaseCheckDirective, \"\\u0275fac\", function _class40_Factory(t) {\n    return new (t || _class40)();\n  });\n  _defineProperty(BaseCheckDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class40,\n    inputs: {\n      valueField: \"valueField\",\n      checkedItems: \"checkedItems\",\n      isHeterogeneous: \"isHeterogeneous\"\n    }\n  }));\n  return BaseCheckDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\nlet CheckDirective = /*#__PURE__*/(() => {\n  var _class41;\n  class CheckDirective extends BaseCheckDirective {\n    constructor(treeView) {\n      super();\n      _defineProperty(this, \"treeView\", void 0);\n      /**\n       * Specifies whether items should be checked on click,\n       * and whether checking a node will also check the node children as well.\n       * The `checkChildren` prop also enables or disables parent item checking (i.e. checking all child items automatically checks the parent).\n       */\n      _defineProperty(this, \"checkable\", void 0);\n      /**\n       * The item key/keys by which the data items will be compared.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * Defines the collection that will store the full checked items.\n       */\n      _defineProperty(this, \"checkedItems\", void 0);\n      /**\n       * Fires when the `checkedItems` collection was updated.\n       */\n      _defineProperty(this, \"checkedItemsChange\", new EventEmitter());\n      /**\n       * Holds a Set with just the checked item keys.\n       *\n       * Should be updated each time the `checkedItems` value or content is changed.\n       * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).\n       */\n      _defineProperty(this, \"checkedKeys\", new Set());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"clickSubscription\", void 0);\n      this.treeView = treeView;\n      this.subscriptions.add(this.treeView.checkedChange.subscribe(this.handleCheckedChange.bind(this)));\n      this.treeView.isChecked = this.getCheckedState.bind(this);\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes['checkable'])) {\n        this.toggleCheckOnClick();\n      }\n      if (isPresent(changes['checkedItems'])) {\n        this.updateItems();\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.unsubscribeClick();\n    }\n    getCheckedState(dataItem, index) {\n      if (this.isItemChecked({\n        dataItem,\n        index\n      })) {\n        return 'checked';\n      } else if (this.checkable.checkChildren && this.isItemIndeterminate(this.treeView.itemLookup(index))) {\n        return 'indeterminate';\n      } else {\n        return 'none';\n      }\n    }\n    handleCheckedChange(node) {\n      this.checkNode(node);\n      // parents should be checked if `checkChildren` is set to `true` (single config option for both)\n      const checkParents = this.checkable.checkChildren;\n      if (checkParents) {\n        this.checkParents(node.parent);\n      }\n      this.checkedItemsChange.emit(this.checkedItems.slice());\n    }\n    toggleCheckOnClick() {\n      this.unsubscribeClick();\n      if (this.checkable.checkOnClick) {\n        this.clickSubscription = this.treeView.nodeClick.pipe(filter(event => event.type === 'click')).subscribe(event => {\n          const lookup = this.treeView.itemLookup(event.item.index);\n          this.handleCheckedChange(lookup);\n        });\n      }\n    }\n    unsubscribeClick() {\n      if (this.clickSubscription) {\n        this.clickSubscription.unsubscribe();\n        this.clickSubscription = null;\n      }\n    }\n    checkNode(lookup) {\n      if (this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index)) {\n        return;\n      }\n      const target = lookup.item;\n      const pendingCheck = [target];\n      // TODO: extract in a separate `checkChildren` method?\n      if (this.checkable.checkChildren) {\n        const filter = item => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index);\n        fetchDescendentNodes(lookup, filter).forEach(lookup => pendingCheck.push(lookup.item));\n      }\n      const shouldCheck = !this.isItemChecked(target);\n      pendingCheck.forEach(item => {\n        if (shouldCheck) {\n          this.addItem(item);\n        } else {\n          this.removeItem(item);\n        }\n      });\n    }\n    checkParents(parent) {\n      let currentParent = parent;\n      while (currentParent) {\n        const allChildrenSelected = currentParent.children.every(item => this.isItemChecked(item));\n        if (allChildrenSelected) {\n          this.addItem(currentParent.item);\n        } else {\n          this.removeItem(currentParent.item);\n        }\n        currentParent = currentParent.parent;\n      }\n    }\n    isItemIndeterminate(lookup) {\n      const children = lookup.children;\n      if (!Array.isArray(children) || children.length === 0) {\n        return false;\n      }\n      let index = 0;\n      let child = children[index];\n      while (isPresent(child)) {\n        if (this.isItemChecked(child.item) || this.isItemIndeterminate(child)) {\n          return true;\n        }\n        index += 1;\n        child = children[index];\n      }\n      return false;\n    }\n  }\n  _class41 = CheckDirective;\n  _defineProperty(CheckDirective, \"\\u0275fac\", function _class41_Factory(t) {\n    return new (t || _class41)(i0.ɵɵdirectiveInject(i1$1.TreeViewComponent));\n  });\n  _defineProperty(CheckDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class41,\n    selectors: [[\"\", \"kendoMultiSelectTreeCheckable\", \"\"]],\n    inputs: {\n      checkable: \"checkable\",\n      valueField: \"valueField\",\n      checkedItems: \"checkedItems\"\n    },\n    outputs: {\n      checkedItemsChange: \"checkedItemsChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return CheckDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\nlet CheckAllDirective = /*#__PURE__*/(() => {\n  var _class42;\n  class CheckAllDirective extends BaseCheckDirective {\n    handleChange(event) {\n      // Need to store the current checkbox state at the moment of click\n      this.currentCheckedState = event.checked;\n      this.currentIndeterminateState = this.isIndeterminate;\n      this.treeview.nodes.map((_value, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        this.checkNode(itemLookup);\n      });\n      this.checkedItemsChange.emit(this.checkedItems.slice());\n    }\n    get isIndeterminate() {\n      const isIndeterminate = this.treeview.nodes.some((_node, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        return this.someChecked(itemLookup);\n      });\n      return this.isChecked ? false : isIndeterminate;\n    }\n    get isChecked() {\n      const isChecked = this.treeview.nodes.every((_node, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        return this.allChecked(itemLookup);\n      });\n      return isChecked;\n    }\n    constructor(element, zone, cdr, renderer) {\n      super();\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"lastAction\", void 0);\n      _defineProperty(this, \"treeview\", void 0);\n      /**\n       * Defines the collection that will store the full checked items.\n       */\n      _defineProperty(this, \"checkedItems\", void 0);\n      /**\n       * The item key/keys by which the data items will be compared.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      _defineProperty(this, \"focused\", void 0);\n      /**\n       * Fires when the `checkedItems` collection was updated.\n       */\n      _defineProperty(this, \"checkedItemsChange\", new EventEmitter());\n      /**\n       * Holds a Set with just the checked item keys.\n       *\n       * Should be updated each time the `checkedItems` value or content is changed.\n       * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).\n       */\n      _defineProperty(this, \"checkedKeys\", new Set());\n      _defineProperty(this, \"currentCheckedState\", void 0);\n      _defineProperty(this, \"currentIndeterminateState\", void 0);\n      this.element = element;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes['checkedItems'])) {\n        this.updateItems();\n        this.renderer.setProperty(this.element.nativeElement, 'checked', this.isChecked);\n        this.renderer.setProperty(this.element.nativeElement, 'indeterminate', this.isIndeterminate);\n      }\n    }\n    ngOnInit() {\n      if (this.focused) {\n        this.nextTick(() => this.element.nativeElement.focus());\n      }\n    }\n    nextTick(fn) {\n      this.zone.runOutsideAngular(() => setTimeout(fn));\n    }\n    checkNode(itemLookup) {\n      if (this.treeview.isDisabled(itemLookup.item.dataItem, itemLookup.item.index)) {\n        return;\n      }\n      const pendingCheck = [];\n      const filter = item => this.treeview.isVisible(item.dataItem, item.index) && !this.treeview.isDisabled(item.dataItem, item.index);\n      pendingCheck.push(itemLookup.item);\n      fetchDescendentNodes(itemLookup, filter).forEach(lookup => pendingCheck.push(lookup.item));\n      pendingCheck.forEach(item => {\n        if (this.currentIndeterminateState) {\n          if (this.lastAction === 'check') {\n            this.addItem(item);\n          } else {\n            this.removeItem(item);\n          }\n          return;\n        }\n        if (this.currentCheckedState) {\n          this.addItem(item);\n        } else {\n          this.removeItem(item);\n        }\n      });\n    }\n    allChecked(lookup) {\n      const children = lookup && lookup.children;\n      if (!Array.isArray(children)) {\n        return;\n      }\n      const childrenChecked = children.every(child => {\n        if (child.children.length) {\n          return this.isItemChecked(child.item) && this.allChecked(child);\n        }\n        return this.isItemChecked(child.item);\n      });\n      return childrenChecked && this.isItemChecked(lookup.item);\n    }\n    someChecked(lookup) {\n      const children = lookup && lookup.children;\n      if (!Array.isArray(children)) {\n        return;\n      }\n      const childrenChecked = children.some(child => {\n        if (child.children.length) {\n          return this.isItemChecked(child.item) || this.someChecked(child);\n        }\n        return this.isItemChecked(child.item);\n      });\n      return childrenChecked || this.isItemChecked(lookup.item);\n    }\n  }\n  _class42 = CheckAllDirective;\n  _defineProperty(CheckAllDirective, \"\\u0275fac\", function _class42_Factory(t) {\n    return new (t || _class42)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(CheckAllDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class42,\n    selectors: [[\"\", \"checkAll\", \"\"]],\n    hostBindings: function _class42_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function _class42_change_HostBindingHandler($event) {\n          return ctx.handleChange($event.target);\n        });\n      }\n    },\n    inputs: {\n      lastAction: \"lastAction\",\n      treeview: \"treeview\",\n      checkedItems: \"checkedItems\",\n      valueField: \"valueField\",\n      focused: [\"checkAll\", \"focused\"]\n    },\n    outputs: {\n      checkedItemsChange: \"checkedItemsChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return CheckAllDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_POPUP_SETTINGS = {\n  animate: true\n};\nconst DEFAULT_CHECKABLE_SETTINGS = {\n  checkChildren: true,\n  checkOnClick: true\n};\nconst hasChildren = () => false;\nconst fetchChildren = () => of([]);\nconst itemDisabled = () => false;\nconst isNodeVisible = () => true;\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_ROUNDED = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Represents the [Kendo UI MultiSelectTree component for Angular]({% slug overview_multiselecttree %}).\n */\nlet MultiSelectTreeComponent = /*#__PURE__*/(() => {\n  var _class43;\n  class MultiSelectTreeComponent {\n    get isDisabled() {\n      return this.disabled || null;\n    }\n    get hostAriaAutocomplete() {\n      return this.filterable ? 'list' : null;\n    }\n    get isLoading() {\n      return this.loading;\n    }\n    get hostAriaInvalid() {\n      return this.formControl ? this.formControl.invalid.toString() : null;\n    }\n    get isBusy() {\n      return this.loading ? 'true' : null;\n    }\n    get id() {\n      return this.focusableId;\n    }\n    get hostTabIndex() {\n      return this.tabindex;\n    }\n    get isReadonly() {\n      return this.readonly ? '' : null;\n    }\n    get ariaDescribedBy() {\n      return this.tagListId;\n    }\n    get ariaActiveDescendant() {\n      return this.focusedTagId;\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * @hidden\n     */\n    onFilterChange(text) {\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onExpand() {\n      this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);\n      this.isActionSheetExpanded = true;\n    }\n    /**\n     * @hidden\n     */\n    onCollapse() {\n      this.isActionSheetExpanded = false;\n    }\n    /**\n     * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.\n     */\n\n    /**\n     * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n     * By default the ActionSheet subtitle uses the text provided for the `placeholder` of the AutoComplete.\n    */\n    set subtitle(_subtitle) {\n      this._subtitle = _subtitle;\n    }\n    get subtitle() {\n      return this._subtitle || this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n    * @hidden\n    */\n\n    /**\n     * @hidden\n     */\n    handleKeydown(event, input) {\n      if (event.target === this.filterInput?.nativeElement && (event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight)) {\n        return;\n      }\n      if (input) {\n        event.stopImmediatePropagation();\n      }\n      const deleteTag = this.isWrapperActive && event.keyCode === Keys.Backspace && this.tags.length > 0;\n      if (deleteTag) {\n        this.handleBackspace();\n        return;\n      }\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {\n        this.printableCharacters.next(event.key);\n      }\n      const eventData = event;\n      const action = this.navigationService.process({\n        originalEvent: eventData,\n        openOnSpace: !this.isOpen,\n        closeOnSpace: false\n      });\n      if (action === NavigationAction.Open) {\n        eventData.preventDefault();\n      }\n      if (this.isOpen && action === NavigationAction.Enter) {\n        const spaceKeyDownEvent = new KeyboardEvent('keydown', {\n          'key': ' ',\n          'code': 'Space',\n          'keyCode': 32,\n          'which': 32\n        });\n        this.treeview?.element.nativeElement.dispatchEvent(spaceKeyDownEvent);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.responsiveRendererComponent?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get actionSheetSearchBar() {\n      return this.responsiveRendererComponent?.actionSheetSearchBar;\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    set treeview(treeview) {\n      this._treeview = treeview;\n      if (treeview) {\n        // If filtering is enabled, focus the TreeView on mobile devices instead of the filter input\n        if (this.isFocused && !this.filterable && !this.checkAll || this.touchEnabled) {\n          treeview.focus();\n        }\n        /**\n         * the treeview animations are initially disabled (we don't want expand animations during popup opening)\n         * re-enables the animations for user interaction\n         * The Promise is required to properly change the `animate` property when\n         * the popup is appended to a container and opened upon initialization.\n         * Otherwise, the \"Expression has changed...\" type error will be thrown.\n         */\n        Promise.resolve(null).then(() => this.treeview.animate = true);\n      }\n    }\n    get treeview() {\n      return this._treeview;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n      const providedTabIndex = parseNumber(value);\n      const defaultTabIndex = 0;\n      this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n    get tabindex() {\n      return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Configures the popup of the MultiSelectTree.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS, settings);\n      // `detectChanges` needed, otherwise upon value initialization and `appendTo` property\n      // an error is thrown => ExpressionChangedAfterItHasBeenCheckedError\n      this.cdr.detectChanges();\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Defines the checkable settings of the MultiSelecTree nodes.\n     * If no value is provided, the default [`CheckableSettings`]({% slug api_dropdowns_multiselecttreecheckablesettings %}) are applied.\n     */\n    set checkableSettings(settings) {\n      this._checkableSettings = Object.assign({}, DEFAULT_CHECKABLE_SETTINGS, settings);\n    }\n    get checkableSettings() {\n      return this._checkableSettings;\n    }\n    /**\n     * Sets the data of the MultiSelectTree.\n     *\n     * > The data has to be provided in an array-like list with objects.\n     */\n    set data(data) {\n      this._nodes = data;\n      this.setState();\n      if (this.isContentInit) {\n        // Needed for when the data is loaded later/asynchronously because it would not exist on ngContentInit\n        this.registerLookupItems(data);\n      }\n    }\n    get data() {\n      return this._nodes;\n    }\n    /**\n     * Sets the value of the MultiSelectTree.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     */\n    set value(value) {\n      this._value = value ? value : [];\n      this.setState();\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Keeps the current `dataItems` object in order to resolve selection.\n     * Needs to be provided when when programmatically setting a `value` and `valuePrimitive` is set to `true`.\n     */\n    set dataItems(items) {\n      this._dataItems = (items || []).map((dataItem, index) => {\n        if (hasProps(dataItem, ['dataItem', 'index', 'level'])) {\n          return dataItem;\n        }\n        const level = this.valueDepth[index] || 0;\n        const key = valueFrom({\n          dataItem,\n          level\n        }, this.valueField) + '_' + (this.isHeterogeneous ? this.valueDepth[index] : 0);\n        return {\n          dataItem,\n          index: null,\n          level,\n          key\n        };\n      });\n      this.setState();\n    }\n    get dataItems() {\n      return this._dataItems || this.value.map((value, index) => {\n        const level = this.valueDepth[index] || 0;\n        const key = valueFrom({\n          dataItem: value,\n          level\n        }, this.valueField) + '_' + (this.isHeterogeneous ? this.valueDepth[index] : 0);\n        return {\n          dataItem: value,\n          index: null,\n          level,\n          key\n        };\n      });\n    }\n    /**\n     * The fields of the data item that provide the text content of the nodes inside the\n     * MultiSelectTree ([see example]({% slug databinding_multiselecttree %})). If the `textField`\n     * input is set to an array, each hierarchical level uses the field that corresponds\n     * to the same index in the array, or the last item in the array.\n     *\n     * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.\n     */\n\n    /**\n     * Sets the height of the options list in the popup. By default, `listHeight` is 200px.\n     *\n     * > The `listHeight` property affects only the list of options and not the whole popup container.\n     * > To set the height of the popup container, use `popupSettings.height`.\n     *\n     * > When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.\n     */\n    set listHeight(_listHeight) {\n      this._listHeight = _listHeight;\n    }\n    get listHeight() {\n      if (this.isAdaptive) {\n        return;\n      }\n      return this._listHeight;\n    }\n    /**\n     * @hidden\n     */\n    get focusedTagId() {\n      if (!isPresent(this.focusedTagIndex) || this.isOpen) {\n        return null;\n      }\n      return this.tagPrefix + '-' + this.focusedTagIndex;\n    }\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * Returns the current open state. Returns `true` if the popup or actionSheet is open.\n     */\n    get isOpen() {\n      return isTruthy(isPresent(this.popupRef) || this.isActionSheetExpanded);\n    }\n    get width() {\n      const wrapperWidth = this.wrapper.nativeElement.offsetWidth;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n    get popupContainerClasses() {\n      const containerClasses = ['k-multiselecttree-popup'];\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives.\n     */\n    set nodes(nodes) {\n      this.data = nodes;\n    }\n    get nodes() {\n      return this.data;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives\n     */\n    set children(callback) {\n      this.fetchChildren = callback;\n    }\n    get children() {\n      return this.fetchChildren;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    get expand() {\n      return this.nodeExpand;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    get collapse() {\n      return this.nodeCollapse;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n    set isExpanded(callback) {\n      this.isNodeExpanded = callback;\n    }\n    get isExpanded() {\n      return this.isNodeExpanded;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.\n     * The `DataBoundComponent` interface is used in the data-binding directives.\n     */\n    set isVisible(callback) {\n      this.isNodeVisible = callback;\n    }\n    get isVisible() {\n      return this.isNodeVisible;\n    }\n    get isTagFocused() {\n      return !this.isOpen && this.focusedTagIndex !== undefined;\n    }\n    get isTreeViewActive() {\n      return this.treeview && this.treeview.isActive;\n    }\n    get isWrapperActive() {\n      return document.activeElement === this.wrapper.nativeElement;\n    }\n    get isFilterActive() {\n      return this.filterInput && document.activeElement === this.filterInput.nativeElement;\n    }\n    get isCheckAllActive() {\n      return this.checkAllInput && document.activeElement === this.checkAllInput.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.togglePopup(false);\n        }\n        this.windowSize = currentWindowSize;\n      }\n      if (this.isOpen && !this.isActionSheetExpanded) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(injector, wrapper, popupService, renderer, navigationService, _zone, localization, cdr, lookup, adaptiveService) {\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"navigationService\", void 0);\n      _defineProperty(this, \"_zone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"lookup\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"touchEnabled\", touchEnabled);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"searchIcon\", searchIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"treeViewId\", `k-${guid$1()}`);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"role\", 'combobox');\n      _defineProperty(this, \"ariaHasPopup\", 'tree');\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.\n       * By default the ActionSheet title uses the text provided for the label of the AutoComplete.\n       */\n      _defineProperty(this, \"title\", '');\n      _defineProperty(this, \"windowSize\", 'large');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"isActionSheetExpanded\", false);\n      _defineProperty(this, \"responsiveRendererComponent\", void 0);\n      _defineProperty(this, \"headerTemplate\", void 0);\n      _defineProperty(this, \"footerTemplate\", void 0);\n      _defineProperty(this, \"nodeTemplate\", void 0);\n      _defineProperty(this, \"noDataTemplate\", void 0);\n      _defineProperty(this, \"tagTemplate\", void 0);\n      _defineProperty(this, \"groupTagTemplate\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"filterInput\", void 0);\n      _defineProperty(this, \"checkAllInput\", void 0);\n      _defineProperty(this, \"textField\", void 0);\n      /**\n       * The fields of the data item that provide the value of the nodes inside the\n       * MultiSelectTree ([see example]({% slug databinding_multiselecttree %})). If the `valueField`\n       * input is set to an array, each hierarchical level uses the field that corresponds\n       * to the same index in the array, or the last item in the array.\n       *\n       * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.\n       */\n      _defineProperty(this, \"valueField\", void 0);\n      /**\n       * Sets the levels in the data set where the values can be found when `valueField` is an Array.\n       * The field serves to correctly allocate a data item used when the MultiSelectTree is initialized with a value.\n       */\n      _defineProperty(this, \"valueDepth\", []);\n      /**\n       * Sets and gets the loading state of the MultiSelectTree.\n       */\n      _defineProperty(this, \"loading\", void 0);\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n      _defineProperty(this, \"placeholder\", '');\n      _defineProperty(this, \"_listHeight\", 200);\n      /**\n       * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiselecttree#toc-managing-the-multiselecttree-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the component.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the type of the selected value\n       * ([more information and example]({% slug valuebinding_multiselecttree %}#toc-primitive-values)).\n       * If set to `true`, the selected value has to be a primitive one.\n       */\n      _defineProperty(this, \"valuePrimitive\", false);\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default false\n       */\n      _defineProperty(this, \"loadOnDemand\", false);\n      /**\n       * @hidden\n       *\n       * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid$1()}`);\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       * @default true\n       */\n      _defineProperty(this, \"clearButton\", true);\n      /**\n       * Renders the built-in input element for filtering the MultiSelectTree.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the MultiSelectTree manually]({% slug filtering_multiselecttree %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoMultiSelectTreeHierarchyBinding`]({% slug api_dropdowns_multiselecttreehierarchybindingdirective %}) and [`kendoMultiSelectTreeFlatBinding`]({% slug api_dropdowns_multiselecttreeflatbindingdirective %}) directives.\n       * @default false\n       */\n      _defineProperty(this, \"filterable\", false);\n      /**\n       * If `checkАll` is set to `true` and the checkboxes are enabled, a tri-state checkbox appears above the embedded treeview.\n       * Clicking the checkbox checks or unchecks all enabled items of the treeview that are loaded.\n       * @default false\n       */\n      _defineProperty(this, \"checkAll\", false);\n      /**\n       * A function which determines if a specific node has child nodes.\n       */\n      _defineProperty(this, \"hasChildren\", hasChildren);\n      /**\n       * A function which provides the child nodes for a given parent node.\n       */\n      _defineProperty(this, \"fetchChildren\", fetchChildren);\n      /**\n       * A function that is executed for each data item and determines if a specific node is expanded.\n       */\n      _defineProperty(this, \"isNodeExpanded\", void 0);\n      /**\n       * A callback which determines whether a tree node should be rendered as hidden. The utility .k-hidden class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n      _defineProperty(this, \"isNodeVisible\", isNodeVisible);\n      /**\n       * A function that is executed for each data item and determines if a specific item is disabled.\n       */\n      _defineProperty(this, \"itemDisabled\", itemDisabled);\n      /**\n       * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.\n       *\n       * @param { Any[] } dataItems - The selected data items from the list.\n       * @returns { Any[] } - The tags that will be rendered by the component.\n       */\n      _defineProperty(this, \"tagMapper\", tags => tags || []);\n      /**\n       * Fires each time the user focuses the MultiSelectTree.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the MultiSelectTree gets blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_multiselecttree %})).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires after the popup has been opened.\n       */\n      _defineProperty(this, \"opened\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_multiselecttree %})).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires after the popup has been closed.\n       */\n      _defineProperty(this, \"closed\", new EventEmitter());\n      /**\n       * Fires when the user expands a node in the popup TreeView.\n       */\n      _defineProperty(this, \"nodeExpand\", new EventEmitter());\n      /**\n       * Fires when the user collapses a node in the popup TreeView.\n       */\n      _defineProperty(this, \"nodeCollapse\", new EventEmitter());\n      /**\n       * Fires each time the value is changed\n       * ([see example](slug:events_multiselecttree)).\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselect %}#toc-notifying-on-removing-group-tags)).\n       * This event is preventable. If you cancel it, the tag will not be removed.\n       */\n      _defineProperty(this, \"removeTag\", new EventEmitter());\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n      _defineProperty(this, \"filterChange\", new EventEmitter());\n      _defineProperty(this, \"filterStateChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"filter\", '');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"checkedItems\", []);\n      /**\n       * @hidden\n       * The flag is needed in order to determine how to construct the items map keys.\n       * If `true`, then the key consists of the item's value and level (depth),\n       * else the key consists of the item's value and 0 (no leveling required)\n       */\n      _defineProperty(this, \"isHeterogeneous\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showAfter\", 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"allNodesHidden\", false);\n      _defineProperty(this, \"tagListId\", `k-${guid$1()}`);\n      _defineProperty(this, \"tagPrefix\", \"tag-\" + guid$1());\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"tags\", void 0);\n      _defineProperty(this, \"focusedTagIndex\", undefined);\n      _defineProperty(this, \"disabledIndices\", void 0);\n      _defineProperty(this, \"_subtitle\", void 0);\n      _defineProperty(this, \"_nodes\", void 0);\n      _defineProperty(this, \"_value\", []);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"_popupSettings\", DEFAULT_POPUP_SETTINGS);\n      _defineProperty(this, \"_checkableSettings\", DEFAULT_CHECKABLE_SETTINGS);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"_treeview\", void 0);\n      _defineProperty(this, \"_dataItems\", void 0);\n      _defineProperty(this, \"_tempValue\", void 0);\n      _defineProperty(this, \"_initiallyCheckedItems\", []);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_searchableNodes\", []);\n      _defineProperty(this, \"_typedValue\", '');\n      _defineProperty(this, \"printableCharacters\", new Subject());\n      _defineProperty(this, \"subs\", new Subscription());\n      // Keep an instance of the last focused node for when the popup close is prevented\n      // in order to be able to properly restore the focus\n      _defineProperty(this, \"lastNodeOnFocus\", void 0);\n      // Used as check to avoid unnecessary 'registerLookupItems()' calls upon initialization\n      _defineProperty(this, \"isContentInit\", void 0);\n      _defineProperty(this, \"lastAction\", 'check');\n      _defineProperty(this, \"onTouchedCallback\", noop);\n      _defineProperty(this, \"onChangeCallback\", noop);\n      this.injector = injector;\n      this.wrapper = wrapper;\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.navigationService = navigationService;\n      this._zone = _zone;\n      this.localization = localization;\n      this.cdr = cdr;\n      this.lookup = lookup;\n      this.adaptiveService = adaptiveService;\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeFocusEvents();\n    }\n    ngOnInit() {\n      this.subs.add(this.printableCharacters.pipe(tap(char => {\n        this._typedValue += char;\n        const itemToFocus = this._searchableNodes.find(node => {\n          return node.text.toLowerCase().indexOf(this._typedValue) === 0;\n        });\n        this.treeview.focus(itemToFocus?.index);\n      }), debounceTime(1000)).subscribe(() => {\n        this._typedValue = '';\n      }));\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', String(this.isOpen));\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      }));\n      this.setComponentClasses();\n      this._initiallyCheckedItems = [...this.checkedItems];\n    }\n    ngAfterViewInit() {\n      this.windowSize = this.adaptiveService.size;\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'click', this.handleClick.bind(this)));\n      this.subs.add(this.renderer.listen(this.wrapper.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.isHeterogeneous = this.valueField && isArray(this.valueField);\n        this.setState();\n      }\n      if (anyChanged(['valueDepth', 'value', 'dataItems'], changes, false)) {\n        if (changes['value'] && !changes['dataItems'] && !this.valuePrimitive) {\n          // Update the dataItems if the value is updated programmatically (non-primitive values only)\n          // In the primitive case, the client should update the dataItems as well\n          this.dataItems = this.value;\n        } else {\n          // Re-map the dataItems because `valueDepth` is not yet available when the check directive parses the items\n          this.dataItems = this.dataItems.map((item, index) => ({\n            ...item,\n            key: valueFrom({\n              dataItem: item.dataItem,\n              index: null,\n              level: this.valueDepth[index] || 0\n            }, this.valueField) + '_' + (this.isHeterogeneous ? this.valueDepth[index] : 0),\n            level: this.valueDepth[index] || 0\n          }));\n        }\n      }\n      if (anyChanged(['data', 'children', 'hasChildren', 'loadOnDemand', 'valueField'], changes, true) && !this.loadOnDemand) {\n        this.lookup.reset();\n        this.registerLookupItems(this.data);\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentChecked() {\n      this.verifySettings();\n      if (this.data?.length > 0 && this.popupRef) {\n        this.allNodesHidden = this.areNodesHidden(this.data);\n      }\n    }\n    /**\n     * @hidden\n     */\n    applyValue() {\n      this.value = this._tempValue;\n      this._initiallyCheckedItems = [...this.checkedItems];\n      this.emitValueChange(this.value);\n      this.setTags();\n      this.toggle(false);\n    }\n    /**\n     * @hidden\n     */\n    cancelValue() {\n      this.checkedItems = [...this._initiallyCheckedItems];\n      this.togglePopup(false);\n    }\n    ngAfterContentInit() {\n      this.isContentInit = true;\n      // Still need to keep the call of 'registerLookupItems()' from ngAfterContentInit in the cases when the data is passed initially\n      // The call is execute here because we have to make sure it happens after all input properties are loaded (not the case in the data setter initially)\n      this.registerLookupItems(this.data);\n    }\n    /**\n     * @hidden\n     *\n     * Used by the kendo-floatinglabel component to determine if the floating label\n     * should be rendered inside the input when the component is not focused.\n     */\n    isEmpty() {\n      return !this.placeholder && (!isPresent(this.value) || this.value.length === 0);\n    }\n    /**\n     * Focuses the MultiSelectTree.\n     */\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the MultiSelectTree.\n     */\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n      }\n    }\n    /**\n     * Focuses a specific item of the MultiSelectTree based on a provided index in the format of `1_1`.\n     * The targeted item should be expanded in order for it to be focused.\n     * If null or invalid index is provided the focus will be set on the first item.\n     */\n    focusItemAt(index) {\n      if (this.treeview) {\n        const lookup = this.treeview.itemLookup(index);\n        const isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);\n        if (!isItemDisabled) {\n          this.treeview.focus(index);\n        }\n      }\n    }\n    /**\n     * Resets the value of the MultiSelectTree.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `valueChange` event will not be fired.\n     */\n    reset() {\n      this.value = [];\n      this.dataItems = [];\n      this.valueDepth = [];\n    }\n    /**\n     * Toggles the visibility of the popup or actionSheet\n     * ([see example]({% slug openstate_multiselecttree %})).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"ViewContainerRef not found...\" error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !isPresent(this.popupRef);\n        this.destroyPopup();\n        if (shouldOpen) {\n          this.createPopup();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      if (!this.isFocused) {\n        this.isFocused = true;\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n        // Re-focus the treeview if `close` is prevented\n        if (this.isOpen && this.treeview) {\n          if (this.lastNodeOnFocus) {\n            this.lastNodeOnFocus.setAttribute('tabindex', '0');\n          }\n          this.treeview.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleBlur(e) {\n      if (!this.isActionSheetExpanded) {\n        const relatedTarget = e && e.relatedTarget;\n        if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {\n          return;\n        }\n        this.isFocused = false;\n        this.togglePopup(false);\n        //this is needed for Ang 18 not to throw ng0100 error when closing the popup\n        //the component could be refactored using kendoDropDownSharedEvents directive\n        //once we are able to debug against Angular 18\n        this.cdr.markForCheck();\n        if (hasObservers(this.onBlur) || isUntouched(this.wrapper.nativeElement) || this.formControl?.updateOn === 'blur') {\n          this._zone.run(() => {\n            this.onBlur.emit();\n            this.onTouchedCallback();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleNodeClick(node) {\n      if (!this.isFocused) {\n        // Re-focus the MultiSelectTree when popup close is prevented and a node is clicked\n        // On click the focus should be on the clicked element which is why we need to update the lastNodeOnFocus\n        const parent = node.originalEvent.target.parentElement.parentElement;\n        this.lastNodeOnFocus = parent;\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n      this._zone.run(() => {\n        this.focusedTagIndex = undefined;\n      });\n      if (isDisabled || sameState) {\n        return;\n      }\n      const togglePrevented = this.triggerPopupEvents(open);\n      if (!togglePrevented) {\n        if (open) {\n          this.createPopup();\n        } else {\n          this.destroyPopup();\n        }\n      } else {\n        this.removeTreeViewFromTabOrder();\n      }\n    }\n    /**\n     * @hidden\n     */\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    handleCheckedItemsChange(items) {\n      this.valueDepth = items.map(item => item.level);\n      this.lastAction = items.length > this.dataItems.length ? 'check' : 'uncheck';\n      this.dataItems = items.slice();\n      this.updateValue(this.dataItems);\n    }\n    /**\n     * @hidden\n     */\n    handleRemoveTag({\n      tag,\n      index\n    }) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      const eventArgs = new RemoveTagEvent(tag);\n      this.removeTag.emit(eventArgs);\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      }\n      // Remove tags based on their position index\n      if (tag instanceof Array) {\n        // Remove group tag\n        this.dataItems = this.dataItems.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));\n        this.valueDepth = this.valueDepth.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));\n      } else if (this.loadOnDemand) {\n        // Remove single tag when the child items are fetched on demand\n        this.dataItems = this.dataItems.filter((_item, i) => i !== index || this.disabledIndices.has(i));\n        this.valueDepth = this.valueDepth.filter((_item, i) => i !== index || this.disabledIndices.has(i));\n      } else {\n        // Remove single tag when the child items are pre-fetched\n        const dataItem = this.dataItems.find(item => item.tagPositionIndex === index);\n        const itemKey = dataItem.key;\n        const lookup = this.lookup.itemLookup(itemKey);\n        const pendingCheck = [lookup.item];\n        if (this.checkableSettings.checkChildren) {\n          fetchDescendentNodes(lookup).forEach(lookup => pendingCheck.push(lookup.item));\n          pendingCheck.push(...this.removeParents(lookup.parent));\n        }\n        const keysToRemove = pendingCheck.map(item => item.key);\n        // Holds the position indexes of the items to be removed\n        const valueDepthIndices = [];\n        this.dataItems = this.dataItems.filter((_item, i) => {\n          const shouldStay = !keysToRemove.includes(_item.key) || this.disabledIndices.has(i);\n          if (!shouldStay) {\n            // We need to know the index position of the data item to be able to update the valueDepth array accordignly\n            // as each data item's position is corresponding to the same position in valueDepth\n            valueDepthIndices.push(i);\n          }\n          return shouldStay;\n        });\n        this.valueDepth = this.valueDepth.filter((_item, i) => {\n          return !valueDepthIndices.includes(i) || this.disabledIndices.has(i);\n        });\n      }\n      this.updateValue(this.dataItems);\n      if (!this.isFocused) {\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleTagMapperChange(showAfter) {\n      this.showAfter = parseNumber(showAfter);\n      this.setTags();\n    }\n    /**\n     * @hidden\n     */\n    clearAll(event) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      this.focus();\n      this.value = this.value.filter((_item, index) => this.disabledIndices.has(index));\n      this.dataItems = this.dataItems.filter((_item, index) => this.disabledIndices.has(index));\n      this.valueDepth = this.valueDepth.filter((_depth, index) => this.disabledIndices.has(index));\n      this.emitValueChange(this.value);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      if (!this.valuePrimitive && isPresent(value)) {\n        this.dataItems = value;\n      }\n      if (!isPresent(value) && isPresent(this.value)) {\n        this.dataItems = null;\n      }\n      this.value = value || [];\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleFilterInputChange(input) {\n      this.filter = input.value;\n      this.filterChange.next(input.value);\n    }\n    /**\n     * @hidden\n     */\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    get checkAllCheckboxClasses() {\n      return `${this.size ? getSizeClass('checkbox', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n    toggleCheckAll() {\n      this.checkAllInput.nativeElement.focus();\n      this.checkAllInput.nativeElement.click();\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(MultiSelectTreeMessages.textAndValue);\n      }\n      if (!isArray(this.value)) {\n        throw new Error(MultiSelectTreeMessages.array);\n      }\n      if (this.value.length > 0) {\n        if (this.valuePrimitive && this.value.some(item => isObject(item))) {\n          throw new Error(MultiSelectTreeMessages.primitive);\n        }\n        const isEveryDataItemObject = this.dataItems.every(item => isObject(item.dataItem));\n        if (this.valuePrimitive && !isArray(this.dataItems)) {\n          throw new Error(MultiSelectTreeMessages.dataItems);\n        }\n        if (this.valuePrimitive && !isEveryDataItemObject) {\n          throw new Error(MultiSelectTreeMessages.dataItems);\n        }\n        if (this.valuePrimitive && this.dataItems.length !== this.value.length) {\n          throw new Error(MultiSelectTreeMessages.dataItemsLength);\n        }\n        if (!this.valuePrimitive && !isObjectArray(this.value)) {\n          throw new Error(MultiSelectTreeMessages.object);\n        }\n        if ((isArray(this.valueField) || isArray(this.textField)) && !isArray(this.valueDepth)) {\n          throw new Error(MultiSelectTreeMessages.valueDepth);\n        }\n        if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length === 0) {\n          throw new Error(MultiSelectTreeMessages.valueDepth);\n        }\n        if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length !== this.value.length) {\n          throw new Error(MultiSelectTreeMessages.valueDepthLength);\n        }\n      }\n    }\n    areNodesHidden(nodes) {\n      return nodes.every((node, index) => !this.isVisible(node, String(index)));\n    }\n    emitValueChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n      if (hasObservers(this.open) || hasObservers(this.close)) {\n        this._zone.run(() => {\n          if (open) {\n            this.open.emit(eventArgs);\n          } else {\n            this.close.emit(eventArgs);\n          }\n        });\n      }\n      return eventArgs.isDefaultPrevented();\n    }\n    createPopup() {\n      this.windowSize = this.adaptiveService.size;\n      if (this.isAdaptive) {\n        this.openActionSheet();\n        this.cdr.detectChanges();\n        return;\n      }\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'bottom'\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'top'\n      };\n      const appendToComponent = typeof this.popupSettings.appendTo === 'string' && this.popupSettings.appendTo === 'component';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        appendTo: this.appendTo,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        positionMode: appendToComponent ? 'fixed' : 'absolute',\n        popupClass: this.popupContainerClasses\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      if (!this.appendTo) {\n        this.renderer.setAttribute(popupWrapper, 'role', 'region');\n        this.renderer.setAttribute(popupWrapper, 'aria-label', this.messageFor('popupLabel'));\n      }\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-controls', this.treeViewId);\n      this.renderer.setAttribute(popupWrapper, 'dir', this.direction);\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.opened.emit();\n        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        if (hasObservers(this.closed)) {\n          this._zone.run(() => {\n            this.closed.emit();\n          });\n        }\n      });\n    }\n    destroyPopup() {\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      }\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'aria-controls');\n        if (this.filter !== \"\") {\n          this.filter = \"\";\n          this.allNodesHidden = false;\n          if (hasObservers(this.filterChange)) {\n            this._zone.run(() => {\n              this.filterChange.emit(\"\");\n            });\n          }\n        }\n      }\n    }\n    handleClick(e) {\n      // The check is needed otherwise when appended to the component, the popup reopens on click\n      // https://github.com/telerik/kendo-angular/issues/3738\n      if (this.popupRef && this.popupRef.popupElement.contains(e.target) || this.isActionSheetExpanded) {\n        return;\n      }\n      this.togglePopup(!this.isOpen);\n    }\n    subscribeEvents() {\n      [this.navigationService.open.subscribe(event => {\n        event.originalEvent.preventDefault();\n        this.togglePopup(true);\n      }), this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(() => this.togglePopup(true)), merge(this.navigationService.close, this.navigationService.esc).subscribe(event => {\n        event.originalEvent.preventDefault();\n        this.focus();\n        this.togglePopup(false);\n      }), this.navigationService.tab.subscribe(this.handleTabKey.bind(this)), this.navigationService.up.subscribe(this.handleUpKey.bind(this)), this.navigationService.down.subscribe(this.handleDownKey.bind(this)), this.navigationService.left.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.home.pipe(filter(() => !this.isOpen)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => !this.isOpen)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(() => this.isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(() => this.isTagFocused)).subscribe(this.handleDelete.bind(this))].forEach(sub => this.subs.add(sub));\n    }\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.handleFocus = this.handleFocus.bind(this);\n        this.handleDocumentBlur = this.handleDocumentBlur.bind(this);\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.handleFocus, useCapture);\n          document.addEventListener('blur', this.handleDocumentBlur, useCapture);\n        });\n      }\n    }\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.handleFocus, useCapture);\n        document.removeEventListener('blur', this.handleDocumentBlur, useCapture);\n      }\n    }\n    handleDocumentBlur(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n      event.stopImmediatePropagation();\n      this.handleBlur(event);\n    }\n    handleTabKey() {\n      if (!this.isActionSheetExpanded) {\n        this.focus();\n      }\n      if (this.isOpen) {\n        this.treeview.blur();\n        this.removeTreeViewFromTabOrder();\n      }\n    }\n    handleUpKey(event) {\n      if (!this.treeview) {\n        return;\n      }\n      event.originalEvent.preventDefault();\n      // Prevent toggling the focus between the filterInput and the wrapper elements with `up` key\n      if (this.isWrapperActive) {\n        return;\n      }\n      const isFirstNodeActive = this.treeview['navigationService']['activeIndex'] === '0';\n      // Current focus is on the filter input => should focus the wrapper\n      if (this.filterable && this.isFilterActive) {\n        this.focus();\n        // Current focus is on the treeview first node => should focus the check all checkbox if enabled\n      } else if (this.checkAll && !this.isCheckAllActive && isFirstNodeActive) {\n        this.checkAllInput.nativeElement.focus();\n        // Current focus is either on the check all checkbox or the treeview's first node\n        // => should focus either the filter input (if enabled) or the wrapper\n      } else if (this.isCheckAllActive || isFirstNodeActive) {\n        if (this.filterable) {\n          this.isActionSheetExpanded ? this.actionSheetSearchBar.focus() : this.filterInput.nativeElement.focus();\n        } else {\n          if (!this.isActionSheetExpanded) {\n            this.focus();\n          }\n        }\n      }\n    }\n    handleDownKey(event) {\n      if (!this.treeview) {\n        return;\n      }\n      event.originalEvent.preventDefault();\n      // Current focus is on the wrapper => should focus the filter input\n      if (this.filterable && this.isWrapperActive) {\n        this.filterInput.nativeElement.focus();\n        // Current focus is on the wrapper/filter input => should focus check all checkbox if enabled\n      } else if (this.checkAll && (this.isWrapperActive || this.isFilterActive)) {\n        this.checkAllInput.nativeElement.focus();\n        // Should focus the treeview if filterable and check all are disabled\n      } else if (!this.treeview.isActive) {\n        this.treeview.focus();\n      }\n      this.focusedTagIndex = undefined;\n    }\n    handleRightKey(event) {\n      event.originalEvent.preventDefault();\n      const last = this.tags.length - 1;\n      if (this.focusedTagIndex === last) {\n        this.focusedTagIndex = undefined;\n      } else if (this.focusedTagIndex < last) {\n        this.focusedTagIndex++;\n      } else if (!this.focusedTagIndex) {\n        this.focusedTagIndex = 0;\n      }\n    }\n    handleLeftKey(event) {\n      event.originalEvent.preventDefault();\n      if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {\n        this.focusedTagIndex = this.tags.length - 1;\n      } else if (this.focusedTagIndex !== 0) {\n        this.focusedTagIndex--;\n      }\n    }\n    handleEnd(event) {\n      event.originalEvent.preventDefault();\n      this.focusedTagIndex = this.tags.length - 1;\n    }\n    handleHome(event) {\n      event.originalEvent.preventDefault();\n      this.focusedTagIndex = 0;\n    }\n    handleBackspace() {\n      if (this.focusedTagIndex !== undefined) {\n        this.handleDelete();\n      } else {\n        const tag = this.tags[this.tags.length - 1];\n        const index = this.tags.length - 1;\n        this.handleRemoveTag({\n          tag,\n          index\n        });\n      }\n    }\n    handleDelete() {\n      const tag = this.tags[this.focusedTagIndex];\n      const index = this.focusedTagIndex;\n      this.handleRemoveTag({\n        tag,\n        index\n      });\n      if (this.focusedTagIndex === this.tags.length) {\n        this.focusedTagIndex = undefined;\n      }\n    }\n    unsubscribeEvents() {\n      this.subs.unsubscribe();\n      this.unSubscribeFocusEvents();\n    }\n    /**\n     * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur\n     * and the user will not be able to tab to the rest of the browser elements\n     */\n    removeTreeViewFromTabOrder() {\n      const nodes = this.treeview.element.nativeElement.querySelectorAll('li');\n      nodes.forEach(item => {\n        if (item.getAttribute('tabindex') === '0') {\n          this.lastNodeOnFocus = item;\n          this.lastNodeOnFocus.setAttribute('tabindex', '-1');\n        }\n      });\n    }\n    setState() {\n      if (isPresent(this.dataItems) && isPresent(this.valueField)) {\n        if (!this.isActionSheetExpanded) {\n          this.setTags();\n        }\n        this.checkedItems = this.dataItems.slice();\n      }\n      this.cdr.markForCheck();\n    }\n    setTags() {\n      const source = this.dataItems.map(item => item.dataItem);\n      this.tags = this.tagMapper(source);\n      this.disabledIndices = this.disabledItemsMapper();\n      // Create a mapping of tags to position indices\n      const tagIndexMap = new Map(this.tags.map((tag, index) => [JSON.stringify(tag), index]));\n      // Modify dataItems by adding a property to hold the item's position as displayed in the tags\n      this.dataItems.forEach(item => {\n        const serializedDataItem = JSON.stringify(item.dataItem);\n        item.tagPositionIndex = tagIndexMap.has(serializedDataItem) ? tagIndexMap.get(serializedDataItem) // Use the index from tags if it exists\n        : null; // Assign a null value if the dataItem is not visible in the tags\n      });\n    }\n\n    updateValue(value) {\n      const newValue = this.valuePrimitive ? value.map(item => valueFrom(item, this.valueField)) : value.map(item => item.dataItem);\n      if (this.isActionSheetExpanded) {\n        this._tempValue = newValue.slice();\n      } else {\n        this.value = newValue;\n        this.emitValueChange(this.value);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onChildrenLoaded() {\n      setTimeout(() => {\n        if (this.popupRef) {\n          this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);\n        }\n        if (this.isActionSheetExpanded) {\n          this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);\n        }\n      });\n    }\n    /**\n     * @hidden\n     *\n     * Determines which of the provided tags should be disabled and stores their position indices\n     */\n    disabledItemsMapper() {\n      return new Set(this.dataItems.reduce((indices, item, index) => {\n        if (this.itemDisabled(item.dataItem, item.index)) {\n          indices.push(index);\n        }\n        return indices;\n      }, []));\n    }\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n    removeParents(parent) {\n      let currentParent = parent;\n      const nodes = [];\n      while (currentParent) {\n        nodes.push(currentParent.item);\n        currentParent = currentParent.parent;\n      }\n      return nodes;\n    }\n    /**\n     * Creates an internal map of the available tree items to be used as a reference\n     * to retrieve the item's children/parent and determine the checked sate\n     */\n    registerLookupItems(data, parentItem = null, levelIndex = 0) {\n      if (!isPresent(data) || data.length === 0) {\n        return;\n      }\n      const parentIndex = nodeIndex(parentItem);\n      const treeItems = data.map(node => buildTreeItem(node, this.valueField, levelIndex));\n      if (isPresent(parentItem)) {\n        this.lookup.registerChildren(parentIndex, treeItems);\n      }\n      treeItems.forEach(item => {\n        this.lookup.registerItem(item, parentItem);\n        if (!this.loadOnDemand) {\n          this.registerChildLookupItems(item, levelIndex);\n        }\n      });\n    }\n    registerChildLookupItems(item, levelIndex) {\n      if (this.hasChildren(item.dataItem)) {\n        this.children(item.dataItem).subscribe(children => {\n          const index = this.isHeterogeneous ? levelIndex + 1 : 0;\n          this.registerLookupItems(children, item, index);\n        });\n      }\n    }\n    closeActionSheet() {\n      this.wrapper.nativeElement.focus();\n      this.actionSheet.toggle(false);\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'aria-controls');\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n      if (this.filterable) {\n        this.actionSheetSearchBar.value = '';\n        this.filterChange.emit('');\n      }\n      this.closed.emit();\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.actionSheet.toggle(true);\n      this.title = setActionSheetTitle(this.wrapper, this.title);\n      this.cdr.detectChanges();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-controls', this.treeViewId);\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n      this.cdr.detectChanges();\n      this.opened.emit();\n      this.filterable && this.actionSheetSearchBar.focus();\n    }\n  }\n  _class43 = MultiSelectTreeComponent;\n  _defineProperty(MultiSelectTreeComponent, \"\\u0275fac\", function _class43_Factory(t) {\n    return new (t || _class43)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MultiSelectTreeLookupService), i0.ɵɵdirectiveInject(i7.AdaptiveService));\n  });\n  _defineProperty(MultiSelectTreeComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class43,\n    selectors: [[\"kendo-multiselecttree\"]],\n    contentQueries: function _class43_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class43_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ResponsiveRendererComponent, 5);\n        i0.ɵɵviewQuery(_c10, 7);\n        i0.ɵɵviewQuery(_c9, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c63, 5);\n        i0.ɵɵviewQuery(_c64, 5);\n        i0.ɵɵviewQuery(_c76, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.responsiveRendererComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeview = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.checkAllInput = _t.first);\n      }\n    },\n    hostVars: 22,\n    hostBindings: function _class43_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"aria-autocomplete\", ctx.hostAriaAutocomplete)(\"aria-invalid\", ctx.hostAriaInvalid)(\"aria-busy\", ctx.isBusy)(\"id\", ctx.id)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabIndex)(\"role\", ctx.role)(\"aria-haspopup\", ctx.ariaHasPopup)(\"readonly\", ctx.isReadonly)(\"aria-describedby\", ctx.ariaDescribedBy)(\"aria-activedescendant\", ctx.ariaActiveDescendant);\n        i0.ɵɵclassProp(\"k-multiselecttree\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading)(\"k-readonly\", ctx.readonly);\n      }\n    },\n    inputs: {\n      adaptiveMode: \"adaptiveMode\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      popupSettings: \"popupSettings\",\n      checkableSettings: \"checkableSettings\",\n      data: \"data\",\n      value: \"value\",\n      dataItems: \"dataItems\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      loading: \"loading\",\n      placeholder: \"placeholder\",\n      listHeight: \"listHeight\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      valuePrimitive: \"valuePrimitive\",\n      loadOnDemand: \"loadOnDemand\",\n      focusableId: \"focusableId\",\n      clearButton: \"clearButton\",\n      filterable: \"filterable\",\n      checkAll: \"checkAll\",\n      hasChildren: \"hasChildren\",\n      fetchChildren: \"fetchChildren\",\n      isNodeExpanded: \"isNodeExpanded\",\n      isNodeVisible: \"isNodeVisible\",\n      itemDisabled: \"itemDisabled\",\n      tagMapper: \"tagMapper\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      nodeExpand: \"nodeExpand\",\n      nodeCollapse: \"nodeCollapse\",\n      valueChange: \"valueChange\",\n      removeTag: \"removeTag\",\n      filterChange: \"filterChange\"\n    },\n    exportAs: [\"kendoMultiSelectTree\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, NavigationService, DataService, DisabledItemsService, SelectionService, MultiSelectTreeLookupService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiselecttree'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class43)\n    }, {\n      provide: DataBoundComponent,\n      useExisting: forwardRef(() => _class43)\n    }, {\n      provide: ExpandableComponent,\n      useExisting: forwardRef(() => _class43)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class43)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 14,\n    vars: 24,\n    consts: function () {\n      let i18n_77;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multiselecttree.noDataText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_78 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_77 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_78;\n      } else {\n        i18n_77 = $localize`:kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n      let i18n_79;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multiselecttree.clearTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_80 = goog.getMsg(\"clear\");\n        i18n_79 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_80;\n      } else {\n        i18n_79 = $localize`:kendo.multiselecttree.clearTitle|The title of the clear button:clear`;\n      }\n      let i18n_81;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed for the check-all checkbox\n         * @meaning kendo.multiselecttree.checkAllText\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_82 = goog.getMsg(\"Check all\");\n        i18n_81 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_82;\n      } else {\n        i18n_81 = $localize`:kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox:Check all`;\n      }\n      let i18n_83;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the filter input\n         * @meaning kendo.multiselecttree.filterInputLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_84 = goog.getMsg(\"Filter\");\n        i18n_83 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_84;\n      } else {\n        i18n_83 = $localize`:kendo.multiselecttree.filterInputLabel|The text set as aria-label on the filter input:Filter`;\n      }\n      let i18n_85;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the popup element that contains the list of options when its role is 'region'\n         * @meaning kendo.multiselecttree.popupLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_86 = goog.getMsg(\"Options list\");\n        i18n_85 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_86;\n      } else {\n        i18n_85 = $localize`:kendo.multiselecttree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;\n      }\n      let i18n_87;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Apply button in the action sheet\n         * @meaning kendo.multiselecttree.applyButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_88 = goog.getMsg(\"Apply\");\n        i18n_87 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_88;\n      } else {\n        i18n_87 = $localize`:kendo.multiselecttree.applyButton|The text of the Apply button in the action sheet:Apply`;\n      }\n      let i18n_89;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Cancel button in the action sheet\n         * @meaning kendo.multiselecttree.cancelButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_90 = goog.getMsg(\"Cancel\");\n        i18n_89 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_90;\n      } else {\n        i18n_89 = $localize`:kendo.multiselecttree.cancelButton|The text of the Cancel button in the action sheet:Cancel`;\n      }\n      return [[\"kendoMultiSelectTreeLocalizedMessages\", \"\", \"noDataText\", i18n_77, \"clearTitle\", i18n_79, \"checkAllText\", i18n_81, \"filterInputLabel\", i18n_83, \"popupLabel\", i18n_85, \"applyButton\", i18n_87, \"cancelButton\", i18n_89], [1, \"k-input-values\", 3, \"size\", \"rounded\", \"fillMode\", \"id\", \"tags\", \"focused\", \"textField\", \"valueField\", \"valueDepth\", \"disabled\", \"tagPrefix\", \"template\", \"groupTemplate\", \"disabledIndices\", \"removeTag\"], [1, \"k-input-inner\"], [\"class\", \"k-input-value-text\", 4, \"ngIf\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"sharedPopupActionSheetTemplate\", \"isActionSheetExpanded\", \"title\", \"showTextInput\", \"showActionButtons\", \"subtitle\", \"closePopup\", \"onExpand\", \"onCollapse\", \"textInputChange\", \"onApply\", \"onCancel\"], [\"sharedPopupActionSheetTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [1, \"k-input-value-text\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"click\"], [\"name\", \"x\", 1, \"k-icon\", 3, \"svgIcon\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [4, \"ngTemplateOutlet\"], [\"class\", \"k-list-filter\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-check-all\", 4, \"ngIf\"], [\"kendoMultiSelectTreeCheckable\", \"\", 3, \"size\", \"nodes\", \"animate\", \"isHeterogeneous\", \"checkable\", \"checkedItems\", \"valueField\", \"textField\", \"children\", \"hasChildren\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"loadOnDemand\", \"filter\", \"isVisible\", \"kendoEventsOutsideAngular\", \"scope\", \"keydown\", \"nodeClick\", \"expand\", \"collapse\", \"checkedItemsChange\", \"childrenLoaded\"], [\"treeview\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\"], [1, \"k-textbox\", \"k-input\", 3, \"ngClass\"], [1, \"k-input-prefix\"], [\"name\", \"search\", 1, \"k-icon\", 3, \"svgIcon\"], [\"role\", \"searchbox\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"aria-readonly\", \"false\", 1, \"k-input-inner\", 3, \"filterInput\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"input\", \"keydown\"], [\"filterInput\", \"\"], [3, \"templateContext\"], [1, \"k-check-all\"], [1, \"k-checkbox-wrap\"], [\"type\", \"checkbox\", \"role\", \"checkbox\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"aria-readonly\", \"false\", 1, \"k-checkbox\", 3, \"checkAll\", \"ngClass\", \"treeview\", \"checkedItems\", \"valueField\", \"lastAction\", \"kendoEventsOutsideAngular\", \"scope\", \"checkedItemsChange\", \"keydown\"], [\"checkAllInput\", \"\"], [1, \"k-checkbox-label\", 3, \"click\", \"mousedown\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"], [3, \"resize\"]];\n    },\n    template: function _class43_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-taglist\", 1);\n        i0.ɵɵlistener(\"removeTag\", function _class43_Template_kendo_taglist_removeTag_1_listener($event) {\n          return ctx.handleRemoveTag($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"span\", 2);\n        i0.ɵɵtemplate(3, _class43_span_3_Template, 2, 1, \"span\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, _class43_span_4_Template, 2, 2, \"span\", 4);\n        i0.ɵɵtemplate(5, _class43_span_5_Template, 1, 0, \"span\", 5);\n        i0.ɵɵtemplate(6, _class43_ng_template_6_Template, 1, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(8, null, 7);\n        i0.ɵɵelementStart(10, \"responsive-renderer\", 8);\n        i0.ɵɵlistener(\"closePopup\", function _class43_Template_responsive_renderer_closePopup_10_listener() {\n          return ctx.togglePopup(false);\n        })(\"onExpand\", function _class43_Template_responsive_renderer_onExpand_10_listener() {\n          return ctx.onExpand();\n        })(\"onCollapse\", function _class43_Template_responsive_renderer_onCollapse_10_listener() {\n          return ctx.onCollapse();\n        })(\"textInputChange\", function _class43_Template_responsive_renderer_textInputChange_10_listener($event) {\n          return ctx.onFilterChange($event);\n        })(\"onApply\", function _class43_Template_responsive_renderer_onApply_10_listener() {\n          return ctx.applyValue();\n        })(\"onCancel\", function _class43_Template_responsive_renderer_onCancel_10_listener() {\n          return ctx.cancelValue();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(11, _class43_ng_template_11_Template, 7, 28, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, _class43_kendo_resize_sensor_13_Template, 1, 0, \"kendo-resize-sensor\", 10);\n      }\n      if (rf & 2) {\n        const _r6 = i0.ɵɵreference(12);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"id\", ctx.tagListId)(\"tags\", ctx.tags)(\"focused\", ctx.focusedTagIndex)(\"textField\", ctx.textField)(\"valueField\", ctx.valueField)(\"valueDepth\", ctx.valueDepth)(\"disabled\", ctx.disabled)(\"tagPrefix\", ctx.tagPrefix)(\"template\", ctx.tagTemplate)(\"groupTemplate\", ctx.groupTagTemplate)(\"disabledIndices\", ctx.disabledIndices);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.tags || !ctx.tags.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.disabled && !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.tags == null ? null : ctx.tags.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"sharedPopupActionSheetTemplate\", _r6)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"title\", ctx.title)(\"showTextInput\", ctx.filterable)(\"showActionButtons\", true)(\"subtitle\", ctx.subtitle);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, TagListComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResponsiveRendererComponent, NgClass, FilterInputDirective, EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, TreeViewComponent, CheckDirective, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return MultiSelectTreeComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the retrieval of the child nodes when flat data is provided.\n */\nlet DropDownTreeFlatBindingDirective = /*#__PURE__*/(() => {\n  var _class44;\n  class DropDownTreeFlatBindingDirective extends FlatDataBindingDirective {\n    /**\n     * The nodes which will be displayed by the DropDownTree.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it matches the accessor in FlatDataBindingDirective it extends\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * Represents the unique field which identifies a node.\n     */\n\n    /**\n     * @hidden\n     */\n    set filter(term) {\n      super.filter = term;\n    }\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      _defineProperty(this, \"dropDownTree\", void 0);\n      _defineProperty(this, \"idField\", void 0);\n      this.dropDownTree = dropDownTree;\n    }\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.dropDownTree.nodes = changes['nodes'].currentValue;\n        super.nodes = changes['nodes'].currentValue;\n      }\n      super.ngOnChanges(changes);\n    }\n  }\n  _class44 = DropDownTreeFlatBindingDirective;\n  _defineProperty(DropDownTreeFlatBindingDirective, \"\\u0275fac\", function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  });\n  _defineProperty(DropDownTreeFlatBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class44,\n    selectors: [[\"\", \"kendoDropDownTreeFlatBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoDropDownTreeFlatBinding\", \"nodes\"],\n      idField: [\"valueField\", \"idField\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return DropDownTreeFlatBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.\n */\nlet DropDownTreeHierarchyBindingDirective = /*#__PURE__*/(() => {\n  var _class45;\n  class DropDownTreeHierarchyBindingDirective extends HierarchyBindingDirective {\n    /**\n     * The nodes which will be displayed by the DropDownTree.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it matches the accessor in FlatDataBindingDirective it extends\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * @hidden\n     */\n    set filter(term) {\n      super.filter = term;\n    }\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      _defineProperty(this, \"dropDownTree\", void 0);\n      this.dropDownTree = dropDownTree;\n    }\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.dropDownTree.nodes = changes['nodes'].currentValue;\n        super.nodes = changes['nodes'].currentValue;\n      }\n      super.ngOnChanges(changes);\n    }\n  }\n  _class45 = DropDownTreeHierarchyBindingDirective;\n  _defineProperty(DropDownTreeHierarchyBindingDirective, \"\\u0275fac\", function _class45_Factory(t) {\n    return new (t || _class45)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  });\n  _defineProperty(DropDownTreeHierarchyBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class45,\n    selectors: [[\"\", \"kendoDropDownTreeHierarchyBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoDropDownTreeHierarchyBinding\", \"nodes\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return DropDownTreeHierarchyBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the retrieval of the child nodes when flat data is provided.\n */\nlet MultiSelectTreeFlatBindingDirective = /*#__PURE__*/(() => {\n  var _class46;\n  class MultiSelectTreeFlatBindingDirective extends FlatDataBindingDirective {\n    /**\n     * The nodes which will be displayed by the MultiSelectTree.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it matches the accessor in FlatDataBindingDirective it extends\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * Represents the unique field which identifies a node.\n     */\n\n    /**\n     * @hidden\n     */\n    set filter(term) {\n      super.filter = term;\n    }\n    constructor(multiSelectTree) {\n      super(multiSelectTree);\n      _defineProperty(this, \"multiSelectTree\", void 0);\n      _defineProperty(this, \"idField\", void 0);\n      this.multiSelectTree = multiSelectTree;\n    }\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.multiSelectTree.nodes = changes['nodes'].currentValue;\n        super.nodes = changes['nodes'].currentValue;\n      }\n      super.ngOnChanges(changes);\n    }\n  }\n  _class46 = MultiSelectTreeFlatBindingDirective;\n  _defineProperty(MultiSelectTreeFlatBindingDirective, \"\\u0275fac\", function _class46_Factory(t) {\n    return new (t || _class46)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  });\n  _defineProperty(MultiSelectTreeFlatBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class46,\n    selectors: [[\"\", \"kendoMultiSelectTreeFlatBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoMultiSelectTreeFlatBinding\", \"nodes\"],\n      idField: [\"valueField\", \"idField\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return MultiSelectTreeFlatBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.\n */\nlet MultiSelectTreeHierarchyBindingDirective = /*#__PURE__*/(() => {\n  var _class47;\n  class MultiSelectTreeHierarchyBindingDirective extends HierarchyBindingDirective {\n    /**\n     * The nodes which will be displayed by the MultiSelectTree.\n     */\n    set nodes(nodes) {\n      // Needs to be a setter so that it matches the accessor in FlatDataBindingDirective it extends\n      this._nodes = nodes;\n    }\n    get nodes() {\n      return this._nodes;\n    }\n    /**\n     * @hidden\n     */\n    set filter(term) {\n      super.filter = term;\n    }\n    constructor(multiSelectTree) {\n      super(multiSelectTree);\n      _defineProperty(this, \"multiSelectTree\", void 0);\n      this.multiSelectTree = multiSelectTree;\n    }\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.multiSelectTree.nodes = changes['nodes'].currentValue;\n        super.nodes = changes['nodes'].currentValue;\n      }\n      super.ngOnChanges(changes);\n    }\n  }\n  _class47 = MultiSelectTreeHierarchyBindingDirective;\n  _defineProperty(MultiSelectTreeHierarchyBindingDirective, \"\\u0275fac\", function _class47_Factory(t) {\n    return new (t || _class47)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  });\n  _defineProperty(MultiSelectTreeHierarchyBindingDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class47,\n    selectors: [[\"\", \"kendoMultiSelectTreeHierarchyBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoMultiSelectTreeHierarchyBinding\", \"nodes\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  }));\n  return MultiSelectTreeHierarchyBindingDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which manages the expanded state of the popup TreeView.\n */\nlet DropDownTreesExpandDirective = /*#__PURE__*/(() => {\n  var _class48;\n  class DropDownTreesExpandDirective extends ExpandDirective {\n    /**\n     * @hidden\n     *\n     * Ensures a user-defined `isNodeExpanded` callback will not be overriden by the default directive setup.\n     * Implemented as a value setter in the base directive, this just overrides the input name.\n     */\n    set isExpanded(value) {\n      this.dropDownTree.isExpanded = value;\n    }\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      _defineProperty(this, \"dropDownTree\", void 0);\n      this.dropDownTree = dropDownTree;\n    }\n  }\n  _class48 = DropDownTreesExpandDirective;\n  _defineProperty(DropDownTreesExpandDirective, \"\\u0275fac\", function _class48_Factory(t) {\n    return new (t || _class48)(i0.ɵɵdirectiveInject(i1$1.ExpandableComponent));\n  });\n  _defineProperty(DropDownTreesExpandDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class48,\n    selectors: [[\"\", \"kendoDropDownTreeExpandable\", \"\"], [\"\", \"kendoMultiSelectTreeExpandable\", \"\"]],\n    inputs: {\n      isExpanded: [\"isNodeExpanded\", \"isExpanded\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return DropDownTreesExpandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_FILTER_SETTINGS = {\n  caseSensitive: false,\n  operator: 'startsWith'\n};\n/**\n * Implements an event handler for the `filterChange` event of a DropDowns component\n * which performs simple data filtering.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"data\"\n *      kendoDropDownFilter\n *      placeholder=\"e.g. Andorra\"\n *  >\n *  </kendo-autocomplete>\n * `\n * })\n * class AppComponent {\n *     public data: Array<string> = [\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\"];\n * }\n * ```\n * > Currently, the built-in filtering does not work with [grouped data]({% slug api_kendo-data-query_groupby %}).\n */\nlet FilterDirective = /*#__PURE__*/(() => {\n  var _class49;\n  class FilterDirective {\n    /**\n     * The initial data that will be used as a source array for the filtering operations.\n     */\n    set data(data) {\n      this._data = data || [];\n    }\n    get data() {\n      return this._data;\n    }\n    /**\n     * The configuration object which sets the behavior of the `kendoDropDownFilter` directive.\n     * If no [DropDownFilterSettings]({% slug api_dropdowns_dropdownfiltersettings %}) object is provided to this input, the directive will use the default interface settings.\n     */\n\n    constructor(component) {\n      _defineProperty(this, \"component\", void 0);\n      _defineProperty(this, \"rawSettings\", void 0);\n      /**\n       * @hidden\n       *\n       * Sets whether the filtering functionality is enabled on component init.\n       */\n      _defineProperty(this, \"filterable\", true);\n      _defineProperty(this, \"_data\", []);\n      _defineProperty(this, \"filterChangeSubscription\", void 0);\n      this.component = component;\n    }\n    ngOnInit() {\n      this.component.filterable = this.filterable;\n      this.filterChangeSubscription = this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n    }\n    ngOnDestroy() {\n      if (isPresent(this.filterChangeSubscription)) {\n        this.filterChangeSubscription.unsubscribe();\n      }\n    }\n    handleFilterChange(query) {\n      this.component.data = this.data.filter(item => this.matchesAnyField(item, query));\n    }\n    matchesAnyField(item, query) {\n      const normalizedQuery = this.normalizeValue(query);\n      const {\n        fields\n      } = this.filterSettings;\n      // if no filter fields are present, we are dealing with primitive data\n      if (fields.length === 0) {\n        return this.checkItem(item, normalizedQuery);\n      }\n      return fields.some(field => this.checkItem(getter(item, field), normalizedQuery));\n    }\n    checkItem(target, query) {\n      target = this.normalizeValue(target);\n      if (this.filterSettings.operator === 'contains') {\n        return target.indexOf(query) !== -1;\n      } else {\n        return target.indexOf(query) === 0;\n      }\n    }\n    normalizeValue(value) {\n      const normalizedValue = isPresent(value) ? value.toString() : '';\n      return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();\n    }\n    getFilterFields(providedFields) {\n      // ignore provided fields if the component deals with primitive data\n      if (!this.component.textField && !this.component.valueField) {\n        return [];\n      }\n      if (isArray(providedFields) && providedFields.length > 0) {\n        return providedFields;\n      } else {\n        // the autocomplete uses `valueField` for text extraction\n        const textField = this.component.textField || this.component.valueField;\n        return [textField];\n      }\n    }\n    get filterSettings() {\n      const settings = this.rawSettings;\n      const providedFields = isPresent(settings) && typeof settings === 'object' ? settings.fields : [];\n      return Object.assign({}, DEFAULT_FILTER_SETTINGS, settings, {\n        fields: this.getFilterFields(providedFields)\n      });\n    }\n  }\n  _class49 = FilterDirective;\n  _defineProperty(FilterDirective, \"\\u0275fac\", function _class49_Factory(t) {\n    return new (t || _class49)(i0.ɵɵdirectiveInject(FilterableComponent));\n  });\n  _defineProperty(FilterDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class49,\n    selectors: [[\"\", \"kendoDropDownFilter\", \"\"]],\n    inputs: {\n      data: \"data\",\n      rawSettings: [\"kendoDropDownFilter\", \"rawSettings\"],\n      filterable: \"filterable\"\n    },\n    standalone: true\n  }));\n  return FilterDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_dropdowns %}#toc-messages)).\n */\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class50;\n  class CustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class50 = CustomMessagesComponent;\n  _defineProperty(CustomMessagesComponent, \"\\u0275fac\", function _class50_Factory(t) {\n    return new (t || _class50)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(CustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class50,\n    selectors: [[\"kendo-dropdownlist-messages\"], [\"kendo-combobox-messages\"], [\"kendo-multicolumncombobox-messages\"], [\"kendo-autocomplete-messages\"], [\"kendo-multiselect-messages\"], [\"kendo-dropdowntree-messages\"], [\"kendo-multiselecttree-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class50)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class50_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return CustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which configures the MultiSelect to show one single summary tag for all selected data items.\n * When a number is provided, the summary tag is displayed after the given amount of data items are selected\n * ([more information and examples]({% slug summarytagmode_multiselect %})).\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"data\"></kendo-multiselect>\n * ```\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect [kendoMultiSelectSummaryTag]=\"2\" [data]=\"data\"></kendo-multiselect>\n * ```\n */\nlet SummaryTagDirective = /*#__PURE__*/(() => {\n  var _class51;\n  class SummaryTagDirective {\n    constructor(multiSelectComponent) {\n      _defineProperty(this, \"multiSelectComponent\", void 0);\n      /**\n       * A numeric value that indicates the number of selected data items after which the summary tag will appear.\n       */\n      _defineProperty(this, \"showAfter\", 0);\n      this.multiSelectComponent = multiSelectComponent;\n      this.createTagMapper();\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes.showAfter)) {\n        this.createTagMapper();\n        this.multiSelectComponent.onTagMapperChange();\n      }\n    }\n    createTagMapper() {\n      const showAfter = parseNumber(this.showAfter);\n      this.multiSelectComponent.tagMapper = tags => {\n        if (tags.length > showAfter) {\n          const result = tags.slice(0, showAfter);\n          result.push(tags.slice(showAfter, tags.length));\n          return result;\n        } else {\n          return tags;\n        }\n      };\n    }\n  }\n  _class51 = SummaryTagDirective;\n  _defineProperty(SummaryTagDirective, \"\\u0275fac\", function _class51_Factory(t) {\n    return new (t || _class51)(i0.ɵɵdirectiveInject(MultiSelectComponent));\n  });\n  _defineProperty(SummaryTagDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class51,\n    selectors: [[\"\", \"kendoMultiSelectSummaryTag\", \"\"]],\n    inputs: {\n      showAfter: [\"kendoMultiSelectSummaryTag\", \"showAfter\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return SummaryTagDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive which configures the MultiSelectTree to show one single summary tag for all selected data items.\n * When a number is provided, the summary tag is displayed after the given amount of data items are selected\n * ([more information and examples]({% slug api_dropdowns_multiselecttreesummarytagdirective %})).\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselecttree kendoMultiSelectTreeSummaryTag [data]=\"data\"></kendo-multiselecttree>\n * ```\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselecttree [kendoMultiSelectTreeSummaryTag]=\"2\" [data]=\"data\"></kendo-multiselecttree>\n * ```\n */\nlet MultiSelectTreeSummaryTagDirective = /*#__PURE__*/(() => {\n  var _class52;\n  class MultiSelectTreeSummaryTagDirective {\n    constructor(multiSelectTreeComponent) {\n      _defineProperty(this, \"multiSelectTreeComponent\", void 0);\n      /**\n       * A numeric value that indicates the number of selected data items after which the summary tag will appear.\n       */\n      _defineProperty(this, \"showAfter\", 0);\n      this.multiSelectTreeComponent = multiSelectTreeComponent;\n      this.createTagMapper();\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes.showAfter)) {\n        this.createTagMapper();\n        this.multiSelectTreeComponent.handleTagMapperChange(this.showAfter);\n      }\n    }\n    createTagMapper() {\n      const showAfter = parseNumber(this.showAfter);\n      this.multiSelectTreeComponent.tagMapper = tags => {\n        if (tags.length > showAfter) {\n          // tags provided in an array are rendered as a single group tag\n          return [...tags.slice(0, showAfter), tags.slice(showAfter)];\n        } else {\n          return tags;\n        }\n      };\n    }\n  }\n  _class52 = MultiSelectTreeSummaryTagDirective;\n  _defineProperty(MultiSelectTreeSummaryTagDirective, \"\\u0275fac\", function _class52_Factory(t) {\n    return new (t || _class52)(i0.ɵɵdirectiveInject(MultiSelectTreeComponent));\n  });\n  _defineProperty(MultiSelectTreeSummaryTagDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class52,\n    selectors: [[\"\", \"kendoMultiSelectTreeSummaryTag\", \"\"]],\n    inputs: {\n      showAfter: [\"kendoMultiSelectTreeSummaryTag\", \"showAfter\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return MultiSelectTreeSummaryTagDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `AutoComplete` related components and directives\n */\nconst KENDO_AUTOCOMPLETE = [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];\n/**\n * Utility array that contains all `ComboBox` related components and directives\n */\nconst KENDO_COMBOBOX = [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];\n/**\n * Utility array that contains all `MultiColumnComboBox` related components and directives\n */\nconst KENDO_MULTICOLUMNCOMBOBOX = [MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];\n/**\n * Utility array that contains all `DropDownList` related components and directives\n */\nconst KENDO_DROPDOWNLIST = [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent];\n/**\n * Utility array that contains all `MultiSelect` related components and directives\n */\nconst KENDO_MULTISELECT = [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];\n/**\n * Utility array that contains all `DropDownTree` related components and directives\n */\nconst KENDO_DROPDOWNTREE = [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent];\n/**\n * Utility array that contains all `MultiSelectTree` related components and directives\n */\nconst KENDO_MULTISELECTTREE = [MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent];\n/**\n * Utility array that contains all `@progress/kendo-angular-dropdowns` related components and directives\n */\nconst KENDO_DROPDOWNS = [...KENDO_AUTOCOMPLETE, ...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_DROPDOWNLIST, ...KENDO_MULTISELECT, ...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE];\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * - `MultiSelectTreeComponent`&mdash;The MultiSelectTree component class.\n * - `DropDownTreeComponent`&mdash;The DropDownTree component class.\n * - `MultiSelectTreeFlatBindingDirective`&mdash;The MultiSelectTree flat binding directive.\n * - `DropDownTreeFlatBindingDirective`&mdash;The DropDownTree flat binding directive.\n * - `MultiSelectTreeHierarchyBindingDirective`&mdash;The MultiSelectTree hierarchy binding directive.\n * - `DropDownTreeHierarchyBindingDirective`&mdash;The DropDownTree hierarchy binding directive.\n * - `DropDownTreesExpandDirective`&mdash;The DropDownTreesExpand directive.\n * - `NodeTemplateDirective`&mdash;The node template directive.\n * - `MultiSelectTreeSummaryTagDirective`&mdash;The MultiSelectTreeSummaryTag directive.\n * - `TagTemplateDirective`&mdash;The tag template directive.\n * - `GroupTagTemplateDirective`&mdash;The group tag template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `ValueTemplateDirective`&mdash;The value template directive.\n * - `NoDataTemplateDirective`&mdash;The no-data template directive.\n * - `CustomMessagesComponent`&mdash;The custom messages component.\n */\nlet DropDownTreesModule = /*#__PURE__*/(() => {\n  var _class53;\n  class DropDownTreesModule {}\n  _class53 = DropDownTreesModule;\n  _defineProperty(DropDownTreesModule, \"\\u0275fac\", function _class53_Factory(t) {\n    return new (t || _class53)();\n  });\n  _defineProperty(DropDownTreesModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class53\n  }));\n  _defineProperty(DropDownTreesModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],\n    imports: [DropDownTreeComponent, MultiSelectTreeComponent]\n  }));\n  return DropDownTreesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Dropdowns components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Dropdowns module\n * import { DropDownsModule } from '@progress/kendo-angular-dropdowns';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DropDownsModule], // import the Dropdowns module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet DropDownsModule = /*#__PURE__*/(() => {\n  var _class54;\n  class DropDownsModule {}\n  _class54 = DropDownsModule;\n  _defineProperty(DropDownsModule, \"\\u0275fac\", function _class54_Factory(t) {\n    return new (t || _class54)();\n  });\n  _defineProperty(DropDownsModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class54\n  }));\n  _defineProperty(DropDownsModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],\n    imports: [AutoCompleteComponent, i10.SeparatorComponent, ComboBoxComponent, i10.SeparatorComponent, MultiColumnComboBoxComponent, i10.SeparatorComponent, DropDownListComponent, MultiSelectComponent, i10.SeparatorComponent, DropDownTreeComponent, MultiSelectTreeComponent, i10.SeparatorComponent]\n  }));\n  return DropDownsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `MultiSelectComponent`&mdash;The MultiSelect component class.\n * - `SummaryTagDirective`&mdash;The MultiSelect summary tag directive.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `CustomItemTemplateDirective`&mdash;The custom item template directive.\n * - `TagTemplateDirective`&mdash;The tag template directive.\n * - `GroupTagTemplateDirective`&mdash;The group tag template directive.\n * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no-data template directive.\n * - `FilterDirective`&mdash;The filter directive.\n * - `CustomMessagesComponent`&mdash;The custom messages component.\n * - `GroupTemplateDirective`&mdash;The group template directive.\n * - `FixedGroupTemplateDirective`&mdash;The fixed group template directive.\n * - `SuffixTemplateDirective`&mdash;The suffix template directive.\n * - `PrefixTemplateDirective`&mdash;The prefix template directive.\n */\nlet MultiSelectModule = /*#__PURE__*/(() => {\n  var _class55;\n  class MultiSelectModule {}\n  _class55 = MultiSelectModule;\n  _defineProperty(MultiSelectModule, \"\\u0275fac\", function _class55_Factory(t) {\n    return new (t || _class55)();\n  });\n  _defineProperty(MultiSelectModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class55\n  }));\n  _defineProperty(MultiSelectModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],\n    imports: [MultiSelectComponent, i10.SeparatorComponent, i10.SeparatorComponent]\n  }));\n  return MultiSelectModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `AutoCompleteComponent`&mdash;The AutoComplete component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no data template directive.\n * - `FixedGroupTemplateDirective`&mdash;The fixed group template directive.\n * - `GroupTemplateDirective`&mdash;The group template directive.\n * - `FilterDirective`&mdash;The filter directive.\n * - `CustomMessagesComponent`&mdash;The custom messages component.\n * - `SuffixTemplateDirective`&mdash;The suffix template directive.\n * - `PrefixTemplateDirective`&mdash;The prefix template directive.\n */\nlet AutoCompleteModule = /*#__PURE__*/(() => {\n  var _class56;\n  class AutoCompleteModule {}\n  _class56 = AutoCompleteModule;\n  _defineProperty(AutoCompleteModule, \"\\u0275fac\", function _class56_Factory(t) {\n    return new (t || _class56)();\n  });\n  _defineProperty(AutoCompleteModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class56\n  }));\n  _defineProperty(AutoCompleteModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],\n    imports: [AutoCompleteComponent, i10.SeparatorComponent, i10.SeparatorComponent]\n  }));\n  return AutoCompleteModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `ComboBoxComponent`&mdash;The ComboBox component class.\n * - `ComboBoxColumnComponent`&mdash;The ComboBoxColumn component class.\n * - `MultiColumnComboBoxComponent`&mdash;The MultiColumnComboBox component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no data template directive.\n * - `FixedGroupTemplateDirective`&mdash;The fixed group template directive.\n * - `GroupTemplateDirective`&mdash;The group template directive.\n * - `FilterDirective`&mdash;The filter directive.\n * - `CustomMessagesComponent`&mdash;The custom messages component.\n * - `SuffixTemplateDirective`&mdash;The suffix template directive.\n * - `PrefixTemplateDirective`&mdash;The prefix template directive.\n */\nlet ComboBoxModule = /*#__PURE__*/(() => {\n  var _class57;\n  class ComboBoxModule {}\n  _class57 = ComboBoxModule;\n  _defineProperty(ComboBoxModule, \"\\u0275fac\", function _class57_Factory(t) {\n    return new (t || _class57)();\n  });\n  _defineProperty(ComboBoxModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class57\n  }));\n  _defineProperty(ComboBoxModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],\n    imports: [ComboBoxComponent, i10.SeparatorComponent, MultiColumnComboBoxComponent, i10.SeparatorComponent, i10.SeparatorComponent]\n  }));\n  return ComboBoxModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// IMPORTANT: NgModule export kept for backwards compatibility\n/**\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownListComponent`&mdash;The DropDownList component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `ValueTemplateDirective`&mdash;The value template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no data template directive.\n * - `GroupTemplateDirective`&mdash;The group template directive.\n * - `FixedGroupTemplateDirective`&mdash;The fixed group template directive.\n * - `FilterDirective`&mdash;The filter directive.\n * - `CustomMessagesComponent`&mdash;The custom messages component.\n */\nlet DropDownListModule = /*#__PURE__*/(() => {\n  var _class58;\n  class DropDownListModule {}\n  _class58 = DropDownListModule;\n  _defineProperty(DropDownListModule, \"\\u0275fac\", function _class58_Factory(t) {\n    return new (t || _class58)();\n  });\n  _defineProperty(DropDownListModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class58\n  }));\n  _defineProperty(DropDownListModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],\n    imports: [DropDownListComponent]\n  }));\n  return DropDownListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoCompleteComponent, AutoCompleteModule, CheckAllDirective, CheckDirective, ColumnCellTemplateDirective, ColumnHeaderTemplateDirective, ComboBoxColumnComponent, ComboBoxComponent, ComboBoxModule, CustomItemTemplateDirective, CustomMessagesComponent, DropDownListComponent, DropDownListModule, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, DropDownTreesModule, DropDownsModule, FilterDirective, FilterInputDirective, FilterableComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTagTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, KENDO_AUTOCOMPLETE, KENDO_COMBOBOX, KENDO_DROPDOWNLIST, KENDO_DROPDOWNS, KENDO_DROPDOWNTREE, KENDO_MULTICOLUMNCOMBOBOX, KENDO_MULTISELECT, KENDO_MULTISELECTTREE, ListComponent, ListItemDirective, LocalizedMessagesDirective, MultiColumnComboBoxComponent, MultiSelectComponent, MultiSelectModule, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, MultiSelectTreeSummaryTagDirective, NoDataTemplateDirective, NodeTemplateDirective, PreventableEvent, RemoveTagEvent, ResponsiveRendererComponent, SearchBarComponent, SelectableDirective, SummaryTagDirective, TagListComponent, TagTemplateDirective, ValueTemplateDirective };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}