{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Directive, Optional, EventEmitter, ElementRef, Component, Input, HostBinding, Output, ViewChild, ContentChild, ViewChildren, forwardRef, Inject, Injectable, HostListener, ContentChildren, ViewContainerRef, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';\nimport { Subscription, fromEvent, interval, merge, BehaviorSubject, Subject } from 'rxjs';\nimport { take, tap, filter, concatMap, startWith, takeUntil, skip, debounceTime, throttleTime } from 'rxjs/operators';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX, RTL } from '@progress/kendo-angular-l10n';\nimport * as i7 from '@progress/kendo-angular-common';\nimport { Keys, guid, anyChanged, isDocumentAvailable, hasObservers, KendoInput, EventsOutsideAngularDirective, DraggableDirective, ResizeSensorComponent, isObjectPresent, removeHTMLAttributes, parseAttributes, isControlRequired, setHTMLAttributes, SuffixTemplateDirective, PrefixTemplateDirective, isChanged, isPresent as isPresent$1, isSafari, PreventableEvent, findFocusableChild, parseCSSClassNames, closest as closest$1, SeparatorComponent, ResizeBatchService, KENDO_ADORNMENTS } from '@progress/kendo-angular-common';\nexport { PrefixTemplateDirective, SeparatorComponent, SuffixTemplateDirective } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { caretAltUpIcon, caretAltDownIcon, caretAltLeftIcon, caretAltRightIcon, checkIcon, exclamationCircleIcon, xIcon, caretAltExpandIcon, xCircleIcon, dropletSlashIcon, dropletSliderIcon, paletteIcon, starIcon, starOutlineIcon, hyperlinkOpenIcon } from '@progress/kendo-svg-icons';\nimport { NgFor, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgIf, NgStyle } from '@angular/common';\nimport { ButtonComponent } from '@progress/kendo-angular-buttons';\nimport { browser, mobileOS } from '@progress/kendo-common';\nimport * as i1$1 from '@progress/kendo-angular-intl';\nimport { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\nimport { parseColor as parseColor$1, Color, namedColors } from '@progress/kendo-drawing';\nimport * as i1$2 from '@progress/kendo-angular-popup';\nimport { PopupService } from '@progress/kendo-angular-popup';\nimport * as i3 from '@progress/kendo-angular-utils';\nimport { AdaptiveService } from '@progress/kendo-angular-utils';\nimport { ActionSheetComponent, ActionSheetTemplateDirective } from '@progress/kendo-angular-navigation';\nimport { SignaturePad } from '@progress/kendo-inputs-common';\nimport { DialogComponent, DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';\n\n/**\n * @hidden\n *\n * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.\n */\nconst _c0 = [\"wrap\"];\nconst _c1 = [\"track\"];\nconst _c2 = [\"sliderSelection\"];\nconst _c3 = [\"ticks\"];\nconst _c4 = [\"tickElement\"];\nconst _c5 = [\"kendoSliderTicks\", \"\"];\nfunction _class6_li_0_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵelementContainer(1, 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const tick_r3 = i0.ɵɵnextContext().$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.labelTemplate || _r1)(\"ngTemplateOutletContext\", tick_r3);\n  }\n}\nfunction _class6_li_0_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1, \"\\xA0\");\n    i0.ɵɵelementContainerEnd();\n  }\n}\nfunction _class6_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 2, 3);\n    i0.ɵɵelementContainerStart(2, 4);\n    i0.ɵɵtemplate(3, _class6_li_0_span_3_Template, 2, 2, \"span\", 5);\n    i0.ɵɵtemplate(4, _class6_li_0_ng_container_4_Template, 2, 0, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const tick_r3 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵpropertyInterpolate(\"title\", ctx_r0.tickTitle(tick_r3.value));\n    i0.ɵɵproperty(\"ngClass\", tick_r3.classes);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngSwitch\", tick_r3.large);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", false);\n  }\n}\nfunction _class6_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const value_r8 = ctx.value;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.tickTitle(value_r8), \" \");\n  }\n}\nconst _c6 = [\"draghandle\"];\nconst _c7 = [\"decreaseButton\"];\nconst _c8 = [\"increaseButton\"];\nfunction _class9_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 13, 14);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r0.decreaseButtonArrowIcon)(\"svgIcon\", ctx_r0.decreaseButtonArrowSVGIcon)(\"title\", ctx_r0.decrementMessage);\n    i0.ɵɵattribute(\"tabindex\", -1);\n  }\n}\nfunction _class9_ul_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 15, 16);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tickTitle\", ctx_r2.title)(\"vertical\", ctx_r2.vertical)(\"step\", ctx_r2.smallStep)(\"largeStep\", ctx_r2.largeStep)(\"min\", ctx_r2.min)(\"max\", ctx_r2.max)(\"labelTemplate\", ctx_r2.labelTemplate == null ? null : ctx_r2.labelTemplate.templateRef);\n  }\n}\nfunction _class9_button_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 17, 18);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r6.increaseButtonArrowIcon)(\"svgIcon\", ctx_r6.increaseButtonArrowSVGIcon)(\"title\", ctx_r6.incrementMessage);\n    i0.ɵɵattribute(\"tabindex\", -1);\n  }\n}\nconst _c15 = function (a0, a1) {\n  return {\n    click: a0,\n    keydown: a1\n  };\n};\nconst _c16 = [\"draghandleStart\"];\nconst _c17 = [\"draghandleEnd\"];\nfunction _class13_ul_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 12, 13);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tickTitle\", ctx_r1.title)(\"vertical\", ctx_r1.vertical)(\"step\", ctx_r1.smallStep)(\"largeStep\", ctx_r1.largeStep)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"labelTemplate\", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\nconst _c22 = [\"thumb\"];\nconst _c27 = [\"numericInput\"];\nfunction _class23_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class23_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtemplate(1, _class23_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class23_kendo_input_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class23_kendo_input_separator_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class23_span_7_ng_template_1_Template(rf, ctx) {}\nfunction _class23_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵtemplate(1, _class23_span_7_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.suffixTemplate == null ? null : ctx_r4.suffixTemplate.templateRef);\n  }\n}\nconst _c32 = function (a0, a1) {\n  return {\n    mouseup: a0,\n    mouseleave: a1\n  };\n};\nconst _c33 = function (a0) {\n  return {\n    mousedown: a0\n  };\n};\nfunction _class23_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11)(1, \"button\", 12);\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 14);\n    i0.ɵɵelement(4, \"kendo-icon-wrapper\", 15);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(15, _c32, ctx_r5.releaseArrow, ctx_r5.releaseArrow));\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-active\", ctx_r5.arrowDirection === ctx_r5.ArrowDirection.Up);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(18, _c33, ctx_r5.increasePress))(\"title\", ctx_r5.incrementTitle);\n    i0.ɵɵattribute(\"aria-hidden\", true)(\"aria-label\", ctx_r5.incrementTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r5.arrowUpIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-active\", ctx_r5.arrowDirection === ctx_r5.ArrowDirection.Down);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(20, _c33, ctx_r5.decreasePress))(\"title\", ctx_r5.decrementTitle);\n    i0.ɵɵattribute(\"aria-hidden\", true)(\"aria-label\", ctx_r5.decrementTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r5.arrowDownIcon);\n  }\n}\nconst _c34 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    mousedown: a0,\n    dragenter: a1,\n    keydown: a2,\n    input: a3,\n    focus: a4,\n    blur: a5,\n    paste: a6\n  };\n};\nconst _c35 = [\"input\"];\nfunction _class29_span_1_ng_template_1_Template(rf, ctx) {}\nfunction _class29_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtemplate(1, _class29_span_1_ng_template_1_Template, 0, 0, \"ng-template\", 7);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\nfunction _class29_kendo_input_separator_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class29_kendo_input_separator_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class29_span_6_ng_template_1_Template(rf, ctx) {}\nfunction _class29_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵtemplate(1, _class29_span_6_ng_template_1_Template, 0, 0, \"ng-template\", 7);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.suffixTemplate == null ? null : ctx_r4.suffixTemplate.templateRef);\n  }\n}\nconst _c36 = function (a0, a1, a2, a3, a4) {\n  return {\n    focus: a0,\n    blur: a1,\n    click: a2,\n    dragstart: a3,\n    drop: a4\n  };\n};\nconst _c37 = function (a0, a1) {\n  return {\n    blur: a0,\n    change: a1\n  };\n};\nfunction _class41_span_2_ng_template_1_Template(rf, ctx) {}\nfunction _class41_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, _class41_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 10);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefix == null ? null : ctx_r0.prefix.templateRef);\n  }\n}\nfunction _class41_kendo_input_separator_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class41_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵlistener(\"click\", function _class41_span_6_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.clearValue());\n    })(\"mousedown\", function _class41_span_6_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    })(\"keydown.enter\", function _class41_span_6_Template_span_keydown_enter_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.clearValue($event));\n    })(\"keydown.space\", function _class41_span_6_Template_span_keydown_space_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.clearValue($event));\n    });\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 12);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r3.tabIndex)(\"title\", ctx_r3.clearTitle());\n    i0.ɵɵattribute(\"aria-label\", ctx_r3.clearTitle());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r3.clearButtonClass)(\"customFontClass\", ctx_r3.customClearButtonClasses)(\"svgIcon\", ctx_r3.clearButtonSvgIcon || ctx_r3.svgIcon(\"xIcon\"));\n  }\n}\nfunction _class41_kendo_icon_wrapper_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r4.errorIconClasses)(\"customFontClass\", ctx_r4.customIconClasses)(\"svgIcon\", ctx_r4.errorSvgIcon || ctx_r4.svgIcon(\"exclamationCircleIcon\"));\n  }\n}\nfunction _class41_kendo_icon_wrapper_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 13);\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r5.successIconClasses)(\"customFontClass\", ctx_r5.customSuccessIconClasses)(\"svgIcon\", ctx_r5.successSvgIcon || ctx_r5.svgIcon(\"checkIcon\"));\n  }\n}\nfunction _class41_kendo_input_separator_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\");\n  }\n}\nfunction _class41_span_10_ng_template_1_Template(rf, ctx) {}\nfunction _class41_span_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 14);\n    i0.ɵɵtemplate(1, _class41_span_10_ng_template_1_Template, 0, 0, \"ng-template\", 10);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r7.suffix == null ? null : ctx_r7.suffix.templateRef);\n  }\n}\nconst _c40 = function (a0, a1, a2) {\n  return {\n    focus: a0,\n    blur: a1,\n    input: a2\n  };\n};\nconst _c41 = [\"opacityInput\"];\nconst _c42 = [\"hexInput\"];\nconst _c43 = [\"blue\"];\nconst _c44 = [\"toggleFormatButton\"];\nfunction _class43_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5)(1, \"kendo-textbox\", 6, 7);\n    i0.ɵɵlistener(\"blur\", function _class43_div_3_Template_kendo_textbox_blur_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.handleHexInputBlur());\n    })(\"input\", function _class43_div_3_Template_kendo_textbox_input_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const _r3 = i0.ɵɵreference(2);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.handleHexValueChange(_r3.value));\n    })(\"keydown.tab\", function _class43_div_3_Template_kendo_textbox_keydown_tab_1_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.focusDragHandle($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"label\", 8);\n    i0.ɵɵtext(4, \"HEX\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-readonly\", ctx_r1.readonly);\n    i0.ɵɵproperty(\"focusableId\", ctx_r1.focusableId)(\"size\", ctx_r1.size)(\"disabled\", ctx_r1.disabled)(\"readonly\", ctx_r1.readonly)(\"value\", ctx_r1.hex || \"\")(\"tabindex\", ctx_r1.tabindex);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", ctx_r1.focusableId);\n  }\n}\nfunction _class43_ng_container_4_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 0)(1, \"kendo-numerictextbox\", 16, 17);\n    i0.ɵɵlistener(\"valueChange\", function _class43_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r14.rgba.a = $event);\n    })(\"blur\", function _class43_ng_container_4_div_16_Template_kendo_numerictextbox_blur_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r16.handleRgbaInputBlur());\n    })(\"valueChange\", function _class43_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r17.handleRgbaValueChange());\n    })(\"keydown.tab\", function _class43_ng_container_4_div_16_Template_kendo_numerictextbox_keydown_tab_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r18.focusDragHandle($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"label\", 8);\n    i0.ɵɵtext(5, \"A\");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const _r13 = i0.ɵɵreference(3);\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"localizationService\", ctx_r11.localizationService)(\"disabled\", ctx_r11.disabled)(\"readonly\", ctx_r11.readonly)(\"tabindex\", ctx_r11.tabindex)(\"size\", ctx_r11.size)(\"min\", 0)(\"max\", 1)(\"value\", ctx_r11.rgba.a)(\"autoCorrect\", true)(\"spinners\", false)(\"step\", 0.01)(\"format\", \"n2\")(\"decimals\", 2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"for\", _r13.focusableId);\n  }\n}\nfunction _class43_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 0)(2, \"kendo-numerictextbox\", 9, 10);\n    i0.ɵɵlistener(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r19.rgba.r = $event);\n    })(\"blur\", function _class43_ng_container_4_Template_kendo_numerictextbox_blur_2_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r21.handleRgbaInputBlur());\n    })(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r22.handleRgbaValueChange());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"label\", 8);\n    i0.ɵɵtext(5, \"R\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"div\", 0)(7, \"kendo-numerictextbox\", 11, 12);\n    i0.ɵɵlistener(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r23.rgba.g = $event);\n    })(\"blur\", function _class43_ng_container_4_Template_kendo_numerictextbox_blur_7_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r24.handleRgbaInputBlur());\n    })(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r25.handleRgbaValueChange());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"label\", 8);\n    i0.ɵɵtext(10, \"G\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"div\", 0)(12, \"kendo-numerictextbox\", 13, 14);\n    i0.ɵɵlistener(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r26 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r26.rgba.b = $event);\n    })(\"blur\", function _class43_ng_container_4_Template_kendo_numerictextbox_blur_12_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r27.handleRgbaInputBlur());\n    })(\"valueChange\", function _class43_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.handleRgbaValueChange());\n    })(\"keydown.tab\", function _class43_ng_container_4_Template_kendo_numerictextbox_keydown_tab_12_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r29.onTab());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"label\", 8);\n    i0.ɵɵtext(15, \"B\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(16, _class43_ng_container_4_div_16_Template, 6, 14, \"div\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const _r8 = i0.ɵɵreference(3);\n    const _r9 = i0.ɵɵreference(8);\n    const _r10 = i0.ɵɵreference(13);\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"localizationService\", ctx_r2.localizationService)(\"disabled\", ctx_r2.disabled)(\"size\", ctx_r2.size)(\"readonly\", ctx_r2.readonly)(\"tabindex\", ctx_r2.tabindex)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.r)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r8.focusableId);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"localizationService\", ctx_r2.localizationService)(\"disabled\", ctx_r2.disabled)(\"readonly\", ctx_r2.readonly)(\"tabindex\", ctx_r2.tabindex)(\"size\", ctx_r2.size)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.g)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r9.focusableId);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"localizationService\", ctx_r2.localizationService)(\"disabled\", ctx_r2.disabled)(\"readonly\", ctx_r2.readonly)(\"tabindex\", ctx_r2.tabindex)(\"size\", ctx_r2.size)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.b)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r10.focusableId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.opacity);\n  }\n}\nconst _c45 = [\"kendoContrastValidation\", \"\"];\nfunction _class44_ng_container_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.passMessage, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.checkIcon);\n  }\n}\nfunction _class44_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelement(2, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.failMessage, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xCircleIcon);\n  }\n}\nfunction _class44_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class44_ng_container_2_span_1_Template, 3, 2, \"span\", 1);\n    i0.ɵɵtemplate(2, _class44_ng_container_2_span_2_Template, 3, 2, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.pass);\n  }\n}\nconst _c46 = [\"kendoContrastTool\", \"\"];\nfunction _class45_ng_container_3_span_1_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r3.checkIcon);\n  }\n}\nfunction _class45_ng_container_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 8);\n    i0.ɵɵtemplate(2, _class45_ng_container_3_span_1_kendo_icon_wrapper_2_Template, 1, 1, \"kendo-icon-wrapper\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.checkIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.satisfiesAAACondition);\n  }\n}\nfunction _class45_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵelement(1, \"kendo-icon-wrapper\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.xCircleIcon);\n  }\n}\nfunction _class45_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class45_ng_container_3_span_1_Template, 3, 2, \"span\", 5);\n    i0.ɵɵtemplate(2, _class45_ng_container_3_span_2_Template, 2, 1, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.satisfiesAACondition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.satisfiesAACondition);\n  }\n}\nconst _c47 = [\"kendoColorContrastSvg\", \"\"];\nfunction _class46__svg_path_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 1);\n  }\n  if (rf & 2) {\n    const path_r1 = ctx.$implicit;\n    i0.ɵɵattribute(\"d\", path_r1);\n  }\n}\nconst _c48 = [\"gradientDragHandle\"];\nconst _c49 = [\"inputs\"];\nconst _c50 = [\"alphaSlider\"];\nconst _c51 = [\"gradientWrapper\"];\nconst _c52 = [\"hsvRectangle\"];\nfunction _class49__svg_svg_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"svg\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(5);\n    i0.ɵɵstyleMap(\"position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px;\");\n    i0.ɵɵproperty(\"wrapper\", _r1 ? _r1 : undefined)(\"hsva\", ctx_r3.hsva)(\"backgroundColor\", ctx_r3.contrastTool);\n  }\n}\nfunction _class49_button_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 16);\n    i0.ɵɵlistener(\"click\", function _class49_button_10_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.reset());\n    })(\"keydown.enter\", function _class49_button_10_Template_button_keydown_enter_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.reset());\n    })(\"keydown.space\", function _class49_button_10_Template_button_keydown_space_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.reset());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵstyleMap(\"position: absolute; top: 0; left: 50%; transform: translateX(-50%);\");\n    i0.ɵɵproperty(\"svgIcon\", ctx_r4.dropletSlashIcon)(\"size\", ctx_r4.size)(\"tabindex\", ctx_r4.innerTabIndex.toString());\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.clearButtonTitle)(\"title\", ctx_r4.clearButtonTitle);\n  }\n}\nconst _c87 = function (a0) {\n  return {\n    \"k-align-self-end\": a0\n  };\n};\nfunction _class49_kendo_slider_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-slider\", 17, 18);\n    i0.ɵɵlistener(\"valueChange\", function _class49_kendo_slider_12_Template_kendo_slider_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.handleAlphaSliderChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"height\", ctx_r5.clearButton ? \"140\" : null, \"px\");\n    i0.ɵɵproperty(\"tabindex\", ctx_r5.innerTabIndex)(\"ngClass\", i0.ɵɵpureFunction1(14, _c87, ctx_r5.clearButton))(\"dragHandleTitle\", ctx_r5.opacitySliderTitle)(\"disabled\", ctx_r5.disabled)(\"readonly\", ctx_r5.readonly)(\"showButtons\", false)(\"vertical\", !ctx_r5.adaptiveMode)(\"min\", 0)(\"max\", 100)(\"smallStep\", 1)(\"largeStep\", 10)(\"value\", ctx_r5.alphaSliderValue);\n  }\n}\nfunction _class49_div_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 19);\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r7.value)(\"ratio\", ctx_r7.contrastTool);\n  }\n}\nconst _c88 = function (a1, a2) {\n  return {\n    \"k-colorgradient-canvas\": true,\n    \"k-vstack\": a1,\n    \"k-hstack\": a2\n  };\n};\nconst _c89 = function (a1, a2, a3) {\n  return {\n    \"k-hsv-controls\": true,\n    \"k-sliders-wrap-clearable\": a1,\n    \"k-vstack\": a2,\n    \"k-hstack\": a3\n  };\n};\nconst _c92 = function (a0, a1, a2, a3) {\n  return {\n    backgroundColor: a0,\n    width: a1,\n    height: a2,\n    minWidth: a3\n  };\n};\nfunction _class52_tr_3_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"td\", 5);\n    i0.ɵɵlistener(\"click\", function _class52_tr_3_td_1_Template_td_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const color_r4 = restoredCtx.$implicit;\n      const colIndex_r5 = restoredCtx.index;\n      const rowIndex_r2 = i0.ɵɵnextContext().index;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.handleCellSelection(color_r4, {\n        row: rowIndex_r2,\n        col: colIndex_r5\n      }));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const color_r4 = ctx.$implicit;\n    const colIndex_r5 = ctx.index;\n    const rowIndex_r2 = i0.ɵɵnextContext().index;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-selected\", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5)(\"k-focus\", ctx_r3.focusInComponent && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.row) === rowIndex_r2 && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.col) === colIndex_r5);\n    i0.ɵɵproperty(\"id\", \"k-\" + rowIndex_r2 + \"-\" + colIndex_r5 + \"-\" + ctx_r3.uniqueId)(\"ngStyle\", i0.ɵɵpureFunction4(9, _c92, color_r4, (ctx_r3.tileLayout == null ? null : ctx_r3.tileLayout.width) + \"px\", (ctx_r3.tileLayout == null ? null : ctx_r3.tileLayout.height) + \"px\", (ctx_r3.tileLayout == null ? null : ctx_r3.tileLayout.width) + \"px\"));\n    i0.ɵɵattribute(\"aria-selected\", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5 ? \"true\" : undefined)(\"aria-label\", color_r4)(\"value\", color_r4);\n  }\n}\nfunction _class52_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 3);\n    i0.ɵɵtemplate(1, _class52_tr_3_td_1_Template, 1, 14, \"td\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\nconst _c93 = [\"clearButton\"];\nconst _c94 = [\"viewButtons\"];\nconst _c95 = [\"kendoFlatColorPickerHeader\", \"\"];\nfunction _class56_div_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 7, 8);\n    i0.ɵɵlistener(\"click\", function _class56_div_1_button_1_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const view_r4 = restoredCtx.$implicit;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.onViewButtonClick(view_r4));\n    })(\"keydown.shift.tab\", function _class56_div_1_button_1_Template_button_keydown_shift_tab_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r5 = restoredCtx.index;\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r9.onHeaderTabOut($event, i_r5));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const view_r4 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"tabindex\", ctx_r3.innerTabIndex.toString())(\"icon\", ctx_r3.getViewButtonIcon(view_r4))(\"svgIcon\", ctx_r3.getViewButtonsSVGIcon(view_r4))(\"size\", ctx_r3.size)(\"ngClass\", ctx_r3.activeView === view_r4 ? \"k-selected\" : \"\");\n    i0.ɵɵattribute(\"title\", ctx_r3.getText(view_r4 === \"gradient\" ? \"gradientView\" : \"paletteView\"))(\"aria-label\", ctx_r3.getText(view_r4 === \"gradient\" ? \"gradientView\" : \"paletteView\"))(\"aria-pressed\", ctx_r3.activeView === view_r4);\n  }\n}\nfunction _class56_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵtemplate(1, _class56_div_1_button_1_Template, 2, 8, \"button\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.views);\n  }\n}\nfunction _class56_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 9, 10);\n    i0.ɵɵlistener(\"click\", function _class56_button_4_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.clearButtonClick.emit());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.innerTabIndex.toString())(\"size\", ctx_r1.size)(\"svgIcon\", ctx_r1.dropletSlashIcon);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.getText(\"clearButton\"))(\"title\", ctx_r1.getText(\"clearButton\"));\n  }\n}\nfunction _class56_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵelement(1, \"span\", 12);\n    i0.ɵɵelementStart(2, \"span\", 13);\n    i0.ɵɵlistener(\"click\", function _class56_div_5_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.valuePaneClick.emit($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"background-color\", ctx_r2.selection);\n    i0.ɵɵattribute(\"title\", ctx_r2.getText(\"previewColor\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"background-color\", ctx_r2.value);\n    i0.ɵɵattribute(\"title\", ctx_r2.getText(\"revertSelection\"));\n  }\n}\nconst _c96 = [\"first\"];\nconst _c97 = [\"last\"];\nconst _c98 = [\"kendoFlatColorPickerActionButtons\", \"\"];\nconst _c99 = [\"header\"];\nconst _c100 = [\"gradient\"];\nconst _c101 = [\"palette\"];\nconst _c102 = [\"footer\"];\nfunction _class58_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 6, 7);\n    i0.ɵɵlistener(\"clearButtonClick\", function _class58_div_1_Template_div_clearButtonClick_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.onClearButtonClick());\n    })(\"viewChange\", function _class58_div_1_Template_div_viewChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.onViewChange($event));\n    })(\"valuePaneClick\", function _class58_div_1_Template_div_valuePaneClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.resetSelection($event));\n    })(\"tabOut\", function _class58_div_1_Template_div_tabOut_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.lastFocusable($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"innerTabIndex\", ctx_r0.innerTabIndex)(\"clearButton\", ctx_r0.clearButton)(\"activeView\", ctx_r0.activeView)(\"views\", ctx_r0.views)(\"size\", ctx_r0.size)(\"value\", ctx_r0.value)(\"selection\", ctx_r0.selection)(\"preview\", ctx_r0.preview);\n  }\n}\nfunction _class58_kendo_colorgradient_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-colorgradient\", 8, 9);\n    i0.ɵɵlistener(\"keydown.tab\", function _class58_kendo_colorgradient_3_Template_kendo_colorgradient_keydown_tab_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.focusFirstHeaderButton());\n    })(\"valueChange\", function _class58_kendo_colorgradient_3_Template_kendo_colorgradient_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.handleValueChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.innerTabIndex)(\"value\", ctx_r1.selection)(\"size\", ctx_r1.size)(\"adaptiveMode\", ctx_r1.adaptiveMode)(\"format\", ctx_r1.format)(\"opacity\", ctx_r1.gradientSettings.opacity)(\"delay\", ctx_r1.gradientSettings.delay)(\"contrastTool\", ctx_r1.gradientSettings.contrastTool)(\"gradientSliderSmallStep\", ctx_r1.gradientSettings.gradientSliderSmallStep)(\"gradientSliderStep\", ctx_r1.gradientSettings.gradientSliderStep)(\"readonly\", ctx_r1.readonly);\n  }\n}\nfunction _class58_kendo_colorpalette_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-colorpalette\", 10, 11);\n    i0.ɵɵlistener(\"valueChange\", function _class58_kendo_colorpalette_4_Template_kendo_colorpalette_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r15.handleValueChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r2.innerTabIndex)(\"palette\", ctx_r2.paletteSettings.palette)(\"size\", ctx_r2.size)(\"columns\", ctx_r2.paletteSettings.columns)(\"tileSize\", ctx_r2.paletteSettings.tileSize)(\"format\", ctx_r2.format)(\"value\", ctx_r2.selection)(\"readonly\", ctx_r2.readonly);\n  }\n}\nfunction _class58_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 12, 13);\n    i0.ɵɵlistener(\"actionButtonClick\", function _class58_div_5_Template_div_actionButtonClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.onAction($event));\n    })(\"tabOut\", function _class58_div_5_Template_div_tabOut_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r20.firstFocusable.focus());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"innerTabIndex\", ctx_r3.innerTabIndex)(\"size\", ctx_r3.size)(\"ngClass\", \"k-justify-content-\" + ctx_r3.actionsLayout);\n  }\n}\nconst _c149 = [\"actionSheetSearchBar\"];\nconst _c150 = [\"cancel\"];\nconst _c151 = [\"apply\"];\nfunction _class60_ng_template_2_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 12)(1, \"kendo-adaptive-close-button\", 13);\n    i0.ɵɵlistener(\"close\", function _class60_ng_template_2_div_6_Template_kendo_adaptive_close_button_close_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r6.onApply.emit($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r2.messageFor(\"closeButton\"))(\"svgIcon\", ctx_r2.checkIcon);\n  }\n}\nfunction _class60_ng_template_2_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 12)(1, \"kendo-adaptive-close-button\", 14);\n    i0.ɵɵlistener(\"close\", function _class60_ng_template_2_div_7_Template_kendo_adaptive_close_button_close_1_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r8.actionSheetClose.emit($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r3.messageFor(\"closeButton\"))(\"svgIcon\", ctx_r3.xIcon);\n  }\n}\nfunction _class60_ng_template_2_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction _class60_ng_template_2_div_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15)(1, \"button\", 16, 17);\n    i0.ɵɵlistener(\"click\", function _class60_ng_template_2_div_10_Template_button_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r12.onCancel.emit($event));\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 18, 19);\n    i0.ɵɵlistener(\"click\", function _class60_ng_template_2_div_10_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r14 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r14.onApply.emit());\n    });\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r5.messageFor(\"cancelButton\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.messageFor(\"cancelButton\"), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r5.messageFor(\"applyButton\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.messageFor(\"applyButton\"), \" \");\n  }\n}\nfunction _class60_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3)(1, \"div\", 4)(2, \"div\", 5)(3, \"div\", 6);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(5, \"div\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, _class60_ng_template_2_div_6_Template, 2, 2, \"div\", 8);\n    i0.ɵɵtemplate(7, _class60_ng_template_2_div_7_Template, 2, 2, \"div\", 8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(8, \"div\", 9);\n    i0.ɵɵtemplate(9, _class60_ng_template_2_ng_container_9_Template, 1, 0, \"ng-container\", 10);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(10, _class60_ng_template_2_div_10_Template, 7, 4, \"div\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r1.messageFor(\"adaptiveTitle\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.preview);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.preview);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.actionSheetTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.preview);\n  }\n}\nconst _c152 = function (a0) {\n  return {\n    duration: a0\n  };\n};\nconst _c153 = [\"container\"];\nconst _c154 = [\"activeColor\"];\nconst _c155 = [\"popupTemplate\"];\nconst _c156 = [\"flatColorPicker\"];\nfunction _class61_kendo_icon_wrapper_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r1.iconStyles)(\"customFontClass\", ctx_r1.customIconStyles)(\"svgIcon\", ctx_r1.svgIcon);\n  }\n}\nfunction _class61_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-flatcolorpicker\", 12, 13);\n    i0.ɵɵlistener(\"cancel\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_cancel_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.handleCancelEvent($event));\n    })(\"focusout\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_focusout_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.handlePopupBlur($event));\n    })(\"valueChange\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.handleValueChange($event));\n    })(\"keydown\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.handlePopupKeyDown($event));\n    })(\"activeViewChange\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_activeViewChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.activeViewChange.emit($event));\n    })(\"clearButtonClick\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_clearButtonClick_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.clearButtonClick.emit());\n    })(\"actionButtonClick\", function _class61_ng_template_7_Template_kendo_flatcolorpicker_actionButtonClick_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.togglePopup());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r3.value)(\"format\", ctx_r3.format)(\"size\", ctx_r3.isAdaptive ? \"large\" : ctx_r3.size)(\"views\", ctx_r3.views)(\"activeView\", ctx_r3.activeView)(\"actionsLayout\", ctx_r3.actionsLayout)(\"adaptiveMode\", ctx_r3.isActionSheetExpanded)(\"preview\", ctx_r3.preview)(\"gradientSettings\", ctx_r3.gradientSettings)(\"paletteSettings\", ctx_r3.paletteSettings)(\"clearButton\", ctx_r3.clearButton);\n  }\n}\nfunction _class61_kendo_resize_sensor_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 14);\n    i0.ɵɵlistener(\"resize\", function _class61_kendo_resize_sensor_12_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r15.onResize());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c209 = function (a0, a1) {\n  return {\n    \"k-icon-color-preview\": a0,\n    \"k-no-color\": a1\n  };\n};\nconst _c210 = [\"*\"];\nfunction _class65_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"hasHints\"]);\n  }\n}\nfunction _class65_ng_content_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3, [\"*ngIf\", \"hasErrors\"]);\n  }\n}\nconst _c211 = [[[\"label\"], [\"kendo-label\"]], \"*\", [[\"kendo-formhint\"]], [[\"kendo-formerror\"]]];\nconst _c212 = [\"label, kendo-label\", \"*\", \"kendo-formhint\", \"kendo-formerror\"];\nfunction _class72_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const item_r2 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", item_r2.selected || item_r2.hovered ? \"star\" : \"star-outline\")(\"svgIcon\", item_r2.selected || item_r2.hovered ? ctx_r10.svgIcon : ctx_r10.svgIconOutline);\n  }\n}\nfunction _class72_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const item_r2 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", item_r2.selected || item_r2.hovered ? ctx_r11.icon : ctx_r11.icon + \"-outline\");\n  }\n}\nfunction _class72_span_1_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template, 1, 2, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtemplate(2, _class72_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template, 1, 1, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.icon);\n  }\n}\nfunction _class72_span_1_ng_container_1_2_ng_template_0_Template(rf, ctx) {}\nconst _c213 = function (a0) {\n  return {\n    index: a0\n  };\n};\nfunction _class72_span_1_ng_container_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class72_span_1_ng_container_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    const i_r3 = i0.ɵɵnextContext(2).index;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r7.itemTemplate == null ? null : ctx_r7.itemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c213, i_r3));\n  }\n}\nfunction _class72_span_1_ng_container_1_3_ng_template_0_Template(rf, ctx) {}\nfunction _class72_span_1_ng_container_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class72_span_1_ng_container_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    const i_r3 = i0.ɵɵnextContext(2).index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.hoveredItemTemplate == null ? null : ctx_r8.hoveredItemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c213, i_r3));\n  }\n}\nfunction _class72_span_1_ng_container_1_4_ng_template_0_Template(rf, ctx) {}\nfunction _class72_span_1_ng_container_1_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class72_span_1_ng_container_1_4_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    const i_r3 = i0.ɵɵnextContext(2).index;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.selectedItemTemplate == null ? null : ctx_r9.selectedItemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c213, i_r3));\n  }\n}\nfunction _class72_span_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_1_ng_container_1_Template, 3, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, _class72_span_1_ng_container_1_2_Template, 1, 4, null, 4);\n    i0.ɵɵtemplate(3, _class72_span_1_ng_container_1_3_Template, 1, 4, null, 4);\n    i0.ɵɵtemplate(4, _class72_span_1_ng_container_1_4_Template, 1, 4, null, 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r2 = i0.ɵɵnextContext().$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.itemTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.itemTemplate && !item_r2.selected && !item_r2.hovered);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hoveredItemTemplate && item_r2.hovered);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.selectedItemTemplate && item_r2.selected && !item_r2.hovered);\n  }\n}\nfunction _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", \"star-outline\")(\"svgIcon\", ctx_r25.svgIconOutline);\n  }\n}\nfunction _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", ctx_r26.icon + \"-outline\");\n  }\n}\nfunction _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", \"star\")(\"svgIcon\", ctx_r27.svgIcon);\n  }\n}\nfunction _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"name\", ctx_r28.icon);\n  }\n}\nconst _c214 = function (a0) {\n  return {\n    \"clipPath\": a0\n  };\n};\nfunction _class72_span_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 10);\n    i0.ɵɵtemplate(2, _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template, 1, 2, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtemplate(3, _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template, 1, 1, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 12);\n    i0.ɵɵtemplate(5, _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template, 1, 2, \"kendo-icon-wrapper\", 5);\n    i0.ɵɵtemplate(6, _class72_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template, 1, 1, \"kendo-icon-wrapper\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r21.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r21.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(5, _c214, ctx_r21.direction === \"rtl\" ? \"inset(0 0 0 50%)\" : \"inset(0 50% 0 0)\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r21.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r21.icon);\n  }\n}\nfunction _class72_span_1_ng_container_2_ng_template_3_Template(rf, ctx) {}\nfunction _class72_span_1_ng_container_2_span_4_ng_template_1_Template(rf, ctx) {}\nfunction _class72_span_1_ng_container_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_2_span_4_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const i_r3 = i0.ɵɵnextContext(2).index;\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(3, _c214, ctx_r23.direction === \"rtl\" ? \"inset(0 0 0 50%)\" : \"inset(0 50% 0 0)\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r23.hoveredItemTemplate == null ? null : ctx_r23.hoveredItemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c213, i_r3));\n  }\n}\nfunction _class72_span_1_ng_container_2_span_5_ng_template_1_Template(rf, ctx) {}\nfunction _class72_span_1_ng_container_2_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_2_span_5_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const i_r3 = i0.ɵɵnextContext(2).index;\n    const ctx_r24 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(3, _c214, ctx_r24.direction === \"rtl\" ? \"inset(0 0 0 50%)\" : \"inset(0 50% 0 0)\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r24.selectedItemTemplate == null ? null : ctx_r24.selectedItemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c213, i_r3));\n  }\n}\nfunction _class72_span_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_2_ng_container_1_Template, 7, 7, \"ng-container\", 4);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵtemplate(3, _class72_span_1_ng_container_2_ng_template_3_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, _class72_span_1_ng_container_2_span_4_Template, 2, 7, \"span\", 11);\n    i0.ɵɵtemplate(5, _class72_span_1_ng_container_2_span_5_Template, 2, 7, \"span\", 11);\n    i0.ɵɵelement(6, \"span\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r33 = i0.ɵɵnextContext();\n    const i_r3 = ctx_r33.index;\n    const item_r2 = ctx_r33.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.itemTemplate);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.itemTemplate == null ? null : ctx_r5.itemTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(11, _c213, i_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.hoveredItemTemplate && item_r2.hovered);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.selectedItemTemplate && item_r2.selected && !item_r2.hovered);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 24, \"px\")(\"height\", 24, \"px\")(\"display\", \"block\");\n  }\n}\nconst _c215 = function (a0, a1) {\n  return {\n    \"k-selected\": a0,\n    \"k-hover\": a1\n  };\n};\nfunction _class72_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"mouseenter\", function _class72_span_1_Template_span_mouseenter_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r34.onMouseEnter($event));\n    })(\"mouseout\", function _class72_span_1_Template_span_mouseout_0_listener() {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r36 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r36.onMouseOut());\n    })(\"click\", function _class72_span_1_Template_span_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r35);\n      const i_r3 = restoredCtx.index;\n      const ctx_r37 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r37.changeValue(i_r3, $event));\n    });\n    i0.ɵɵtemplate(1, _class72_span_1_ng_container_1_Template, 5, 4, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, _class72_span_1_ng_container_2_Template, 7, 13, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    i0.ɵɵproperty(\"title\", item_r2.title)(\"ngClass\", i0.ɵɵpureFunction2(4, _c215, item_r2.selected || item_r2.selectedIndicator, item_r2.hovered));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r2.half);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r2.half);\n  }\n}\nfunction _class72_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.label);\n  }\n}\nconst _c216 = [\"canvas\"];\nconst _c217 = [\"minimize\"];\nconst _c218 = [\"maximize\"];\nfunction _class76_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 10, 11);\n    i0.ɵɵlistener(\"click\", function _class76_button_4_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.onMaximize());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r1.svgIcon(\"hyperlinkOpenIcon\"))(\"size\", ctx_r1.size)(\"title\", ctx_r1.maximizeTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.maximizeTitle);\n  }\n}\nfunction _class76_button_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 12, 13);\n    i0.ɵɵlistener(\"click\", function _class76_button_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.onMinimize());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.svgIcon(\"hyperlinkOpenIcon\"))(\"size\", ctx_r2.size)(\"title\", ctx_r2.minimizeTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.minimizeTitle);\n  }\n}\nfunction _class76_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 14);\n  }\n}\nfunction _class76_button_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 15);\n    i0.ɵɵlistener(\"click\", function _class76_button_8_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.onClear());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r4.svgIcon(\"xIcon\"))(\"size\", ctx_r4.size)(\"title\", ctx_r4.clearTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.clearTitle);\n  }\n}\nfunction _class76_kendo_dialog_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-dialog\", 16);\n    i0.ɵɵlistener(\"click\", function _class76_kendo_dialog_9_Template_kendo_dialog_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.onDialogClick($event));\n    })(\"keydown\", function _class76_kendo_dialog_9_Template_kendo_dialog_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.onDialogKeydown($event));\n    });\n    i0.ɵɵelementStart(1, \"kendo-signature\", 17);\n    i0.ɵɵlistener(\"valueChange\", function _class76_kendo_dialog_9_Template_kendo_signature_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r17.onDialogValueChange($event));\n    })(\"minimize\", function _class76_kendo_dialog_9_Template_kendo_signature_minimize_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.onDialogClose());\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-signature-maximized\", true);\n    i0.ɵɵproperty(\"readonly\", ctx_r5.readonly)(\"disabled\", ctx_r5.disabled)(\"size\", ctx_r5.size)(\"rounded\", ctx_r5.rounded)(\"fillMode\", ctx_r5.fillMode)(\"color\", ctx_r5.color)(\"backgroundColor\", ctx_r5.backgroundColor)(\"strokeWidth\", ctx_r5.strokeWidth)(\"smooth\", ctx_r5.smooth)(\"value\", ctx_r5.popupValue)(\"hideLine\", ctx_r5.hideLine)(\"maximized\", true)(\"width\", ctx_r5.popupWidth)(\"height\", ctx_r5.popupHeight)(\"popupScale\", ctx_r5.popupScale)(\"exportScale\", 1 / ctx_r5.popupScale * ctx_r5.exportScale)(\"parentLocalization\", ctx_r5.localization);\n  }\n}\nfunction _class82_kendo_input_separator_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"orientation\", ctx_r0.separatorOrientation);\n  }\n}\nfunction _class82_kendo_input_separator_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-input-separator\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"orientation\", ctx_r2.separatorOrientation);\n  }\n}\nconst _c227 = [[[\"kendo-textarea-prefix\"]], [[\"kendo-textarea-suffix\"]]];\nconst _c228 = [\"kendo-textarea-prefix\", \"kendo-textarea-suffix\"];\nfunction _class84_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.separator);\n  }\n}\nfunction _class84_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 3);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.separatorIconString);\n  }\n}\nfunction _class84_kendo_icon_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r2.separatorIconString)(\"svgIcon\", ctx_r2.separatorSVGIcon);\n  }\n}\nconst _c229 = [\"inputGroup\"];\nfunction _class87_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-otpinput-separator\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"separator\", ctx_r6.separator);\n  }\n}\nfunction _class87_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"kendo-textbox\", 6);\n    i0.ɵɵlistener(\"focus\", function _class87_ng_container_3_ng_container_1_Template_kendo_textbox_focus_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r5 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r7.handleInputFocus(i_r5));\n    })(\"input\", function _class87_ng_container_3_ng_container_1_Template_kendo_textbox_input_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r5 = restoredCtx.index;\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r9.handleInput($event, i_r5));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(2, _class87_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template, 1, 1, \"kendo-otpinput-separator\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const i_r5 = ctx.index;\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-invalid\", ctx_r3.isControlInvalid);\n    i0.ɵɵproperty(\"selectOnFocus\", true)(\"maxlength\", 1)(\"type\", ctx_r3.type !== \"number\" ? ctx_r3.type : null)(\"placeholder\", ctx_r3.placeholder)(\"size\", ctx_r3.size)(\"rounded\", ctx_r3.rounded)(\"fillMode\", ctx_r3.fillMode)(\"disabled\", ctx_r3.disabled)(\"readonly\", ctx_r3.readonly);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.showSeparator(i_r5));\n  }\n}\nfunction _class87_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class87_ng_container_3_ng_container_1_Template, 3, 12, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.inputsArray);\n  }\n}\nfunction _class87_ng_template_4_ng_container_0_kendo_textbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"kendo-textbox\", 6);\n    i0.ɵɵlistener(\"focus\", function _class87_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_focus_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r19);\n      const j_r17 = restoredCtx.index;\n      const i_r12 = i0.ɵɵnextContext().index;\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r18.handleInputFocus(j_r17, i_r12));\n    })(\"input\", function _class87_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_input_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r19);\n      const j_r17 = restoredCtx.index;\n      const i_r12 = i0.ɵɵnextContext().index;\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r21.handleInput($event, j_r17, i_r12));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassProp(\"k-invalid\", ctx_r14.isControlInvalid);\n    i0.ɵɵproperty(\"selectOnFocus\", true)(\"maxlength\", 1)(\"type\", ctx_r14.type !== \"number\" ? ctx_r14.type : null)(\"placeholder\", ctx_r14.placeholder)(\"size\", ctx_r14.size)(\"rounded\", ctx_r14.rounded)(\"fillMode\", ctx_r14.fillMode)(\"disabled\", ctx_r14.disabled)(\"readonly\", ctx_r14.readonly);\n  }\n}\nfunction _class87_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-otpinput-separator\", 8);\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"separator\", ctx_r15.separator);\n  }\n}\nconst _c232 = function () {\n  return [];\n};\nfunction _class87_ng_template_4_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 9, 10);\n    i0.ɵɵtemplate(3, _class87_ng_template_4_ng_container_0_kendo_textbox_3_Template, 1, 11, \"kendo-textbox\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, _class87_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template, 1, 1, \"kendo-otpinput-separator\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const group_r11 = ctx.$implicit;\n    const i_r12 = ctx.index;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpureFunction0(2, _c232).constructor(group_r11));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.showGroupSeparator(i_r12));\n  }\n}\nfunction _class87_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class87_ng_template_4_ng_container_0_Template, 5, 3, \"ng-container\", 5);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.adjacentGroups);\n  }\n}\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst areSame = (value1, value2) => value1 === value2 || value1 === null && value2 === undefined || value1 === undefined && value2 === null;\n/**\n * @hidden\n */\nconst requiresZoneOnBlur = ngControl => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === 'blur');\n/**\n * @hidden\n *\n * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.\n *\n * @param contender Represents the number you want to fit into specified bounds.\n * @param min The inclusive lower bound number.\n * @param max The inclusive upper bound number.\n */\nconst fitIntoBounds = (contender, min, max) => {\n  if (!isPresent(contender) || isNaN(contender)) {\n    return min;\n  }\n  return contender <= min ? min : contender >= max ? max : contender;\n};\n/**\n * @hidden\n */\nconst SIZE_MAP = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\n/**\n * @hidden\n */\nconst ROUNDED_MAP = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\n/**\n * @hidden\n */\nconst isNone = style => style === 'none';\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZE_MAP[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZE_MAP[newValue]}` : ''\n      };\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDED_MAP[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDED_MAP[newValue]}` : ''\n      };\n    case 'fillMode':\n      return {\n        toRemove: `k-${componentType}-${previousValue}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''\n      };\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n *\n * Used to differentiate between the Radio and CheckBox components in their base class.\n */\nconst COMPONENT_TYPE = new InjectionToken('TYPE_TOKEN');\n/**\n * @hidden\n */\nconst replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`{\\\\s*${name}\\\\s*}`, 'g'), value);\n\n/**\n * @hidden\n */\nconst MAX_PRECISION = 20;\n/**\n * @hidden\n */\nconst limitPrecision = precision => Math.min(precision, MAX_PRECISION);\n/**\n * @hidden\n */\nconst fractionLength = value => {\n  return (String(value).split('.')[1] || \"\").length;\n};\nconst maxFractionLength = (value1, value2) => {\n  return Math.max(fractionLength(value1), fractionLength(value2));\n};\n/**\n * @hidden\n */\nconst toFixedPrecision = (value, precision) => {\n  const maxPrecision = limitPrecision(precision);\n  return parseFloat(value.toFixed(maxPrecision));\n};\n/**\n * @hidden\n */\nconst add = (value1, value2) => {\n  const maxPrecision = maxFractionLength(value1, value2);\n  return toFixedPrecision(value1 + value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst subtract = (value1, value2) => {\n  return add(value1, -value2);\n};\n/**\n * @hidden\n */\nconst multiply = (value1, value2) => {\n  const maxPrecision = fractionLength(value1) + fractionLength(value2);\n  return toFixedPrecision(value1 * value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst divide = (dividend, divisor) => {\n  if (divisor === 0) {\n    return NaN;\n  }\n  const power = maxFractionLength(dividend, divisor);\n  const correctionValue = Math.pow(10, power);\n  return correctionValue * dividend / (correctionValue * divisor);\n};\n/**\n * @hidden\n */\nconst remainder = (dividend, divisor) => {\n  return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));\n};\n\n/**\n * @hidden\n */\nconst calculateFixedTrackSize = ({\n  max,\n  min,\n  smallStep,\n  fixedTickWidth\n}) => (max - min) / smallStep * fixedTickWidth;\n/**\n * @hidden\n */\nconst calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {\n  if (smallStep <= 0) {\n    throw new Error('Invalid argument: smallStep must be a positive number');\n  }\n  const adjustedRange = Math.abs(subtract(max, min));\n  const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));\n  const result = add(adjustedRatio, 1);\n  return result;\n};\n/**\n * @hidden\n */\nconst calculateValueFromTick = (index, {\n  max,\n  min,\n  smallStep,\n  reverse,\n  vertical\n}) => {\n  const value = add(min, multiply(index, smallStep));\n  return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n};\n/**\n * @hidden\n */\nconst calculateHandlePosition = ({\n  trackWidth,\n  min,\n  max,\n  value\n}) => {\n  const step = trackWidth / Math.abs(max - min);\n  const pos = isPresent(value) ? step * (value - min) : min;\n  return Math.floor(pos);\n};\n/**\n * @hidden\n */\nconst decreaseValueToStep = (value, {\n  max,\n  min,\n  smallStep,\n  largeStep\n}, large = false) => {\n  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n  const stepValue = subtract(value, min);\n  let result;\n  const stepRemainder = remainder(stepValue, step);\n  if (stepRemainder === 0) {\n    result = subtract(stepValue, step);\n  } else {\n    result = subtract(stepValue, stepRemainder);\n  }\n  return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\nconst increaseValueToStep = (value, {\n  max,\n  min,\n  smallStep,\n  largeStep\n}, large = false) => {\n  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n  const stepValue = subtract(value, min);\n  const stepRemainder = remainder(stepValue, step);\n  const result = add(subtract(stepValue, stepRemainder), step);\n  return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\nconst isStartHandle = dragHandle => dragHandle.id.indexOf('k-start-handle') > -1;\n/**\n * @hidden\n */\nconst snapValue = (value, options) => {\n  const {\n    smallStep,\n    min,\n    max\n  } = options;\n  const limited = limitValue(value, min, max);\n  if (value !== limited) {\n    return limited;\n  }\n  const left = decreaseValueToStep(value, options);\n  const right = increaseValueToStep(value, options);\n  if ((value - min) % smallStep === 0) {\n    return value;\n  }\n  if (right - value <= (right - left) / 2) {\n    return right;\n  }\n  return left;\n};\n/**\n * @hidden\n */\nconst trimValue = (max, min, value) => {\n  if (value > max) {\n    return max;\n  }\n  if (value < min) {\n    return min;\n  }\n  return value;\n};\n/**\n * @hidden\n */\nconst trimValueRange = (max, min, value) => {\n  return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];\n};\n/**\n * @hidden\n */\nconst identity = value => value;\n/**\n * @hidden\n */\nconst isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);\n/**\n * @hidden\n */\nconst elementOffset = element => {\n  const box = element.getBoundingClientRect();\n  const documentElement = document.documentElement;\n  return {\n    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),\n    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)\n  };\n};\n/**\n * @hidden\n */\nconst limitValue = (value, min, max) => {\n  return Math.max(Math.min(value, max), min);\n};\n/**\n * @hidden\n */\nconst eventValue = (eventArgs, scaleElement, options) => {\n  const {\n    min,\n    max,\n    vertical,\n    rtl\n  } = options;\n  const trackOffset = elementOffset(scaleElement);\n  const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n  const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n  const offsetValue = offset * scale;\n  let value = rtl || vertical ? max - offsetValue : min + offsetValue;\n  const stepFractionLength = fractionLength(options.smallStep);\n  value = toFixedPrecision(value, stepFractionLength + 1);\n  return snapValue(value, options);\n};\n/**\n * @hidden\n */\nconst isButton = element => {\n  return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n};\n/**\n * @hidden\n */\nconst increment = options => {\n  return increaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\nconst decrement = options => {\n  return decreaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\nconst incrementLarge = options => {\n  return increaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\nconst decrementLarge = options => {\n  return decreaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\nconst validateValue = value => {\n  if (isDevMode && value && value[0] > value[1]) {\n    throw new Error('[RangeSlider] The start value should not be greater than the end value.');\n  }\n};\n/**\n * @hidden\n */\nvar slidersUtil = {\n  calculateFixedTrackSize,\n  calculateValueFromTick,\n  calculateTicksCount,\n  calculateHandlePosition,\n  decreaseValueToStep,\n  decrement,\n  decrementLarge,\n  eventValue,\n  identity,\n  increment,\n  incrementLarge,\n  isButton,\n  isSameRange,\n  isStartHandle,\n  increaseValueToStep,\n  trimValue,\n  trimValueRange,\n  snapValue,\n  validateValue\n};\n\n/**\n * @hidden\n */\nclass SliderModelBase {\n  constructor(props, wrapper, track, renderer, button) {\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"wrapper\", void 0);\n    _defineProperty(this, \"track\", void 0);\n    _defineProperty(this, \"renderer\", void 0);\n    _defineProperty(this, \"button\", void 0);\n    _defineProperty(this, \"tickSizes\", void 0);\n    this.props = props;\n    this.wrapper = wrapper;\n    this.track = track;\n    this.renderer = renderer;\n    this.button = button;\n    this.props = props;\n    this.wrapper = wrapper;\n    this.track = track;\n    this.tickSizes = this.getTickSizes();\n  }\n  resizeTrack() {\n    const orientation = this.props.vertical ? 'height' : 'width';\n    const altOrientation = this.props.vertical ? 'width' : 'height';\n    const trackWidth = this.trackWidth();\n    this.track.parentElement.style[orientation] = `${trackWidth}px`;\n    this.track.parentElement.style[altOrientation] = '';\n  }\n  resizeTicks(ticksContainer, ticks) {\n    const dimension = this.props.vertical ? \"height\" : \"width\";\n    [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);\n    if (this.props.vertical) {\n      this.adjustPadding(ticksContainer);\n    }\n  }\n  resizeWrapper() {\n    const dimension = this.props.vertical ? \"height\" : \"width\";\n    const fixedTrackWidth = calculateFixedTrackSize(this.props);\n    const wrapperParentEl = this.wrapper.parentElement;\n    if (fixedTrackWidth) {\n      wrapperParentEl.style[dimension] = \"auto\";\n    }\n  }\n  trackWidth() {\n    if (this.props.fixedTickWidth) {\n      return calculateFixedTrackSize(this.props);\n    }\n    const wrapperWidth = this.elementSize(this.wrapper.parentElement);\n    const trackOffset = this.getTrackOffset();\n    return wrapperWidth - trackOffset;\n  }\n  getTickSizes() {\n    const {\n      min,\n      max,\n      smallStep\n    } = this.props;\n    const count = calculateTicksCount(min, max, smallStep);\n    const trackSize = this.trackWidth();\n    const distStep = trackSize / subtract(max, min);\n    const result = [];\n    let usedSpace = 0;\n    let endPoint = 0;\n    for (let i = 0; i < count; i++) {\n      if (i === 0 || i === count - 1) {\n        endPoint += smallStep / 2 * distStep;\n      } else {\n        endPoint += smallStep * distStep;\n      }\n      // ensure that the sum of the tick sizes does not exceed the track width\n      endPoint = +endPoint.toFixed(2) - 0.01;\n      const size = Math.round(endPoint - usedSpace);\n      result.push(size);\n      usedSpace += size;\n    }\n    if (usedSpace >= trackSize) {\n      result[result.length - 1] -= 1;\n    }\n    return result;\n  }\n  adjustPadding(ticksContainer) {\n    const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);\n    const trackWidth = this.trackWidth();\n    const reminder = trackWidth - totalTickSize;\n    if (reminder !== 0) {\n      const padding = reminder + this.elementOffset(this.track);\n      ticksContainer.style.paddingTop = `${padding}px`;\n    }\n  }\n  elementOffset(element) {\n    const {\n      vertical\n    } = this.props;\n    const style = getComputedStyle(element);\n    return parseInt(vertical ? style.bottom : style.left, 10);\n  }\n  elementSize(element) {\n    const {\n      vertical\n    } = this.props;\n    return vertical ? element.clientHeight : element.clientWidth;\n  }\n  getTrackOffset() {\n    const showButtons = this.props.buttons && isPresent(this.button);\n    if (!showButtons) {\n      return 0;\n    }\n    const BUTTONS_COUNT = 2;\n    const buttonStyles = this.button.nativeElement.getBoundingClientRect();\n    const wrapperGap = parseInt(window.getComputedStyle(this.wrapper.parentElement).gap);\n    const buttonSize = this.props.vertical ? buttonStyles?.height : buttonStyles?.width;\n    return (buttonSize + wrapperGap) * BUTTONS_COUNT;\n  }\n}\n\n/**\n * @hidden\n */\nclass SliderModel extends SliderModelBase {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"handlePosition\", void 0);\n  }\n  positionHandle(dragHandle) {\n    const {\n      max,\n      min,\n      reverse,\n      vertical\n    } = this.props;\n    const position = vertical ? 'bottom' : reverse ? 'right' : 'left';\n    const trackWidth = this.trackWidth();\n    const value = trimValue(max, min, this.props.value);\n    this.handlePosition = calculateHandlePosition({\n      min,\n      max,\n      reverse,\n      value,\n      trackWidth\n    });\n    this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);\n  }\n  positionSelection(selection) {\n    const {\n      vertical\n    } = this.props;\n    const dimension = vertical ? 'height' : 'width';\n    const size = this.handlePosition;\n    this.renderer.setStyle(selection, dimension, `${size}px`);\n  }\n}\nconst UNTOUCHED = 'ng-untouched';\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find(name => name === className));\n/**\n * @hidden\n */\nfunction invokeElementMethod(element, name, ...args) {\n  if (element && element.nativeElement) {\n    // eslint-disable-next-line prefer-spread\n    return element.nativeElement[name].apply(element.nativeElement, args);\n  }\n}\n/**\n * @hidden\n */\nconst isUntouched = element => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);\n/**\n * @hidden\n */\nconst containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n  return node;\n};\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-inputs',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163631,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * Represents the template for the labels of the Slider.\n * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside\n * the `<kendo-slider>` tag. The template context is passed to the `label` value.\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-slider [largeStep]=\"2\">\n *           <ng-template kendoSliderLabelTemplate let-value=\"value\">\n *             <b>{{value}}</b>\n *           </ng-template>\n *         </kendo-slider>\n *     `\n * })\n *\n * class AppComponent {\n * }\n *\n * ```\n */\nlet LabelTemplateDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class LabelTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class3 = LabelTemplateDirective;\n  _defineProperty(LabelTemplateDirective, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(LabelTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"\", \"kendoSliderLabelTemplate\", \"\"]],\n    standalone: true\n  }));\n  return LabelTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SliderBase = /*#__PURE__*/(() => {\n  var _class4;\n  class SliderBase {\n    get horizontalClass() {\n      return !this.vertical;\n    }\n    get verticalClass() {\n      return this.vertical;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title\n       * for each tick is its Slider value. If you use a callback function, the function accepts an argument\n       * that holds the value of the component and returns a string with the new title.\n       */\n      _defineProperty(this, \"title\", identity);\n      /**\n       * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).\n       *\n       * The available options are:\n       * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.\n       * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.\n       * * `both`&mdash; (Default) The tick marks are located on both sides of the track.\n       * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.\n       */\n      _defineProperty(this, \"tickPlacement\", 'both');\n      /**\n       * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical\n       * ([see example]({% slug orientation_slider %})).\n       */\n      _defineProperty(this, \"vertical\", false);\n      /**\n       * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * The attribute accepts both integers and floating-point numbers.\n       */\n      _defineProperty(this, \"min\", 0);\n      /**\n       * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * The attribute accepts both integers and floating-point numbers.\n       */\n      _defineProperty(this, \"max\", 10);\n      /**\n       * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * Accepts positive values only. Can be an integer or a floating-point number.\n       */\n      _defineProperty(this, \"smallStep\", 1);\n      /**\n       * Specifies that every n<sup>th</sup> tick will be large and will have a label\n       * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).\n       * Accepts positive integer values only.\n       */\n      _defineProperty(this, \"largeStep\", null);\n      /**\n       * Sets the width between each two ticks along the track ([see example]({% slug ticks_slider %}#toc-width)). The value\n       * has to be set in pixels. If no `fixedTickWidth` is provided, the Slider automatically adjusts the tick width to\n       * accommodate the elements within the size of the component.\n       */\n      _defineProperty(this, \"fixedTickWidth\", void 0);\n      /**\n       * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_slider#toc-managing-the-slider-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      /**\n       * Fires each time the user focuses the component.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the component is blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user selects a new value.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"sliderClass\", true);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"track\", void 0);\n      _defineProperty(this, \"sliderSelection\", void 0);\n      _defineProperty(this, \"ticksContainer\", void 0);\n      _defineProperty(this, \"ticks\", void 0);\n      _defineProperty(this, \"labelTemplate\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"isDragged\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"ifEnabled\", (callback, event) => {\n        if (!this.isDisabled) {\n          callback.call(this, event);\n        }\n      });\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    ngOnInit() {\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.sizeComponent();\n      }));\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n      this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    get reverse() {\n      return this.localizationService.rtl && !this.vertical;\n    }\n    get keyBinding() {\n      const reverse = this.reverse;\n      return {\n        [Keys.ArrowLeft]: reverse ? increment : decrement,\n        [Keys.ArrowRight]: reverse ? decrement : increment,\n        [Keys.ArrowDown]: decrement,\n        [Keys.ArrowUp]: increment,\n        [Keys.PageUp]: incrementLarge,\n        [Keys.PageDown]: decrementLarge,\n        [Keys.Home]: ({\n          min\n        }) => min,\n        [Keys.End]: ({\n          max\n        }) => max\n      };\n    }\n    resetStyles(elements) {\n      elements.forEach(el => {\n        if (el) {\n          if (this.vertical) {\n            this.renderer.removeStyle(el, 'width');\n            this.renderer.removeStyle(el, 'left');\n            this.renderer.removeStyle(el, 'right');\n          } else {\n            this.renderer.removeStyle(el, 'height');\n            this.renderer.removeStyle(el, 'bottom');\n          }\n          this.renderer.removeStyle(el, 'padding-top');\n        }\n      });\n    }\n  }\n  _class4 = SliderBase;\n  _defineProperty(SliderBase, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(SliderBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class4,\n    selectors: [[\"kendo-slider-base\"]],\n    contentQueries: function _class4_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, LabelTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class4_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n        i0.ɵɵviewQuery(_c3, 5, ElementRef);\n        i0.ɵɵviewQuery(_c3, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ticks = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function _class4_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-slider-horizontal\", ctx.horizontalClass)(\"k-slider-vertical\", ctx.verticalClass)(\"k-slider\", ctx.sliderClass)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      tickPlacement: \"tickPlacement\",\n      vertical: \"vertical\",\n      min: \"min\",\n      max: \"max\",\n      smallStep: \"smallStep\",\n      largeStep: \"largeStep\",\n      fixedTickWidth: \"fixedTickWidth\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function _class4_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SliderBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @angular-eslint/component-selector */\n/**\n * @hidden\n */\nclass SliderTick {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"classes\", {\n      'k-tick': true\n    });\n    _defineProperty(this, \"large\", void 0);\n    this.value = value;\n  }\n}\n/**\n * @hidden\n */\nlet SliderTicksComponent = /*#__PURE__*/(() => {\n  var _class6;\n  class SliderTicksComponent {\n    constructor() {\n      _defineProperty(this, \"wrapperClasses\", 'k-reset k-slider-items');\n      _defineProperty(this, \"tickTitle\", void 0);\n      _defineProperty(this, \"vertical\", void 0);\n      _defineProperty(this, \"step\", void 0);\n      _defineProperty(this, \"largeStep\", void 0);\n      _defineProperty(this, \"min\", void 0);\n      _defineProperty(this, \"max\", void 0);\n      _defineProperty(this, \"labelTemplate\", void 0);\n      _defineProperty(this, \"tickElements\", void 0);\n      _defineProperty(this, \"ticks\", []);\n    }\n    ngOnChanges(_) {\n      this.createTicks();\n    }\n    createTicks() {\n      const count = calculateTicksCount(this.min, this.max, this.step);\n      const largeStep = this.largeStep;\n      const tickValueProps = {\n        max: this.max,\n        min: this.min,\n        smallStep: this.step\n      };\n      const result = [];\n      for (let i = 0; i < count; i++) {\n        result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));\n        if (largeStep && i % largeStep === 0) {\n          result[i].large = true;\n          result[i].classes['k-tick-large'] = true;\n        }\n      }\n      if (result.length > 0) {\n        Object.assign(result[0].classes, this.endTickClasses(true));\n        Object.assign(result[result.length - 1].classes, this.endTickClasses(false));\n      }\n      this.ticks = result;\n    }\n    endTickClasses(first) {\n      return {\n        'k-first': first && !this.vertical || !first && this.vertical,\n        'k-last': !first && !this.vertical || first && this.vertical\n      };\n    }\n  }\n  _class6 = SliderTicksComponent;\n  _defineProperty(SliderTicksComponent, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)();\n  });\n  _defineProperty(SliderTicksComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class6,\n    selectors: [[\"\", \"kendoSliderTicks\", \"\"]],\n    viewQuery: function _class6_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c4, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tickElements = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function _class6_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.wrapperClasses);\n      }\n    },\n    inputs: {\n      tickTitle: \"tickTitle\",\n      vertical: \"vertical\",\n      step: \"step\",\n      largeStep: \"largeStep\",\n      min: \"min\",\n      max: \"max\",\n      labelTemplate: \"labelTemplate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c5,\n    decls: 3,\n    vars: 1,\n    consts: [[\"role\", \"presentation\", 3, \"ngClass\", \"title\", 4, \"ngFor\", \"ngForOf\"], [\"defaultLabel\", \"\"], [\"role\", \"presentation\", 3, \"ngClass\", \"title\"], [\"tickElement\", \"\"], [3, \"ngSwitch\"], [\"class\", \"k-label\", 4, \"ngSwitchCase\"], [4, \"ngSwitchCase\"], [1, \"k-label\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class6_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class6_li_0_Template, 5, 5, \"li\", 0);\n        i0.ɵɵtemplate(1, _class6_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n      }\n    },\n    dependencies: [NgFor, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return SliderTicksComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SliderMessages = /*#__PURE__*/(() => {\n  var _class7;\n  class SliderMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the **Decrease** button of the Slider.\n       */\n      _defineProperty(this, \"decrement\", void 0);\n      /**\n       * The title of the **Increase** button of the Slider.\n       */\n      _defineProperty(this, \"increment\", void 0);\n      /**\n       * The title of the drag handle of the Slider.\n       */\n      _defineProperty(this, \"dragHandle\", void 0);\n    }\n  }\n  _class7 = SliderMessages;\n  _defineProperty(SliderMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class7_BaseFactory;\n    return function _class7_Factory(t) {\n      return (ɵ_class7_BaseFactory || (ɵ_class7_BaseFactory = i0.ɵɵgetInheritedFactory(_class7)))(t || _class7);\n    };\n  }());\n  _defineProperty(SliderMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class7,\n    selectors: [[\"kendo-slider-messages-base\"]],\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\",\n      dragHandle: \"dragHandle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return SliderMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedSliderMessagesDirective = /*#__PURE__*/(() => {\n  var _class8;\n  class LocalizedSliderMessagesDirective extends SliderMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class8 = LocalizedSliderMessagesDirective;\n  _defineProperty(LocalizedSliderMessagesDirective, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedSliderMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class8,\n    selectors: [[\"\", \"kendoSliderLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SliderMessages,\n      useExisting: forwardRef(() => _class8)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedSliderMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst PRESSED$1 = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nlet SliderComponent = /*#__PURE__*/(() => {\n  var _class9;\n  class SliderComponent extends SliderBase {\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    get currentValue() {\n      return isPresent(this.value) ? this.value.toString() : '';\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n      super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Changes the `title` attribute of the drag handle so that it can be localized.\n       */\n      _defineProperty(this, \"dragHandleTitle\", void 0);\n      /**\n       * Sets the title of the **Increase** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).\n       */\n      _defineProperty(this, \"incrementTitle\", void 0);\n      /**\n       * Determines if the animation will be played on value change.\n       * Regardless of this setting, no animation will be played during the initial rendering.\n       */\n      _defineProperty(this, \"animate\", true);\n      /**\n       * Sets the title of the **Decrease** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).\n       */\n      _defineProperty(this, \"decrementTitle\", void 0);\n      /**\n       * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n       * When `showButtons` is set to `false`, the buttons are not displayed.\n       */\n      _defineProperty(this, \"showButtons\", true);\n      /**\n       * The current value of the Slider when it is initially displayed.\n       * The component can use either NgModel or the `value` binding but not both of them at the same time.\n       */\n      _defineProperty(this, \"value\", this.min);\n      _defineProperty(this, \"arrowUpIcon\", caretAltUpIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowDownIcon\", caretAltDownIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowLeftIcon\", caretAltLeftIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowRightIcon\", caretAltRightIcon);\n      _defineProperty(this, \"draghandle\", void 0);\n      _defineProperty(this, \"decreaseButton\", void 0);\n      _defineProperty(this, \"increaseButton\", void 0);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      _defineProperty(this, \"isInvalid\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onWrapClick\", args => {\n        const target = args.target;\n        if (!this.isDisabled && !target.closest('.k-button')) {\n          const value = eventValue(args, this.track.nativeElement, this.getProps());\n          this.changeValue(value);\n        }\n        invokeElementMethod(this.draghandle, 'focus');\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onKeyDown\", e => {\n        const options = this.getProps();\n        const {\n          max,\n          min\n        } = options;\n        const handler = this.keyBinding[e.keyCode];\n        if (this.isDisabled || !handler) {\n          return;\n        }\n        const value = handler(options);\n        this.changeValue(trimValue(max, min, value));\n        e.preventDefault();\n      });\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      _defineProperty(this, \"decreaseValue\", () => {\n        this.changeValue(decreaseValueToStep(this.value, this.getProps()));\n      });\n      _defineProperty(this, \"increaseValue\", () => {\n        this.changeValue(increaseValueToStep(this.value, this.getProps()));\n      });\n      _defineProperty(this, \"handleBlur\", () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            if (!this.focusChangedProgrammatically) {\n              this.onBlur.emit();\n            }\n          });\n        }\n      });\n      this.localization = localization;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n    }\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      if (!this.disabled) {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandle, 'focus');\n        this.focusChangedProgrammatically = false;\n      }\n    }\n    /**\n     * Blurs the Slider.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      invokeElementMethod(this.draghandle, 'blur');\n      this.handleBlur();\n      this.focusChangedProgrammatically = false;\n    }\n    ngOnChanges(changes) {\n      if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          this.sizeComponent(false);\n        });\n      }\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.showButtons) {\n        this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());\n        this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());\n      }\n      this.sizeComponent(false);\n      if (this.ticks) {\n        this.ticks.tickElements.changes.subscribe(() => this.sizeComponent(false));\n      }\n      this.attachElementEventHandlers();\n      this.isSliderInvalid();\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get incrementMessage() {\n      return this.incrementTitle || this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementMessage() {\n      return this.decrementTitle || this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n    get dragHandleMessage() {\n      return this.dragHandleTitle || this.localizationService.get('dragHandle');\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n      if (args.originalEvent) {\n        args.originalEvent.preventDefault();\n      }\n      this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n      this.dragging = true;\n      this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n      this.dragging = false; //needed for animation\n      this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.changeDetector.markForCheck();\n      this.value = value;\n      this.sizeComponent(this.animate);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.sizeComponent(this.animate);\n          this.changeDetector.markForCheck();\n        });\n      }\n      this.isSliderInvalid();\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent(animate) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const wrapper = this.wrapper.nativeElement;\n      const track = this.track.nativeElement;\n      const selectionEl = this.sliderSelection.nativeElement;\n      const dragHandleEl = this.draghandle.nativeElement;\n      const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n      if (!animate) {\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n      }\n      this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n      const props = this.getProps();\n      const model = new SliderModel(props, wrapper, track, this.renderer, this.increaseButton);\n      model.resizeTrack();\n      if (this.ticks) {\n        //for case when tickPlacement: none\n        model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n      }\n      model.positionHandle(dragHandleEl);\n      model.positionSelection(selectionEl);\n      if (!animate) {\n        this.hostElement.nativeElement.getBoundingClientRect();\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n      }\n      if (this.fixedTickWidth) {\n        model.resizeWrapper();\n      }\n    }\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        this.isFocused = value;\n      }\n    }\n    set dragging(value) {\n      if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n        const sliderSelection = this.sliderSelection.nativeElement;\n        const draghandle = this.draghandle.nativeElement;\n        if (value) {\n          this.renderer.addClass(sliderSelection, PRESSED$1);\n          this.renderer.addClass(draghandle, PRESSED$1);\n        } else {\n          this.renderer.removeClass(sliderSelection, PRESSED$1);\n          this.renderer.removeClass(draghandle, PRESSED$1);\n        }\n        this.isDragged = value;\n      }\n    }\n    setValueChangeInterval(element, callback) {\n      this.ngZone.runOutsideAngular(() => {\n        const pointerdown = fromEvent(element, 'pointerdown');\n        const pointerup = fromEvent(element, 'pointerup');\n        const pointerout = fromEvent(element, 'pointerout');\n        const subscription = pointerdown.pipe(tap(e => e.preventDefault()), filter(e => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(pointerup, pointerout))))).subscribe(() => {\n          if (!this.isFocused) {\n            invokeElementMethod(this.draghandle, 'focus');\n          }\n          callback();\n        });\n        this.subscriptions.add(subscription);\n      });\n    }\n    getProps() {\n      return {\n        buttons: this.showButtons,\n        disabled: this.disabled,\n        fixedTickWidth: this.fixedTickWidth,\n        largeStep: this.largeStep,\n        max: this.max,\n        min: this.min,\n        readonly: this.readonly,\n        reverse: this.reverse,\n        rtl: this.localizationService.rtl,\n        smallStep: this.smallStep,\n        value: trimValue(this.max, this.min, this.value),\n        vertical: this.vertical\n      };\n    }\n    isSliderInvalid() {\n      const sliderClasses = this.hostElement.nativeElement.classList;\n      this.isInvalid = sliderClasses.contains('ng-invalid') ? true : false;\n      this.renderer.setAttribute(this.draghandle.nativeElement, 'aria-invalid', `${this.isInvalid}`);\n    }\n    attachElementEventHandlers() {\n      const hostElement = this.hostElement.nativeElement;\n      let tabbing = false;\n      let cursorInsideWrapper = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              if (!this.focusChangedProgrammatically) {\n                this.onFocus.emit();\n              }\n              this.focused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n          if (tabbing) {\n            if (args.relatedTarget !== this.draghandle.nativeElement) {\n              this.handleBlur();\n            }\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n    get decreaseButtonArrowIcon() {\n      const icon = !this.vertical ? this.direction === 'ltr' ? 'caret-alt-left' : 'caret-alt-right' : 'caret-alt-down';\n      return icon;\n    }\n    get increaseButtonArrowIcon() {\n      const icon = !this.vertical ? this.direction === 'ltr' ? 'caret-alt-right' : 'caret-alt-left' : 'caret-alt-up';\n      return icon;\n    }\n    get decreaseButtonArrowSVGIcon() {\n      const icon = !this.vertical ? this.direction === 'ltr' ? this.arrowLeftIcon : this.arrowRightIcon : this.arrowDownIcon;\n      return icon;\n    }\n    get increaseButtonArrowSVGIcon() {\n      const icon = !this.vertical ? this.direction === 'ltr' ? this.arrowRightIcon : this.arrowLeftIcon : this.arrowUpIcon;\n      return icon;\n    }\n  }\n  _class9 = SliderComponent;\n  _defineProperty(SliderComponent, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(SliderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class9,\n    selectors: [[\"kendo-slider\"]],\n    viewQuery: function _class9_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 7);\n        i0.ɵɵviewQuery(_c7, 5, ElementRef);\n        i0.ɵɵviewQuery(_c8, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.increaseButton = _t.first);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      dragHandleTitle: \"dragHandleTitle\",\n      incrementTitle: \"incrementTitle\",\n      animate: \"animate\",\n      decrementTitle: \"decrementTitle\",\n      showButtons: \"showButtons\",\n      value: \"value\",\n      tabIndex: \"tabIndex\"\n    },\n    exportAs: [\"kendoSlider\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.slider'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class9)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class9)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 13,\n    vars: 23,\n    consts: function () {\n      let i18n_9;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Increase** button of the Slider.\n         * @meaning kendo.slider.increment\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10 = goog.getMsg(\"increment\");\n        i18n_9 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10;\n      } else {\n        i18n_9 = $localize`:kendo.slider.increment|The title of the **Increase** button of the Slider.:increment`;\n      }\n      let i18n_11;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Decrease** button of the Slider.\n         * @meaning kendo.slider.decrement\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12 = goog.getMsg(\"decrement\");\n        i18n_11 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12;\n      } else {\n        i18n_11 = $localize`:kendo.slider.decrement|The title of the **Decrease** button of the Slider.:decrement`;\n      }\n      let i18n_13;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the drag handle of the Slider.\n         * @meaning kendo.slider.dragHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14 = goog.getMsg(\"Drag\");\n        i18n_13 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14;\n      } else {\n        i18n_13 = $localize`:kendo.slider.dragHandle|The title of the drag handle of the Slider.:Drag`;\n      }\n      return [[\"kendoSliderLocalizedMessages\", \"\", \"increment\", i18n_9, \"decrement\", i18n_11, \"dragHandle\", i18n_13], [\"kendoButton\", \"\", \"type\", \"button\", \"rounded\", \"full\", \"class\", \"k-button-decrease\", \"aria-hidden\", \"true\", 3, \"icon\", \"svgIcon\", \"title\", 4, \"ngIf\"], [1, \"k-slider-track-wrap\", 3, \"kendoEventsOutsideAngular\"], [\"wrap\", \"\"], [\"kendoSliderTicks\", \"\", \"aria-hidden\", \"true\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\", 4, \"ngIf\"], [1, \"k-slider-track\"], [\"track\", \"\"], [1, \"k-slider-selection\"], [\"sliderSelection\", \"\"], [\"role\", \"slider\", \"kendoDraggable\", \"\", 1, \"k-draghandle\", \"k-draghandle-end\", 3, \"title\", \"id\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"draghandle\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", \"rounded\", \"full\", \"class\", \"k-button-increase\", \"aria-hidden\", \"true\", 3, \"icon\", \"svgIcon\", \"title\", 4, \"ngIf\"], [3, \"resize\"], [\"kendoButton\", \"\", \"type\", \"button\", \"rounded\", \"full\", \"aria-hidden\", \"true\", 1, \"k-button-decrease\", 3, \"icon\", \"svgIcon\", \"title\"], [\"decreaseButton\", \"\"], [\"kendoSliderTicks\", \"\", \"aria-hidden\", \"true\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\"], [\"ticks\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", \"rounded\", \"full\", \"aria-hidden\", \"true\", 1, \"k-button-increase\", 3, \"icon\", \"svgIcon\", \"title\"], [\"increaseButton\", \"\"]];\n    },\n    template: function _class9_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵtemplate(1, _class9_button_1_Template, 2, 4, \"button\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2, 3);\n        i0.ɵɵtemplate(4, _class9_ul_4_Template, 2, 7, \"ul\", 4);\n        i0.ɵɵelementStart(5, \"div\", 5, 6);\n        i0.ɵɵelement(7, \"div\", 7, 8);\n        i0.ɵɵelementStart(9, \"span\", 9, 10);\n        i0.ɵɵlistener(\"kendoPress\", function _class9_Template_span_kendoPress_9_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function _class9_Template_span_kendoDrag_9_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function _class9_Template_span_kendoRelease_9_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(11, _class9_button_11_Template, 2, 4, \"button\", 11);\n        i0.ɵɵelementStart(12, \"kendo-resize-sensor\", 12);\n        i0.ɵɵlistener(\"resize\", function _class9_Template_kendo_resize_sensor_resize_12_listener() {\n          return ctx.sizeComponent(false);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButtons);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-slider-topleft\", ctx.tickPlacement === \"before\")(\"k-slider-bottomright\", ctx.tickPlacement === \"after\");\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(20, _c15, ctx.onWrapClick, ctx.onKeyDown));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.tickPlacement !== \"none\");\n        i0.ɵɵadvance(5);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"title\", ctx.dragHandleMessage)(\"id\", ctx.focusableId);\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.currentValue)(\"aria-valuetext\", ctx.currentValue)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\")(\"tabindex\", ctx.disabled ? \"-1\" : ctx.tabIndex);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButtons);\n      }\n    },\n    dependencies: [LocalizedSliderMessagesDirective, NgIf, ButtonComponent, EventsOutsideAngularDirective, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return SliderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nclass RangeSliderModel extends SliderModelBase {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"startHandlePosition\", void 0);\n    _defineProperty(this, \"endHandlePosition\", void 0);\n  }\n  positionHandle(dragHandle) {\n    if (!dragHandle.id) {\n      return;\n    }\n    const {\n      max,\n      min,\n      reverse,\n      vertical\n    } = this.props;\n    const position = vertical ? 'bottom' : reverse ? 'right' : 'left';\n    const trackWidth = this.trackWidth();\n    const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0] : trimValueRange(max, min, this.props.value)[1];\n    if (isStartHandle(dragHandle)) {\n      this.startHandlePosition = calculateHandlePosition({\n        min,\n        max,\n        reverse,\n        value,\n        trackWidth\n      });\n      this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);\n    } else {\n      this.endHandlePosition = calculateHandlePosition({\n        min,\n        max,\n        reverse,\n        value,\n        trackWidth\n      });\n      this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);\n    }\n  }\n  positionSelection(dragHandle, selection) {\n    const {\n      reverse,\n      vertical\n    } = this.props;\n    const dimension = vertical ? 'height' : 'width';\n    const position = vertical ? 'bottom' : reverse ? 'right' : 'left';\n    const size = Math.abs(this.endHandlePosition - this.startHandlePosition);\n    const currentSelectionPosition = vertical ? dragHandle.style.bottom : reverse ? dragHandle.style.right : dragHandle.style.left;\n    this.renderer.setStyle(selection, dimension, `${size}px`);\n    this.renderer.setStyle(selection, position, parseFloat(currentSelectionPosition) + 'px');\n  }\n}\n\n/**\n * @hidden\n */\nlet RangeSliderMessages = /*#__PURE__*/(() => {\n  var _class11;\n  class RangeSliderMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the range `start` drag handle.\n       */\n      _defineProperty(this, \"dragHandleStart\", void 0);\n      /**\n       * The title of the range `end` drag handle.\n       */\n      _defineProperty(this, \"dragHandleEnd\", void 0);\n    }\n  }\n  _class11 = RangeSliderMessages;\n  _defineProperty(RangeSliderMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class11_BaseFactory;\n    return function _class11_Factory(t) {\n      return (ɵ_class11_BaseFactory || (ɵ_class11_BaseFactory = i0.ɵɵgetInheritedFactory(_class11)))(t || _class11);\n    };\n  }());\n  _defineProperty(RangeSliderMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class11,\n    selectors: [[\"kendo-rangeslider-messages-base\"]],\n    inputs: {\n      dragHandleStart: \"dragHandleStart\",\n      dragHandleEnd: \"dragHandleEnd\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return RangeSliderMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedRangeSliderMessagesDirective = /*#__PURE__*/(() => {\n  var _class12;\n  class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class12 = LocalizedRangeSliderMessagesDirective;\n  _defineProperty(LocalizedRangeSliderMessagesDirective, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedRangeSliderMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class12,\n    selectors: [[\"\", \"kendoSliderLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: RangeSliderMessages,\n      useExisting: forwardRef(() => _class12)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedRangeSliderMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).\n */\nlet RangeSliderComponent = /*#__PURE__*/(() => {\n  var _class13;\n  class RangeSliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n      super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Sets the range value of the RangeSlider.\n       * The component can use either NgModel or the `value` binding but not both of them at the same time.\n       */\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"draghandleStart\", void 0);\n      _defineProperty(this, \"draghandleEnd\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"startHandleId\", `k-start-handle-${guid()}`);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"endHandleId\", `k-end-handle-${guid()}`);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", this.startHandleId);\n      _defineProperty(this, \"draggedHandle\", void 0);\n      _defineProperty(this, \"lastHandlePosition\", void 0);\n      _defineProperty(this, \"activeHandle\", 'startHandle');\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      _defineProperty(this, \"isInvalid\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onWrapClick\", args => {\n        if (!this.isDisabled) {\n          this.value = this.value || [this.min, this.min];\n          const trackValue = eventValue(args, this.track.nativeElement, this.getProps());\n          let newRangeValue;\n          const [startValue, endValue] = newRangeValue = this.value;\n          if (trackValue <= startValue) {\n            newRangeValue = [trackValue, endValue];\n            this.activeHandle = 'startHandle';\n          } else if (startValue < trackValue && trackValue < endValue) {\n            if (trackValue < (startValue + endValue) / 2) {\n              newRangeValue = [trackValue, endValue];\n              this.activeHandle = 'startHandle';\n            } else {\n              newRangeValue = [startValue, trackValue];\n              this.activeHandle = 'endHandle';\n            }\n          } else if (trackValue >= endValue) {\n            newRangeValue = [startValue, trackValue];\n            this.activeHandle = 'endHandle';\n          }\n          const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n          invokeElementMethod(activeHandle, 'focus');\n          this.changeValue(newRangeValue);\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onKeyDown\", e => {\n        this.value = this.value || [this.min, this.min];\n        const options = this.getProps();\n        const {\n          max,\n          min\n        } = options;\n        const handler = this.keyBinding[e.keyCode];\n        if (this.isDisabled || !handler) {\n          return;\n        }\n        const startHandleIsActive = isStartHandle(e.target);\n        const nonDraggedHandle = startHandleIsActive ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;\n        this.renderer.removeStyle(nonDraggedHandle, 'zIndex');\n        this.renderer.setStyle(e.target, 'zIndex', 1);\n        const value = handler({\n          ...options,\n          value: startHandleIsActive ? this.value[0] : this.value[1]\n        });\n        if (startHandleIsActive) {\n          if (value > this.value[1]) {\n            this.value[1] = value;\n          }\n        } else {\n          if (value < this.value[0]) {\n            this.value[0] = value;\n          }\n        }\n        const trimmedValue = trimValue(max, min, value);\n        const newValue = startHandleIsActive ? [trimmedValue, this.value[1]] : [this.value[0], trimmedValue];\n        this.changeValue(newValue);\n        e.preventDefault();\n      });\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      _defineProperty(this, \"handleBlur\", () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            if (!this.focusChangedProgrammatically) {\n              this.onBlur.emit();\n            }\n          });\n        }\n      });\n      this.localization = localization;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n    }\n    /**\n     * Focuses the RangeSlider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *     <div>\n     *         <button class=\"k-button\" (click)=\"slider.focus()\">Focus</button>\n     *     </div>\n     *     <kendo-rangeslider #slider></kendo-rangeslider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      this.focusChangedProgrammatically = true;\n      invokeElementMethod(this.draghandleStart, 'focus');\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the RangeSlider.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n      invokeElementMethod(activeHandle, 'blur');\n      this.handleBlur();\n      this.focusChangedProgrammatically = false;\n    }\n    ngOnInit() {\n      if (!this.value) {\n        this.value = [this.min, this.max];\n      }\n      super.ngOnInit();\n    }\n    ngOnChanges(changes) {\n      if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n        if (changes['value'] && changes['value'].currentValue) {\n          validateValue(changes['value'].currentValue);\n        }\n        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          this.sizeComponent();\n        });\n      }\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.sizeComponent();\n      if (this.ticks) {\n        this.ticks.tickElements.changes.subscribe(() => this.sizeComponent());\n      }\n      this.isRangeSliderInvalid();\n      this.attachElementEventHandlers();\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get valueText() {\n      return this.value ? `${this.value[0]} - ${this.value[1]}` : '';\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n      if (args.originalEvent) {\n        args.originalEvent.preventDefault();\n      }\n      const target = args.originalEvent.target;\n      this.draggedHandle = target;\n      const nonDraggedHandle = this.draghandleStart.nativeElement === this.draggedHandle ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;\n      this.renderer.removeStyle(nonDraggedHandle, 'zIndex');\n      this.renderer.setStyle(target, 'zIndex', 1);\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n      this.value = this.value || [this.min, this.min];\n      const target = args.originalEvent.target;\n      const lastCoords = this.draggedHandle.getBoundingClientRect();\n      this.lastHandlePosition = {\n        x: lastCoords.left,\n        y: lastCoords.top\n      };\n      this.dragging = {\n        value: true,\n        target\n      };\n      const mousePos = {\n        x: args.pageX - 0.5 - lastCoords.width / 2,\n        y: args.pageY - lastCoords.width / 2\n      };\n      const left = mousePos.x < this.lastHandlePosition.x;\n      const right = mousePos.x > this.lastHandlePosition.x;\n      const up = mousePos.y > this.lastHandlePosition.y;\n      const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);\n      const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);\n      const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);\n      const activeStartHandle = isStartHandle(this.draggedHandle);\n      const vertical = this.vertical;\n      const horizontal = !vertical;\n      const forward = vertical && up || (this.reverse ? horizontal && right : horizontal && left);\n      const incorrectValueState = this.value[0] > this.value[1];\n      if (this.value[0] === this.value[1] || incorrectValueState) {\n        if (forward) {\n          // eslint-disable-next-line no-unused-expressions\n          activeStartHandle ? moveStartHandle() : moveBothHandles();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          activeStartHandle ? moveBothHandles() : moveEndHandle();\n        }\n      } else {\n        // eslint-disable-next-line no-unused-expressions\n        activeStartHandle ? moveStartHandle() : moveEndHandle();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease(args) {\n      this.dragging = {\n        value: false,\n        target: args.originalEvent.target\n      }; //needed for animation\n      this.draggedHandle = undefined;\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      validateValue(value);\n      this.value = value;\n      this.sizeComponent();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n      if (!this.value || !isSameRange(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          if (this.value) {\n            this.valueChange.emit(value);\n          }\n          this.sizeComponent();\n        });\n      }\n      this.isRangeSliderInvalid();\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      const wrapper = this.wrapper.nativeElement;\n      const track = this.track.nativeElement;\n      const selectionEl = this.sliderSelection.nativeElement;\n      const dragHandleStartEl = this.draghandleStart.nativeElement;\n      const dragHandleEndEl = this.draghandleEnd.nativeElement;\n      const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n      this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);\n      const props = this.getProps();\n      const model = new RangeSliderModel(props, wrapper, track, this.renderer);\n      model.resizeTrack();\n      if (this.ticks) {\n        //for case when tickPlacement: none\n        model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n      }\n      model.positionHandle(dragHandleStartEl);\n      model.positionHandle(dragHandleEndEl);\n      model.positionSelection(dragHandleStartEl, selectionEl);\n      if (this.fixedTickWidth) {\n        model.resizeWrapper();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        this.isFocused = value;\n      }\n    }\n    set dragging(data) {\n      if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {\n        const sliderSelection = this.sliderSelection.nativeElement;\n        const draghandle = data.target;\n        if (data.value) {\n          this.renderer.addClass(sliderSelection, PRESSED);\n          this.renderer.addClass(draghandle, PRESSED);\n        } else {\n          this.renderer.removeClass(sliderSelection, PRESSED);\n          this.renderer.removeClass(draghandle, PRESSED);\n        }\n        this.isDragged = data.value;\n      }\n    }\n    getProps() {\n      return {\n        disabled: this.disabled,\n        fixedTickWidth: this.fixedTickWidth,\n        largeStep: this.largeStep,\n        max: this.max,\n        min: this.min,\n        readonly: this.readonly,\n        reverse: this.reverse,\n        rtl: this.localizationService.rtl,\n        smallStep: this.smallStep,\n        value: trimValueRange(this.max, this.min, this.value),\n        vertical: this.vertical,\n        buttons: false\n      };\n    }\n    isRangeSliderInvalid() {\n      const rangeSliderClasses = this.hostElement.nativeElement.classList;\n      this.isInvalid = rangeSliderClasses.contains('ng-invalid') ? true : false;\n      this.renderer.setAttribute(this.draghandleStart.nativeElement, 'aria-invalid', `${this.isInvalid}`);\n      this.renderer.setAttribute(this.draghandleEnd.nativeElement, 'aria-invalid', `${this.isInvalid}`);\n    }\n    attachElementEventHandlers() {\n      const hostElement = this.hostElement.nativeElement;\n      let tabbing = false;\n      let cursorInsideWrapper = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              if (!this.focusChangedProgrammatically) {\n                this.onFocus.emit();\n              }\n              this.focused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n          if (tabbing) {\n            if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {\n              this.handleBlur();\n            }\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n  }\n  _class13 = RangeSliderComponent;\n  _defineProperty(RangeSliderComponent, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(RangeSliderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class13,\n    selectors: [[\"kendo-rangeslider\"]],\n    viewQuery: function _class13_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c16, 7);\n        i0.ɵɵviewQuery(_c17, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);\n      }\n    },\n    inputs: {\n      value: \"value\"\n    },\n    exportAs: [\"kendoRangeSlider\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.rangeslider'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class13)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class13)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 13,\n    vars: 33,\n    consts: function () {\n      let i18n_18;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Start** drag handle of the Slider.\n         * @meaning kendo.rangeslider.dragHandleStart\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19 = goog.getMsg(\"Drag\");\n        i18n_18 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19;\n      } else {\n        i18n_18 = $localize`:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.:Drag`;\n      }\n      let i18n_20;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **End** drag handle of the Slider.\n         * @meaning kendo.rangeslider.dragHandleEnd\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21 = goog.getMsg(\"Drag\");\n        i18n_20 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21;\n      } else {\n        i18n_20 = $localize`:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.:Drag`;\n      }\n      return [[\"kendoSliderLocalizedMessages\", \"\", \"dragHandleStart\", i18n_18, \"dragHandleEnd\", i18n_20], [1, \"k-slider-track-wrap\", 3, \"kendoEventsOutsideAngular\"], [\"wrap\", \"\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\", 4, \"ngIf\"], [1, \"k-slider-track\"], [\"track\", \"\"], [1, \"k-slider-selection\"], [\"sliderSelection\", \"\"], [\"role\", \"slider\", \"kendoDraggable\", \"\", 1, \"k-draghandle\", 3, \"id\", \"title\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"draghandleStart\", \"\"], [\"draghandleEnd\", \"\"], [3, \"resize\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\"], [\"ticks\", \"\"]];\n    },\n    template: function _class13_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵtemplate(3, _class13_ul_3_Template, 2, 8, \"ul\", 3);\n        i0.ɵɵelementStart(4, \"div\", 4, 5);\n        i0.ɵɵelement(6, \"div\", 6, 7);\n        i0.ɵɵelementStart(8, \"span\", 8, 9);\n        i0.ɵɵlistener(\"kendoPress\", function _class13_Template_span_kendoPress_8_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function _class13_Template_span_kendoDrag_8_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function _class13_Template_span_kendoRelease_8_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(10, \"span\", 8, 10);\n        i0.ɵɵlistener(\"kendoPress\", function _class13_Template_span_kendoPress_10_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function _class13_Template_span_kendoDrag_10_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function _class13_Template_span_kendoRelease_10_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(12, \"kendo-resize-sensor\", 11);\n        i0.ɵɵlistener(\"resize\", function _class13_Template_kendo_resize_sensor_resize_12_listener() {\n          return ctx.sizeComponent();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-slider-topleft\", ctx.tickPlacement === \"before\")(\"k-slider-bottomright\", ctx.tickPlacement === \"after\");\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(30, _c15, ctx.onWrapClick, ctx.onKeyDown));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.tickPlacement !== \"none\");\n        i0.ɵɵadvance(5);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"id\", ctx.startHandleId)(\"title\", ctx.textFor(\"dragHandleStart\"));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value ? ctx.value[0] : null)(\"aria-valuetext\", ctx.valueText)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"id\", ctx.endHandleId)(\"title\", ctx.textFor(\"dragHandleEnd\"));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value ? ctx.value[1] : null)(\"aria-valuetext\", ctx.valueText)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\");\n      }\n    },\n    dependencies: [LocalizedRangeSliderMessagesDirective, EventsOutsideAngularDirective, NgIf, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],\n    encapsulation: 2\n  }));\n  return RangeSliderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  var _class14;\n  class Messages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the **On** button of the Switch.\n       */\n      _defineProperty(this, \"on\", void 0);\n      /**\n       * The title of the **Off** button of the Switch.\n       */\n      _defineProperty(this, \"off\", void 0);\n    }\n  }\n  _class14 = Messages;\n  _defineProperty(Messages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class14_BaseFactory;\n    return function _class14_Factory(t) {\n      return (ɵ_class14_BaseFactory || (ɵ_class14_BaseFactory = i0.ɵɵgetInheritedFactory(_class14)))(t || _class14);\n    };\n  }());\n  _defineProperty(Messages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class14,\n    selectors: [[\"kendo-switch-messages-base\"]],\n    inputs: {\n      on: \"on\",\n      off: \"off\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedSwitchMessagesDirective = /*#__PURE__*/(() => {\n  var _class15;\n  class LocalizedSwitchMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class15 = LocalizedSwitchMessagesDirective;\n  _defineProperty(LocalizedSwitchMessagesDirective, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedSwitchMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class15,\n    selectors: [[\"\", \"kendoSwitchLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class15)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedSwitchMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FOCUSED$5 = 'k-focus';\nconst DEFAULT_SIZE$e = 'medium';\nconst DEFAULT_THUMB_ROUNDED = 'full';\nconst DEFAULT_TRACK_ROUNDED = 'full';\n/**\n * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).\n */\nlet SwitchComponent = /*#__PURE__*/(() => {\n  var _class16;\n  class SwitchComponent {\n    /**\n     * @hidden\n     */\n    get focusableId() {\n      if (this.hostElement.nativeElement.hasAttribute('id')) {\n        return this.hostElement.nativeElement.getAttribute('id');\n      }\n      return `k-${guid()}`;\n    }\n    /**\n     * Sets the **On** label ([see example]({% slug labels_switch %})).\n     * Takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).\n     */\n\n    /**\n     * Sets the value of the Switch when it is initially displayed.\n     */\n    set checked(value) {\n      this.setHostClasses(value);\n      this._checked = value;\n    }\n    get checked() {\n      return this._checked;\n    }\n    /**\n     * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_switch#toc-managing-the-switch-disabled-state-in-reactive-forms).\n     */\n\n    /**\n     * Specifies the width and height of the Switch.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$e;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Specifies the border radius of the Switch thumb.\n     *\n     * The possible values are:\n     * * `full` (default)\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n    set thumbRounded(thumbRounded) {\n      const newThumbRounded = thumbRounded ? thumbRounded : DEFAULT_THUMB_ROUNDED;\n      this.handleThumbClasses(newThumbRounded);\n      this._thumbRounded = newThumbRounded;\n    }\n    get thumbRounded() {\n      return this._thumbRounded;\n    }\n    /**\n     * Specifies the border radius of the Switch track.\n     *\n     * The possible values are:\n     * * `full` (default)\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n    set trackRounded(trackRounded) {\n      const newTrackRounded = trackRounded ? trackRounded : DEFAULT_TRACK_ROUNDED;\n      this.handleTrackClasses(newTrackRounded);\n      this._trackRounded = newTrackRounded;\n    }\n    get trackRounded() {\n      return this._trackRounded;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Fires each time the Switch component is focused as a result of user interaction.\n     */\n\n    get ieClass() {\n      return browser && browser.msie;\n    }\n    get hostId() {\n      return this.focusableId;\n    }\n    get ariaChecked() {\n      return this.checked;\n    }\n    get ariaInvalid() {\n      return this.isControlInvalid ? true : undefined;\n    }\n    get hostTabIndex() {\n      return this.disabled ? undefined : this.tabIndex;\n    }\n    get ariaDisabled() {\n      return this.disabled ? true : undefined;\n    }\n    get ariaReadonly() {\n      return this.readonly;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"onLabel\", void 0);\n      /**\n       * Sets the **Off** label ([see example]({% slug labels_switch %})).\n       * Takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).\n       */\n      _defineProperty(this, \"offLabel\", void 0);\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the Switch component is blurred as a result of user interaction.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user selects a new value.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"hostRole\", 'switch');\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"track\", void 0);\n      _defineProperty(this, \"thumb\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"initialized\", false);\n      _defineProperty(this, \"localizationChangeSubscription\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"domSubscriptions\", []);\n      _defineProperty(this, \"_checked\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_trackRounded\", 'full');\n      _defineProperty(this, \"_thumbRounded\", 'full');\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleFocus\", event => {\n        if (this.isFocused) {\n          return;\n        }\n        event.stopImmediatePropagation();\n        this.focused = true;\n        if (hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            const eventArgs = {\n              originalEvent: event\n            };\n            this.onFocus.emit(eventArgs);\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleBlur\", event => {\n        const relatedTarget = event && event.relatedTarget;\n        if (this.hostElement.nativeElement.contains(relatedTarget)) {\n          return;\n        }\n        event.stopImmediatePropagation();\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            const eventArgs = {\n              originalEvent: event\n            };\n            this.onBlur.emit(eventArgs);\n          });\n        }\n      });\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.changeDetector = changeDetector;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n      this.keyDownHandler = this.keyDownHandler.bind(this);\n      this.clickHandler = this.clickHandler.bind(this);\n    }\n    /**\n     * @hidden\n     */\n    get onLabelMessage() {\n      return this.onLabel !== undefined ? this.onLabel : this.localizationService.get('on');\n    }\n    /**\n     * @hidden\n     */\n    get offLabelMessage() {\n      return this.offLabel !== undefined ? this.offLabel : this.localizationService.get('off');\n    }\n    get isEnabled() {\n      return !this.disabled && !this.readonly;\n    }\n    ngOnInit() {\n      if (this.hostElement) {\n        const wrapper = this.hostElement.nativeElement;\n        this.renderer.removeAttribute(wrapper, \"tabindex\");\n      }\n      this.localizationChangeSubscription = this.localizationService.changes.pipe(skip(1)).subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.control = this.injector.get(NgControl, null);\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);\n    }\n    ngAfterViewInit() {\n      const wrapper = this.hostElement.nativeElement;\n      if (!this.checked && !wrapper.classList.contains('k-switch-off')) {\n        this.renderer.addClass(wrapper, 'k-switch-off');\n      }\n      this.handleClasses(this.size, 'size');\n      this.handleTrackClasses(this.trackRounded);\n      this.handleThumbClasses(this.thumbRounded);\n      this.attachHostHandlers();\n    }\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n      this.domSubscriptions.forEach(subscription => subscription());\n      const wrapper = this.hostElement.nativeElement;\n      wrapper.removeEventListener('focus', this.handleFocus, true);\n      wrapper.removeEventListener('blur', this.handleBlur, true);\n    }\n    /**\n     * Focuses the Switch.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"switch.focus()\">Focus</button>\n     *  <kendo-switch #switch></kendo-switch>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      if (!this.hostElement) {\n        return;\n      }\n      this.hostElement.nativeElement.focus();\n    }\n    /**\n     * Blurs the Switch.\n     */\n    blur() {\n      if (!this.hostElement) {\n        return;\n      }\n      this.hostElement.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && !this.control.valid;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.checked = value === null ? false : value;\n      this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(e) {\n      const keyCode = e.keyCode;\n      if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {\n        this.changeValue(!this.checked);\n        e.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n    clickHandler() {\n      if (this.isEnabled) {\n        this.changeValue(!this.checked);\n      }\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    changeValue(value) {\n      if (this.checked !== value) {\n        this.ngZone.run(() => {\n          this.checked = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const wrapper = this.hostElement.nativeElement;\n        if (value) {\n          this.renderer.addClass(wrapper, FOCUSED$5);\n        } else {\n          this.renderer.removeClass(wrapper, FOCUSED$5);\n        }\n        this.isFocused = value;\n      }\n    }\n    attachHostHandlers() {\n      this.ngZone.runOutsideAngular(() => {\n        const wrapper = this.hostElement.nativeElement;\n        this.domSubscriptions.push(this.renderer.listen(wrapper, 'click', this.clickHandler), this.renderer.listen(wrapper, 'keydown', this.keyDownHandler));\n        wrapper.addEventListener('focus', this.handleFocus, true);\n        wrapper.addEventListener('blur', this.handleBlur, true);\n      });\n    }\n    setHostClasses(value) {\n      const wrapper = this.hostElement.nativeElement;\n      if (value) {\n        this.renderer.removeClass(wrapper, 'k-switch-off');\n        this.renderer.addClass(wrapper, 'k-switch-on');\n      } else {\n        this.renderer.removeClass(wrapper, 'k-switch-on');\n        this.renderer.addClass(wrapper, 'k-switch-off');\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('switch', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleTrackClasses(value) {\n      const track = this.track?.nativeElement;\n      if (!track) {\n        return;\n      }\n      const classes = getStylingClasses('switch', 'rounded', this.trackRounded, value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(track, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(track, classes.toAdd);\n      }\n    }\n    handleThumbClasses(value) {\n      const thumb = this.thumb?.nativeElement;\n      if (!thumb) {\n        return;\n      }\n      const classes = getStylingClasses('switch', 'rounded', this.thumbRounded, value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(thumb, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(thumb, classes.toAdd);\n      }\n    }\n  }\n  _class16 = SwitchComponent;\n  _defineProperty(SwitchComponent, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(SwitchComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class16,\n    selectors: [[\"kendo-switch\"]],\n    viewQuery: function _class16_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c22, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 16,\n    hostBindings: function _class16_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"role\", ctx.hostRole)(\"id\", ctx.hostId)(\"aria-checked\", ctx.ariaChecked)(\"aria-invalid\", ctx.ariaInvalid)(\"tabindex\", ctx.hostTabIndex)(\"aria-disabled\", ctx.ariaDisabled)(\"aria-readonly\", ctx.ariaReadonly);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-ie\", ctx.ieClass)(\"k-switch\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      onLabel: \"onLabel\",\n      offLabel: \"offLabel\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      thumbRounded: \"thumbRounded\",\n      trackRounded: \"trackRounded\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoSwitch\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.switch'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class16) /* eslint-disable-line*/\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class16)\n    }]), i0.ɵɵStandaloneFeature],\n    decls: 10,\n    vars: 8,\n    consts: function () {\n      let i18n_23;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The **On** label of the Switch.\n         * @meaning kendo.switch.on\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24 = goog.getMsg(\"ON\");\n        i18n_23 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24;\n      } else {\n        i18n_23 = $localize`:kendo.switch.on|The **On** label of the Switch.:ON`;\n      }\n      let i18n_25;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The **Off** label of the Switch.\n         * @meaning kendo.switch.off\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26 = goog.getMsg(\"OFF\");\n        i18n_25 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26;\n      } else {\n        i18n_25 = $localize`:kendo.switch.off|The **Off** label of the Switch.:OFF`;\n      }\n      return [[\"kendoSwitchLocalizedMessages\", \"\", \"on\", i18n_23, \"off\", i18n_25], [1, \"k-switch-track\"], [\"track\", \"\"], [1, \"k-switch-label-on\"], [1, \"k-switch-label-off\"], [1, \"k-switch-thumb-wrap\"], [1, \"k-switch-thumb\"], [\"thumb\", \"\"]];\n    },\n    template: function _class16_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1, 2)(3, \"span\", 3);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 4);\n        i0.ɵɵtext(6);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(7, \"span\", 5);\n        i0.ɵɵelement(8, \"span\", 6, 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"transition-duration\", ctx.initialized ? \"200ms\" : \"0ms\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.onLabelMessage);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.offLabelMessage);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"transition-duration\", ctx.initialized ? \"200ms\" : \"0ms\");\n      }\n    },\n    dependencies: [LocalizedSwitchMessagesDirective],\n    encapsulation: 2\n  }));\n  return SwitchComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.\n * Used to style the textbox of any `input` element.\n *\n * @example\n * ```ts-no-run\n * <input kendoTextBox />\n * <input kendoTextBox type=\"email\" />\n * <input kendoTextBox type=\"password\" />\n * ```\n */\nlet TextBoxDirective = /*#__PURE__*/(() => {\n  var _class17;\n  class TextBoxDirective {\n    /**\n     * @hidden\n     */\n    set value(text) {\n      if (!this.inputElement) {\n        return;\n      }\n      this.inputElement.nativeElement.value = text === undefined || text === null ? '' : text;\n      this.onValueChange.emit();\n    }\n    /**\n     * @hidden\n     */\n    get value() {\n      return this.inputElement.nativeElement.value;\n    }\n    get id() {\n      return this.inputElement.nativeElement.id;\n    }\n    set id(id) {\n      this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);\n    }\n    constructor(renderer, inputElement, ngZone) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"inputElement\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onValueChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"autoFillStart\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"autoFillEnd\", new EventEmitter());\n      _defineProperty(this, \"listeners\", []);\n      this.renderer = renderer;\n      this.inputElement = inputElement;\n      this.ngZone = ngZone;\n    }\n    ngAfterViewInit() {\n      const input = this.inputElement.nativeElement;\n      this.listeners = [this.renderer.listen(input, 'focus', () => this.onFocus.emit()), this.renderer.listen(input, 'blur', () => this.onBlur.emit())];\n      this.ngZone.runOutsideAngular(() => {\n        this.renderer.listen(input, 'animationstart', e => {\n          if (e.animationName === 'autoFillStart') {\n            this.autoFillStart.emit();\n          } else if (e.animationName === 'autoFillEnd') {\n            this.autoFillEnd.emit();\n          }\n        });\n      });\n    }\n    ngOnDestroy() {\n      this.listeners.forEach(listener => listener());\n    }\n  }\n  _class17 = TextBoxDirective;\n  _defineProperty(TextBoxDirective, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(TextBoxDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class17,\n    selectors: [[\"input\", \"kendoTextBox\", \"\"]],\n    hostVars: 10,\n    hostBindings: function _class17_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-textbox\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-input-md\", ctx.hostClasses)(\"k-rounded-md\", ctx.hostClasses)(\"k-input-solid\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      value: \"value\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class17)\n    }])]\n  }));\n  return TextBoxDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).\n * Provides floating labels to `textarea` elements.\n *\n * @example\n * ```ts-no-run\n * <textarea kendoTextArea></textarea>\n * ```\n */\nlet TextAreaDirective = /*#__PURE__*/(() => {\n  var _class18;\n  class TextAreaDirective {\n    get id() {\n      return this.element.nativeElement.id;\n    }\n    set id(id) {\n      this.renderer.setAttribute(this.element.nativeElement, 'id', id);\n    }\n    constructor(renderer, element, zone, changeDetector, injector, rtl) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"elementClasses\", true);\n      _defineProperty(this, \"autofillClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Fires each time the textarea value is changed.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Specifies if the `textarea` element will resize its height automatically\n       * ([see example](slug:textarea_sizing#toc-auto-resizing)).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"autoSize\", false);\n      /**\n       * Specifies the textarea value.\n       */\n      _defineProperty(this, \"value\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"onValueChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"autoFillStart\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"autoFillEnd\", new EventEmitter());\n      _defineProperty(this, \"listeners\", []);\n      _defineProperty(this, \"inputSubscription\", void 0);\n      _defineProperty(this, \"initialHeight\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"resizeSubscription\", void 0);\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      this.renderer = renderer;\n      this.element = element;\n      this.zone = zone;\n      this.changeDetector = changeDetector;\n      this.injector = injector;\n      this.direction = rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.elementValue = value;\n      this.resize();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.setElementProperty('disabled', isDisabled);\n    }\n    ngOnInit() {\n      const element = this.element.nativeElement;\n      this.zone.runOutsideAngular(() => {\n        this.listeners = [this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'animationstart', e => {\n          if (e.animationName === 'autoFillStart') {\n            this.autoFillStart.emit();\n          } else if (e.animationName === 'autoFillEnd') {\n            this.autoFillEnd.emit();\n          }\n        })];\n        if (isDocumentAvailable() && this.autoSize) {\n          this.resizeSubscription = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(() => this.resize());\n        }\n        this.inputSubscription = fromEvent(element, 'input').subscribe(this.handleInput.bind(this));\n      });\n      this.control = this.injector.get(NgControl, null);\n    }\n    ngOnChanges(changes) {\n      const element = this.element.nativeElement;\n      if (changes.value) {\n        this.elementValue = this.value;\n      }\n      if (changes.autoSize) {\n        if (this.autoSize) {\n          this.initialHeight = element.offsetHeight;\n          this.renderer.setStyle(element, 'resize', 'none');\n        } else {\n          this.renderer.setStyle(element, 'overflow-y', 'auto');\n          this.renderer.setStyle(element, 'resize', 'both');\n          element.style.height = `${this.initialHeight}px`;\n        }\n      }\n      this.zone.onStable.pipe(take(1)).subscribe(() => this.resize());\n    }\n    ngOnDestroy() {\n      this.listeners.forEach(listener => listener());\n      if (this.inputSubscription) {\n        this.inputSubscription.unsubscribe();\n      }\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n    get elementValue() {\n      if (this.element) {\n        return this.element.nativeElement.value;\n      }\n      return '';\n    }\n    set elementValue(value) {\n      this.setElementProperty('value', value === undefined || value === null ? '' : value);\n    }\n    setElementProperty(name, value) {\n      if (this.element) {\n        this.renderer.setProperty(this.element.nativeElement, name, value);\n      }\n    }\n    resize() {\n      if (!this.autoSize) {\n        return;\n      }\n      const element = this.element.nativeElement;\n      this.renderer.setStyle(element, 'overflow-y', 'hidden');\n      element.style.height = `${this.initialHeight}px`;\n      const scrollHeight = element.scrollHeight;\n      if (scrollHeight > this.initialHeight) {\n        element.style.height = `${scrollHeight}px`;\n      }\n    }\n    handleInput() {\n      const value = this.elementValue;\n      this.value = value;\n      if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {\n        this.zone.run(() => {\n          this.ngChange(value);\n          this.onValueChange.emit(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n      this.resize();\n    }\n    handleFocus() {\n      if (hasObservers(this.onFocus)) {\n        this.zone.run(() => {\n          this.onFocus.emit();\n        });\n      }\n    }\n    handleBlur() {\n      if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n        this.zone.run(() => {\n          this.ngTouched();\n          this.onBlur.emit();\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n  }\n  _class18 = TextAreaDirective;\n  _defineProperty(TextAreaDirective, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(RTL, 8));\n  });\n  _defineProperty(TextAreaDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class18,\n    selectors: [[\"textarea\", \"kendoTextArea\", \"\"]],\n    hostVars: 13,\n    hostBindings: function _class18_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-textarea\", ctx.elementClasses)(\"k-input\", ctx.elementClasses)(\"k-input-md\", ctx.elementClasses)(\"k-rounded-md\", ctx.elementClasses)(\"k-input-solid\", ctx.elementClasses)(\"k-autofill\", ctx.autofillClass);\n      }\n    },\n    inputs: {\n      autoSize: \"autoSize\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class18),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class18)\n    }]), i0.ɵɵNgOnChangesFeature]\n  }));\n  return TextAreaDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst createMaxValidator = maxValue => {\n  return c => {\n    if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {\n      return null;\n    }\n    return {\n      maxError: {\n        maxValue: maxValue,\n        value: c.value\n      }\n    };\n  };\n};\n\n/**\n * @hidden\n */\nconst createMinValidator = minValue => {\n  return c => {\n    if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {\n      return null;\n    }\n    return {\n      minError: {\n        minValue: minValue,\n        value: c.value\n      }\n    };\n  };\n};\n\n/**\n * @hidden\n */\nconst MIN_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';\n/**\n * @hidden\n */\nconst MAX_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';\n/**\n * @hidden\n */\nconst POINT = \".\";\n/**\n * @hidden\n */\nconst INITIAL_SPIN_DELAY = 500;\n/**\n * @hidden\n */\nconst SPIN_DELAY = 50;\n/**\n * @hidden\n */\nconst EXPONENT_REGEX = /[eE][\\-+]?([0-9]+)/;\n\n/**\n * @hidden\n */\nconst numericRegex = options => {\n  const {\n    autoCorrect,\n    decimals,\n    min\n  } = options;\n  let separator = options.separator;\n  if (separator === POINT) {\n    separator = '\\\\' + separator;\n  }\n  const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';\n  let numberPattern;\n  if (decimals === 0) {\n    numberPattern = '\\\\d*';\n  } else {\n    numberPattern = `(?:(?:\\\\d+(${separator}\\\\d*)?)|(?:${separator}\\\\d*))?`;\n  }\n  return new RegExp(`^${signPattern}${numberPattern}$`);\n};\n/**\n * @hidden\n */\nconst decimalPart = value => {\n  return value >= 0 ? Math.floor(value) : Math.ceil(value);\n};\n/**\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop$1 = _ => {};\n/**\n * @hidden\n */\nconst defined = value => {\n  return typeof value !== 'undefined';\n};\n/**\n * @hidden\n */\nconst isNumber = value => {\n  return !isNaN(value) && value !== null;\n};\n/**\n * @hidden\n */\nfunction pad(value, digits) {\n  const count = digits - String(value).length;\n  let result = value;\n  if (count > 0) {\n    const padString = new Array(count + 1).join(\"0\");\n    result = parseFloat(value + padString);\n  }\n  return result;\n}\n/**\n * @hidden\n */\nconst getDeltaFromMouseWheel = e => {\n  let delta = 0;\n  if (e.wheelDelta) {\n    delta = e.wheelDelta / 120;\n    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n  } else if (e.detail) {\n    delta = Math.round(-e.detail / 3);\n  }\n  return delta;\n};\n/**\n * @hidden\n */\nconst getCaretPosition = element => element.selectionStart;\n/**\n * @hidden\n */\nconst extractSignificantNumericChars = (formattedString, separator) => {\n  const significantCharacters = `${separator}0123456789-`;\n  return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);\n};\n/**\n * @hidden\n */\nconst isRightClick = event => {\n  const isRightClickIE = event.button && event.button === 2;\n  const isRightClickOther = event.which && event.which === 3;\n  return isRightClickIE || isRightClickOther;\n};\n\n/**\n * @hidden\n */\nvar ArrowDirection = /*#__PURE__*/function (ArrowDirection) {\n  ArrowDirection[ArrowDirection[\"Down\"] = -1] = \"Down\";\n  ArrowDirection[ArrowDirection[\"None\"] = 0] = \"None\";\n  ArrowDirection[ArrowDirection[\"Up\"] = 1] = \"Up\";\n  return ArrowDirection;\n}(ArrowDirection || {});\n/**\n * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <kendo-input-separator></kendo-input-separator>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet InputSeparatorComponent = /*#__PURE__*/(() => {\n  var _class19;\n  class InputSeparatorComponent {\n    constructor() {\n      /**\n       * Specifies the orientation of the separator. Applicable for the adornments of the [`TextAreaComponent`](slug:api_inputs_textareacomponent).\n       *\n       * @default 'vertical'\n       */\n      _defineProperty(this, \"orientation\", 'vertical');\n      _defineProperty(this, \"hostClass\", true);\n    }\n    get vertical() {\n      return this.orientation === 'vertical';\n    }\n    get horizontal() {\n      return this.orientation === 'horizontal';\n    }\n  }\n  _class19 = InputSeparatorComponent;\n  _defineProperty(InputSeparatorComponent, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)();\n  });\n  _defineProperty(InputSeparatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class19,\n    selectors: [[\"kendo-input-separator\"], [\"kendo-textbox-separator\"]],\n    hostVars: 6,\n    hostBindings: function _class19_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input-separator-vertical\", ctx.vertical)(\"k-input-separator-horizontal\", ctx.horizontal)(\"k-input-separator\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class19_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return InputSeparatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SharedInputEventsDirective = /*#__PURE__*/(() => {\n  var _class20;\n  class SharedInputEventsDirective {\n    constructor(ngZone, renderer, cdr) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"clearButtonClicked\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"isFocusedChange\", new EventEmitter());\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      _defineProperty(this, \"handleBlur\", new EventEmitter());\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n    }\n    ngAfterViewInit() {\n      const hostElement = this.hostElement.nativeElement;\n      let cursorInsideWrapper = false;\n      let tabbing = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          this.cdr.detectChanges();\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              this.onFocus.emit();\n              this.isFocused = true;\n              this.isFocusedChange.emit(this.isFocused);\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n          if (tabbing) {\n            const closestTextbox = closest(args.relatedTarget, element => element === hostElement);\n            if (!closestTextbox) {\n              this.handleBlur.emit();\n            }\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper && !this?.clearButtonClicked) {\n              this.handleBlur.emit();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  _class20 = SharedInputEventsDirective;\n  _defineProperty(SharedInputEventsDirective, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(SharedInputEventsDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class20,\n    selectors: [[\"\", \"kendoInputSharedEvents\", \"\"]],\n    inputs: {\n      hostElement: \"hostElement\",\n      clearButtonClicked: \"clearButtonClicked\",\n      isFocused: \"isFocused\"\n    },\n    outputs: {\n      isFocusedChange: \"isFocusedChange\",\n      onFocus: \"onFocus\",\n      handleBlur: \"handleBlur\"\n    },\n    standalone: true\n  }));\n  return SharedInputEventsDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet NumericTextBoxMessages = /*#__PURE__*/(() => {\n  var _class21;\n  class NumericTextBoxMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the **Decrement** button of the NumericTextBox.\n       */\n      _defineProperty(this, \"decrement\", void 0);\n      /**\n       * The title of the **Increment** button of the NumericTextBox.\n       */\n      _defineProperty(this, \"increment\", void 0);\n    }\n  }\n  _class21 = NumericTextBoxMessages;\n  _defineProperty(NumericTextBoxMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class21_BaseFactory;\n    return function _class21_Factory(t) {\n      return (ɵ_class21_BaseFactory || (ɵ_class21_BaseFactory = i0.ɵɵgetInheritedFactory(_class21)))(t || _class21);\n    };\n  }());\n  _defineProperty(NumericTextBoxMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class21,\n    selectors: [[\"kendo-numerictextbox-messages-base\"]],\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return NumericTextBoxMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedNumericTextBoxMessagesDirective = /*#__PURE__*/(() => {\n  var _class22;\n  class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class22 = LocalizedNumericTextBoxMessagesDirective;\n  _defineProperty(LocalizedNumericTextBoxMessagesDirective, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedNumericTextBoxMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class22,\n    selectors: [[\"\", \"kendoNumericTextBoxLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NumericTextBoxMessages,\n      useExisting: forwardRef(() => _class22)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedNumericTextBoxMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];\nconst PARSABLE_DEFAULTS = {\n  decimals: null,\n  max: null,\n  min: null,\n  step: 1\n};\nconst FOCUSED$4 = 'k-focus';\nconst DEFAULT_SIZE$d = 'medium';\nconst DEFAULT_ROUNDED$8 = 'medium';\nconst DEFAULT_FILL_MODE$6 = 'solid';\n/**\n * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).\n */\nlet NumericTextBoxComponent = /*#__PURE__*/(() => {\n  var _class23;\n  class NumericTextBoxComponent {\n    /**\n     * Specifies the number format which is used when the NumericTextBox is not focused\n     * ([see example]({% slug formats_numerictextbox %})).\n     * If `format` is set to `null` or `undefined`, the default format will be used.\n     */\n    get format() {\n      const format = this._format;\n      return format !== null && format !== undefined ? format : 'n2';\n    }\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * Specifies the greatest value that is valid\n     * ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.\n     *\n     * @default true\n     */\n\n    /**\n     * The size property specifies padding of the NumericTextBox internal input element\n     * ([see example]({% slug appearance_numerictextbox %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$d;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The `rounded` property specifies the border radius of the NumericTextBox\n     * ([see example](slug:appearance_numerictextbox#toc-roundness)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$8;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The `fillMode` property specifies the background and border styles of the NumericTextBox\n     * ([see example](slug:appearance_numerictextbox#toc-fill-mode)).\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$6;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.numericInput.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    /**\n     * Fires each time the user selects a new value ([see example](slug:events_numerictextbox)).\n     */\n\n    get disableClass() {\n      return this.disabled;\n    }\n    get defaultAttributes() {\n      return {\n        id: this.focusableId,\n        disabled: this.disabled ? '' : null,\n        readonly: this.readonly ? '' : null,\n        tabindex: this.tabIndex,\n        placeholder: this.placeholder,\n        title: this.title,\n        maxlength: this.maxlength,\n        'aria-valuemin': this.min,\n        'aria-valuemax': this.max,\n        'aria-valuenow': this.value,\n        required: this.isControlRequired ? '' : null,\n        'aria-invalid': this.isControlInvalid\n      };\n    }\n    get mutableAttributes() {\n      return {\n        autocomplete: 'off',\n        autocorrect: 'off',\n        role: 'spinbutton'\n      };\n    }\n    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {\n      _defineProperty(this, \"intl\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_numerictextbox#toc-managing-the-numerictextbox-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Sets the title of the `input` element of the NumericTextBox.\n       */\n      _defineProperty(this, \"title\", '');\n      /**\n       * Specifies whether the value will be auto-corrected based on the minimum and maximum values\n       * ([see example]({% slug precision_numerictextbox %})).\n       */\n      _defineProperty(this, \"autoCorrect\", false);\n      _defineProperty(this, \"max\", void 0);\n      /**\n       * Specifies the smallest value that is valid\n       * ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).\n       */\n      _defineProperty(this, \"min\", void 0);\n      /**\n       * Specifies the number of decimals that the user can enter when the input is focused\n       * ([see example]({% slug precision_numerictextbox %})).\n       */\n      _defineProperty(this, \"decimals\", null);\n      /**\n       * Specifies the input placeholder.\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      /**\n       * Specifies the value that is used to increment or decrement the component value\n       * ([see example]({% slug predefinedsteps_numerictextbox %})).\n       */\n      _defineProperty(this, \"step\", 1);\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered\n       * ([see example]({% slug spinbuttons_numerictextbox %})).\n       */\n      _defineProperty(this, \"spinners\", true);\n      /**\n       * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.\n       *\n       * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`\n       * to `false`, the built-in Angular validators will be executed.\n       */\n      _defineProperty(this, \"rangeValidation\", true);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"changeValueOnScroll\", true);\n      /**\n       * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.\n       */\n      _defineProperty(this, \"selectOnFocus\", true);\n      /**\n       * Specifies the value of the NumericTextBox\n       * ([see example]({% slug formats_numerictextbox %})).\n       */\n      _defineProperty(this, \"value\", null);\n      /**\n       * Specifies the maximum number of characters the end user can type or paste in the input.\n       * The locale-specific decimal separator and negative sign (`-`) are included in the length of the value when present.\n       * The `maxlength` restriction is not applied to the length of the formatted value when the component is not focused.\n       */\n      _defineProperty(this, \"maxlength\", void 0);\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the NumericTextBox element ([see example](slug:events_numerictextbox)).\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the NumericTextBox component gets blurred ([see example](slug:events_numerictextbox)).\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"numericInput\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"ArrowDirection\", ArrowDirection);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowDirection\", ArrowDirection.None);\n      _defineProperty(this, \"hostClasses\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowUpIcon\", caretAltUpIcon);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"inputValue\", '');\n      _defineProperty(this, \"spinTimeout\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"minValidateFn\", noop$1);\n      _defineProperty(this, \"maxValidateFn\", noop$1);\n      _defineProperty(this, \"numericRegex\", void 0);\n      _defineProperty(this, \"_format\", \"n2\");\n      _defineProperty(this, \"previousSelection\", void 0);\n      _defineProperty(this, \"pressedKey\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"isPasted\", false);\n      _defineProperty(this, \"mouseDown\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"ngChange\", noop$1);\n      _defineProperty(this, \"ngTouched\", noop$1);\n      _defineProperty(this, \"ngValidatorChange\", noop$1);\n      _defineProperty(this, \"domEvents\", []);\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"increasePress\", e => {\n        this.arrowPress(ArrowDirection.Up, e);\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"decreasePress\", e => {\n        this.arrowPress(ArrowDirection.Down, e);\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"releaseArrow\", () => {\n        clearTimeout(this.spinTimeout);\n        if (this.arrowDirection !== ArrowDirection.None) {\n          this.arrowDirection = ArrowDirection.None;\n          this.changeDetector.detectChanges();\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handlePaste\", () => {\n        this.isPasted = true;\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInput\", () => {\n        const input = this.numericInput.nativeElement;\n        let {\n          selectionStart,\n          selectionEnd,\n          value: inputValue\n        } = input;\n        if (this.pressedKey === Keys.NumpadDecimal) {\n          inputValue = this.replaceNumpadDotValue();\n        }\n        if (this.isPasted) {\n          inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));\n        }\n        if (!this.isValid(inputValue)) {\n          input.value = this.inputValue;\n          this.setSelection(selectionStart - 1, selectionEnd - 1);\n          return;\n        }\n        const parsedValue = this.intl.parseNumber(inputValue);\n        let value = this.restrictDecimals(parsedValue);\n        if (this.autoCorrect) {\n          const limited = this.limitInputValue(value);\n          value = limited.value;\n          selectionStart = limited.selectionStart;\n          selectionEnd = limited.selectionEnd;\n        }\n        if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {\n          this.setInputValue(value);\n          this.setSelection(selectionStart, selectionEnd);\n        } else {\n          this.inputValue = inputValue;\n        }\n        if (this.isPasted) {\n          input.value = this.inputValue;\n        }\n        this.updateValue(value);\n        this.previousSelection = null;\n        this.isPasted = false;\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleDragEnter\", () => {\n        if (!this.focused && !this.isDisabled) {\n          this.setInputValue(this.value, true);\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleMouseDown\", () => {\n        this.mouseDown = true;\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputFocus\", () => {\n        if (!this.focused) {\n          this.focused = true;\n          if (!this.isDisabled) {\n            const shouldSelectAll = this.selectOnFocus || !this.mouseDown;\n            this.ngZone.runOutsideAngular(() => {\n              setTimeout(() => {\n                if (shouldSelectAll) {\n                  this.selectAll();\n                } else {\n                  this.selectCaret();\n                }\n              }, 0);\n            });\n          }\n          if (hasObservers(this.onFocus)) {\n            this.ngZone.run(() => {\n              this.onFocus.emit();\n            });\n          }\n        }\n        this.mouseDown = false;\n        if (hasObservers(this.inputFocus)) {\n          this.ngZone.run(() => {\n            this.inputFocus.emit();\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleBlur\", () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        //blur is thrown before input when dragging the input text in IE\n        if (this.inputValue !== this.elementValue) {\n          this.handleInput();\n        }\n        this.setInputValue();\n        if (hasObservers(this.onBlur)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.onBlur.emit();\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputBlur\", () => {\n        this.changeDetector.markForCheck();\n        //blur is thrown before input when dragging the input text in IE\n        if (this.inputValue !== this.elementValue) {\n          this.handleInput();\n        }\n        this.setInputValue();\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.inputBlur.emit();\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleKeyDown\", e => {\n        if (this.isDisabled) {\n          return;\n        }\n        let step;\n        if (e.keyCode === Keys.ArrowDown) {\n          step = -1;\n        } else if (e.keyCode === Keys.ArrowUp) {\n          step = 1;\n        }\n        if (step && this.step) {\n          e.preventDefault();\n          this.addStep(step);\n        }\n        const input = this.numericInput.nativeElement;\n        this.previousSelection = {\n          end: input.selectionEnd,\n          start: input.selectionStart\n        };\n        this.pressedKey = e.keyCode;\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleWheel\", e => {\n        if (this.focused && !this.isDisabled && this.changeValueOnScroll) {\n          e.preventDefault();\n          const delta = getDeltaFromMouseWheel(e);\n          this.addStep(delta);\n        }\n      });\n      this.intl = intl;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n      this.control = this.injector.get(NgControl, null);\n      this.ngZone.runOutsideAngular(() => {\n        this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'mousewheel', this.handleWheel.bind(this)));\n        this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'DOMMouseScroll', this.handleWheel.bind(this)));\n      });\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (anyChanged(PARSABLE_OPTIONS, changes, false)) {\n        this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));\n      }\n      this.verifySettings();\n      if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {\n        this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop$1;\n        this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop$1;\n        this.ngValidatorChange();\n      }\n      if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {\n        delete this.numericRegex;\n      }\n      if (anyChanged(['value', 'format'], changes, false)) {\n        this.verifyValue(this.value);\n        this.value = this.restrictModelValue(this.value);\n        if (!this.focused || this.intl.parseNumber(this.elementValue) !== this.value) {\n          this.setInputValue();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n      clearTimeout(this.spinTimeout);\n      this.domEvents.forEach(unbindHandler => unbindHandler());\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n      this.ngValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.verifyValue(value);\n      const restrictedValue = this.restrictModelValue(value);\n      this.value = restrictedValue;\n      this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * Focuses the NumericTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"numerictextbox.focus()\">Focus NumericTextBox</button>\n     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      invokeElementMethod(this.numericInput, 'focus');\n    }\n    /**\n     * Blurs the NumericTextBox.\n     */\n    blur() {\n      invokeElementMethod(this.numericInput, 'blur');\n    }\n    /**\n     * Notifies the `NumericTextBoxComponent` that the input value should be changed.\n     * Can be used to update the input after setting the component properties directly.\n     */\n    notifyValueChange() {\n      this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.ngZone.run(() => {\n        if (!this.focused && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.focused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    get incrementTitle() {\n      return this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementTitle() {\n      return this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && !this.control.valid;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.control?.control);\n    }\n    /**\n     * @hidden\n     */\n    get focused() {\n      return this.isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const wrap = this.hostElement.nativeElement;\n        if (value) {\n          this.renderer.addClass(wrap, FOCUSED$4);\n        } else {\n          this.renderer.removeClass(wrap, FOCUSED$4);\n        }\n        this.isFocused = value;\n      }\n    }\n    get decimalSeparator() {\n      const numberSymbols = this.intl.numberSymbols();\n      return numberSymbols.decimal;\n    }\n    get elementValue() {\n      return this.numericInput.nativeElement.value;\n    }\n    set elementValue(value) {\n      this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);\n    }\n    get hasDecimals() {\n      return this.decimals !== null && this.decimals >= 0;\n    }\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n    arrowPress(direction, e) {\n      e.preventDefault();\n      if (this.isDisabled || isRightClick(e)) {\n        return;\n      }\n      if (!mobileOS) {\n        this.focus();\n        this.focused = true;\n      }\n      if (this.arrowDirection !== direction) {\n        this.arrowDirection = direction;\n        this.changeDetector.detectChanges();\n      }\n      if (this.step) {\n        this.spin(direction, INITIAL_SPIN_DELAY);\n      } else {\n        this.setInputValue();\n      }\n    }\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n    replaceNumpadDotValue() {\n      let value = this.inputValue || \"\";\n      if (this.previousSelection) {\n        const input = this.numericInput.nativeElement;\n        const {\n          selectionStart,\n          selectionEnd\n        } = input;\n        const {\n          start,\n          end\n        } = this.previousSelection;\n        input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);\n        this.setSelection(selectionStart, selectionEnd);\n      }\n      return value;\n    }\n    isValid(value) {\n      if (!this.numericRegex) {\n        this.numericRegex = numericRegex({\n          autoCorrect: this.autoCorrect,\n          decimals: this.decimals,\n          min: this.min,\n          separator: this.decimalSeparator\n        });\n      }\n      return this.numericRegex.test(value);\n    }\n    spin(step, timeout) {\n      clearTimeout(this.spinTimeout);\n      this.spinTimeout = window.setTimeout(() => {\n        this.spin(step, SPIN_DELAY);\n      }, timeout);\n      this.addStep(step);\n    }\n    addStep(step) {\n      let value = add(this.value || 0, this.step * step);\n      value = this.limitValue(value);\n      value = this.restrictDecimals(value);\n      this.setInputValue(value);\n      this.updateValue(value);\n    }\n    setSelection(start, end) {\n      if (this.focused) {\n        invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);\n      }\n    }\n    limitValue(value) {\n      let result = value;\n      if (!this.isInRange(value)) {\n        if (isNumber(this.max) && value > this.max) {\n          result = this.max;\n        }\n        if (isNumber(this.min) && value < this.min) {\n          result = this.min;\n        }\n      }\n      return result;\n    }\n    limitInputValue(value) {\n      const {\n        selectionStart,\n        selectionEnd,\n        value: enteredValue\n      } = this.numericInput.nativeElement;\n      let limitedValue = value;\n      let selectToEnd = false;\n      if (!this.isInRange(value)) {\n        const lengthChange = enteredValue.length - String(this.inputValue).length;\n        const {\n          min,\n          max\n        } = this;\n        const hasMax = isNumber(max);\n        const hasMin = isNumber(min);\n        let padLimit, replaceNext;\n        let correctedValue = value;\n        if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {\n          return {\n            selectionEnd: selectionEnd,\n            selectionStart: selectionStart,\n            value: null\n          };\n        }\n        if (hasMax && value > max) {\n          if (value > 0) {\n            replaceNext = true;\n          } else {\n            padLimit = max;\n          }\n        } else if (hasMin && value < min) {\n          if (value > 0) {\n            padLimit = min;\n          } else {\n            replaceNext = true;\n          }\n        }\n        if (padLimit) {\n          const paddedValue = this.tryPadValue(value, padLimit);\n          if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {\n            correctedValue = paddedValue;\n            selectToEnd = true;\n          }\n        } else if (replaceNext) {\n          if (this.inputValue && selectionStart !== enteredValue.length) {\n            correctedValue = parseFloat(enteredValue.substr(0, selectionStart) + enteredValue.substr(selectionStart + lengthChange));\n          }\n        }\n        limitedValue = this.limitValue(correctedValue);\n        selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection && this.previousSelection.end - this.previousSelection.start + lengthChange > 0;\n      }\n      return {\n        selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,\n        selectionStart: selectionStart,\n        value: limitedValue\n      };\n    }\n    tryPadValue(value, limit) {\n      const limitLength = String(Math.floor(limit)).length;\n      const zeroPadded = pad(value, limitLength);\n      const zeroPaddedNext = pad(value, limitLength + 1);\n      let result;\n      if (this.isInRange(zeroPadded)) {\n        result = zeroPadded;\n      } else if (this.isInRange(zeroPaddedNext)) {\n        result = zeroPaddedNext;\n      }\n      return result;\n    }\n    isInRange(value) {\n      return !isNumber(value) || (!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max);\n    }\n    restrictModelValue(value) {\n      let result = this.restrictDecimals(value, true);\n      if (this.autoCorrect && this.limitValue(result) !== result) {\n        result = null;\n      }\n      return result;\n    }\n    restrictDecimals(value, round) {\n      let result = value;\n      if (value && this.hasDecimals) {\n        const decimals = this.decimals;\n        const stringValue = String(value);\n        if (round || EXPONENT_REGEX.test(stringValue)) {\n          result = toFixedPrecision(value, decimals);\n        } else {\n          const parts = stringValue.split(POINT);\n          let fraction = parts[1];\n          if (fraction && fraction.length > decimals) {\n            fraction = fraction.substr(0, decimals);\n            result = parseFloat(`${parts[0]}${POINT}${fraction}`);\n          }\n        }\n      }\n      return result;\n    }\n    formatInputValue(value) {\n      let stringValue = Object.is(value, -0) ? '-0' : String(value);\n      const exponentMatch = EXPONENT_REGEX.exec(stringValue);\n      if (exponentMatch) {\n        stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));\n      }\n      return stringValue.replace(POINT, this.decimalSeparator);\n    }\n    formatValue(value, focused) {\n      let formattedValue;\n      if (value === null || !defined(value) || value === '') {\n        formattedValue = '';\n      } else if (focused && !this.readonly) {\n        formattedValue = this.formatInputValue(value);\n      } else {\n        formattedValue = this.intl.formatNumber(value, this.format);\n      }\n      return formattedValue;\n    }\n    setInputValue(value = this.value, focused = this.focused) {\n      const formattedValue = this.formatValue(value, focused);\n      this.elementValue = formattedValue;\n      this.inputValue = formattedValue;\n    }\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n      if (this.min !== null && this.max !== null && this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n      }\n    }\n    verifyValue(value) {\n      if (isDevMode() && value && typeof value !== 'number') {\n        throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);\n      }\n    }\n    parseOptions(options) {\n      for (let idx = 0; idx < options.length; idx++) {\n        const name = options[idx];\n        const value = this[name];\n        if (typeof value === 'string') {\n          const parsed = parseFloat(value);\n          const valid = !isNaN(parsed);\n          if (isDevMode() && !valid && value !== '') {\n            throw new Error('The NumericTextBox component requires value of type Number or a String representing ' + `a number for the ${name} property and ${JSON.stringify(value)} was set.`);\n          }\n          this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];\n        }\n      }\n    }\n    intlChange() {\n      delete this.numericRegex;\n      if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {\n        this.setInputValue();\n      }\n    }\n    hasTrailingZeros(inputValue) {\n      if (this.hasDecimals && this.focused) {\n        const fraction = inputValue.split(this.decimalSeparator)[1];\n        return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;\n      }\n    }\n    selectAll() {\n      this.setInputValue();\n      this.setSelection(0, this.inputValue.length);\n    }\n    selectCaret() {\n      const caretPosition = getCaretPosition(this.numericInput.nativeElement);\n      const formattedValue = this.elementValue;\n      const partialValue = formattedValue.substring(0, caretPosition);\n      this.setInputValue();\n      if (partialValue.length) {\n        const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);\n        const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);\n        this.setSelection(adjustedSignificantChars, adjustedSignificantChars);\n      } else {\n        this.setSelection(0, 0);\n      }\n    }\n    numberOfLeadingZeroes(formattedValue) {\n      const separatorIndex = formattedValue.indexOf(this.decimalSeparator);\n      const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);\n      if (matchedLeadingZeroes) {\n        const lengthOfMatch = matchedLeadingZeroes[0].length;\n        const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;\n        return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;\n      }\n      return 0;\n    }\n    adjustSignificantChars(formattedValue, significantChars) {\n      const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);\n      if (leadingZeroes > 0) {\n        return Math.max(0, significantChars - leadingZeroes);\n      }\n      return significantChars;\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    setInputAttributes() {\n      const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);\n      setHTMLAttributes(attributesToRender, this.renderer, this.numericInput.nativeElement, this.ngZone);\n    }\n  }\n  _class23 = NumericTextBoxComponent;\n  _defineProperty(NumericTextBoxComponent, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(i1$1.IntlService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(NumericTextBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class23,\n    selectors: [[\"kendo-numerictextbox\"]],\n    contentQueries: function _class23_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class23_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c27, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function _class23_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-disabled\", ctx.disableClass)(\"k-input\", ctx.hostClasses)(\"k-numerictextbox\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      title: \"title\",\n      autoCorrect: \"autoCorrect\",\n      format: \"format\",\n      max: \"max\",\n      min: \"min\",\n      decimals: \"decimals\",\n      placeholder: \"placeholder\",\n      step: \"step\",\n      spinners: \"spinners\",\n      rangeValidation: \"rangeValidation\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      changeValueOnScroll: \"changeValueOnScroll\",\n      selectOnFocus: \"selectOnFocus\",\n      value: \"value\",\n      maxlength: \"maxlength\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\"\n    },\n    exportAs: [\"kendoNumericTextBox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.numerictextbox'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class23),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => _class23),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class23)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 9,\n    vars: 28,\n    consts: function () {\n      let i18n_28;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Increment** button in the NumericTextBox\n         * @meaning kendo.numerictextbox.increment\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29 = goog.getMsg(\"Increase value\");\n        i18n_28 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29;\n      } else {\n        i18n_28 = $localize`:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox:Increase value`;\n      }\n      let i18n_30;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Decrement** button in the NumericTextBox\n         * @meaning kendo.numerictextbox.decrement\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31 = goog.getMsg(\"Decrease value\");\n        i18n_30 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31;\n      } else {\n        i18n_30 = $localize`:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox:Decrease value`;\n      }\n      return [[\"kendoNumericTextBoxLocalizedMessages\", \"\", \"increment\", i18n_28, \"decrement\", i18n_30], [\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [\"role\", \"spinbutton\", \"autocomplete\", \"off\", \"autocorrect\", \"off\", 1, \"k-input-inner\", 3, \"id\", \"tabindex\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"numericInput\", \"\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [\"class\", \"k-input-spinner k-spin-button\", 3, \"kendoEventsOutsideAngular\", 4, \"ngIf\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"], [1, \"k-input-spinner\", \"k-spin-button\", 3, \"kendoEventsOutsideAngular\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-spinner-increase\", \"k-button\", \"k-button-md\", \"k-icon-button\", \"k-button-solid\", \"k-button-solid-base\", 3, \"kendoEventsOutsideAngular\", \"title\"], [\"name\", \"caret-alt-up\", \"innerCssClass\", \"k-button-icon\", 3, \"svgIcon\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-spinner-decrease\", \"k-button\", \"k-button-md\", \"k-icon-button\", \"k-button-solid\", \"k-button-solid-base\", 3, \"kendoEventsOutsideAngular\", \"title\"], [\"name\", \"caret-alt-down\", \"innerCssClass\", \"k-button-icon\", 3, \"svgIcon\"]];\n    },\n    template: function _class23_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class23_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.focused = $event;\n        })(\"handleBlur\", function _class23_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class23_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class23_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class23_kendo_input_separator_3_Template, 1, 0, \"kendo-input-separator\", 3);\n        i0.ɵɵelement(4, \"input\", 4, 5);\n        i0.ɵɵtemplate(6, _class23_kendo_input_separator_6_Template, 1, 0, \"kendo-input-separator\", 3);\n        i0.ɵɵtemplate(7, _class23_span_7_Template, 2, 1, \"span\", 6);\n        i0.ɵɵtemplate(8, _class23_span_8_Template, 5, 22, \"span\", 7);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.focused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction7(20, _c34, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handlePaste));\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value)(\"title\", ctx.title)(\"placeholder\", ctx.placeholder)(\"maxLength\", ctx.maxlength)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && (ctx.suffixTemplate == null ? null : ctx.suffixTemplate.showSeparator));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.spinners);\n      }\n    },\n    dependencies: [LocalizedNumericTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return NumericTextBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet NumericTextBoxCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class24;\n  class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class24 = NumericTextBoxCustomMessagesComponent;\n  _defineProperty(NumericTextBoxCustomMessagesComponent, \"\\u0275fac\", function _class24_Factory(t) {\n    return new (t || _class24)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(NumericTextBoxCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class24,\n    selectors: [[\"kendo-numerictextbox-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NumericTextBoxMessages,\n      useExisting: forwardRef(() => _class24)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class24_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return NumericTextBoxCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nvar ResultType = /*#__PURE__*/function (ResultType) {\n  ResultType[ResultType[\"Literal\"] = 0] = \"Literal\";\n  ResultType[ResultType[\"Mask\"] = 1] = \"Mask\";\n  // eslint-disable-next-line id-denylist\n  ResultType[ResultType[\"Undefined\"] = 2] = \"Undefined\";\n  return ResultType;\n}(ResultType || {});\n/**\n * @hidden\n */\nclass Result {\n  constructor(value, rest, type = ResultType.Undefined) {\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"rest\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    this.value = value;\n    this.rest = rest;\n    this.type = type;\n  }\n  //map :: Functor f => f a ~> (a -> b) -> f b\n  map(fn) {\n    return new Result(fn(this.value), this.rest);\n  }\n  //chain :: Chain m => m a ~> (a -> m b) -> m b\n  chain(fn) {\n    return fn(this.value, this.rest);\n  }\n  fold(s, _ /*we don't need it*/) {\n    return s(this.value, this.rest);\n  }\n  concat(r) {\n    return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));\n  }\n  toString() {\n    return `Result({ value: '${this.value}', rest: ${this.rest} })`;\n  }\n}\n\n/**\n * @hidden\n */\nclass Stream {\n  constructor(input = [], control = []) {\n    _defineProperty(this, \"input\", void 0);\n    _defineProperty(this, \"control\", void 0);\n    _defineProperty(this, \"inputCursor\", 0);\n    _defineProperty(this, \"controlCursor\", 0);\n    this.input = input;\n    this.control = control;\n  }\n  eof() {\n    return this.inputCursor >= this.input.length;\n  }\n  // Get the first value from the input.\n  next() {\n    return {\n      char: this.input[this.inputCursor++],\n      control: this.control[this.controlCursor++]\n    };\n  }\n  peek() {\n    return {\n      char: this.input[this.inputCursor],\n      control: this.control[this.controlCursor]\n    };\n  }\n  eat_input() {\n    this.inputCursor++;\n  }\n  eat_control() {\n    this.controlCursor++;\n  }\n  eat() {\n    this.inputCursor++;\n    this.controlCursor++;\n  }\n}\nconst toArray = value => (value || '').split('');\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nclass Parser {\n  constructor(parse) {\n    _defineProperty(this, \"parse\", void 0);\n    this.parse = parse;\n  }\n  run(input, control = '') {\n    if (input instanceof Stream) {\n      return this.parse(input);\n    } else {\n      return this.parse(new Stream(toArray(input), toArray(control)));\n    }\n  }\n  //map :: Functor f => f a ~> (a -> b) -> f b\n  map(f) {\n    return new Parser(stream => this.parse(stream).map(f));\n  }\n  //chain :: Chain m => m a ~> (a -> m b) -> m b\n  chain(f) {\n    return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n  }\n  isLiteral(c) {\n    return this.run(c).type === ResultType.Literal;\n  }\n}\n/**\n * @hidden\n */\nconst mask = ({\n  prompt,\n  promptPlaceholder\n}) => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n    if (char === control && control === prompt) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream, ResultType.Mask);\n    }\n    if (char === promptPlaceholder) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n    stream.eat_input();\n  }\n  stream.eat();\n  return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\nconst literal = _token => new Parser(stream => {\n  //    let {char, control} = stream.peek();\n  const char = stream.peek().char;\n  if (char === _token) {\n    stream.eat();\n    return new Result(_token, stream, ResultType.Literal);\n  }\n  //    if (control === _token) {\n  //        while (!stream.eof() && char !== _token) {\n  //            stream.eat_input();\n  //            char = stream.peek().char;\n  //        }\n  //    }\n  //\n  //    if (control !== undefined) {\n  //        stream.eat();\n  //    }\n  return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\nconst unmask = prompt => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n    if (char === prompt && control === prompt) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n    stream.eat_input();\n  }\n  stream.eat();\n  return new Result('', stream);\n});\n/**\n * @hidden\n */\nconst unliteral = _token => new Parser(stream => {\n  if (stream.eof()) {\n    return new Result('', stream);\n  }\n  const {\n    char\n  } = stream.peek();\n  if (char === _token) {\n    stream.eat();\n  }\n  return new Result(_token, stream);\n});\n/**\n * @hidden\n */\nconst token = (rules, creator) => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n  const rule = rules[char];\n  if (char === ESCAPE_CHARACTER) {\n    char = stream.next().char;\n    return new Result(creator.literal(char), stream);\n  }\n  if (!rule) {\n    return new Result(creator.literal(char), stream);\n  }\n  return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\nconst rawMask = ({\n  prompt,\n  promptPlaceholder\n}) => new Parser(stream => {\n  const {\n    char\n  } = stream.next();\n  if (char === prompt) {\n    return new Result(promptPlaceholder, stream);\n  }\n  return new Result(char, stream);\n});\n/**\n * @hidden\n */\nconst rawLiteral = includeLiterals => new Parser(stream => {\n  const {\n    char\n  } = stream.next();\n  if (includeLiterals) {\n    return new Result(char, stream);\n  }\n  return new Result('', stream);\n});\n\n/**\n * @hidden\n */\nconst always = value => new Parser(stream => new Result(value, stream));\n/**\n * @hidden\n */\nconst append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));\n/**\n * @hidden\n */\nconst sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));\n/**\n * @hidden\n */\nconst greedy = parser => new Parser(stream => {\n  let result = new Result([], stream);\n  while (!stream.eof()) {\n    result = result.concat(parser.run(stream));\n  }\n  return result;\n});\n\n/**\n * @hidden\n */\nlet MaskingService = /*#__PURE__*/(() => {\n  var _class28;\n  class MaskingService {\n    constructor() {\n      _defineProperty(this, \"rules\", {});\n      _defineProperty(this, \"prompt\", \"_\");\n      _defineProperty(this, \"mask\", \"\");\n      _defineProperty(this, \"promptPlaceholder\", \" \");\n      _defineProperty(this, \"includeLiterals\", false);\n      _defineProperty(this, \"maskTokens\", []);\n      _defineProperty(this, \"unmaskTokens\", []);\n      _defineProperty(this, \"rawTokens\", []);\n      _defineProperty(this, \"validationTokens\", []);\n    }\n    update({\n      mask = '',\n      prompt = '',\n      promptPlaceholder = ' ',\n      rules = {},\n      includeLiterals = false\n    }) {\n      this.mask = mask;\n      this.prompt = prompt;\n      this.promptPlaceholder = promptPlaceholder;\n      this.rules = rules;\n      this.includeLiterals = includeLiterals;\n      this.tokenize();\n    }\n    validationValue(maskedValue = '') {\n      let value = maskedValue;\n      sequence(this.validationTokens).run(maskedValue).fold(unmasked => {\n        value = unmasked.join('');\n      });\n      return value;\n    }\n    rawValue(maskedValue = '') {\n      let value = maskedValue;\n      if (!this.rawTokens.length) {\n        return value;\n      }\n      sequence(this.rawTokens).run(maskedValue).fold(unmasked => {\n        value = unmasked.join('');\n      });\n      return value;\n    }\n    /**\n     * @hidden\n     */\n    maskRaw(rawValue = '') {\n      let value = rawValue;\n      if (!this.maskTokens.length) {\n        return value;\n      }\n      sequence(this.maskTokens).run(rawValue).fold(masked => {\n        value = masked.join('');\n      });\n      return value;\n    }\n    maskInput(input, control, splitPoint) {\n      if (input.length < control.length) {\n        return this.maskRemoved(input, control, splitPoint);\n      }\n      return this.maskInserted(input, control, splitPoint);\n    }\n    maskInRange(pasted, oldValue, start, end) {\n      let value = '';\n      const selection = end;\n      const beforeChange = oldValue.split('').slice(0, start);\n      const afterChange = oldValue.split('').slice(end);\n      sequence(this.maskTokens.slice(start, end)).run(pasted).fold(masked => {\n        value = beforeChange.concat(masked).concat(afterChange).join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n    maskRemoved(input, control, splitPoint) {\n      let value = '';\n      let selection = splitPoint;\n      const unchanged = input.split('').slice(splitPoint);\n      const changed = input.split('').slice(0, splitPoint).join('');\n      const take = this.maskTokens.length - (input.length - splitPoint);\n      sequence(this.maskTokens.slice(0, take)).run(changed, control).fold(masked => {\n        selection = this.adjustPosition(masked, selection);\n        value = masked.concat(unchanged).join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n    adjustPosition(input, selection) {\n      const caretChar = input[selection];\n      const isLiteral = this.maskTokens[selection].isLiteral(caretChar);\n      if (!isLiteral && caretChar !== this.prompt) {\n        return selection + 1;\n      }\n      return selection;\n    }\n    maskInserted(input, control, splitPoint) {\n      let value = '';\n      let selection = splitPoint;\n      const changed = input.slice(0, splitPoint);\n      sequence(this.unmaskTokens).run(changed, control).chain(unmasked => {\n        selection = unmasked.join('').length;\n        const unchanged = control.slice(selection);\n        return sequence(this.maskTokens).run(unmasked.join('') + unchanged, control);\n      }).fold(masked => {\n        value = masked.join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n    get maskTokenCreator() {\n      const {\n        prompt,\n        promptPlaceholder\n      } = this;\n      return {\n        literal: rule => literal(rule),\n        mask: rule => mask({\n          prompt,\n          promptPlaceholder\n        })(rule)\n      };\n    }\n    get unmaskTokenCreator() {\n      return {\n        literal: rule => unliteral(rule),\n        mask: rule => unmask(this.prompt)(rule)\n      };\n    }\n    get rawTokenCreator() {\n      const {\n        prompt,\n        promptPlaceholder,\n        includeLiterals\n      } = this;\n      return {\n        literal: _ => rawLiteral(includeLiterals),\n        mask: _ => rawMask({\n          prompt,\n          promptPlaceholder\n        })\n      };\n    }\n    get validationTokenCreator() {\n      const {\n        prompt\n      } = this;\n      return {\n        literal: _ => rawLiteral(false),\n        mask: _ => rawMask({\n          prompt,\n          promptPlaceholder: ''\n        })\n      };\n    }\n    tokenize() {\n      greedy(token(this.rules, this.maskTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.maskTokens = tokens;\n      });\n      greedy(token(this.rules, this.unmaskTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.unmaskTokens = tokens;\n      });\n      greedy(token(this.rules, this.rawTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.rawTokens = tokens;\n      });\n      greedy(token(this.rules, this.validationTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.validationTokens = tokens;\n      });\n    }\n  }\n  _class28 = MaskingService;\n  _defineProperty(MaskingService, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)();\n  });\n  _defineProperty(MaskingService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class28,\n    factory: _class28.ɵfac\n  }));\n  return MaskingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst resolvedPromise = Promise.resolve(null);\nconst FOCUSED$3 = 'k-focus';\nconst DEFAULT_SIZE$c = 'medium';\nconst DEFAULT_ROUNDED$7 = 'medium';\nconst DEFAULT_FILL_MODE$5 = 'solid';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nlet MaskedTextBoxComponent = /*#__PURE__*/(() => {\n  var _class29;\n  class MaskedTextBoxComponent {\n    /**\n     * The size property specifies the padding of the MaskedTextBox internal input element\n     * ([see example]({% slug appearance_maskedtextbox %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$c;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the MaskedTextBox\n     * ([see example](slug:appearance_maskedtextbox#toc-roundness)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$7;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The `fillMode` property specifies the background and border styles of the MaskedTexBox\n     * ([see example]({% slug appearance_maskedtextbox %}#toc-fill-mode)).\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$5;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Represents the current mask ([see example]({% slug value_maskedtextbox %})).\n     * If no mask is set, the component behaves as a standard `type=\"text\"` input.\n     *\n     * > If the mask allows for spaces, set the [promptPlaceholder]({% slug api_inputs_maskedtextboxcomponent %}#toc-promptplaceholder)\n     * to a character that is not accepted by the mask.\n     */\n\n    /**\n     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n     */\n    set rules(value) {\n      this._rules = Object.assign({}, this.defaultRules, value);\n    }\n    get rules() {\n      return this._rules || this.defaultRules;\n    }\n    /**\n     * Represents a prompt character for the masked value.\n     * @default `_`\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    get defaultAttributes() {\n      return {\n        id: this.focusableId,\n        disabled: this.disabled ? '' : null,\n        readonly: this.readonly ? '' : null,\n        tabindex: this.tabIndex,\n        'aria-invalid': this.isControlInvalid,\n        title: this.title,\n        required: this.isControlRequired ? '' : null\n      };\n    }\n    get mutableAttributes() {\n      return {\n        'aria-placeholder': this.mask,\n        autocomplete: 'off',\n        autocorrect: 'off',\n        autocapitalize: 'off',\n        spellcheck: 'false'\n      };\n    }\n    /**\n     * Fires each time the user focuses the MaskedTextBox component.\n     *\n     * > To wire the event programmatically, use the `onFocus` property.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent {\n     *   public handleFocus(): void {\n     *      console.log(\"Component is focused\");\n     *   }\n     * }\n     * ```\n     */\n\n    get hostDisabledClass() {\n      return this.disabled;\n    }\n    /**\n     * Represents the `ElementRef` of the visible `input` element.\n     */\n\n    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_maskedtextbox#toc-managing-the-maskedtextbox-disabled-state-in-reactive-forms).\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Sets the title of the `input` element.\n       */\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"mask\", void 0);\n      /**\n       * Provides a value for the MaskedTextBox.\n       */\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"prompt\", '_');\n      /**\n       * Indicates a character which represents an empty position in the raw value.\n       * @default ' '\n       */\n      _defineProperty(this, \"promptPlaceholder\", ' ');\n      /**\n       * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n       * @default false\n       */\n      _defineProperty(this, \"includeLiterals\", false);\n      /**\n       * Specifies if the mask should be shown on focus for empty value.\n       */\n      _defineProperty(this, \"maskOnFocus\", false);\n      /**\n       * Determines whether the built-in mask validator is enforced when a form is validated\n       * ([see example]({% slug validation_maskedtextbox %})).\n       * @default true\n       */\n      _defineProperty(this, \"maskValidation\", true);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the MaskedTextBox component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log(\"Component is blurred\");\n       *   }\n       * }\n       * ```\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * Fires each time the value changes.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"input\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"isFocused\", void 0);\n      _defineProperty(this, \"maskedValue\", void 0);\n      _defineProperty(this, \"focusClick\", false);\n      _defineProperty(this, \"defaultRules\", {\n        \"#\": /[\\d\\s\\+\\-]/,\n        \"&\": /[\\S]/,\n        \"0\": /[\\d]/,\n        \"9\": /[\\d\\s]/,\n        \"?\": /[a-zA-Z\\s]/,\n        \"A\": /[a-zA-Z0-9]/,\n        \"C\": /./,\n        \"L\": /[a-zA-Z]/,\n        \"a\": /[a-zA-Z0-9\\s]/\n      });\n      _defineProperty(this, \"_rules\", void 0);\n      _defineProperty(this, \"isPasted\", false);\n      _defineProperty(this, \"selection\", [0, 0]);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleFocus\", () => {\n        this.ngZone.run(() => {\n          if (!this.focused && hasObservers(this.onFocus)) {\n            this.onFocus.emit();\n          }\n          this.focused = true;\n        });\n        if (this.maskOnFocus && this.emptyMask) {\n          this.updateInput(this.service.maskRaw(this.value));\n          this.ngZone.runOutsideAngular(() => {\n            setTimeout(() => {\n              this.setSelection(0, 0);\n            }, 0);\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputFocus\", () => {\n        this.handleFocus();\n        if (hasObservers(this.inputFocus)) {\n          this.ngZone.run(() => {\n            this.inputFocus.emit();\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleClick\", () => {\n        if (this.focused && !this.focusClick) {\n          this.focusClick = true;\n        }\n        if (this.promptPlaceholder === null || this.promptPlaceholder === '') {\n          const {\n            selectionStart,\n            selectionEnd\n          } = this.input.nativeElement;\n          if (selectionStart === selectionEnd) {\n            this.setFocusSelection();\n          }\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleBlur\", () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        this.focusClick = false;\n        if (this.maskOnFocus && this.emptyMask) {\n          this.updateInput(this.maskedValue);\n        }\n        if (hasObservers(this.onBlur)) {\n          this.ngZone.run(() => {\n            this.onBlur.emit();\n          });\n        }\n        this.ngZone.run(() => {\n          if (this.control) {\n            this.control && !this.control.touched && this.onTouched();\n          }\n        });\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputBlur\", () => {\n        this.changeDetector.markForCheck();\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.inputBlur.emit();\n          });\n        }\n      });\n      _defineProperty(this, \"onChange\", _ => {});\n      _defineProperty(this, \"onTouched\", () => {});\n      this.service = service;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.changeDetector = changeDetector;\n      validatePackage(packageMetadata);\n      this.direction = rtl ? 'rtl' : 'ltr';\n      this.updateService();\n    }\n    ngOnInit() {\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n      this.control = this.injector.get(NgControl, null);\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the MaskedTextBox is empty.\n     */\n    isEmpty() {\n      if (this.input) {\n        return !this.input.nativeElement.value;\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleDragDrop() {\n      return false;\n    }\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      if (!this.input) {\n        return;\n      }\n      this.input.nativeElement.focus();\n      this.focused = true;\n      this.setFocusSelection();\n    }\n    /**\n     * Blurs the MaskedTextBox.\n     */\n    blur() {\n      if (!this.input) {\n        return;\n      }\n      this.input.nativeElement.blur();\n      this.focused = false;\n    }\n    /**\n     * @hidden\n     */\n    pasteHandler(e) {\n      const {\n        selectionStart,\n        selectionEnd\n      } = e.target;\n      if (selectionEnd === selectionStart) {\n        return;\n      }\n      this.isPasted = true;\n      this.selection = [selectionStart, selectionEnd];\n    }\n    /**\n     * @hidden\n     */\n    inputHandler(e) {\n      const value = e.target.value;\n      const [start, end] = this.selection;\n      if (!this.mask) {\n        this.updateValueWithEvents(value);\n        this.isPasted = false;\n        return;\n      }\n      let result;\n      if (this.isPasted) {\n        this.isPasted = false;\n        const rightPart = this.maskedValue.length - end;\n        const to = value.length - rightPart;\n        result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n      } else {\n        result = this.service.maskInput(value, this.maskedValue || '', e.target.selectionStart);\n      }\n      this.updateInput(result.value, result.selection);\n      this.updateValueWithEvents(result.value);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n      if (changes['value']) {\n        this.value = this.normalizeValue(this.value);\n      }\n      const next = this.extractChanges(changes);\n      this.updateService(next);\n      if (!this.mask) {\n        this.updateInput(this.value);\n        return;\n      }\n      const maskedValue = this.service.maskRaw(this.value);\n      this.updateInput(maskedValue, null, true);\n      if (changes['includeLiterals'] || isChanged('promptPlaceholder', changes)) {\n        resolvedPromise.then(() => {\n          this.updateValueWithEvents(this.maskedValue, false);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    writeValue(value) {\n      this.value = this.normalizeValue(value);\n      this.updateInput(this.service.maskRaw(this.value));\n      if (this.includeLiterals) {\n        this.updateValue(this.maskedValue, false);\n      }\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    validate(_) {\n      if (this.maskValidation === false || !this.mask) {\n        return null;\n      }\n      if (!this.service.validationValue(this.maskedValue)) {\n        return null;\n      }\n      if (this.maskedValue.indexOf(this.prompt) !== -1) {\n        return {\n          patternError: {\n            mask: this.mask,\n            maskedValue: this.maskedValue,\n            value: this.value\n          }\n        };\n      }\n      return null;\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && this.control.invalid;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.control?.control);\n    }\n    /**\n     * @hidden\n     */\n    updateValueWithEvents(maskedValue, callOnChange = true) {\n      const previousValue = this.value;\n      this.updateValue(maskedValue, callOnChange);\n      const valueChanged = this.value !== previousValue;\n      if (valueChanged && hasObservers(this.valueChange)) {\n        this.valueChange.emit(this.value);\n      }\n    }\n    updateValue(value, callOnChange = true) {\n      if (this.mask && !this.service.validationValue(value) && !this.includeLiterals) {\n        this.value = '';\n      } else {\n        this.value = this.service.rawValue(value);\n      }\n      callOnChange && this.onChange(this.value);\n    }\n    updateInput(maskedValue = '', selection, isFromOnChanges) {\n      if (isFromOnChanges && maskedValue === this.maskedValue) {\n        return;\n      }\n      this.maskedValue = maskedValue;\n      const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n      this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n      if (selection !== undefined) {\n        this.setSelection(selection, selection);\n      }\n    }\n    extractChanges(changes) {\n      return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {\n        obj[key] = changes[key].currentValue;\n        return obj;\n      }, {});\n    }\n    updateService(extra) {\n      const config = Object.assign({\n        includeLiterals: this.includeLiterals,\n        mask: this.mask,\n        prompt: this.prompt,\n        promptPlaceholder: this.promptPlaceholder,\n        rules: this.rules\n      }, extra);\n      this.service.update(config);\n    }\n    setSelection(start = this.selection[0], end = this.selection[1]) {\n      if (this.focused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n    get emptyMask() {\n      return this.service.maskRaw() === this.maskedValue;\n    }\n    setFocusSelection() {\n      const selectionStart = this.input.nativeElement.selectionStart;\n      const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n      if (index >= 0 && index < selectionStart) {\n        this.selection = [index, index];\n        this.setSelection();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get focused() {\n      return this.isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n        if (value) {\n          this.renderer.addClass(element, FOCUSED$3);\n        } else {\n          this.renderer.removeClass(element, FOCUSED$3);\n        }\n        this.isFocused = value;\n      }\n    }\n    normalizeValue(value) {\n      const present = isPresent(value);\n      if (present && typeof value !== 'string') {\n        if (isDevMode()) {\n          throw new Error('The MaskedTextBox component supports only string values.');\n        }\n        return String(value);\n      }\n      return present ? value : '';\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    setInputAttributes() {\n      const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);\n      setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);\n    }\n  }\n  _class29 = MaskedTextBoxComponent;\n  _defineProperty(MaskedTextBoxComponent, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)(i0.ɵɵdirectiveInject(MaskingService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(RTL, 8));\n  });\n  _defineProperty(MaskedTextBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class29,\n    selectors: [[\"kendo-maskedtextbox\"]],\n    contentQueries: function _class29_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function _class29_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function _class29_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"paste\", function _class29_paste_HostBindingHandler($event) {\n          return ctx.pasteHandler($event);\n        })(\"input\", function _class29_input_HostBindingHandler($event) {\n          return ctx.inputHandler($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-input\", ctx.hostClasses)(\"k-maskedtextbox\", ctx.hostClasses)(\"k-disabled\", ctx.hostDisabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      title: \"title\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      mask: \"mask\",\n      value: \"value\",\n      rules: \"rules\",\n      prompt: \"prompt\",\n      promptPlaceholder: \"promptPlaceholder\",\n      includeLiterals: \"includeLiterals\",\n      maskOnFocus: \"maskOnFocus\",\n      maskValidation: \"maskValidation\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoMaskedTextBox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([MaskingService, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class29) /* eslint-disable-line*/\n    }, {\n      multi: true,\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => _class29) /* eslint-disable-line*/\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class29)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 7,\n    vars: 21,\n    consts: [[\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [\"autocomplete\", \"off\", \"autocorrect\", \"off\", \"autocapitalize\", \"off\", \"spellcheck\", \"false\", 1, \"k-input-inner\", 3, \"id\", \"tabindex\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"]],\n    template: function _class29_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class29_Template_ng_container_isFocusedChange_0_listener($event) {\n          return ctx.focused = $event;\n        })(\"handleBlur\", function _class29_Template_ng_container_handleBlur_0_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class29_Template_ng_container_onFocus_0_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(1, _class29_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class29_kendo_input_separator_2_Template, 1, 0, \"kendo-input-separator\", 2);\n        i0.ɵɵelement(3, \"input\", 3, 4);\n        i0.ɵɵtemplate(5, _class29_kendo_input_separator_5_Template, 1, 0, \"kendo-input-separator\", 2);\n        i0.ɵɵtemplate(6, _class29_span_6_Template, 2, 1, \"span\", 5);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.focused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction5(15, _c36, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));\n        i0.ɵɵattribute(\"title\", ctx.title)(\"aria-placeholder\", ctx.mask)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n      }\n    },\n    dependencies: [SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective],\n    encapsulation: 2\n  }));\n  return MaskedTextBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FOCUSED$2 = 'k-focus';\nconst DEFAULT_SIZE$b = 'medium';\n/**\n * @hidden\n */\nlet RadioCheckBoxBase = /*#__PURE__*/(() => {\n  var _class30;\n  class RadioCheckBoxBase {\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Provides a value for the component.\n     */\n\n    /**\n     * The size property specifies the width and height of the component.\n     *\n     * @default 'medium'\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$b;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * Fires each time the user focuses the component.\n     *\n     * > To wire the event programmatically, use the `onFocus` property.\n     */\n\n    /**\n     * Focuses the component.\n     */\n    focus() {\n      if (!this.input) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.input.nativeElement.focus();\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the component.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.ngTouched();\n          this.onBlur.emit();\n        }\n        this.isFocused = false;\n      });\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.control?.control);\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && !this.control.valid;\n    }\n    /**\n     * Represents the visible `input` element.\n     */\n\n    /**\n     * @hidden\n     */\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set isFocused(value) {\n      if (this._isFocused !== value && this.input) {\n        const element = this.input.nativeElement;\n        if (value && !this.disabled) {\n          this.renderer.addClass(element, FOCUSED$2);\n        } else {\n          this.renderer.removeClass(element, FOCUSED$2);\n        }\n        this._isFocused = value;\n      }\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    get defaultAttributes() {\n      return null;\n    }\n    constructor(componentType, hostElement, renderer, cdr, ngZone, injector) {\n      _defineProperty(this, \"componentType\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Sets the `title` attribute of the `input` element of the component.\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Sets the `name` attribute for the component.\n       */\n      _defineProperty(this, \"name\", void 0);\n      /**\n       * Sets the disabled state of the component.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Specifies the `tabindex` of the component.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      _defineProperty(this, \"handleInputBlur\", () => {\n        this.cdr.markForCheck();\n        if (requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n          });\n        }\n      });\n      _defineProperty(this, \"input\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      _defineProperty(this, \"parsedAttributes\", {});\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE$b);\n      this.componentType = componentType;\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.injector = injector;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(_value) {}\n    handleClasses(value, input) {\n      if (!isPresent$1(this.input)) {\n        return;\n      }\n      const inputElem = this.input.nativeElement;\n      const classes = getStylingClasses(this.componentType, input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(inputElem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(inputElem, classes.toAdd);\n      }\n    }\n    setInputAttributes() {\n      setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);\n    }\n  }\n  _class30 = RadioCheckBoxBase;\n  _defineProperty(RadioCheckBoxBase, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)(i0.ɵɵdirectiveInject(COMPONENT_TYPE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n  });\n  _defineProperty(RadioCheckBoxBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class30,\n    selectors: [[\"ng-component\"]],\n    viewQuery: function _class30_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      title: \"title\",\n      name: \"name\",\n      disabled: \"disabled\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      value: \"value\",\n      size: \"size\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function _class30_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return RadioCheckBoxBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_ROUNDED$6 = 'medium';\nlet CheckBoxComponent = /*#__PURE__*/(() => {\n  var _class31;\n  class CheckBoxComponent extends RadioCheckBoxBase {\n    /**\n     * Sets the checked state of the component.\n     *\n     * @default false\n     */\n    set checkedState(value) {\n      this._checkedState = value;\n      if (!isPresent$1(this.input)) {\n        return;\n      }\n      this.input.nativeElement.indeterminate = value === 'indeterminate';\n    }\n    get checkedState() {\n      return this._checkedState;\n    }\n    /**\n     * The rounded property specifies the border radius of the CheckBox\n     * ([see example](slug:appearance_checkboxdirective#toc-roundness)).\n     *\n     * @default 'medium'\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$6;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Fires each time the inner input's checked state is changed.\n     * When the state of the component is programmatically changed to `ngModel` or `formControl`\n     * through its API or form binding, the `checkedStateChange` event is not triggered because it\n     * might cause a mix-up with the built-in mechanisms of the `ngModel` or `formControl` bindings.\n     *\n     * Used to provide a two-way binding for the `checkedState` property.\n     */\n\n    /**\n     * @hidden\n     */\n    get isChecked() {\n      return typeof this.checkedState === 'boolean' && this.checkedState;\n    }\n    /**\n     * @hidden\n     */\n    get isIndeterminate() {\n      return typeof this.checkedState === 'string' && this.checkedState === 'indeterminate';\n    }\n    get defaultAttributes() {\n      return {\n        type: 'checkbox',\n        id: this.focusableId,\n        title: this.title,\n        tabindex: this.tabindex,\n        tabIndex: this.tabindex,\n        disabled: this.disabled ? '' : null,\n        value: this.value,\n        checked: this.isChecked,\n        'aria-invalid': this.isControlInvalid\n      };\n    }\n    constructor(renderer, hostElement, cdr, ngZone, injector) {\n      super('checkbox', hostElement, renderer, cdr, ngZone, injector);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"checkedStateChange\", new EventEmitter());\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED$6);\n      _defineProperty(this, \"_checkedState\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleChange\", $event => {\n        this.ngZone.run(() => {\n          this.checkedState = $event && $event.target && $event.target.checked;\n          this.checkedStateChange.emit(this.checkedState);\n          this.ngChange(this.checkedState);\n        });\n      });\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      validatePackage(packageMetadata);\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.input.nativeElement.indeterminate = this.checkedState === 'indeterminate';\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.checkedState = value;\n    }\n  }\n  _class31 = CheckBoxComponent;\n  _defineProperty(CheckBoxComponent, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n  });\n  _defineProperty(CheckBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class31,\n    selectors: [[\"kendo-checkbox\"]],\n    hostVars: 2,\n    hostBindings: function _class31_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-checkbox-wrap\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      checkedState: \"checkedState\",\n      rounded: \"rounded\"\n    },\n    outputs: {\n      checkedStateChange: \"checkedStateChange\"\n    },\n    exportAs: [\"kendoCheckBox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.checkbox'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class31),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class31)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 22,\n    consts: [[\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"type\", \"checkbox\", 1, \"k-checkbox\", 3, \"id\", \"disabled\", \"value\", \"checked\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"]],\n    template: function _class31_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class31_Template_ng_container_isFocusedChange_0_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class31_Template_ng_container_handleBlur_0_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class31_Template_ng_container_onFocus_0_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵelement(1, \"input\", 1, 2);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabled)(\"k-checked\", ctx.isChecked)(\"k-indeterminate\", ctx.isIndeterminate)(\"k-invalid\", ctx.isControlInvalid);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"disabled\", ctx.disabled)(\"value\", ctx.value)(\"checked\", ctx.isChecked)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(19, _c37, ctx.handleInputBlur, ctx.handleChange));\n        i0.ɵɵattribute(\"title\", ctx.title)(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null);\n      }\n    },\n    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],\n    encapsulation: 2\n  }));\n  return CheckBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SIZE$a = 'medium';\nconst DEFAULT_ROUNDED$5 = 'medium';\n/**\n * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"checkbox\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"checkbox\" kendoCheckBox />\n * ```\n */\nlet CheckBoxDirective = /*#__PURE__*/(() => {\n  var _class32;\n  class CheckBoxDirective {\n    /**\n     * The size property specifies the width and height of the CheckBox\n     * ([see example]({% slug appearance_checkboxdirective %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$a;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the CheckBox\n     * ([see example](slug:appearance_checkboxdirective#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    constructor(renderer, hostElement) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"kendoClass\", true);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('checkbox', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n  }\n  _class32 = CheckBoxDirective;\n  _defineProperty(CheckBoxDirective, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(CheckBoxDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class32,\n    selectors: [[\"input\", \"kendoCheckBox\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class32_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-checkbox\", ctx.kendoClass);\n      }\n    },\n    inputs: {\n      size: \"size\",\n      rounded: \"rounded\"\n    },\n    standalone: true\n  }));\n  return CheckBoxDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * Returns the hex or rgba string representation of the color.\n */\nconst parseColor = (value, format, opacityEnabled = false, safe = true) => {\n  const allowedFormats = ['hex', 'rgba', 'name'];\n  if (allowedFormats.indexOf(format) === -1) {\n    throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);\n  }\n  if (!isPresent(value)) {\n    return;\n  }\n  if (format === 'name') {\n    return nameFormat(value, safe);\n  }\n  const parsedColor = parseColor$1(value.trim(), safe);\n  if (!isPresent(parsedColor)) {\n    return;\n  }\n  const parsedColorResult = format === 'hex' ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();\n  return parsedColorResult;\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\nconst getHSV = (value, safe = true) => {\n  const parsed = parseColor$1(value, safe);\n  if (!isPresent(parsed)) {\n    return {};\n  }\n  return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\nconst getRGBA = (value, safe = true) => {\n  const parsed = parseColor$1(value, safe);\n  if (!isPresent(parsed)) {\n    return {};\n  }\n  return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromHSV = (hsva, format = 'rgba', opacityEnabled = false) => {\n  const hue = fitIntoBounds(hsva.h, 0, 359.9);\n  const saturation = fitIntoBounds(hsva.s, 0, 1);\n  const value = fitIntoBounds(hsva.v, 0, 1);\n  const alpha = fitIntoBounds(hsva.a, 0, 1);\n  const color = Color.fromHSV(hue, saturation, value, alpha);\n  return format === 'hex' ? getHexValue(color, opacityEnabled) : color.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the HEX value.\n */\nconst getHexValue = (color, opacity) => {\n  return opacity && color.a < 1 ? color.toCss({\n    alpha: true\n  }) : color.toCss();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.\n */\nconst getColorFromHue = hue => {\n  return getColorFromHSV({\n    h: hue,\n    s: 1,\n    v: 1,\n    a: 1\n  });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromRGBA = rgba => {\n  const red = fitIntoBounds(rgba.r, 0, 255);\n  const green = fitIntoBounds(rgba.g, 0, 255);\n  const blue = fitIntoBounds(rgba.b, 0, 255);\n  const alpha = fitIntoBounds(rgba.a, 0, 1);\n  return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n/**\n *\n * @hidden\n */\nfunction nameFormat(value, safe) {\n  value = value.toLowerCase().trim();\n  if (isPresent(namedColors[value])) {\n    return value;\n  }\n  if (parseColor$1(value, safe)) {\n    value = parseColor$1(value, safe).toHex();\n  }\n  const key = Object.keys(namedColors).find(key => namedColors[key] === value);\n  if (!key && !safe) {\n    throw new Error(`The provided color ${value} is not supported for 'format=\"name\"' property.To display ${value} color, the component 'format' property should be set to 'hex' or 'rgba' `);\n  }\n  return key;\n}\n/**\n * @hidden\n *\n * Returns the RGB object representation of the color based on the background color.\n */\nconst getRGBFromRGBA = (foregroundColor, backgroundColor) => {\n  const r1 = fitIntoBounds(foregroundColor.r, 0, 255);\n  const g1 = fitIntoBounds(foregroundColor.g, 0, 255);\n  const b1 = fitIntoBounds(foregroundColor.b, 0, 255);\n  const a1 = fitIntoBounds(foregroundColor.a, 0, 1);\n  const r2 = fitIntoBounds(backgroundColor.r, 0, 255);\n  const g2 = fitIntoBounds(backgroundColor.g, 0, 255);\n  const b2 = fitIntoBounds(backgroundColor.b, 0, 255);\n  return {\n    r: Math.round((1 - a1) * r2 + a1 * r1),\n    g: Math.round((1 - a1) * g2 + a1 * g1),\n    b: Math.round((1 - a1) * b2 + a1 * b1)\n  };\n};\n/**\n * @hidden\n *\n * Returns the relative luminance.\n */\nconst getLuminance = rgb => {\n  const a = [rgb.r, rgb.g, rgb.b].map(function (v) {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n};\n/**\n * @hidden\n *\n * Returns the color contrast.\n */\nconst getContrast = (luminance1, luminance2) => {\n  const brightest = Math.max(luminance1, luminance2);\n  const darkest = Math.min(luminance1, luminance2);\n  return (brightest + 0.05) / (darkest + 0.05);\n};\n/**\n * @hidden\n *\n * Returns the color contrast from two RGBA colors.\n */\nconst getContrastFromTwoRGBAs = (a, b) => {\n  return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  })));\n};\n\n/**\n * @hidden\n */\nconst bezierCommand = controlPointCalc => (point, i, a) => {\n  // start control point\n  const [cpsX, cpsY] = controlPointCalc(a[i - 1], a[i - 2], point);\n  // end control point\n  const [cpeX, cpeY] = controlPointCalc(point, a[i - 1], a[i + 1], true);\n  return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point[0]},${point[1]}`;\n};\n/**\n * @hidden\n */\nconst controlPoint = lineCalc => (current, previous, next, reverse) => {\n  // when 'current' is the first or last point of the array\n  // 'previous' and 'next' are undefined\n  // replace with 'current'\n  const p = previous || current;\n  const n = next || current;\n  const smooth = 0.1;\n  // properties of the line between previous and next\n  const l = lineCalc(p, n);\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = l.angle + (reverse ? Math.PI : 0);\n  const length = l.length * smooth;\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[1] + Math.sin(angle) * length;\n  return [x, y];\n};\n/**\n * @hidden\n */\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n */\nconst d = (points, command) => {\n  if (points.length === 0) {\n    return '';\n  }\n  // build the d attributes by looping over the points\n  const d = points.reduce((acc, point, i, a) => i === 0 ?\n  // if first point\n  `M ${point[0]},${point[1]}` :\n  // else\n  `${acc} ${command(point, i, a)}`, '');\n  return d;\n};\n/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nconst svgPath = (points, command) => {\n  if (points.length === 0) {\n    return '';\n  }\n  // build the d attributes by looping over the points\n  const d = points.reduce((acc, point, i, a) => i === 0 ?\n  // if first point\n  `M ${point[0]},${point[1]}` :\n  // else\n  `${acc} ${command(point, i, a)}`, '');\n  return d;\n};\n\n/**\n * @hidden\n */\nlet ColorPickerLocalizationService = /*#__PURE__*/(() => {\n  var _class33;\n  class ColorPickerLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl) {\n      super(prefix, messageService, _rtl);\n    }\n  }\n  _class33 = ColorPickerLocalizationService;\n  _defineProperty(ColorPickerLocalizationService, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8));\n  });\n  _defineProperty(ColorPickerLocalizationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class33,\n    factory: _class33.ɵfac\n  }));\n  return ColorPickerLocalizationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FlatColorPickerLocalizationService = /*#__PURE__*/(() => {\n  var _class34;\n  class FlatColorPickerLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, colorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      _defineProperty(this, \"colorPickerLocalization\", void 0);\n      this.colorPickerLocalization = colorPickerLocalization;\n    }\n    get(shortKey) {\n      if (this.colorPickerLocalization) {\n        return this.colorPickerLocalization.get(shortKey);\n      }\n      return super.get(shortKey);\n    }\n  }\n  _class34 = FlatColorPickerLocalizationService;\n  _defineProperty(FlatColorPickerLocalizationService, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(ColorPickerLocalizationService, 8));\n  });\n  _defineProperty(FlatColorPickerLocalizationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class34,\n    factory: _class34.ɵfac\n  }));\n  return FlatColorPickerLocalizationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColorGradientLocalizationService = /*#__PURE__*/(() => {\n  var _class35;\n  class ColorGradientLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      _defineProperty(this, \"flatColorPickerLocalization\", void 0);\n      this.flatColorPickerLocalization = flatColorPickerLocalization;\n    }\n    get(shortKey) {\n      if (this.flatColorPickerLocalization) {\n        return this.flatColorPickerLocalization.get(shortKey);\n      }\n      return super.get(shortKey);\n    }\n  }\n  _class35 = ColorGradientLocalizationService;\n  _defineProperty(ColorGradientLocalizationService, \"\\u0275fac\", function _class35_Factory(t) {\n    return new (t || _class35)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(FlatColorPickerLocalizationService, 8));\n  });\n  _defineProperty(ColorGradientLocalizationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class35,\n    factory: _class35.ɵfac\n  }));\n  return ColorGradientLocalizationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet NumericLabelDirective = /*#__PURE__*/(() => {\n  var _class36;\n  class NumericLabelDirective {\n    constructor(host) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"kendoAdditionalNumericLabel\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      this.host = host;\n    }\n    ngOnInit() {\n      const localizationToken = `${this.kendoAdditionalNumericLabel}ChannelLabel`;\n      this.host.numericInput.nativeElement.setAttribute('aria-label', this.localizationService.get(localizationToken));\n    }\n  }\n  _class36 = NumericLabelDirective;\n  _defineProperty(NumericLabelDirective, \"\\u0275fac\", function _class36_Factory(t) {\n    return new (t || _class36)(i0.ɵɵdirectiveInject(NumericTextBoxComponent));\n  });\n  _defineProperty(NumericLabelDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class36,\n    selectors: [[\"\", \"kendoAdditionalNumericLabel\", \"\"]],\n    inputs: {\n      kendoAdditionalNumericLabel: \"kendoAdditionalNumericLabel\",\n      localizationService: \"localizationService\"\n    },\n    standalone: true\n  }));\n  return NumericLabelDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n *\n * Checks if input is Japanese IME\n */\nconst isJapanese = input => {\n  const japaneseRegex = /[\\u3000-\\u303F]|[\\u3040-\\u309F]|[\\u30A0-\\u30FF]|[\\uFF00-\\uFFEF]|[\\u4E00-\\u9FAF]|[\\u2605-\\u2606]|[\\u2190-\\u2195]|\\u203B/g;\n  return japaneseRegex.test(input);\n};\n\n/**\n * Specifies the adornments in the suffix container ([see examples](slug:adornments_textbox#toc-suffix-adornments)).\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextBoxSuffixTemplateDirective = /*#__PURE__*/(() => {\n  var _class37;\n  class TextBoxSuffixTemplateDirective {\n    /**\n     * Sets the `showSeparator` attribute of the `kendoTextBoxSuffixTemplate`.\n     *\n     * @default false\n     */\n    set showSeparator(value) {\n      this._showSeparator = value;\n    }\n    get showSeparator() {\n      return this._showSeparator;\n    }\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      _defineProperty(this, \"_showSeparator\", false);\n      this.templateRef = templateRef;\n    }\n  }\n  _class37 = TextBoxSuffixTemplateDirective;\n  _defineProperty(TextBoxSuffixTemplateDirective, \"\\u0275fac\", function _class37_Factory(t) {\n    return new (t || _class37)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(TextBoxSuffixTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class37,\n    selectors: [[\"\", \"kendoTextBoxSuffixTemplate\", \"\"]],\n    inputs: {\n      showSeparator: \"showSeparator\"\n    },\n    standalone: true\n  }));\n  return TextBoxSuffixTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the adornments in the prefix container ([see examples](slug:adornments_textbox#toc-prefix-adornments)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxPrefixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextBoxPrefixTemplateDirective = /*#__PURE__*/(() => {\n  var _class38;\n  class TextBoxPrefixTemplateDirective {\n    /**\n     * Sets the `showSeparator` attribute of the `kendoTextBoxPrefixTemplate`.\n     *\n     * @default false\n     */\n    set showSeparator(value) {\n      this._showSeparator = value;\n    }\n    get showSeparator() {\n      return this._showSeparator;\n    }\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      _defineProperty(this, \"_showSeparator\", false);\n      this.templateRef = templateRef;\n    }\n  }\n  _class38 = TextBoxPrefixTemplateDirective;\n  _defineProperty(TextBoxPrefixTemplateDirective, \"\\u0275fac\", function _class38_Factory(t) {\n    return new (t || _class38)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  });\n  _defineProperty(TextBoxPrefixTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class38,\n    selectors: [[\"\", \"kendoTextBoxPrefixTemplate\", \"\"]],\n    inputs: {\n      showSeparator: \"showSeparator\"\n    },\n    standalone: true\n  }));\n  return TextBoxPrefixTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TextBoxMessages = /*#__PURE__*/(() => {\n  var _class39;\n  class TextBoxMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the **Clear** button of the TextBox.\n       */\n      _defineProperty(this, \"clear\", void 0);\n    }\n  }\n  _class39 = TextBoxMessages;\n  _defineProperty(TextBoxMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class39_BaseFactory;\n    return function _class39_Factory(t) {\n      return (ɵ_class39_BaseFactory || (ɵ_class39_BaseFactory = i0.ɵɵgetInheritedFactory(_class39)))(t || _class39);\n    };\n  }());\n  _defineProperty(TextBoxMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class39,\n    selectors: [[\"kendo-textbox-messages-base\"]],\n    inputs: {\n      clear: \"clear\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return TextBoxMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedTextBoxMessagesDirective = /*#__PURE__*/(() => {\n  var _class40;\n  class LocalizedTextBoxMessagesDirective extends TextBoxMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class40 = LocalizedTextBoxMessagesDirective;\n  _defineProperty(LocalizedTextBoxMessagesDirective, \"\\u0275fac\", function _class40_Factory(t) {\n    return new (t || _class40)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedTextBoxMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class40,\n    selectors: [[\"\", \"kendoTextBoxLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TextBoxMessages,\n      useExisting: forwardRef(() => _class40)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedTextBoxMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst FOCUSED$1 = 'k-focus';\nconst DEFAULT_SIZE$9 = 'medium';\nconst DEFAULT_ROUNDED$4 = 'medium';\nconst DEFAULT_FILL_MODE$4 = 'solid';\nconst iconsMap$1 = {\n  checkIcon,\n  exclamationCircleIcon,\n  xIcon\n};\nlet TextBoxComponent = /*#__PURE__*/(() => {\n  var _class41;\n  class TextBoxComponent {\n    /**\n     * The size property specifies the padding of the TextBox internal input element\n     * ([see example]({% slug appearance_textbox %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$9;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The `rounded` property specifies the border radius of the TextBox\n     * ([see example](slug:appearance_textbox#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The `fillMode` property specifies the background and border styles of the TextBox\n     * ([see example]({% slug appearance_textbox %}#toc-fill-mode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * The hint, which is displayed when the component is empty.\n     */\n\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    /**\n     * Fires each time the value is changed&mdash;\n     * when the component is blurred or the value is cleared through the **Clear** button\n     * ([see example](slug:events_textbox)).\n     * When the value of the component is programmatically changed to `ngModel` or `formControl`\n     * through its API or form binding, the `valueChange` event is not triggered because it\n     * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n     */\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    get defaultAttributes() {\n      return {\n        id: this.focusableId,\n        disabled: this.disabled ? '' : null,\n        readonly: this.readonly ? '' : null,\n        tabindex: this.disabled ? undefined : this.tabindex,\n        type: this.type,\n        placeholder: this.placeholder,\n        title: this.title,\n        maxlength: this.maxlength,\n        'aria-invalid': this.isControlInvalid,\n        required: this.isControlRequired ? '' : null\n      };\n    }\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * Sets the `title` attribute of the `input` element of the TextBox.\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Sets the `type` attribute of the `input` element of the TextBox.\n       */\n      _defineProperty(this, \"type\", 'text');\n      /**\n       * Sets the disabled state of the TextBox. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_textbox#toc-managing-the-textbox-disabled-state-in-reactive-forms).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the component.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the `tabindex` of the TextBox.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      /**\n       * Provides a value for the TextBox.\n       */\n      _defineProperty(this, \"value\", null);\n      /**\n       * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"selectOnFocus\", false);\n      /**\n       * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).\n       *\n       * The possible values are:\n       *\n       * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.\n       *\n       * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"showSuccessIcon\", false);\n      /**\n       * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).\n       *\n       * The possible values are:\n       *\n       * * `initial`&mdash;The Error icon will be displayed when the component state is\n       * `invalid` and `touched` or `dirty`.\n       * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"showErrorIcon\", false);\n      /**\n       * Specifies whether a Clear button will be rendered.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"clearButton\", false);\n      /**\n       * Sets a custom icon that will be rendered instead of the default one for a valid user input.\n       */\n      _defineProperty(this, \"successIcon\", void 0);\n      /**\n       * Sets a custom SVG icon that will be rendered instead of the default one for a valid user input.\n       */\n      _defineProperty(this, \"successSvgIcon\", void 0);\n      /**\n       * Sets a custom icon that will be rendered instead of the default one for invalid user input.\n       */\n      _defineProperty(this, \"errorIcon\", void 0);\n      /**\n       * Sets a custom SVG icon that will be rendered instead of the default one for invalid user input.\n       */\n      _defineProperty(this, \"errorSvgIcon\", void 0);\n      /**\n       * Sets a custom icon that will be rendered instead of the default one.\n       */\n      _defineProperty(this, \"clearButtonIcon\", void 0);\n      /**\n       * Sets a custom SVG icon that will be rendered instead of the default one.\n       */\n      _defineProperty(this, \"clearButtonSvgIcon\", void 0);\n      _defineProperty(this, \"placeholder\", void 0);\n      /**\n       * Specifies the maximum length of the TextBox value.\n       */\n      _defineProperty(this, \"maxlength\", void 0);\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the TextBox component.\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textbox (focus)=\"handleFocus()\"></kendo-textbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log('Component is focused.');\n       *   }\n       * }\n       * ```\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the TextBox component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textbox (blur)=\"handleBlur()\"></kendo-textbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log('Component is blurred');\n       *   }\n       * }\n       * ```\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Represents the visible `input` element of the TextBox.\n       */\n      _defineProperty(this, \"input\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"textBoxSuffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"textBoxPrefixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffixTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefixTemplate\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showClearButton\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"clearButtonClicked\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffix\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefix\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"parsedAttributes\", {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputFocus\", () => {\n        if (!this.disabled) {\n          if (this.selectOnFocus && this.value) {\n            this.ngZone.run(() => {\n              setTimeout(() => {\n                this.selectAll();\n              });\n            });\n          }\n          if (!this.isFocused) {\n            this.handleFocus();\n          }\n          if (hasObservers(this.inputFocus)) {\n            if (!this.focusChangedProgrammatically || this.focusChangedProgrammatically && this.clearButtonClicked) {\n              this.ngZone.run(() => {\n                this.inputFocus.emit();\n              });\n            }\n          }\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputBlur\", () => {\n        this.changeDetector.markForCheck();\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.inputBlur.emit();\n          });\n        }\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInput\", ev => {\n        const target = ev.target;\n        const isBrowserSafari = isSafari(navigator.userAgent);\n        const incomingValue = isBrowserSafari && isJapanese(target.value) ? ev.data : target.value;\n        const [caretStart, caretEnd] = [target.selectionStart, target.selectionEnd];\n        this.updateValue(incomingValue);\n        if (isBrowserSafari) {\n          target.setSelectionRange(caretStart, caretEnd);\n        }\n      });\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n      this.checkClearButton();\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    ngAfterContentInit() {\n      this.configureAdornments();\n      this.subscriptions.add(this.textBoxPrefixTemplate.changes.subscribe(this.configureAdornments.bind(this)));\n      this.subscriptions.add(this.textBoxSuffixTemplate.changes.subscribe(this.configureAdornments.bind(this)));\n    }\n    ngOnChanges(changes) {\n      if (changes['disabled'] || changes['readonly'] || changes['value']) {\n        this.checkClearButton();\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    svgIcon(name) {\n      return iconsMap$1[name];\n    }\n    /**\n     * Focuses the TextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"input.focus()\">Focus the input</button>\n     *  <kendo-textbox #input></kendo-textbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      if (!this.input) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.input.nativeElement.focus();\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextBox.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n    clearTitle() {\n      return this.localizationService.get('clear');\n    }\n    /**\n     * @hidden\n     */\n    checkClearButton() {\n      this.showClearButton = !this.disabled && !this.readonly && this.clearButton && !!this.value;\n    }\n    /**\n     * @hidden\n     */\n    clearValue(ev) {\n      if (ev) {\n        ev.preventDefault();\n      }\n      this.clearButtonClicked = true;\n      this.input.nativeElement.value = '';\n      this.input.nativeElement.focus();\n      this.updateValue('');\n      this.checkClearButton();\n      this.clearButtonClicked = false;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n      this.checkClearButton();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    showErrorsInitial() {\n      if (!this.control) {\n        return false;\n      }\n      const {\n        invalid,\n        dirty,\n        touched\n      } = this.control;\n      return invalid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    showSuccessInitial() {\n      if (!this.control) {\n        return false;\n      }\n      const {\n        valid,\n        dirty,\n        touched\n      } = this.control;\n      return valid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && !this.control.valid;\n    }\n    /**\n     * @hidden\n     */\n    get successIconClasses() {\n      if (!this.successIcon) {\n        return `check`;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get customSuccessIconClasses() {\n      if (this.successIcon) {\n        return this.successIcon;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get errorIconClasses() {\n      if (!this.errorIcon) {\n        return `exclamation-circle`;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get customIconClasses() {\n      if (this.errorIcon) {\n        return this.errorIcon;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get customClearButtonClasses() {\n      if (this.clearButtonIcon) {\n        return this.clearButtonIcon;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get clearButtonClass() {\n      if (!this.clearButtonIcon) {\n        return 'x';\n      }\n    }\n    /**\n     * @hidden\n     */\n    get hasErrors() {\n      return this.showErrorIcon === 'initial' ? this.showErrorsInitial() : this.showErrorIcon;\n    }\n    /**\n     * @hidden\n     */\n    get isSuccessful() {\n      return this.showSuccessIcon === 'initial' ? this.showSuccessInitial() : this.showSuccessIcon;\n    }\n    /**\n     * @hidden\n     */\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set isFocused(value) {\n      if (this._isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n        if (value && !this.disabled) {\n          this.renderer.addClass(element, FOCUSED$1);\n        } else {\n          this.renderer.removeClass(element, FOCUSED$1);\n        }\n        this._isFocused = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.control?.control);\n    }\n    setSelection(start, end) {\n      if (this.isFocused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n    selectAll() {\n      if (this.value) {\n        this.setSelection(0, this.value.length);\n      }\n    }\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.checkClearButton();\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.onBlur.emit();\n        }\n        this.isFocused = false;\n      });\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    configureAdornments() {\n      this.prefix = this.textBoxPrefixTemplate.first || this.prefixTemplate;\n      this.suffix = this.textBoxSuffixTemplate.first || this.suffixTemplate;\n    }\n    setInputAttributes() {\n      setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);\n    }\n  }\n  _class41 = TextBoxComponent;\n  _defineProperty(TextBoxComponent, \"\\u0275fac\", function _class41_Factory(t) {\n    return new (t || _class41)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(TextBoxComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class41,\n    selectors: [[\"kendo-textbox\"]],\n    contentQueries: function _class41_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textBoxSuffixTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textBoxPrefixTemplate = _t);\n      }\n    },\n    viewQuery: function _class41_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function _class41_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-disabled\", ctx.disabledClass)(\"k-textbox\", ctx.hostClasses)(\"k-input\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      title: \"title\",\n      type: \"type\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      value: \"value\",\n      selectOnFocus: \"selectOnFocus\",\n      showSuccessIcon: \"showSuccessIcon\",\n      showErrorIcon: \"showErrorIcon\",\n      clearButton: \"clearButton\",\n      successIcon: \"successIcon\",\n      successSvgIcon: \"successSvgIcon\",\n      errorIcon: \"errorIcon\",\n      errorSvgIcon: \"errorSvgIcon\",\n      clearButtonIcon: \"clearButtonIcon\",\n      clearButtonSvgIcon: \"clearButtonSvgIcon\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      tabIndex: \"tabIndex\",\n      placeholder: \"placeholder\",\n      maxlength: \"maxlength\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoTextBox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.textbox'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class41),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class41)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 12,\n    vars: 26,\n    consts: function () {\n      let i18n_38;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Clear** button in the TextBox.\n         * @meaning kendo.textbox.clear\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39 = goog.getMsg(\"Clear\");\n        i18n_38 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39;\n      } else {\n        i18n_38 = $localize`:kendo.textbox.clear|The title for the **Clear** button in the TextBox.:Clear`;\n      }\n      return [[\"kendoTextBoxLocalizedMessages\", \"\", \"clear\", i18n_38], [\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"clearButtonClicked\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"class\", \"k-input-prefix k-input-prefix-horizontal\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-input-inner\", 3, \"id\", \"disabled\", \"readonly\", \"value\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"], [\"role\", \"button\", \"class\", \"k-clear-value\", 3, \"tabindex\", \"title\", \"click\", \"mousedown\", \"keydown.enter\", \"keydown.space\", 4, \"ngIf\"], [\"innerCssClass\", \"k-input-validation-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-input-suffix k-input-suffix-horizontal\", 4, \"ngIf\"], [1, \"k-input-prefix\", \"k-input-prefix-horizontal\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", 1, \"k-clear-value\", 3, \"tabindex\", \"title\", \"click\", \"mousedown\", \"keydown.enter\", \"keydown.space\"], [3, \"name\", \"customFontClass\", \"svgIcon\"], [\"innerCssClass\", \"k-input-validation-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [1, \"k-input-suffix\", \"k-input-suffix-horizontal\"]];\n    },\n    template: function _class41_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementContainerStart(1, 1);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class41_Template_ng_container_isFocusedChange_1_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class41_Template_ng_container_handleBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class41_Template_ng_container_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(2, _class41_span_2_Template, 2, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, _class41_kendo_input_separator_3_Template, 1, 0, \"kendo-input-separator\", 3);\n        i0.ɵɵelement(4, \"input\", 4, 5);\n        i0.ɵɵtemplate(6, _class41_span_6_Template, 2, 6, \"span\", 6);\n        i0.ɵɵtemplate(7, _class41_kendo_icon_wrapper_7_Template, 1, 3, \"kendo-icon-wrapper\", 7);\n        i0.ɵɵtemplate(8, _class41_kendo_icon_wrapper_8_Template, 1, 3, \"kendo-icon-wrapper\", 7);\n        i0.ɵɵtemplate(9, _class41_kendo_input_separator_9_Template, 1, 0, \"kendo-input-separator\", 3);\n        i0.ɵɵtemplate(10, _class41_span_10_Template, 2, 1, \"span\", 8);\n        i0.ɵɵelementContainer(11);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused)(\"clearButtonClicked\", ctx.clearButtonClicked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefix);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefix && ctx.prefix.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"value\", ctx.value)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(22, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"type\", ctx.type)(\"placeholder\", ctx.placeholder)(\"title\", ctx.title)(\"maxlength\", ctx.maxlength)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showClearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasErrors);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isSuccessful);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffix && ctx.suffix.showSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffix);\n      }\n    },\n    dependencies: [LocalizedTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return TextBoxComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TextLabelDirective = /*#__PURE__*/(() => {\n  var _class42;\n  class TextLabelDirective {\n    constructor(textBox, renderer) {\n      _defineProperty(this, \"textBox\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"focusableId\", void 0);\n      this.textBox = textBox;\n      this.renderer = renderer;\n    }\n    ngOnInit() {\n      this.renderer.setAttribute(this.textBox.input.nativeElement, 'id', this.focusableId);\n    }\n  }\n  _class42 = TextLabelDirective;\n  _defineProperty(TextLabelDirective, \"\\u0275fac\", function _class42_Factory(t) {\n    return new (t || _class42)(i0.ɵɵdirectiveInject(TextBoxComponent), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(TextLabelDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class42,\n    selectors: [[\"\", \"kendoTextLabel\", \"\"]],\n    inputs: {\n      focusableId: \"focusableId\"\n    },\n    standalone: true\n  }));\n  return TextLabelDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst DEFAULT_SIZE$8 = 'medium';\n/**\n * @hidden\n */\nlet ColorInputComponent = /*#__PURE__*/(() => {\n  var _class43;\n  class ColorInputComponent {\n    /**\n     * Indicates whether any of the inputs are focused.\n     */\n    get isFocused() {\n      if (!(isDocumentAvailable() && isPresent(this.host))) {\n        return false;\n      }\n      const activeElement = document.activeElement;\n      return this.host.nativeElement.contains(activeElement);\n    }\n    /**\n     * Indicates whether any of the rgba inputs have value.\n     */\n    get rgbaInputValid() {\n      return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(host, renderer, cdr, localizationService) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      /**\n       * The id of the hex input.\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      /**\n       * The color format view.\n       */\n      _defineProperty(this, \"formatView\", void 0);\n      /**\n       * The size property specifies the padding of the ColorInput.\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `none`\n       */\n      _defineProperty(this, \"size\", DEFAULT_SIZE$8);\n      /**\n       * The inputs tabindex.\n       */\n      _defineProperty(this, \"tabindex\", -1);\n      /**\n       * The color value that will be parsed and populate the hex & rgba inputs.\n       * Required input property.\n       */\n      _defineProperty(this, \"value\", void 0);\n      /**\n       * Sets whether the alpha slider will be shown.\n       */\n      _defineProperty(this, \"opacity\", true);\n      /**\n       * Sets the disabled state of the ColorInput.\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the ColorInput.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Emits a parsed rgba string color.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Emits when the user tabs out of the last focusable input.\n       */\n      _defineProperty(this, \"tabOut\", new EventEmitter());\n      _defineProperty(this, \"colorInputClass\", true);\n      _defineProperty(this, \"opacityInput\", void 0);\n      _defineProperty(this, \"hexInput\", void 0);\n      _defineProperty(this, \"blueInput\", void 0);\n      _defineProperty(this, \"toggleFormatButton\", void 0);\n      /**\n       * The rgba inputs values.\n       */\n      _defineProperty(this, \"rgba\", {});\n      /*\n       * The hex input value.\n       */\n      _defineProperty(this, \"hex\", void 0);\n      _defineProperty(this, \"caretAltExpandIcon\", caretAltExpandIcon);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.host = host;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.localizationService = localizationService;\n    }\n    ngAfterViewInit() {\n      this.initDomEvents();\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes['value']) && !this.isFocused) {\n        this.hex = parseColor(this.value, 'hex', this.opacity);\n        this.rgba = getRGBA(this.value);\n        this.rgba.a = parseColor(this.value, 'rgba', this.opacity) ? this.rgba.a : 1;\n      }\n    }\n    get formatButtonTitle() {\n      return this.localizationService.get('formatButton');\n    }\n    handleRgbaValueChange() {\n      const color = getColorFromRGBA(this.rgba);\n      if (!this.rgbaInputValid || color === this.value) {\n        return;\n      }\n      this.value = color;\n      this.rgba = getRGBA(this.value);\n      this.hex = parseColor(color, 'hex', this.opacity);\n      this.valueChange.emit(color);\n    }\n    focusDragHandle(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      this.tabOut.emit();\n    }\n    handleHexValueChange(hex) {\n      this.hex = hex;\n      const color = parseColor(hex, 'rgba', this.opacity);\n      if (!isPresent(color) || color === this.value) {\n        return;\n      }\n      this.value = color;\n      this.rgba = getRGBA(color);\n      this.valueChange.emit(color);\n    }\n    handleRgbaInputBlur() {\n      if (!this.rgbaInputValid) {\n        this.rgba = getRGBA(this.value);\n      }\n    }\n    handleHexInputBlur() {\n      this.hex = parseColor(this.value, 'hex', this.opacity);\n    }\n    focusLast() {\n      this.lastInput().focus();\n    }\n    onTab() {\n      if (this.opacity) {\n        return;\n      }\n    }\n    toggleFormatView() {\n      this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';\n      // needed to update the view when ChangeDetectionStrategy.OnPush\n      this.cdr.markForCheck();\n    }\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n      this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));\n    }\n    lastInput() {\n      return this.hexInput?.nativeElement || this.opacityInput || this.blueInput;\n    }\n  }\n  _class43 = ColorInputComponent;\n  _defineProperty(ColorInputComponent, \"\\u0275fac\", function _class43_Factory(t) {\n    return new (t || _class43)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ColorInputComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class43,\n    selectors: [[\"kendo-colorinput\"]],\n    viewQuery: function _class43_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c41, 5);\n        i0.ɵɵviewQuery(_c42, 5);\n        i0.ɵɵviewQuery(_c43, 5);\n        i0.ɵɵviewQuery(_c44, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.opacityInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hexInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.blueInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleFormatButton = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class43_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-colorgradient-inputs\", ctx.colorInputClass)(\"k-hstack\", ctx.colorInputClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      formatView: \"formatView\",\n      size: \"size\",\n      tabindex: \"tabindex\",\n      value: \"value\",\n      opacity: \"opacity\",\n      disabled: \"disabled\",\n      readonly: \"readonly\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      tabOut: \"tabOut\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 5,\n    vars: 8,\n    consts: [[1, \"k-vstack\"], [\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", \"icon\", \"caret-alt-expand\", 1, \"k-colorgradient-toggle-mode\", 3, \"svgIcon\", \"size\", \"disabled\", \"tabindex\"], [\"toggleFormatButton\", \"\"], [\"class\", \"k-vstack k-flex-1\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-vstack\", \"k-flex-1\"], [\"kendoTextLabel\", \"\", 1, \"k-hex-value\", 3, \"focusableId\", \"size\", \"disabled\", \"readonly\", \"value\", \"tabindex\", \"blur\", \"input\", \"keydown.tab\"], [\"hexInput\", \"\"], [1, \"k-colorgradient-input-label\", 3, \"for\"], [\"kendoAdditionalNumericLabel\", \"red\", 3, \"localizationService\", \"disabled\", \"size\", \"readonly\", \"tabindex\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"format\", \"decimals\", \"valueChange\", \"blur\"], [\"red\", \"\"], [\"kendoAdditionalNumericLabel\", \"green\", 3, \"localizationService\", \"disabled\", \"readonly\", \"tabindex\", \"size\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"format\", \"decimals\", \"valueChange\", \"blur\"], [\"green\", \"\"], [\"kendoAdditionalNumericLabel\", \"blue\", 3, \"localizationService\", \"disabled\", \"readonly\", \"tabindex\", \"size\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"format\", \"decimals\", \"valueChange\", \"blur\", \"keydown.tab\"], [\"blue\", \"\"], [\"class\", \"k-vstack\", 4, \"ngIf\"], [\"kendoAdditionalNumericLabel\", \"alpha\", 3, \"localizationService\", \"disabled\", \"readonly\", \"tabindex\", \"size\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"step\", \"format\", \"decimals\", \"valueChange\", \"blur\", \"keydown.tab\"], [\"opacityInput\", \"\", \"alpha\", \"\"]],\n    template: function _class43_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"button\", 1, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class43_div_3_Template, 5, 9, \"div\", 3);\n        i0.ɵɵtemplate(4, _class43_ng_container_4_Template, 17, 40, \"ng-container\", 4);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"svgIcon\", ctx.caretAltExpandIcon)(\"size\", ctx.size)(\"disabled\", ctx.disabled)(\"tabindex\", ctx.tabindex.toString());\n        i0.ɵɵattribute(\"aria-label\", ctx.formatButtonTitle)(\"title\", ctx.formatButtonTitle);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.formatView === \"hex\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.formatView === \"rgba\");\n      }\n    },\n    dependencies: [ButtonComponent, NgIf, NumericTextBoxComponent, NumericLabelDirective, TextBoxComponent, TextLabelDirective],\n    encapsulation: 2\n  }));\n  return ColorInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst DEFAULT_OUTPUT_FORMAT = 'rgba';\n/**\n * @hidden\n */\nconst DEFAULT_GRADIENT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';\n/**\n * @hidden\n */\nconst DRAGHANDLE_MOVE_SPEED = 5;\n/**\n * @hidden\n */\nconst DRAGHANDLE_MOVE_SPEED_SMALL_STEP = 2;\n/**\n * @hidden\n */\nconst AAA_RATIO = 7.0;\n/**\n * @hidden\n */\nconst AA_RATIO = 4.5;\n/**\n * @hidden\n */\nconst DEFAULT_PRESET$1 = 'office';\n/**\n * @hidden\n */\nconst DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';\n/**\n * @hidden\n */\nconst STEP_COUNT = 16;\n\n/**\n * @hidden\n */\nlet ContrastValidationComponent = /*#__PURE__*/(() => {\n  var _class44;\n  class ContrastValidationComponent {\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"type\", void 0);\n      _defineProperty(this, \"pass\", void 0);\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"checkIcon\", checkIcon);\n      _defineProperty(this, \"xCircleIcon\", xCircleIcon);\n      this.localization = localization;\n    }\n    get passMessage() {\n      return this.localization.get('passContrast');\n    }\n    get failMessage() {\n      return this.localization.get('failContrast');\n    }\n    get contrastText() {\n      const ratio = this.type === 'AA' ? AA_RATIO : AAA_RATIO;\n      return `${this.type}: ${ratio.toFixed(1)}`;\n    }\n  }\n  _class44 = ContrastValidationComponent;\n  _defineProperty(ContrastValidationComponent, \"\\u0275fac\", function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ContrastValidationComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class44,\n    selectors: [[\"\", \"kendoContrastValidation\", \"\"]],\n    inputs: {\n      type: \"type\",\n      pass: \"pass\",\n      value: \"value\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c45,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-success\", 4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-error\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-success\"], [\"name\", \"check\", 3, \"svgIcon\"], [1, \"k-contrast-validation\", \"k-text-error\"], [\"name\", \"x\", 3, \"svgIcon\"]],\n    template: function _class44_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\");\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, _class44_ng_container_2_Template, 3, 2, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.contrastText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.value);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return ContrastValidationComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ContrastComponent = /*#__PURE__*/(() => {\n  var _class45;\n  class ContrastComponent {\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"ratio\", void 0);\n      _defineProperty(this, \"checkIcon\", checkIcon);\n      _defineProperty(this, \"xCircleIcon\", xCircleIcon);\n      this.localization = localization;\n    }\n    get formatedRatio() {\n      return this.contrastRatio.toFixed(2);\n    }\n    get contrastRatioText() {\n      return `${this.localization.get('contrastRatio')}: ${this.value ? this.formatedRatio : 'n/a'}`;\n    }\n    get satisfiesAACondition() {\n      return this.contrastRatio >= AA_RATIO;\n    }\n    get satisfiesAAACondition() {\n      return this.contrastRatio >= AAA_RATIO;\n    }\n    get contrastRatio() {\n      const contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));\n      return contrast;\n    }\n  }\n  _class45 = ContrastComponent;\n  _defineProperty(ContrastComponent, \"\\u0275fac\", function _class45_Factory(t) {\n    return new (t || _class45)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ContrastComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class45,\n    selectors: [[\"\", \"kendoContrastTool\", \"\"]],\n    inputs: {\n      value: \"value\",\n      ratio: \"ratio\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c46,\n    decls: 6,\n    vars: 6,\n    consts: [[1, \"k-contrast-ratio\"], [1, \"k-contrast-ratio-text\"], [4, \"ngIf\"], [\"kendoContrastValidation\", \"\", \"type\", \"AA\", 3, \"value\", \"pass\"], [\"kendoContrastValidation\", \"\", \"type\", \"AAA\", 3, \"value\", \"pass\"], [\"class\", \"k-contrast-validation k-text-success\", 4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-error\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-success\"], [\"name\", \"check\", 3, \"svgIcon\"], [\"name\", \"check\", 3, \"svgIcon\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-error\"], [\"name\", \"x\", 3, \"svgIcon\"]],\n    template: function _class45_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"span\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, _class45_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(4, \"div\", 3)(5, \"div\", 4);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.contrastRatioText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"pass\", ctx.satisfiesAACondition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"pass\", ctx.satisfiesAAACondition);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, ContrastValidationComponent],\n    encapsulation: 2\n  }));\n  return ContrastComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColorContrastSvgComponent = /*#__PURE__*/(() => {\n  var _class46;\n  class ColorContrastSvgComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"hsva\", void 0);\n      _defineProperty(this, \"backgroundColor\", void 0);\n      _defineProperty(this, \"paths\", void 0);\n      _defineProperty(this, \"oldHsva\", void 0);\n      _defineProperty(this, \"oldH\", void 0);\n      _defineProperty(this, \"oldA\", void 0);\n      _defineProperty(this, \"metrics\", void 0);\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.metrics = this.wrapper.getBoundingClientRect();\n      this.oldA = this.hsva.value.a;\n      this.oldH = this.hsva.value.h;\n      this.hsva.subscribe(value => {\n        if (value.h !== this.oldH || value.a !== this.oldA) {\n          this.oldH = value.h;\n          this.oldA = value.a;\n          this.setPaths();\n        }\n      });\n    }\n    ngOnChanges(changes) {\n      if (isPresent(changes['backgroundColor']) && this.metrics) {\n        this.setPaths();\n      }\n    }\n    setPaths() {\n      const bezierCommandCalc = bezierCommand(controlPoint(line));\n      this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];\n    }\n    findValue(contrast, saturation, low, high, comparer) {\n      const mid = (low + high) / 2;\n      const hsva = {\n        ...this.hsva.value,\n        s: saturation / this.metrics.width,\n        v: 1 - mid / this.metrics.height\n      };\n      const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ''));\n      if (low + 0.5 > high) {\n        if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {\n          return mid;\n        } else {\n          return null;\n        }\n      }\n      if (comparer(currentContrast, contrast)) {\n        return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);\n      }\n      return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);\n    }\n    getPaths(contrast, stepCount, reversed = false) {\n      const points = [];\n      for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {\n        const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? (a, b) => a < b : (a, b) => a > b);\n        if (value !== null) {\n          points.push([i, value]);\n        }\n      }\n      return points;\n    }\n  }\n  _class46 = ColorContrastSvgComponent;\n  _defineProperty(ColorContrastSvgComponent, \"\\u0275fac\", function _class46_Factory(t) {\n    return new (t || _class46)();\n  });\n  _defineProperty(ColorContrastSvgComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class46,\n    selectors: [[\"\", \"kendoColorContrastSvg\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class46_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-color-contrast-svg\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      wrapper: \"wrapper\",\n      hsva: \"hsva\",\n      backgroundColor: \"backgroundColor\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c47,\n    decls: 1,\n    vars: 1,\n    consts: [[\"fill\", \"none\", \"stroke\", \"white\", \"stroke-width\", \"1\", 4, \"ngFor\", \"ngForOf\"], [\"fill\", \"none\", \"stroke\", \"white\", \"stroke-width\", \"1\"]],\n    template: function _class46_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class46__svg_path_0_Template, 1, 1, \"path\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.paths);\n      }\n    },\n    dependencies: [NgFor],\n    encapsulation: 2\n  }));\n  return ColorContrastSvgComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColorPickerMessages = /*#__PURE__*/(() => {\n  var _class47;\n  class ColorPickerMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The aria-label applied to the ColorPalette component when the value is empty.\n       */\n      _defineProperty(this, \"colorPaletteNoColor\", void 0);\n      /**\n       * The aria-label applied to the ColorGradient component when the value is empty.\n       */\n      _defineProperty(this, \"colorGradientNoColor\", void 0);\n      /**\n       * The aria-label applied to the FlatColorPicker component when the value is empty.\n       */\n      _defineProperty(this, \"flatColorPickerNoColor\", void 0);\n      /**\n       * The aria-label applied to the ColorPicker component when the value is empty.\n       */\n      _defineProperty(this, \"colorPickerNoColor\", void 0);\n      /**\n       * The title for the gradient color drag handle chooser.\n       */\n      _defineProperty(this, \"colorGradientHandle\", void 0);\n      /**\n       * The title for the clear button.\n       */\n      _defineProperty(this, \"clearButton\", void 0);\n      /**\n       * The title for the hue slider handle.\n       */\n      _defineProperty(this, \"hueSliderHandle\", void 0);\n      /**\n       * The title for the opacity slider handle.\n       */\n      _defineProperty(this, \"opacitySliderHandle\", void 0);\n      /**\n       * The placeholder for the HEX color input.\n       */\n      _defineProperty(this, \"hexInputPlaceholder\", void 0);\n      /**\n       * The placeholder for the red color input.\n       */\n      _defineProperty(this, \"redInputPlaceholder\", void 0);\n      /**\n       * The placeholder for the green color input.\n       */\n      _defineProperty(this, \"greenInputPlaceholder\", void 0);\n      /**\n       * The placeholder for the blue color input.\n       */\n      _defineProperty(this, \"blueInputPlaceholder\", void 0);\n      /**\n       * The placeholder for the alpha input.\n       */\n      _defineProperty(this, \"alphaInputPlaceholder\", void 0);\n      /**\n       * The aria-label attribute of the red color input.\n       */\n      _defineProperty(this, \"redChannelLabel\", void 0);\n      /**\n       * The aria-label attribute of the green color input.\n       */\n      _defineProperty(this, \"greenChannelLabel\", void 0);\n      /**\n       * The aria-label attribute of the blue color input.\n       */\n      _defineProperty(this, \"blueChannelLabel\", void 0);\n      /**\n       * The aria-label attribute of the alpha color input.\n       */\n      _defineProperty(this, \"alphaChannelLabel\", void 0);\n      /**\n       * The \"Pass\" message for the contrast tool.\n       */\n      _defineProperty(this, \"passContrast\", void 0);\n      /**\n       * The \"Fail\" message for the contrast tool.\n       */\n      _defineProperty(this, \"failContrast\", void 0);\n      /**\n       * The \"Contrast ratio\" message for the contrast tool.\n       */\n      _defineProperty(this, \"contrastRatio\", void 0);\n      /**\n       * The message for the color preview pane.\n       */\n      _defineProperty(this, \"previewColor\", void 0);\n      /**\n       * The message for the selected color pane.\n       */\n      _defineProperty(this, \"revertSelection\", void 0);\n      /**\n       * The message for the gradient view button.\n       */\n      _defineProperty(this, \"gradientView\", void 0);\n      /**\n       * The message for the palette view button.\n       */\n      _defineProperty(this, \"paletteView\", void 0);\n      /**\n       * The message for the input format toggle button.\n       */\n      _defineProperty(this, \"formatButton\", void 0);\n      /**\n       * The message for the Apply action button.\n       */\n      _defineProperty(this, \"applyButton\", void 0);\n      /**\n       * The message for the Cancel action button.\n       */\n      _defineProperty(this, \"cancelButton\", void 0);\n      /**\n       * The title for the Close button in adaptive mode.\n       */\n      _defineProperty(this, \"closeButton\", void 0);\n      /**\n       * The title for the ActionSheet when in adaptive mode.\n       */\n      _defineProperty(this, \"adaptiveTitle\", void 0);\n    }\n  }\n  _class47 = ColorPickerMessages;\n  _defineProperty(ColorPickerMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class47_BaseFactory;\n    return function _class47_Factory(t) {\n      return (ɵ_class47_BaseFactory || (ɵ_class47_BaseFactory = i0.ɵɵgetInheritedFactory(_class47)))(t || _class47);\n    };\n  }());\n  _defineProperty(ColorPickerMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class47,\n    selectors: [[\"kendo-colorpicker-messages-base\"]],\n    inputs: {\n      colorPaletteNoColor: \"colorPaletteNoColor\",\n      colorGradientNoColor: \"colorGradientNoColor\",\n      flatColorPickerNoColor: \"flatColorPickerNoColor\",\n      colorPickerNoColor: \"colorPickerNoColor\",\n      colorGradientHandle: \"colorGradientHandle\",\n      clearButton: \"clearButton\",\n      hueSliderHandle: \"hueSliderHandle\",\n      opacitySliderHandle: \"opacitySliderHandle\",\n      hexInputPlaceholder: \"hexInputPlaceholder\",\n      redInputPlaceholder: \"redInputPlaceholder\",\n      greenInputPlaceholder: \"greenInputPlaceholder\",\n      blueInputPlaceholder: \"blueInputPlaceholder\",\n      alphaInputPlaceholder: \"alphaInputPlaceholder\",\n      redChannelLabel: \"redChannelLabel\",\n      greenChannelLabel: \"greenChannelLabel\",\n      blueChannelLabel: \"blueChannelLabel\",\n      alphaChannelLabel: \"alphaChannelLabel\",\n      passContrast: \"passContrast\",\n      failContrast: \"failContrast\",\n      contrastRatio: \"contrastRatio\",\n      previewColor: \"previewColor\",\n      revertSelection: \"revertSelection\",\n      gradientView: \"gradientView\",\n      paletteView: \"paletteView\",\n      formatButton: \"formatButton\",\n      applyButton: \"applyButton\",\n      cancelButton: \"cancelButton\",\n      closeButton: \"closeButton\",\n      adaptiveTitle: \"adaptiveTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return ColorPickerMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedColorPickerMessagesDirective = /*#__PURE__*/(() => {\n  var _class48;\n  class LocalizedColorPickerMessagesDirective extends ColorPickerMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class48 = LocalizedColorPickerMessagesDirective;\n  _defineProperty(LocalizedColorPickerMessagesDirective, \"\\u0275fac\", function _class48_Factory(t) {\n    return new (t || _class48)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedColorPickerMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class48,\n    selectors: [[\"\", \"kendoColorPickerLocalizedMessages\", \"\"], [\"\", \"kendoFlatColorPickerLocalizedMessages\", \"\"], [\"\", \"kendoColorGradientLocalizedMessages\", \"\"], [\"\", \"kendoColorPaletteLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColorPickerMessages,\n      useExisting: forwardRef(() => _class48)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedColorPickerMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nlet serial$3 = 0;\nconst DEFAULT_SIZE$7 = 'medium';\n/**\n * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.\n * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nlet ColorGradientComponent = /*#__PURE__*/(() => {\n  var _class49;\n  class ColorGradientComponent {\n    get readonlyAttribute() {\n      return this.readonly;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get gradientId() {\n      return this.id;\n    }\n    get hostTabindex() {\n      return this.tabindex?.toString() || '0';\n    }\n    get isControlInvalid() {\n      return this.control?.invalid?.toString();\n    }\n    get isDisabled() {\n      return this.disabled?.toString() || undefined;\n    }\n    /**\n     * @hidden\n     */\n    enterHandler(event) {\n      if (event.target !== this.host.nativeElement) {\n        return;\n      }\n      this.internalNavigation = true;\n      this.gradientDragHandle.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    escapeHandler(event) {\n      if (!this.host.nativeElement.matches(':focus')) {\n        event.stopImmediatePropagation();\n      }\n      this.internalNavigation = false;\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    focusHandler(ev) {\n      this.internalNavigation = ev.target !== this.host.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * The size property specifies the padding of the ColorGradient internal elements.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size || DEFAULT_SIZE$7;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the disabled state of the ColorGradient. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorgradient#toc-managing-the-colorgradient-disabled-state-in-reactive-forms).\n     *\n     * @default false\n     */\n\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n      this._value = parseColor(value, this.format, this.opacity);\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Enables the color contrast tool. Accepts the background color that will be compared to the selected value.\n     * The tool will calculate the contrast ratio between the two colors.\n     */\n    set contrastTool(value) {\n      this._contrastTool = parseColor(value, this.format, this.opacity);\n    }\n    get contrastTool() {\n      return this._contrastTool;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n    set tabindex(value) {\n      if (isPresent(value)) {\n        const tabindex = Number(value);\n        this._tabindex = !isNaN(tabindex) ? tabindex : 0;\n      } else {\n        // Allows removal of the tabindex attribute\n        this._tabindex = value;\n      }\n    }\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Specifies the output format of the ColorGradientComponent.\n     * The input value may be in a different format, but it will be parsed into the output `format`\n     * after the component processes it.\n     *\n     * The supported values are:\n     * * (Default) `rgba`\n     * * `hex`\n     */\n\n    /**\n     * Indicates whether the ColorGradient or any of its content is focused.\n     */\n    get isFocused() {\n      if (!(isDocumentAvailable() && isPresent(this.host))) {\n        return false;\n      }\n      return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);\n    }\n    /**\n     * @hidden\n     */\n    get alphaSliderValue() {\n      // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run\n      if (!(isPresent(this.hsva.value) && isPresent(this.hsva.value.a))) {\n        return;\n      }\n      return this.hsva.value.a * 100;\n    }\n    /**\n     * Determines the step (in pixels) when moving the gradient drag handle using the keyboard arrow keys.\n     *\n     * @default 5\n     */\n\n    get gradientRect() {\n      return this.gradientWrapper.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * @hidden\n     */\n    get hsvSliderValueText() {\n      return `X: ${this.hsvHandleCoordinates.x} Y: ${this.hsvHandleCoordinates.y}`;\n    }\n    /**\n     * @hidden\n     */\n    get contrastToolVisible() {\n      return this.contrastTool && this.contrastTool.length > 0;\n    }\n    /**\n     * @hidden\n     */\n    get innerTabIndex() {\n      return this.internalNavigation ? 0 : -1;\n    }\n    constructor(host, ngZone, renderer, cdr, localizationService, injector) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"ariaRole\", 'textbox');\n      _defineProperty(this, \"adaptiveMode\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"id\", `k-colorgradient-${serial$3++}`);\n      /**\n       * Defines whether the alpha slider will be displayed.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"opacity\", true);\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the ColorGradient.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies whether the ColorGradient should display a 'Clear color' button.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"clearButton\", false);\n      /**\n       * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.\n       *\n       * @default 0\n       */\n      _defineProperty(this, \"delay\", 0);\n      _defineProperty(this, \"format\", DEFAULT_OUTPUT_FORMAT);\n      /**\n       * Fires each time the user selects a new color.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"backgroundColor\", DEFAULT_GRADIENT_BACKGROUND_COLOR);\n      /**\n       * @hidden\n       *\n       * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.\n       * The values are initially set in `ngOnInit` or in `ngOnChanges` and are\n       * updated on moving the drag handle or the sliders.\n       */\n      _defineProperty(this, \"hsva\", new BehaviorSubject({}));\n      _defineProperty(this, \"gradientSliderStep\", DRAGHANDLE_MOVE_SPEED);\n      /**\n       * Determines the step (in pixels) when moving the gradient drag handle using the keyboard arrow keys while holding the shift key.\n       *\n       * @default 2\n       */\n      _defineProperty(this, \"gradientSliderSmallStep\", DRAGHANDLE_MOVE_SPEED_SMALL_STEP);\n      _defineProperty(this, \"gradientDragHandle\", void 0);\n      _defineProperty(this, \"inputs\", void 0);\n      _defineProperty(this, \"alphaSlider\", void 0);\n      _defineProperty(this, \"gradientWrapper\", void 0);\n      _defineProperty(this, \"hsvRectangle\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"internalNavigation\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dropletSlashIcon\", dropletSlashIcon);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"_contrastTool\", void 0);\n      _defineProperty(this, \"listeners\", []);\n      _defineProperty(this, \"hueSliderTouched\", false);\n      _defineProperty(this, \"alphaSliderTouched\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"updateValues\", new Subject());\n      _defineProperty(this, \"changeRequestsSubscription\", void 0);\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"hsvHandleCoordinates\", {\n        x: 0,\n        y: 0\n      });\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"notifyNgChanged\", () => {});\n      _defineProperty(this, \"notifyNgTouched\", () => {});\n      this.host = host;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.localizationService = localizationService;\n      this.injector = injector;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this.updateUI();\n        this.cdr.detectChanges();\n      });\n      this.addEventListeners();\n      this.subscribeChanges();\n    }\n    ngOnChanges(changes) {\n      if (isChanged('value', changes) && !this.isFocused) {\n        this.updateUI();\n      }\n      if (isChanged('delay', changes)) {\n        this.unsubscribeChanges();\n        this.subscribeChanges();\n      }\n    }\n    ngOnDestroy() {\n      this.listeners.forEach(removeListener => removeListener());\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n      this.unsubscribeChanges();\n    }\n    /**\n     * Focuses the component.\n     */\n    focus() {\n      if (this.disabled) {\n        return;\n      }\n      this.gradientDragHandle.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n      this.handleValueChange(undefined);\n      this.updateUI();\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n      if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {\n        return;\n      }\n      this.focus();\n      args.originalEvent.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n      this.changePosition(args);\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n    }\n    /**\n     * @hidden\n     */\n    onKeyboardAction(args) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      if (args.key && args.key.indexOf('Arrow') !== -1) {\n        args.preventDefault();\n        const dragHandleElement = this.gradientDragHandle.nativeElement;\n        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        let keyboardMoveX = 0;\n        let keyboardMoveY = 0;\n        const shiftKey = args.shiftKey;\n        switch (args.key) {\n          case 'ArrowRight':\n            keyboardMoveX = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;\n            break;\n          case 'ArrowLeft':\n            keyboardMoveX = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;\n            break;\n          case 'ArrowUp':\n            keyboardMoveY = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;\n            break;\n          case 'ArrowDown':\n            keyboardMoveY = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;\n            break;\n          default:\n            break;\n        }\n        const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;\n        const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;\n        this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);\n        this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);\n        this.ngZone.run(() => this.moveDragHandle(newX, newY));\n      }\n    }\n    /**\n     * @hidden\n     */\n    changePosition(position) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      this.gradientDragHandle.nativeElement.focus();\n      const gradientRect = this.gradientRect;\n      const newX = position.clientX - gradientRect.left;\n      const newY = position.clientY - gradientRect.top;\n      this.ngZone.run(() => this.moveDragHandle(newX, newY));\n    }\n    /**\n     * @hidden\n     */\n    handleHueSliderChange(hue) {\n      const hsva = this.hsva.value;\n      hsva.h = hue;\n      this.hsva.next(hsva);\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.backgroundColor = getColorFromHue(hue);\n      this.setBackgroundColor(this.backgroundColor);\n      this.setAlphaSliderBackground(this.backgroundColor);\n      this.hueSliderTouched = true;\n    }\n    /**\n     * @hidden\n     */\n    handleAlphaSliderChange(alpha) {\n      const hsva = this.hsva.value;\n      hsva.a = alpha / 100;\n      this.hsva.next(hsva);\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.alphaSliderTouched = true;\n    }\n    /**\n     * @hidden\n     */\n    handleInputsValueChange(color) {\n      const parsed = parseColor(color, this.format, this.opacity);\n      if (this.value !== parsed) {\n        this.handleValueChange(parsed);\n        this.updateUI();\n      }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n      if (isPresent(this.gradientWrapper)) {\n        this.updateUI();\n      }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get colorGradientHandleTitle() {\n      return this.localizationService.get('colorGradientHandle');\n    }\n    /**\n     * @hidden\n     */\n    get colorGradientHandleAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.opacity);\n      return `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`;\n    }\n    /**\n     * @hidden\n     */\n    get hueSliderTitle() {\n      return this.localizationService.get('hueSliderHandle');\n    }\n    /**\n     * @hidden\n     */\n    get opacitySliderTitle() {\n      return this.localizationService.get('opacitySliderHandle');\n    }\n    /**\n     * @hidden\n     */\n    get clearButtonTitle() {\n      return this.localizationService.get('clearButton');\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    moveDragHandle(positionX, positionY) {\n      const gradientRect = this.gradientRect;\n      const gradientRectWidth = gradientRect.width;\n      const gradientRectHeight = gradientRect.height;\n      const top = fitIntoBounds(positionY, 0, gradientRectHeight);\n      const left = fitIntoBounds(positionX, 0, gradientRectWidth);\n      this.setDragHandleElementPosition(top, left);\n      const hsva = this.hsva.value;\n      hsva.s = left / gradientRectWidth;\n      hsva.v = 1 - top / gradientRectHeight;\n      this.hsva.next(hsva);\n      this.updateValues.next(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.setAlphaSliderBackground(getColorFromHSV({\n        ...this.hsva.value,\n        a: 1\n      }, this.format, this.opacity));\n    }\n    handleValueChange(color) {\n      if (this.value === color) {\n        return;\n      }\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n    setDragHandleElementPosition(top, left) {\n      const dragHandle = this.gradientDragHandle.nativeElement;\n      this.hsvHandleCoordinates = {\n        x: left,\n        y: top\n      };\n      this.renderer.setStyle(dragHandle, 'top', `${top}px`);\n      this.renderer.setStyle(dragHandle, 'left', `${left}px`);\n    }\n    setAlphaSliderBackground(backgroundColor) {\n      if (!isPresent(this.alphaSlider)) {\n        return;\n      }\n      const sliderTrack = this.alphaSlider.track.nativeElement;\n      this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to ${this.adaptiveMode ? 'right' : 'top'}, transparent, ${backgroundColor})`);\n    }\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.opacity);\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);\n    }\n    setBackgroundColor(color) {\n      this.renderer.setStyle(this.hsvRectangle.nativeElement, 'background', color);\n    }\n    updateUI() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      if (this.hueSliderTouched || this.alphaSliderTouched) {\n        this.hueSliderTouched = false;\n        this.alphaSliderTouched = false;\n        return;\n      }\n      this.hsva.next(this.value ? getHSV(this.value) : {\n        h: 0,\n        s: 0,\n        v: 1,\n        a: 1\n      });\n      const gradientRect = this.gradientRect;\n      const top = (1 - this.hsva.value.v) * gradientRect.height;\n      const left = this.hsva.value.s * gradientRect.width;\n      this.setDragHandleElementPosition(top, left);\n      this.backgroundColor = getColorFromHue(this.hsva.value.h);\n      this.setBackgroundColor(this.backgroundColor);\n      this.setAlphaSliderBackground(this.backgroundColor);\n      this.setHostElementAriaLabel();\n    }\n    addEventListeners() {\n      this.ngZone.runOutsideAngular(() => {\n        const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', event => {\n          if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {\n            this.ngZone.run(() => this.notifyNgTouched());\n          }\n        });\n        const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', event => {\n          this.onKeyboardAction(event);\n        });\n        const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {\n          this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n          if (!this.readonly && !this.disabled) {\n            this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity)));\n          }\n        });\n        const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {\n          this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-focus');\n        });\n        const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {\n          this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-focus');\n        });\n        this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);\n      });\n    }\n    subscribeChanges() {\n      this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {\n        this.handleValueChange(value);\n      });\n    }\n    unsubscribeChanges() {\n      if (this.changeRequestsSubscription) {\n        this.changeRequestsSubscription.unsubscribe();\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.host.nativeElement;\n      const classes = getStylingClasses('colorgradient', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n  }\n  _class49 = ColorGradientComponent;\n  _defineProperty(ColorGradientComponent, \"\\u0275fac\", function _class49_Factory(t) {\n    return new (t || _class49)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector));\n  });\n  _defineProperty(ColorGradientComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class49,\n    selectors: [[\"kendo-colorgradient\"]],\n    viewQuery: function _class49_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c48, 5);\n        i0.ɵɵviewQuery(_c49, 5);\n        i0.ɵɵviewQuery(_c50, 5);\n        i0.ɵɵviewQuery(_c51, 5);\n        i0.ɵɵviewQuery(_c52, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientDragHandle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputs = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hsvRectangle = _t.first);\n      }\n    },\n    hostVars: 13,\n    hostBindings: function _class49_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.enter\", function _class49_keydown_enter_HostBindingHandler($event) {\n          return ctx.enterHandler($event);\n        })(\"keydown.escape\", function _class49_keydown_escape_HostBindingHandler($event) {\n          return ctx.escapeHandler($event);\n        })(\"focusin\", function _class49_focusin_HostBindingHandler($event) {\n          return ctx.focusHandler($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-readonly\", ctx.readonlyAttribute)(\"id\", ctx.gradientId)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabindex)(\"role\", ctx.ariaRole)(\"aria-invalid\", ctx.isControlInvalid)(\"aria-disabled\", ctx.isDisabled);\n        i0.ɵɵclassProp(\"k-colorgradient\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass)(\"k-readonly\", ctx.readonly);\n      }\n    },\n    inputs: {\n      adaptiveMode: \"adaptiveMode\",\n      id: \"id\",\n      opacity: \"opacity\",\n      size: \"size\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      clearButton: \"clearButton\",\n      delay: \"delay\",\n      value: \"value\",\n      contrastTool: \"contrastTool\",\n      tabindex: \"tabindex\",\n      format: \"format\",\n      gradientSliderStep: \"gradientSliderStep\",\n      gradientSliderSmallStep: \"gradientSliderSmallStep\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoColorGradient\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class49)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class49)\n    }, ColorGradientLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorGradientLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorgradient'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 16,\n    vars: 46,\n    consts: function () {\n      let i18n_53;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.colorgradient.colorGradientNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_53 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54;\n      } else {\n        i18n_53 = $localize`:kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n      let i18n_55;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.colorgradient.colorGradientHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56 = goog.getMsg(\"Choose color\");\n        i18n_55 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56;\n      } else {\n        i18n_55 = $localize`:kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n      let i18n_57;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.colorgradient.clearButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58 = goog.getMsg(\"Clear value\");\n        i18n_57 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58;\n      } else {\n        i18n_57 = $localize`:kendo.colorgradient.clearButton|The title for the clear button.:Clear value`;\n      }\n      let i18n_59;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.colorgradient.hueSliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60 = goog.getMsg(\"Set hue\");\n        i18n_59 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60;\n      } else {\n        i18n_59 = $localize`:kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n      let i18n_61;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.colorgradient.opacitySliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62 = goog.getMsg(\"Set opacity\");\n        i18n_61 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62;\n      } else {\n        i18n_61 = $localize`:kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n      let i18n_63;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The pass message for the contrast tool.\n         * @meaning kendo.colorgradient.passContrast\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64 = goog.getMsg(\"Pass\");\n        i18n_63 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64;\n      } else {\n        i18n_63 = $localize`:kendo.colorgradient.passContrast|The pass message for the contrast tool.:Pass`;\n      }\n      let i18n_65;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The fail message for the contrast tool.\n         * @meaning kendo.colorgradient.failContrast\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66 = goog.getMsg(\"Fail\");\n        i18n_65 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66;\n      } else {\n        i18n_65 = $localize`:kendo.colorgradient.failContrast|The fail message for the contrast tool.:Fail`;\n      }\n      let i18n_67;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.colorgradient.contrastRatio\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68 = goog.getMsg(\"Contrast ratio\");\n        i18n_67 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68;\n      } else {\n        i18n_67 = $localize`:kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n      let i18n_69;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.colorgradient.formatButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70 = goog.getMsg(\"Change color format\");\n        i18n_69 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70;\n      } else {\n        i18n_69 = $localize`:kendo.colorgradient.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n      let i18n_71;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.colorgradient.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72 = goog.getMsg(\"Red channel\");\n        i18n_71 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72;\n      } else {\n        i18n_71 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;\n      }\n      let i18n_73;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the green color channel.\n         * @meaning kendo.colorgradient.greenChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74 = goog.getMsg(\"Green channel\");\n        i18n_73 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74;\n      } else {\n        i18n_73 = $localize`:kendo.colorgradient.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;\n      }\n      let i18n_75;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the blue color channel.\n         * @meaning kendo.colorgradient.blueChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76 = goog.getMsg(\"Blue channel\");\n        i18n_75 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76;\n      } else {\n        i18n_75 = $localize`:kendo.colorgradient.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;\n      }\n      let i18n_77;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the alpha color channel.\n         * @meaning kendo.colorgradient.alphaChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78 = goog.getMsg(\"Alpha channel\");\n        i18n_77 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78;\n      } else {\n        i18n_77 = $localize`:kendo.colorgradient.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;\n      }\n      let i18n_79;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.colorgradient.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80 = goog.getMsg(\"R\");\n        i18n_79 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80;\n      } else {\n        i18n_79 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;\n      }\n      let i18n_81;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the green color input.\n         * @meaning kendo.colorgradient.greenInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_82 = goog.getMsg(\"G\");\n        i18n_81 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_82;\n      } else {\n        i18n_81 = $localize`:kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input.:G`;\n      }\n      let i18n_83;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the blue color input.\n         * @meaning kendo.colorgradient.blueInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_84 = goog.getMsg(\"B\");\n        i18n_83 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_84;\n      } else {\n        i18n_83 = $localize`:kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input.:B`;\n      }\n      let i18n_85;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the HEX color input.\n         * @meaning kendo.colorgradient.hexInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_86 = goog.getMsg(\"HEX\");\n        i18n_85 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_86;\n      } else {\n        i18n_85 = $localize`:kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;\n      }\n      return [[\"kendoColorGradientLocalizedMessages\", \"\", \"colorGradientNoColor\", i18n_53, \"colorGradientHandle\", i18n_55, \"clearButton\", i18n_57, \"hueSliderHandle\", i18n_59, \"opacitySliderHandle\", i18n_61, \"passContrast\", i18n_63, \"failContrast\", i18n_65, \"contrastRatio\", i18n_67, \"formatButton\", i18n_69, \"redChannelLabel\", i18n_71, \"greenChannelLabel\", i18n_73, \"blueChannelLabel\", i18n_75, \"alphaChannelLabel\", i18n_77, \"redChannelLabel\", i18n_79, \"greenInputPlaceholder\", i18n_81, \"blueInputPlaceholder\", i18n_83, \"hexInputPlaceholder\", i18n_85], [3, \"ngClass\"], [1, \"k-hsv-rectangle\"], [\"hsvRectangle\", \"\"], [\"kendoDraggable\", \"\", 1, \"k-hsv-gradient\", 3, \"click\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"gradientWrapper\", \"\"], [\"role\", \"slider\", 1, \"k-hsv-draghandle\", \"k-draghandle\", 3, \"tabindex\", \"keydown.shift.tab\"], [\"gradientDragHandle\", \"\"], [\"kendoColorContrastSvg\", \"\", \"class\", \"k-color-contrast-svg\", \"xmlns\", \"http://www.w3.org/2000/svg\", 3, \"wrapper\", \"hsva\", \"backgroundColor\", \"style\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"class\", \"k-clear-color\", \"fillMode\", \"flat\", \"icon\", \"droplet-slash\", 3, \"svgIcon\", \"size\", \"tabindex\", \"style\", \"click\", \"keydown.enter\", \"keydown.space\", 4, \"ngIf\"], [\"tickPlacement\", \"none\", 1, \"k-hue-slider\", \"k-colorgradient-slider\", 3, \"ngClass\", \"dragHandleTitle\", \"tabindex\", \"disabled\", \"readonly\", \"showButtons\", \"vertical\", \"min\", \"max\", \"value\", \"smallStep\", \"largeStep\", \"valueChange\"], [\"class\", \"k-alpha-slider k-colorgradient-slider\", \"tickPlacement\", \"none\", 3, \"tabindex\", \"ngClass\", \"height\", \"dragHandleTitle\", \"disabled\", \"readonly\", \"showButtons\", \"vertical\", \"min\", \"max\", \"smallStep\", \"largeStep\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"tabindex\", \"opacity\", \"size\", \"formatView\", \"value\", \"disabled\", \"readonly\", \"valueChange\", \"tabOut\"], [\"inputs\", \"\"], [\"class\", \"k-colorgradient-color-contrast k-vbox\", \"kendoContrastTool\", \"\", 3, \"value\", \"ratio\", 4, \"ngIf\"], [\"kendoColorContrastSvg\", \"\", \"xmlns\", \"http://www.w3.org/2000/svg\", 1, \"k-color-contrast-svg\", 3, \"wrapper\", \"hsva\", \"backgroundColor\"], [\"kendoButton\", \"\", \"fillMode\", \"flat\", \"icon\", \"droplet-slash\", 1, \"k-clear-color\", 3, \"svgIcon\", \"size\", \"tabindex\", \"click\", \"keydown.enter\", \"keydown.space\"], [\"tickPlacement\", \"none\", 1, \"k-alpha-slider\", \"k-colorgradient-slider\", 3, \"tabindex\", \"ngClass\", \"dragHandleTitle\", \"disabled\", \"readonly\", \"showButtons\", \"vertical\", \"min\", \"max\", \"smallStep\", \"largeStep\", \"value\", \"valueChange\"], [\"alphaSlider\", \"\"], [\"kendoContrastTool\", \"\", 1, \"k-colorgradient-color-contrast\", \"k-vbox\", 3, \"value\", \"ratio\"]];\n    },\n    template: function _class49_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r15 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2, 3)(4, \"div\", 4, 5);\n        i0.ɵɵlistener(\"click\", function _class49_Template_div_click_4_listener($event) {\n          return ctx.changePosition($event);\n        })(\"kendoPress\", function _class49_Template_div_kendoPress_4_listener($event) {\n          return ctx.handleDragPress($event);\n        })(\"kendoDrag\", function _class49_Template_div_kendoDrag_4_listener($event) {\n          return ctx.onHandleDrag($event);\n        })(\"kendoRelease\", function _class49_Template_div_kendoRelease_4_listener() {\n          return ctx.onHandleRelease();\n        });\n        i0.ɵɵelementStart(6, \"div\", 6, 7);\n        i0.ɵɵlistener(\"keydown.shift.tab\", function _class49_Template_div_keydown_shift_tab_6_listener($event) {\n          i0.ɵɵrestoreView(_r15);\n          const _r6 = i0.ɵɵreference(14);\n          $event.preventDefault();\n          return i0.ɵɵresetView(_r6.focusLast());\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(8, _class49__svg_svg_8_Template, 1, 5, \"svg\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"div\", 1);\n        i0.ɵɵtemplate(10, _class49_button_10_Template, 1, 7, \"button\", 9);\n        i0.ɵɵelementStart(11, \"kendo-slider\", 10);\n        i0.ɵɵlistener(\"valueChange\", function _class49_Template_kendo_slider_valueChange_11_listener($event) {\n          return ctx.handleHueSliderChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, _class49_kendo_slider_12_Template, 2, 16, \"kendo-slider\", 11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(13, \"kendo-colorinput\", 12, 13);\n        i0.ɵɵlistener(\"valueChange\", function _class49_Template_kendo_colorinput_valueChange_13_listener($event) {\n          return ctx.handleInputsValueChange($event);\n        })(\"tabOut\", function _class49_Template_kendo_colorinput_tabOut_13_listener() {\n          i0.ɵɵrestoreView(_r15);\n          const _r2 = i0.ɵɵreference(7);\n          return i0.ɵɵresetView(_r2.focus());\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(15, _class49_div_15_Template, 1, 2, \"div\", 14);\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(5);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(37, _c88, ctx.adaptiveMode, !ctx.adaptiveMode));\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"touch-action\", \"none\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"tabindex\", ctx.innerTabIndex.toString());\n        i0.ɵɵattribute(\"title\", ctx.colorGradientHandleTitle)(\"aria-label\", ctx.colorGradientHandleTitle + \" \" + ctx.colorGradientHandleAriaLabel)(\"aria-valuetext\", ctx.hsvSliderValueText)(\"aria-readonly\", ctx.readonly ? ctx.readonly : undefined)(\"aria-disabled\", ctx.disabled ? ctx.disabled : undefined)(\"aria-orientation\", \"undefined\")(\"aria-valuenow\", \"0\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.contrastToolVisible && _r1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction3(40, _c89, ctx.clearButton, ctx.adaptiveMode, !ctx.adaptiveMode));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.clearButton ? \"140\" : null, \"px\");\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(44, _c87, ctx.clearButton))(\"dragHandleTitle\", ctx.hueSliderTitle)(\"tabindex\", ctx.innerTabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"showButtons\", false)(\"vertical\", !ctx.adaptiveMode)(\"min\", 0)(\"max\", 360)(\"value\", ctx.hsva.value.h)(\"smallStep\", 5)(\"largeStep\", 10);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.opacity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"tabindex\", ctx.innerTabIndex)(\"opacity\", ctx.opacity)(\"size\", ctx.size)(\"formatView\", ctx.format)(\"value\", ctx.value)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.contrastToolVisible);\n      }\n    },\n    dependencies: [LocalizedColorPickerMessagesDirective, DraggableDirective, NgIf, ColorContrastSvgComponent, ButtonComponent, SliderComponent, NgClass, ColorInputComponent, ContrastComponent],\n    encapsulation: 2\n  }));\n  return ColorGradientComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ColorPaletteLocalizationService = /*#__PURE__*/(() => {\n  var _class50;\n  class ColorPaletteLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      _defineProperty(this, \"flatColorPickerLocalization\", void 0);\n      this.flatColorPickerLocalization = flatColorPickerLocalization;\n    }\n    get(shortKey) {\n      if (this.flatColorPickerLocalization) {\n        return this.flatColorPickerLocalization.get(shortKey);\n      }\n      return super.get(shortKey);\n    }\n  }\n  _class50 = ColorPaletteLocalizationService;\n  _defineProperty(ColorPaletteLocalizationService, \"\\u0275fac\", function _class50_Factory(t) {\n    return new (t || _class50)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(FlatColorPickerLocalizationService, 8));\n  });\n  _defineProperty(ColorPaletteLocalizationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class50,\n    factory: _class50.ɵfac\n  }));\n  return ColorPaletteLocalizationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable max-line-length\n/**\n * @hidden\n */\nconst PALETTEPRESETS = {\n  basic: {\n    colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',\n    columns: 10\n  },\n  office: {\n    colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',\n    columns: 10\n  },\n  apex: {\n    colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',\n    columns: 10\n  },\n  austin: {\n    colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',\n    columns: 10\n  },\n  clarity: {\n    colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',\n    columns: 10\n  },\n  slipstream: {\n    colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',\n    columns: 10\n  },\n  metro: {\n    colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',\n    columns: 10\n  },\n  flow: {\n    colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',\n    columns: 10\n  },\n  hardcover: {\n    colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',\n    columns: 10\n  },\n  trek: {\n    colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',\n    columns: 10\n  },\n  verve: {\n    colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',\n    columns: 10\n  },\n  monochrome: {\n    colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',\n    columns: 12\n  },\n  accessible: {\n    colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',\n    columns: 10\n  }\n};\n\n/**\n * @hidden\n */\nlet ColorPaletteService = /*#__PURE__*/(() => {\n  var _class51;\n  class ColorPaletteService {\n    constructor() {\n      _defineProperty(this, \"colorRows\", []);\n    }\n    setColorMatrix(palette, columns) {\n      this.colorRows = [];\n      if (!(isPresent(palette) && palette.length)) {\n        return;\n      }\n      columns = columns || palette.length;\n      for (let start = 0; start < palette.length; start += columns) {\n        const row = palette.slice(start, columns + start);\n        this.colorRows.push(row);\n      }\n    }\n    getCellCoordsFor(color) {\n      if (!isPresent(color)) {\n        return;\n      }\n      for (let row = 0; row < this.colorRows.length; row++) {\n        for (let col = 0; col < this.colorRows[row].length; col++) {\n          if (this.colorRows[row][col] === color) {\n            return {\n              row,\n              col\n            };\n          }\n        }\n      }\n    }\n    getColorAt(cellCoords) {\n      if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n        return;\n      }\n      return this.colorRows[cellCoords.row][cellCoords.col];\n    }\n    getNextCell(current, horizontalStep, verticalStep) {\n      if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n        return {\n          row: 0,\n          col: 0\n        };\n      }\n      const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n      const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n      return {\n        row,\n        col\n      };\n    }\n    clampIndex(index, max) {\n      const minArrayIndex = 0;\n      if (index < minArrayIndex) {\n        return minArrayIndex;\n      }\n      if (index > max) {\n        return max;\n      }\n      return index;\n    }\n  }\n  _class51 = ColorPaletteService;\n  _defineProperty(ColorPaletteService, \"\\u0275fac\", function _class51_Factory(t) {\n    return new (t || _class51)();\n  });\n  _defineProperty(ColorPaletteService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class51,\n    factory: _class51.ɵfac\n  }));\n  return ColorPaletteService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst DEFAULT_COLUMNS_COUNT = 10;\nconst DEFAULT_PRESET = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET = 'accessible';\nconst DEFAULT_SIZE$6 = 'medium';\nlet serial$2 = 0;\n/**\n * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.\n * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nlet ColorPaletteComponent = /*#__PURE__*/(() => {\n  var _class52;\n  class ColorPaletteComponent {\n    /**\n     * @hidden\n     */\n    get activeDescendant() {\n      return this.activeCellId;\n    }\n    /**\n     * @hidden\n     */\n    get paletteId() {\n      return this.id;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n      this._value = parseColor(value, this.format);\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the number of columns that will be displayed.\n     * Defaults to `10`.\n     */\n    set columns(value) {\n      const minColumnsCount = 1;\n      this._columns = value > minColumnsCount ? value : minColumnsCount;\n    }\n    get columns() {\n      return this._columns;\n    }\n    /**\n     * The color palette that will be displayed.\n     *\n     * The supported values are:\n     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).\n     * * A string with comma-separated colors.\n     * * A string array.\n     */\n    set palette(value) {\n      if (!isPresent(value)) {\n        value = DEFAULT_PRESET;\n      }\n      if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {\n        this.columns = this.columns || PALETTEPRESETS[value].columns;\n        value = PALETTEPRESETS[value].colors;\n      }\n      const colors = typeof value === 'string' ? value.split(',') : value;\n      this._palette = colors.map(color => parseColor(color, this.format, false, false));\n    }\n    get palette() {\n      return this._palette;\n    }\n    /**\n     * The size property specifies the padding of the ColorPalette internal elements.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size || DEFAULT_SIZE$6;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Sets the disabled state of the ColorPalette. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorpalette#toc-managing-the-colorpalette-disabled-state-in-reactive-forms).\n     */\n\n    /**\n     * @hidden\n     */\n    get tileLayout() {\n      if (typeof this.tileSize !== 'number') {\n        return this.tileSize;\n      }\n      return {\n        width: this.tileSize,\n        height: this.tileSize\n      };\n    }\n    /**\n     * Fires each time the color selection is changed.\n     */\n\n    /**\n     * @hidden\n     */\n    get colorRows() {\n      return this.service.colorRows;\n    }\n    /**\n     * @hidden\n     */\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    get readonlyAttribute() {\n      return this.readonly;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(host, service, cdr, renderer, localizationService, ngZone) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"role\", 'grid');\n      _defineProperty(this, \"id\", `k-colorpalette-${serial$2++}`);\n      /**\n       * Specifies the output format of the ColorPaletteComponent.\n       * The input value may be in a different format. However, it will be parsed into the output `format`\n       * after the component processes it.\n       *\n       * The supported values are:\n       * * (Default) `hex`\n       * * `rgba`\n       * * `name`\n       */\n      _defineProperty(this, \"format\", 'hex');\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the ColorPalette.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the size of a color cell. The default tile size depends on the `size` of the component.\n       */\n      _defineProperty(this, \"tileSize\", void 0);\n      _defineProperty(this, \"selectionChange\", new EventEmitter());\n      /**\n       * Fires each time the value is changed.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user selects a cell with the mouse or presses `Enter`.\n       *\n       * @hidden\n       */\n      _defineProperty(this, \"cellSelection\", new EventEmitter());\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"activeCellId\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusedCell\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"selectedCell\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusInComponent\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"uniqueId\", guid());\n      _defineProperty(this, \"selection\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_columns\", void 0);\n      _defineProperty(this, \"_palette\", void 0);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"subs\", new Subscription());\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"notifyNgTouched\", () => {});\n      _defineProperty(this, \"notifyNgChanged\", () => {});\n      this.host = host;\n      this.service = service;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnInit() {\n      if (this.colorRows.length === 0) {\n        const defaultPreset = this.format !== 'name' ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;\n        this.palette = this.palette || defaultPreset;\n        this.setRows();\n      }\n      const elem = this.host.nativeElement;\n      this.subs.add(this.renderer.listen(elem, 'keydown', event => this.handleKeydown(event)));\n      this.subs.add(this.renderer.listen(elem, 'focus', () => this.handleFocus()));\n      this.subs.add(this.renderer.listen(elem, 'blur', () => this.handleHostBlur()));\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.setHostElementAriaLabel();\n      if (this.value) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          this.selectCell(this.value);\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes['palette'] || changes['columns']) {\n        this.setRows();\n      }\n      if (changes['palette'] || changes['value'] || changes['columns']) {\n        this.selectCell(this.value);\n        this.setHostElementAriaLabel();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n      const isRTL = this.direction === 'rtl';\n      switch (event.keyCode) {\n        case Keys.ArrowDown:\n          this.handleCellNavigation(0, 1);\n          break;\n        case Keys.ArrowUp:\n          this.handleCellNavigation(0, -1);\n          break;\n        case Keys.ArrowRight:\n          this.handleCellNavigation(isRTL ? -1 : 1, 0);\n          break;\n        case Keys.ArrowLeft:\n          this.handleCellNavigation(isRTL ? 1 : -1, 0);\n          break;\n        case Keys.Enter:\n          this.handleEnter();\n          break;\n        default:\n          return;\n      }\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      if (!this.focusInComponent) {\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleHostBlur() {\n      this.notifyNgTouched();\n      this.handleCellFocusOnBlur();\n    }\n    /**\n     * @hidden\n     */\n    handleCellSelection(value, focusedCell) {\n      if (this.readonly) {\n        return;\n      }\n      this.selectedCell = focusedCell;\n      this.focusedCell = this.selectedCell;\n      this.focusInComponent = true;\n      const parsedColor = parseColor(value, this.format, false, false);\n      this.cellSelection.emit(parsedColor);\n      this.handleValueChange(parsedColor);\n      if (this.selection !== parsedColor) {\n        this.selection = parsedColor;\n        this.selectionChange.emit(parsedColor);\n      }\n      if (focusedCell) {\n        this.activeCellId = `k-${this.selectedCell.row}-${this.selectedCell.col}-${this.uniqueId}`;\n      }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n      this.selectCell(value);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    focus() {\n      this.host.nativeElement.focus();\n      if (!this.focusedCell && !this.readonly && !this.disabled) {\n        this.focusedCell = {\n          row: 0,\n          col: 0\n        };\n        this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;\n      }\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    /**\n     * Clears the color value of the ColorPalette.\n     */\n    reset() {\n      this.focusedCell = null;\n      if (isPresent(this.value)) {\n        this.handleValueChange(undefined);\n      }\n      this.selectedCell = undefined;\n    }\n    handleValueChange(color) {\n      if (this.value === color) {\n        return;\n      }\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n    handleCellFocusOnBlur() {\n      this.focusInComponent = false;\n      this.focusedCell = this.selectedCell;\n    }\n    selectCell(value) {\n      const parsedColor = parseColor(value, 'hex');\n      this.selectedCell = this.service.getCellCoordsFor(parsedColor);\n      this.focusedCell = this.selectedCell;\n    }\n    setRows() {\n      if (!isPresent(this.palette)) {\n        return;\n      }\n      this.columns = this.columns || DEFAULT_COLUMNS_COUNT;\n      this.service.setColorMatrix(this.palette, this.columns);\n    }\n    handleCellNavigation(horizontalStep, verticalStep) {\n      if (this.readonly) {\n        return;\n      }\n      this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);\n      this.focusInComponent = true;\n      if (this.focusedCell) {\n        this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;\n      }\n    }\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format);\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);\n    }\n    handleEnter() {\n      if (!isPresent(this.focusedCell)) {\n        return;\n      }\n      const selectedColor = this.service.getColorAt(this.focusedCell);\n      this.handleCellSelection(selectedColor, this.focusedCell);\n    }\n    handleClasses(value, input) {\n      const elem = this.host.nativeElement;\n      const classes = getStylingClasses('colorpalette', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n  }\n  _class52 = ColorPaletteComponent;\n  _defineProperty(ColorPaletteComponent, \"\\u0275fac\", function _class52_Factory(t) {\n    return new (t || _class52)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColorPaletteService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(ColorPaletteComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class52,\n    selectors: [[\"kendo-colorpalette\"]],\n    hostVars: 13,\n    hostBindings: function _class52_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"role\", ctx.role)(\"aria-activedescendant\", ctx.activeDescendant)(\"id\", ctx.paletteId)(\"tabindex\", ctx.hostTabindex)(\"aria-disabled\", ctx.disabledClass)(\"aria-readonly\", ctx.readonlyAttribute);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-colorpalette\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      format: \"format\",\n      value: \"value\",\n      columns: \"columns\",\n      palette: \"palette\",\n      size: \"size\",\n      tabindex: \"tabindex\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tileSize: \"tileSize\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\",\n      valueChange: \"valueChange\",\n      cellSelection: \"cellSelection\"\n    },\n    exportAs: [\"kendoColorPalette\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class52)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class52)\n    }, ColorPaletteService, ColorPaletteLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorPaletteLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorpalette'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 4,\n    vars: 1,\n    consts: function () {\n      let i18n_90;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.colorpalette.colorPaletteNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_91 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_90 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_91;\n      } else {\n        i18n_90 = $localize`:kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n      return [[\"kendoColorPaletteLocalizedMessages\", \"\", \"colorPaletteNoColor\", i18n_90], [\"role\", \"presentation\", 1, \"k-colorpalette-table\"], [\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"row\"], [\"role\", \"gridcell\", \"class\", \"k-colorpalette-tile\", 3, \"k-selected\", \"k-focus\", \"id\", \"ngStyle\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"gridcell\", 1, \"k-colorpalette-tile\", 3, \"id\", \"ngStyle\", \"click\"]];\n    },\n    template: function _class52_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"table\", 1)(2, \"tbody\");\n        i0.ɵɵtemplate(3, _class52_tr_3_Template, 2, 1, \"tr\", 2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.colorRows);\n      }\n    },\n    dependencies: [LocalizedColorPickerMessagesDirective, NgFor, NgStyle],\n    encapsulation: 2\n  }));\n  return ColorPaletteComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FlatColorPickerService = /*#__PURE__*/(() => {\n  var _class53;\n  class FlatColorPickerService {\n    getPaletteSettings(settings, format) {\n      const defaultPreset = format !== 'name' ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n      const settingsPalette = settings.palette;\n      const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : undefined;\n      return {\n        palette: settingsPalette || defaultPreset,\n        tileSize: settings.tileSize,\n        columns: settings.columns || presetColumns || 10\n      };\n    }\n    paletteTileLayout(tileSize) {\n      if (typeof tileSize === 'number') {\n        return {\n          width: tileSize,\n          height: tileSize\n        };\n      }\n      return {\n        width: tileSize?.width ? tileSize?.width : tileSize?.height,\n        height: tileSize?.height ? tileSize?.height : tileSize?.width\n      };\n    }\n  }\n  _class53 = FlatColorPickerService;\n  _defineProperty(FlatColorPickerService, \"\\u0275fac\", function _class53_Factory(t) {\n    return new (t || _class53)();\n  });\n  _defineProperty(FlatColorPickerService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class53,\n    factory: _class53.ɵfac\n  }));\n  return FlatColorPickerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `cancel` event of the ColorPicker and FlatColorPicker components.\n */\nclass ColorPickerCancelEvent extends PreventableEvent {\n  constructor(originalEvent) {\n    super();\n    /**\n     * The DOM event that triggered the `cancel` event.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n    this.originalEvent = originalEvent;\n  }\n}\n\n/**\n * Arguments for the `close` event of the ColorPicker component.\n */\nclass ColorPickerCloseEvent extends PreventableEvent {}\n\n/**\n * Arguments for the `open` event of the ColorPicker component.\n */\nclass ColorPickerOpenEvent extends PreventableEvent {}\n\n/**\n * Fires each time the left side of the ColorPicker wrapper is clicked.\n * The event is triggered regardless of whether a ColorPicker icon is set or not.\n *\n * Provides information about the current active color and gives the option to prevent the opening of the popup.\n *\n * @example\n *\n * ```ts-no-run\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-colorpicker\n *           [icon]=\"'edit-tools'\"\n *           [value]=\"'#900'\"\n *           (activeColorClick)=\"handleActiveColorClick($event)\"\n *       >\n *       </kendo-colorpicker>\n *   `\n * })\n * class AppComponent {\n *     public handleActiveColorClick(event: ActiveColorClickEvent): void {\n *         event.preventOpen();\n *\n *         console.log('Open prevented:', event.isOpenPrevented());\n *         console.log('Current color:', event.color);\n *     }\n *  }\n * ```\n */\nclass ActiveColorClickEvent {\n  /**\n   * @hidden\n   * @param color Represents the current value of the ColorPicker.\n   */\n  constructor(color) {\n    _defineProperty(this, \"color\", void 0);\n    _defineProperty(this, \"openPrevented\", false);\n    this.color = color;\n  }\n  /**\n   * Prevents the opening of the popup.\n   */\n  preventOpen() {\n    this.openPrevented = true;\n  }\n  /**\n   * Returns `true` if the popup opening is prevented by any of its subscribers.\n   *\n   * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.\n   */\n  isOpenPrevented() {\n    return this.openPrevented;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @hidden\n */\nlet FlatColorPickerHeaderComponent = /*#__PURE__*/(() => {\n  var _class56;\n  class FlatColorPickerHeaderComponent {\n    constructor(localizationService, renderer) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"clearButton\", void 0);\n      _defineProperty(this, \"activeView\", void 0);\n      _defineProperty(this, \"views\", void 0);\n      _defineProperty(this, \"preview\", void 0);\n      _defineProperty(this, \"innerTabIndex\", -1);\n      _defineProperty(this, \"value\", void 0);\n      _defineProperty(this, \"selection\", void 0);\n      _defineProperty(this, \"size\", void 0);\n      _defineProperty(this, \"viewChange\", new EventEmitter());\n      _defineProperty(this, \"valuePaneClick\", new EventEmitter());\n      _defineProperty(this, \"clearButtonClick\", new EventEmitter());\n      _defineProperty(this, \"tabOut\", new EventEmitter());\n      _defineProperty(this, \"viewButtonsCollection\", void 0);\n      _defineProperty(this, \"clearButtonElement\", void 0);\n      _defineProperty(this, \"dropletSliderIcon\", dropletSliderIcon);\n      _defineProperty(this, \"paletteIcon\", paletteIcon);\n      _defineProperty(this, \"dropletSlashIcon\", dropletSlashIcon);\n      this.localizationService = localizationService;\n      this.renderer = renderer;\n    }\n    ngAfterViewInit() {\n      if (this.viewButtonsCollection.length > 0) {\n        this.viewButtonsCollection.forEach(button => {\n          const buttonElem = button.nativeElement;\n          const isViewActive = buttonElem.getAttribute('aria-pressed') === 'true';\n          if (isViewActive) {\n            this.renderer.addClass(buttonElem, 'k-selected');\n          }\n        });\n      }\n    }\n    onViewButtonClick(view) {\n      this.activeView = view;\n      this.viewChange.emit(view);\n    }\n    get viewButtons() {\n      return this.views && this.views.indexOf('gradient') >= 0 && this.views.indexOf('palette') >= 0;\n    }\n    getViewButtonIcon(view) {\n      return view === 'gradient' ? 'color-canvas' : 'palette';\n    }\n    getViewButtonsSVGIcon(view) {\n      return view === 'gradient' ? this.dropletSliderIcon : this.paletteIcon;\n    }\n    getText(text) {\n      return this.localizationService.get(text);\n    }\n    onHeaderTabOut(ev, index) {\n      if (index === 0) {\n        ev.preventDefault();\n        this.tabOut.emit(ev);\n      }\n    }\n  }\n  _class56 = FlatColorPickerHeaderComponent;\n  _defineProperty(FlatColorPickerHeaderComponent, \"\\u0275fac\", function _class56_Factory(t) {\n    return new (t || _class56)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  });\n  _defineProperty(FlatColorPickerHeaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class56,\n    selectors: [[\"\", \"kendoFlatColorPickerHeader\", \"\"]],\n    viewQuery: function _class56_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c93, 5, ElementRef);\n        i0.ɵɵviewQuery(_c94, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearButtonElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewButtonsCollection = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class56_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-coloreditor-header\", ctx.hostClasses)(\"k-hstack\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      clearButton: \"clearButton\",\n      activeView: \"activeView\",\n      views: \"views\",\n      preview: \"preview\",\n      innerTabIndex: \"innerTabIndex\",\n      value: \"value\",\n      selection: \"selection\",\n      size: \"size\"\n    },\n    outputs: {\n      viewChange: \"viewChange\",\n      valuePaneClick: \"valuePaneClick\",\n      clearButtonClick: \"clearButtonClick\",\n      tabOut: \"tabOut\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c95,\n    decls: 6,\n    vars: 3,\n    consts: [[1, \"k-coloreditor-header-actions\", \"k-hstack\"], [\"class\", \"k-button-group k-button-group-flat\", \"role\", \"group\", 4, \"ngIf\"], [1, \"k-spacer\"], [\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", \"icon\", \"reset-color\", \"class\", \"k-coloreditor-reset\", 3, \"tabindex\", \"size\", \"svgIcon\", \"click\", 4, \"ngIf\"], [\"class\", \"k-coloreditor-preview k-vstack\", \"aria-hidden\", \"true\", 4, \"ngIf\"], [\"role\", \"group\", 1, \"k-button-group\", \"k-button-group-flat\"], [\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", 3, \"tabindex\", \"icon\", \"svgIcon\", \"size\", \"ngClass\", \"click\", \"keydown.shift.tab\", 4, \"ngFor\", \"ngForOf\"], [\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", 3, \"tabindex\", \"icon\", \"svgIcon\", \"size\", \"ngClass\", \"click\", \"keydown.shift.tab\"], [\"viewButtons\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", \"icon\", \"reset-color\", 1, \"k-coloreditor-reset\", 3, \"tabindex\", \"size\", \"svgIcon\", \"click\"], [\"clearButton\", \"\"], [\"aria-hidden\", \"true\", 1, \"k-coloreditor-preview\", \"k-vstack\"], [1, \"k-coloreditor-preview-color\", \"k-color-preview\"], [1, \"k-coloreditor-current-color\", \"k-color-preview\", 3, \"click\"]],\n    template: function _class56_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, _class56_div_1_Template, 2, 1, \"div\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 0);\n        i0.ɵɵtemplate(4, _class56_button_4_Template, 2, 5, \"button\", 3);\n        i0.ɵɵtemplate(5, _class56_div_5_Template, 3, 6, \"div\", 4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.viewButtons);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.preview);\n      }\n    },\n    dependencies: [NgIf, NgFor, ButtonComponent, NgClass],\n    encapsulation: 2\n  }));\n  return FlatColorPickerHeaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet FlatColorPickerActionButtonsComponent = /*#__PURE__*/(() => {\n  var _class57;\n  class FlatColorPickerActionButtonsComponent {\n    constructor(localizationService) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"innerTabIndex\", -1);\n      _defineProperty(this, \"size\", void 0);\n      _defineProperty(this, \"actionButtonClick\", new EventEmitter());\n      _defineProperty(this, \"tabOut\", new EventEmitter());\n      _defineProperty(this, \"firstButton\", void 0);\n      _defineProperty(this, \"lastButton\", void 0);\n      this.localizationService = localizationService;\n    }\n    getText(text) {\n      return this.localizationService.get(text);\n    }\n    onActionButtonClick(type, ev) {\n      const args = {\n        target: type,\n        originalEvent: ev\n      };\n      this.actionButtonClick.emit(args);\n    }\n  }\n  _class57 = FlatColorPickerActionButtonsComponent;\n  _defineProperty(FlatColorPickerActionButtonsComponent, \"\\u0275fac\", function _class57_Factory(t) {\n    return new (t || _class57)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(FlatColorPickerActionButtonsComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class57,\n    selectors: [[\"\", \"kendoFlatColorPickerActionButtons\", \"\"]],\n    viewQuery: function _class57_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c96, 5, ElementRef);\n        i0.ɵɵviewQuery(_c97, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.firstButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lastButton = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function _class57_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-coloreditor-footer\", ctx.hostClasses)(\"k-actions\", ctx.hostClasses)(\"k-actions-horizontal\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      innerTabIndex: \"innerTabIndex\",\n      size: \"size\"\n    },\n    outputs: {\n      actionButtonClick: \"actionButtonClick\",\n      tabOut: \"tabOut\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    attrs: _c98,\n    decls: 6,\n    vars: 8,\n    consts: [[\"kendoButton\", \"\", \"type\", \"button\", 1, \"k-coloreditor-cancel\", 3, \"size\", \"tabindex\", \"click\"], [\"first\", \"\"], [\"kendoButton\", \"\", \"themeColor\", \"primary\", \"type\", \"button\", 1, \"k-coloreditor-apply\", 3, \"size\", \"tabindex\", \"click\", \"keydown.tab\"], [\"last\", \"\"]],\n    template: function _class57_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function _class57_Template_button_click_0_listener($event) {\n          return ctx.onActionButtonClick(\"cancel\", $event);\n        });\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"button\", 2, 3);\n        i0.ɵɵlistener(\"click\", function _class57_Template_button_click_3_listener($event) {\n          return ctx.onActionButtonClick(\"apply\", $event);\n        })(\"keydown.tab\", function _class57_Template_button_keydown_tab_3_listener($event) {\n          $event.preventDefault();\n          return ctx.tabOut.emit();\n        });\n        i0.ɵɵtext(5);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"size\", ctx.size)(\"tabindex\", ctx.innerTabIndex.toString());\n        i0.ɵɵattribute(\"title\", ctx.getText(\"cancelButton\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.getText(\"cancelButton\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"tabindex\", ctx.innerTabIndex.toString());\n        i0.ɵɵattribute(\"title\", ctx.getText(\"applyButton\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.getText(\"applyButton\"));\n      }\n    },\n    dependencies: [ButtonComponent],\n    encapsulation: 2\n  }));\n  return FlatColorPickerActionButtonsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-unused-expressions */\nconst DEFAULT_SIZE$5 = 'medium';\n/**\n * Represents the [Kendo UI FlatColorPicker component for Angular]({% slug overview_flatcolorpicker %}).\n *\n * The FlatColorPicker is a powerful tool which allows the user to choose colors through palettes with predefined sets of colors and\n * through a gradient that renders an hsv canvas. It supports previewing the selected color, reverting it to its previous state or clearing it completely.\n */\nlet FlatColorPickerComponent = /*#__PURE__*/(() => {\n  var _class58;\n  class FlatColorPickerComponent {\n    get disabledClass() {\n      return this.disabled;\n    }\n    get ariaReadonly() {\n      return this.readonly;\n    }\n    get hostTabindex() {\n      return this.tabindex?.toString() || '0';\n    }\n    get isControlInvalid() {\n      return this.control?.invalid?.toString();\n    }\n    get isDisabled() {\n      return this.disabled?.toString() || undefined;\n    }\n    /**\n     * @hidden\n     */\n    enterHandler(event) {\n      if (event.target !== this.host.nativeElement) {\n        return;\n      }\n      event.preventDefault();\n      this.internalNavigation = true;\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.firstFocusable?.focus());\n    }\n    /**\n     * @hidden\n     */\n    escapeHandler() {\n      this.internalNavigation = false;\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    focusHandler(ev) {\n      this.internalNavigation = ev.target !== this.host.nativeElement;\n    }\n    /**\n     * Sets the read-only state of the FlatColorPicker.\n     *\n     * @default false\n     */\n\n    /**\n     * Specifies the initially selected color.\n     */\n    set value(value) {\n      this._value = parseColor(value, this.format, this.gradientSettings.opacity);\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n    set tabindex(value) {\n      if (isPresent(value)) {\n        const tabindex = Number(value);\n        this._tabindex = !isNaN(tabindex) ? tabindex : 0;\n      } else {\n        // Allows removal of the tabindex attribute\n        this._tabindex = value;\n      }\n    }\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Specifies whether the FlatColorPicker should display a 'Clear color' button.\n     *\n     * @default true\n     */\n\n    /**\n     * Configures the gradient view.\n     */\n    set gradientSettings(value) {\n      Object.assign(this._gradientSettings, value);\n    }\n    get gradientSettings() {\n      return this._gradientSettings;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * Configures the palette view.\n     */\n    set paletteSettings(value) {\n      Object.assign(this._paletteSettings, value);\n    }\n    get paletteSettings() {\n      return this._paletteSettings;\n    }\n    /**\n     * The size property specifies the padding of the FlatColorPicker internal elements.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size || DEFAULT_SIZE$5;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * Fires each time the component value is changed.\n     */\n\n    /**\n     * @hidden\n     */\n    get innerTabIndex() {\n      return this.internalNavigation ? 0 : -1;\n    }\n    /**\n     * @hidden\n     */\n    get firstFocusable() {\n      if (this.headerHasContent) {\n        return this.headerElement.nativeElement.querySelector('.k-button');\n      }\n      return this.activeView === 'gradient' ? this.gradient : this.palette;\n    }\n    constructor(host, service, localizationService, cdr, renderer, ngZone, injector) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"ariaRole\", 'textbox');\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Sets the disabled state of the FlatColorPicker. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_flatcolorpicker#toc-managing-the-flatcolorpicker-disabled-state-in-reactive-forms).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Specifies the output format of the FlatColorPicker.\n       *\n       * If the input value is in a different format, it will be parsed into the specified output `format`.\n       *\n       * The supported values are:\n       * * `rgba` (default)\n       * * `hex`\n       */\n      _defineProperty(this, \"format\", 'rgba');\n      _defineProperty(this, \"clearButton\", true);\n      /**\n       * Displays `Apply` and `Cancel` action buttons and a color preview pane.\n       *\n       * When enabled, the component value will not change immediately upon\n       * color selection, but only after the `Apply` button is clicked.\n       *\n       * The `Cancel` button reverts the current selection to its\n       * initial state i.e. to the current value.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"preview\", true);\n      /**\n       * Configures the layout of the `Apply` and `Cancel` action buttons.\n       * * `start`\n       * * `center`\n       * * `end` (default)\n       * * `stretch`\n       */\n      _defineProperty(this, \"actionsLayout\", 'end');\n      /**\n       * Sets the initially active view in the FlatColorPicker. The property supports two-way binding.\n       * * `gradient` (default)\n       * * `palette`\n       */\n      _defineProperty(this, \"activeView\", void 0);\n      /**\n       * Specifies the views that will be rendered. Default value is gradient and palette.\n       */\n      _defineProperty(this, \"views\", ['gradient', 'palette']);\n      _defineProperty(this, \"adaptiveMode\", false);\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires when the user cancels the current color selection.\n       *\n       * The event is emitted on preview pane or on 'Cancel' button click.\n       */\n      _defineProperty(this, \"cancel\", new EventEmitter());\n      /**\n       * Fires each time the view is about to change.\n       * Used to provide a two-way binding for the `activeView` property.\n       */\n      _defineProperty(this, \"activeViewChange\", new EventEmitter());\n      /**\n       * @hidden\n       * Fires each time the clear button is clicked.\n       */\n      _defineProperty(this, \"clearButtonClick\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionButtonClick\", new EventEmitter());\n      _defineProperty(this, \"header\", void 0);\n      _defineProperty(this, \"headerElement\", void 0);\n      _defineProperty(this, \"gradient\", void 0);\n      _defineProperty(this, \"gradientElement\", void 0);\n      _defineProperty(this, \"palette\", void 0);\n      _defineProperty(this, \"footer\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"selection\", void 0);\n      _defineProperty(this, \"focused\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"_gradientSettings\", {\n        opacity: true,\n        delay: 0,\n        gradientSliderStep: DRAGHANDLE_MOVE_SPEED,\n        gradientSliderSmallStep: DRAGHANDLE_MOVE_SPEED_SMALL_STEP\n      });\n      _defineProperty(this, \"_paletteSettings\", {});\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"internalNavigation\", false);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"notifyNgChanged\", () => {});\n      _defineProperty(this, \"notifyNgTouched\", () => {});\n      this.host = host;\n      this.service = service;\n      this.localizationService = localizationService;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnInit() {\n      this.selection = this.value;\n      this.control = this.injector.get(NgControl, null);\n      this._paletteSettings = this.service.getPaletteSettings(this._paletteSettings, this.format);\n      this.setActiveView();\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.setHostElementAriaLabel();\n      this.initDomEvents();\n      this.setSizingVariables();\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.removeGradientAttributes());\n    }\n    ngOnChanges(changes) {\n      if (isChanged('value', changes)) {\n        this.selection = this.value;\n        this.setHostElementAriaLabel();\n      }\n      if (isChanged('paletteSettings', changes)) {\n        this.setSizingVariables();\n      }\n    }\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    focusFirstHeaderButton() {\n      if (this.gradientElement.nativeElement === document.activeElement) {\n        if (this.headerHasContent && !this.preview) {\n          const firstHeaderButton = this.headerElement.nativeElement.querySelector('.k-button');\n          firstHeaderButton.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    lastFocusable(event) {\n      if (this.preview) {\n        this.footer.lastButton.nativeElement.focus();\n        return;\n      }\n      event.stopImmediatePropagation();\n      const gradient = this.gradientElement?.nativeElement;\n      const palette = this.palette?.host.nativeElement;\n      this.activeView === 'gradient' ? gradient.focus() : palette.focus();\n    }\n    /**\n     * @hidden\n     */\n    onTab(ev) {\n      const {\n        shiftKey\n      } = ev;\n      const nextTabStop = this.preview ? this.footer.firstButton.nativeElement : this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : null;\n      const previousTabStop = this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : this.preview ? this.footer.lastButton.nativeElement : null;\n      if (!nextTabStop && !previousTabStop) {\n        return;\n      }\n      ev.preventDefault();\n      // eslint-disable-next-line no-unused-expressions\n      shiftKey ? previousTabStop?.focus() : nextTabStop?.focus();\n    }\n    /**\n     * @hidden\n     */\n    get headerHasContent() {\n      return this.preview || this.views.length > 1 || this.clearButton;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    /**\n     * Focuses the wrapper of the FlatColorPicker.\n     */\n    focus() {\n      if (this.disabled || this.focused) {\n        return;\n      }\n      this.host.nativeElement.focus();\n      this.focused = true;\n    }\n    /**\n     * Blurs the wrapper of the FlatColorPicker.\n     */\n    blur() {\n      if (!this.focused) {\n        return;\n      }\n      this.notifyNgTouched();\n      this.host.nativeElement.blur();\n      this.focused = false;\n    }\n    /**\n     * Clears the value of the FlatColorPicker.\n     */\n    reset() {\n      if (!isPresent(this.value)) {\n        return;\n      }\n      this.value = undefined;\n      this.notifyNgChanged(undefined);\n      this.setHostElementAriaLabel();\n    }\n    /**\n     * @hidden\n     */\n    onViewChange(view) {\n      if (this.activeView === view) {\n        return;\n      }\n      this.activeView = view;\n      this.activeViewChange.emit(view);\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          this[this.activeView]?.focus();\n        });\n      });\n      if (this.activeView === 'gradient') {\n        this.removeGradientAttributes();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onClearButtonClick() {\n      this.resetInnerComponentValue();\n      this.clearButtonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    handleValueChange(color) {\n      // eslint-disable-next-line no-unused-expressions\n      this.preview ? this.changeCurrentValue(color) : this.setFlatColorPickerValue(color);\n    }\n    /**\n     * @hidden\n     */\n    onAction(ev) {\n      // eslint-disable-next-line no-unused-expressions\n      ev.target === 'apply' ? this.setFlatColorPickerValue(this.selection) : this.resetSelection(ev.originalEvent);\n      this.actionButtonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    resetSelection(ev) {\n      const eventArgs = new ColorPickerCancelEvent(ev);\n      this.cancel.emit(eventArgs);\n      if (!eventArgs.isDefaultPrevented()) {\n        this.selection = this.value;\n      }\n      this.notifyNgTouched();\n    }\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.gradientSettings.opacity);\n      const ariaLabelValue = `${this.value ? parsed : this.localizationService.get('flatColorPickerNoColor')}`;\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);\n    }\n    setSizingVariables() {\n      const paletteTileSize = this.service.paletteTileLayout(this.paletteSettings.tileSize);\n      const element = this.host.nativeElement.querySelector('.k-coloreditor-views.k-vstack');\n      const cssProperties = [`--kendo-color-preview-columns: ${this.paletteSettings.columns};`];\n      if (paletteTileSize.width) {\n        cssProperties.push(`--kendo-color-preview-width: ${paletteTileSize.width}px;`);\n      }\n      if (paletteTileSize.height) {\n        cssProperties.push(`--kendo-color-preview-height: ${paletteTileSize.height}px;`);\n      }\n      this.renderer.setProperty(element, 'style', cssProperties.join(' '));\n    }\n    changeCurrentValue(color) {\n      this.selection = color;\n      this.notifyNgTouched();\n    }\n    resetInnerComponentValue() {\n      this.selection = null;\n      if (this.gradient) {\n        this.gradient.reset();\n        return;\n      }\n      this.palette.reset();\n    }\n    setFlatColorPickerValue(color) {\n      if (this.value === color) {\n        return;\n      }\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n    setActiveView() {\n      if (!isPresent(this.activeView)) {\n        this.activeView = this.views[0];\n        return;\n      }\n      if (isDevMode() && this.views.indexOf(this.activeView) === -1) {\n        throw new Error(\"Invalid configuration: The current activeView is not present in the views collection\");\n      }\n    }\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n      const hostElement = this.host.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focus', () => {\n          this.focused = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'blur', () => {\n          this.focused = false;\n          this.notifyNgTouched();\n        }));\n      });\n    }\n    removeGradientAttributes() {\n      this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, 'role');\n      this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, 'aria-label');\n    }\n    handleClasses(value, input) {\n      const elem = this.host.nativeElement;\n      const classes = getStylingClasses('coloreditor', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n  }\n  _class58 = FlatColorPickerComponent;\n  _defineProperty(FlatColorPickerComponent, \"\\u0275fac\", function _class58_Factory(t) {\n    return new (t || _class58)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FlatColorPickerService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n  });\n  _defineProperty(FlatColorPickerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class58,\n    selectors: [[\"kendo-flatcolorpicker\"]],\n    viewQuery: function _class58_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c99, 5);\n        i0.ɵɵviewQuery(_c99, 5, ElementRef);\n        i0.ɵɵviewQuery(_c100, 5);\n        i0.ɵɵviewQuery(_c100, 5, ElementRef);\n        i0.ɵɵviewQuery(_c101, 5);\n        i0.ɵɵviewQuery(_c102, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradient = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.palette = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footer = _t.first);\n      }\n    },\n    hostVars: 14,\n    hostBindings: function _class58_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.enter\", function _class58_keydown_enter_HostBindingHandler($event) {\n          return ctx.enterHandler($event);\n        })(\"keydown.escape\", function _class58_keydown_escape_HostBindingHandler() {\n          return ctx.escapeHandler();\n        })(\"focusin\", function _class58_focusin_HostBindingHandler($event) {\n          return ctx.focusHandler($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"aria-readonly\", ctx.ariaReadonly)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabindex)(\"role\", ctx.ariaRole)(\"aria-invalid\", ctx.isControlInvalid);\n        i0.ɵɵclassProp(\"k-flatcolorpicker\", ctx.hostClasses)(\"k-coloreditor\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass)(\"k-readonly\", ctx.readonly);\n      }\n    },\n    inputs: {\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      format: \"format\",\n      value: \"value\",\n      tabindex: \"tabindex\",\n      clearButton: \"clearButton\",\n      preview: \"preview\",\n      actionsLayout: \"actionsLayout\",\n      activeView: \"activeView\",\n      views: \"views\",\n      gradientSettings: \"gradientSettings\",\n      adaptiveMode: \"adaptiveMode\",\n      paletteSettings: \"paletteSettings\",\n      size: \"size\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      cancel: \"cancel\",\n      activeViewChange: \"activeViewChange\",\n      clearButtonClick: \"clearButtonClick\",\n      actionButtonClick: \"actionButtonClick\"\n    },\n    exportAs: [\"kendoFlatColorPicker\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class58)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class58)\n    }, FlatColorPickerService, FlatColorPickerLocalizationService, {\n      provide: LocalizationService,\n      useExisting: FlatColorPickerLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.flatcolorpicker'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 6,\n    vars: 4,\n    consts: function () {\n      let i18n_103;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.\n         * @meaning kendo.flatcolorpicker.flatColorPickerNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_104 = goog.getMsg(\"Flatcolorpicker no color chosen\");\n        i18n_103 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_104;\n      } else {\n        i18n_103 = $localize`:kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;\n      }\n      let i18n_105;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.flatcolorpicker.colorGradientNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_106 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_105 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_106;\n      } else {\n        i18n_105 = $localize`:kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n      let i18n_107;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.flatcolorpicker.colorPaletteNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_108 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_107 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_108;\n      } else {\n        i18n_107 = $localize`:kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n      let i18n_109;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.flatcolorpicker.colorGradientHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_110 = goog.getMsg(\"Choose color\");\n        i18n_109 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_110;\n      } else {\n        i18n_109 = $localize`:kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n      let i18n_111;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.flatcolorpicker.clearButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_112 = goog.getMsg(\"Clear value\");\n        i18n_111 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_112;\n      } else {\n        i18n_111 = $localize`:kendo.flatcolorpicker.clearButton|The title for the clear button.:Clear value`;\n      }\n      let i18n_113;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.flatcolorpicker.hueSliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_114 = goog.getMsg(\"Set hue\");\n        i18n_113 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_114;\n      } else {\n        i18n_113 = $localize`:kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n      let i18n_115;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.flatcolorpicker.opacitySliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_116 = goog.getMsg(\"Set opacity\");\n        i18n_115 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_116;\n      } else {\n        i18n_115 = $localize`:kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n      let i18n_117;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.flatcolorpicker.contrastRatio\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_118 = goog.getMsg(\"Contrast ratio\");\n        i18n_117 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_118;\n      } else {\n        i18n_117 = $localize`:kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n      let i18n_119;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the color preview pane.\n         * @meaning kendo.flatcolorpicker.previewColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_120 = goog.getMsg(\"Color preview\");\n        i18n_119 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_120;\n      } else {\n        i18n_119 = $localize`:kendo.flatcolorpicker.previewColor|The message for the color preview pane.:Color preview`;\n      }\n      let i18n_121;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the selected color pane.\n         * @meaning kendo.flatcolorpicker.revertSelection\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_122 = goog.getMsg(\"Revert selection\");\n        i18n_121 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_122;\n      } else {\n        i18n_121 = $localize`:kendo.flatcolorpicker.revertSelection|The message for the selected color pane.:Revert selection`;\n      }\n      let i18n_123;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the gradient view button.\n         * @meaning kendo.flatcolorpicker.gradientView\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_124 = goog.getMsg(\"Gradient view\");\n        i18n_123 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_124;\n      } else {\n        i18n_123 = $localize`:kendo.flatcolorpicker.gradientView|The message for the gradient view button.:Gradient view`;\n      }\n      let i18n_125;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the palette view button.\n         * @meaning kendo.flatcolorpicker.paletteView\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_126 = goog.getMsg(\"Palette view\");\n        i18n_125 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_126;\n      } else {\n        i18n_125 = $localize`:kendo.flatcolorpicker.paletteView|The message for the palette view button.:Palette view`;\n      }\n      let i18n_127;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.flatcolorpicker.formatButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_128 = goog.getMsg(\"Change color format\");\n        i18n_127 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_128;\n      } else {\n        i18n_127 = $localize`:kendo.flatcolorpicker.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n      let i18n_129;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Apply action button.\n         * @meaning kendo.flatcolorpicker.applyButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_130 = goog.getMsg(\"Apply\");\n        i18n_129 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_130;\n      } else {\n        i18n_129 = $localize`:kendo.flatcolorpicker.applyButton|The message for the Apply action button.:Apply`;\n      }\n      let i18n_131;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Cancel action button.\n         * @meaning kendo.flatcolorpicker.cancelButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_132 = goog.getMsg(\"Cancel\");\n        i18n_131 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_132;\n      } else {\n        i18n_131 = $localize`:kendo.flatcolorpicker.cancelButton|The message for the Cancel action button.:Cancel`;\n      }\n      let i18n_133;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.flatcolorpicker.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_134 = goog.getMsg(\"Red channel\");\n        i18n_133 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_134;\n      } else {\n        i18n_133 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;\n      }\n      let i18n_135;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the green color channel.\n         * @meaning kendo.flatcolorpicker.greenChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_136 = goog.getMsg(\"Green channel\");\n        i18n_135 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_136;\n      } else {\n        i18n_135 = $localize`:kendo.flatcolorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;\n      }\n      let i18n_137;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the blue color channel.\n         * @meaning kendo.flatcolorpicker.blueChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_138 = goog.getMsg(\"Blue channel\");\n        i18n_137 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_138;\n      } else {\n        i18n_137 = $localize`:kendo.flatcolorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;\n      }\n      let i18n_139;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the alpha color channel.\n         * @meaning kendo.flatcolorpicker.alphaChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_140 = goog.getMsg(\"Alpha channel\");\n        i18n_139 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_140;\n      } else {\n        i18n_139 = $localize`:kendo.flatcolorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;\n      }\n      let i18n_141;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.flatcolorpicker.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_142 = goog.getMsg(\"R\");\n        i18n_141 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_142;\n      } else {\n        i18n_141 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;\n      }\n      let i18n_143;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the green color input.\n         * @meaning kendo.flatcolorpicker.greenInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_144 = goog.getMsg(\"G\");\n        i18n_143 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_144;\n      } else {\n        i18n_143 = $localize`:kendo.flatcolorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;\n      }\n      let i18n_145;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the blue color input.\n         * @meaning kendo.flatcolorpicker.blueInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_146 = goog.getMsg(\"B\");\n        i18n_145 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_146;\n      } else {\n        i18n_145 = $localize`:kendo.flatcolorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;\n      }\n      let i18n_147;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the HEX color input.\n         * @meaning kendo.flatcolorpicker.hexInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_148 = goog.getMsg(\"HEX\");\n        i18n_147 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_148;\n      } else {\n        i18n_147 = $localize`:kendo.flatcolorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;\n      }\n      return [[\"kendoFlatColorPickerLocalizedMessages\", \"\", \"flatColorPickerNoColor\", i18n_103, \"colorGradientNoColor\", i18n_105, \"colorPaletteNoColor\", i18n_107, \"colorGradientHandle\", i18n_109, \"clearButton\", i18n_111, \"hueSliderHandle\", i18n_113, \"opacitySliderHandle\", i18n_115, \"contrastRatio\", i18n_117, \"previewColor\", i18n_119, \"revertSelection\", i18n_121, \"gradientView\", i18n_123, \"paletteView\", i18n_125, \"formatButton\", i18n_127, \"applyButton\", i18n_129, \"cancelButton\", i18n_131, \"redChannelLabel\", i18n_133, \"greenChannelLabel\", i18n_135, \"blueChannelLabel\", i18n_137, \"alphaChannelLabel\", i18n_139, \"redChannelLabel\", i18n_141, \"greenInputPlaceholder\", i18n_143, \"blueInputPlaceholder\", i18n_145, \"hexInputPlaceholder\", i18n_147], [\"kendoFlatColorPickerHeader\", \"\", 3, \"innerTabIndex\", \"clearButton\", \"activeView\", \"views\", \"size\", \"value\", \"selection\", \"preview\", \"clearButtonClick\", \"viewChange\", \"valuePaneClick\", \"tabOut\", 4, \"ngIf\"], [1, \"k-coloreditor-views\", \"k-vstack\"], [3, \"tabindex\", \"value\", \"size\", \"adaptiveMode\", \"format\", \"opacity\", \"delay\", \"contrastTool\", \"gradientSliderSmallStep\", \"gradientSliderStep\", \"readonly\", \"keydown.tab\", \"valueChange\", 4, \"ngIf\"], [3, \"tabindex\", \"palette\", \"size\", \"columns\", \"tileSize\", \"format\", \"value\", \"readonly\", \"valueChange\", 4, \"ngIf\"], [\"kendoFlatColorPickerActionButtons\", \"\", 3, \"innerTabIndex\", \"size\", \"ngClass\", \"actionButtonClick\", \"tabOut\", 4, \"ngIf\"], [\"kendoFlatColorPickerHeader\", \"\", 3, \"innerTabIndex\", \"clearButton\", \"activeView\", \"views\", \"size\", \"value\", \"selection\", \"preview\", \"clearButtonClick\", \"viewChange\", \"valuePaneClick\", \"tabOut\"], [\"header\", \"\"], [3, \"tabindex\", \"value\", \"size\", \"adaptiveMode\", \"format\", \"opacity\", \"delay\", \"contrastTool\", \"gradientSliderSmallStep\", \"gradientSliderStep\", \"readonly\", \"keydown.tab\", \"valueChange\"], [\"gradient\", \"\"], [3, \"tabindex\", \"palette\", \"size\", \"columns\", \"tileSize\", \"format\", \"value\", \"readonly\", \"valueChange\"], [\"palette\", \"\"], [\"kendoFlatColorPickerActionButtons\", \"\", 3, \"innerTabIndex\", \"size\", \"ngClass\", \"actionButtonClick\", \"tabOut\"], [\"footer\", \"\"]];\n    },\n    template: function _class58_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, _class58_div_1_Template, 2, 8, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵtemplate(3, _class58_kendo_colorgradient_3_Template, 2, 11, \"kendo-colorgradient\", 3);\n        i0.ɵɵtemplate(4, _class58_kendo_colorpalette_4_Template, 2, 8, \"kendo-colorpalette\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, _class58_div_5_Template, 2, 3, \"div\", 5);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.headerHasContent);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.activeView === \"gradient\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.activeView === \"palette\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.preview && !ctx.adaptiveMode);\n      }\n    },\n    dependencies: [LocalizedColorPickerMessagesDirective, NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, NgClass],\n    encapsulation: 2\n  }));\n  return FlatColorPickerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst animationDuration = 300;\n/**\n * @hidden\n */\nconst updateActionSheetAdaptiveAppearance = (actionSheet, windowSize, renderer) => {\n  const element = actionSheet['element'].nativeElement.querySelector('.k-actionsheet');\n  const animationContainer = actionSheet['element'].nativeElement.querySelector('.k-child-animation-container');\n  renderer.addClass(element, 'k-adaptive-actionsheet');\n  renderer.setStyle(animationContainer, 'width', '100%');\n  if (windowSize === 'medium') {\n    renderer.removeClass(element, 'k-actionsheet-fullscreen');\n    renderer.addClass(element, 'k-actionsheet-bottom');\n    renderer.setStyle(animationContainer, 'bottom', '0px');\n  } else if (windowSize === 'small') {\n    renderer.removeClass(element, 'k-actionsheet-bottom');\n    renderer.addClass(element, 'k-actionsheet-fullscreen');\n    renderer.setStyle(animationContainer, 'height', '100%');\n  }\n};\n\n/**\n * @hidden\n */\nlet AdaptiveCloseButtonComponent = /*#__PURE__*/(() => {\n  var _class59;\n  class AdaptiveCloseButtonComponent {\n    constructor() {\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"icon\", void 0);\n      _defineProperty(this, \"svgIcon\", void 0);\n      _defineProperty(this, \"color\", void 0);\n      _defineProperty(this, \"close\", new EventEmitter());\n    }\n  }\n  _class59 = AdaptiveCloseButtonComponent;\n  _defineProperty(AdaptiveCloseButtonComponent, \"\\u0275fac\", function _class59_Factory(t) {\n    return new (t || _class59)();\n  });\n  _defineProperty(AdaptiveCloseButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class59,\n    selectors: [[\"kendo-adaptive-close-button\"]],\n    inputs: {\n      title: \"title\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      color: \"color\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 5,\n    consts: [[\"kendoButton\", \"\", \"type\", \"button\", \"fillMode\", \"flat\", \"size\", \"large\", 3, \"title\", \"icon\", \"svgIcon\", \"themeColor\", \"tabIndex\", \"click\"]],\n    template: function _class59_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function _class59_Template_button_click_0_listener($event) {\n          return ctx.close.emit($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"title\", ctx.title)(\"icon\", ctx.icon)(\"svgIcon\", ctx.svgIcon)(\"themeColor\", ctx.color)(\"tabIndex\", -1);\n      }\n    },\n    dependencies: [ButtonComponent],\n    encapsulation: 2\n  }));\n  return AdaptiveCloseButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet AdaptiveRendererComponent = /*#__PURE__*/(() => {\n  var _class60;\n  class AdaptiveRendererComponent {\n    constructor(localization) {\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"subtitle\", void 0);\n      _defineProperty(this, \"actionSheetTemplate\", void 0);\n      _defineProperty(this, \"isActionSheetExpanded\", void 0);\n      _defineProperty(this, \"preview\", void 0);\n      _defineProperty(this, \"actionSheetClose\", new EventEmitter());\n      _defineProperty(this, \"onExpand\", new EventEmitter());\n      _defineProperty(this, \"onCollapse\", new EventEmitter());\n      _defineProperty(this, \"onApply\", new EventEmitter());\n      _defineProperty(this, \"onCancel\", new EventEmitter());\n      _defineProperty(this, \"actionSheet\", void 0);\n      _defineProperty(this, \"actionSheetSearchBar\", void 0);\n      _defineProperty(this, \"cancelButton\", void 0);\n      _defineProperty(this, \"applyButton\", void 0);\n      _defineProperty(this, \"animationDuration\", animationDuration);\n      _defineProperty(this, \"xIcon\", xIcon);\n      _defineProperty(this, \"checkIcon\", checkIcon);\n      this.localization = localization;\n    }\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n  }\n  _class60 = AdaptiveRendererComponent;\n  _defineProperty(AdaptiveRendererComponent, \"\\u0275fac\", function _class60_Factory(t) {\n    return new (t || _class60)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(AdaptiveRendererComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class60,\n    selectors: [[\"kendo-adaptive-renderer\"]],\n    viewQuery: function _class60_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(ActionSheetComponent, 5);\n        i0.ɵɵviewQuery(_c149, 5);\n        i0.ɵɵviewQuery(_c150, 5);\n        i0.ɵɵviewQuery(_c151, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionSheet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancelButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.applyButton = _t.first);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      subtitle: \"subtitle\",\n      actionSheetTemplate: \"actionSheetTemplate\",\n      isActionSheetExpanded: \"isActionSheetExpanded\",\n      preview: \"preview\"\n    },\n    outputs: {\n      actionSheetClose: \"actionSheetClose\",\n      onExpand: \"onExpand\",\n      onCollapse: \"onCollapse\",\n      onApply: \"onApply\",\n      onCancel: \"onCancel\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 4,\n    consts: [[3, \"animation\", \"expanded\", \"overlayClick\", \"expand\", \"collapse\"], [\"actionSheet\", \"\"], [\"kendoActionSheetTemplate\", \"\"], [1, \"k-text-center\", \"k-actionsheet-titlebar\"], [1, \"k-actionsheet-titlebar-group\", \"k-hbox\"], [1, \"k-actionsheet-title\"], [1, \"k-text-center\"], [1, \"k-actionsheet-subtitle\", \"k-text-center\"], [\"class\", \"k-actionsheet-actions\", 4, \"ngIf\"], [1, \"k-actionsheet-content\", \"!k-overflow-hidden\"], [4, \"ngTemplateOutlet\"], [\"class\", \"k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer\", 4, \"ngIf\"], [1, \"k-actionsheet-actions\"], [\"icon\", \"check\", \"color\", \"primary\", 3, \"title\", \"svgIcon\", \"close\"], [\"icon\", \"x\", 3, \"title\", \"svgIcon\", \"close\"], [1, \"k-actions\", \"k-actions-stretched\", \"k-actions-horizontal\", \"k-actionsheet-footer\"], [\"kendoButton\", \"\", \"size\", \"large\", 3, \"title\", \"click\"], [\"cancel\", \"\"], [\"kendoButton\", \"\", \"size\", \"large\", \"themeColor\", \"primary\", 3, \"title\", \"click\"], [\"apply\", \"\"]],\n    template: function _class60_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-actionsheet\", 0, 1);\n        i0.ɵɵlistener(\"overlayClick\", function _class60_Template_kendo_actionsheet_overlayClick_0_listener() {\n          return ctx.actionSheetClose.emit();\n        })(\"expand\", function _class60_Template_kendo_actionsheet_expand_0_listener() {\n          return ctx.onExpand.emit();\n        })(\"collapse\", function _class60_Template_kendo_actionsheet_collapse_0_listener() {\n          return ctx.onCollapse.emit();\n        });\n        i0.ɵɵtemplate(2, _class60_ng_template_2_Template, 11, 5, \"ng-template\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"animation\", i0.ɵɵpureFunction1(2, _c152, ctx.animationDuration))(\"expanded\", ctx.isActionSheetExpanded);\n      }\n    },\n    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, NgTemplateOutlet, AdaptiveCloseButtonComponent],\n    encapsulation: 2\n  }));\n  return AdaptiveRendererComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst DOM_FOCUS_EVENTS = ['focus', 'blur'];\nconst DEFAULT_SIZE$4 = 'medium';\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * @hidden\n */\nlet nextColorPickerId = 0;\n/**\n * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).\n *\n * The ColorPicker is a powerful tool for choosing colors from Gradient and Palette views\n * which are rendered in its popup. It supports previewing the selected color, reverting it to its previous state or clearing it completely.\n */\nlet ColorPickerComponent = /*#__PURE__*/(() => {\n  var _class61;\n  class ColorPickerComponent {\n    get focusedClass() {\n      return this.isFocused;\n    }\n    get disabledClass() {\n      return this.disabled;\n    }\n    get ariaReadonly() {\n      return this.readonly;\n    }\n    get ariaExpanded() {\n      return this.isOpen;\n    }\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    get isControlInvalid() {\n      return this.control?.invalid?.toString();\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    set view(view) {\n      this.views = [view];\n    }\n    get view() {\n      return this.views && this.views.length > 0 ? this.views[0] : null;\n    }\n    /**\n     * Enables or disables the adaptive mode. By default, adaptive rendering is disabled.\n     */\n\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n      this._value = parseColor(value, this.format, this.gradientSettings.opacity);\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Configures the popup of the ColorPicker.\n     */\n    set popupSettings(value) {\n      this._popupSettings = Object.assign(this._popupSettings, value);\n    }\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Configures the palette that is displayed in the ColorPicker popup.\n     */\n    set paletteSettings(value) {\n      this._paletteSettings = Object.assign(this._paletteSettings, value);\n    }\n    get paletteSettings() {\n      return this._paletteSettings;\n    }\n    /**\n     * Configures the gradient that is displayed in the ColorPicker popup.\n     */\n    set gradientSettings(value) {\n      this._gradientSettings = Object.assign(this._gradientSettings, value);\n    }\n    get gradientSettings() {\n      return this._gradientSettings;\n    }\n    /**\n     * Defines the name of an [existing icon in the Kendo UI theme]({% slug icons %}).\n     * Provide only the name of the icon without the `k-icon` or the `k-i-` prefixes.\n     *\n     * For example, `pencil-tools` will be parsed to `k-icon k-i-pencil-tools`.\n     */\n\n    /**\n     * Defines an SVGIcon to be rendered within the button.\n     * The input can take either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.\n     */\n    set svgIcon(icon) {\n      if (isDevMode() && icon && this.icon && this.iconClass) {\n        throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');\n      }\n      this._svgIcon = icon;\n    }\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    /**\n     * Specifies whether the ColorPicker should display a 'Clear color' button.\n     *\n     * @default true\n     */\n\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Displays `Apply` and `Cancel` action buttons and color preview panes.\n     *\n     * When enabled, the component value will not change immediately upon\n     * color selection, but only after the `Apply` button is clicked.\n     *\n     * The `Cancel` button reverts the current selection to its\n     * previous state i.e. to the current value.\n     *\n     * @default false\n     */\n\n    /**\n     * The size property specifies the padding of the ColorPicker internal elements\n     * ([see example]({% slug appearance_colorpicker %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$4;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the ColorPicker\n     * ([see example](slug:appearance_colorpicker#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the ColorPicker\n     * ([see example]({% slug appearance_colorpicker %}#toc-fill-mode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Fires each time the value is changed.\n     */\n\n    /**\n     * Returns the current open state. Returns `true` if the Popup (or ActionSheet in adaptive mode) is currently open.\n     */\n    get isOpen() {\n      return isPresent(this.popupRef) || this.isActionSheetExpanded;\n    }\n    /**\n     * @hidden\n     */\n    get customIconStyles() {\n      if (this.iconClass) {\n        let parsedIconClass = '';\n        parseCSSClassNames(this.iconClass).forEach(iconClass => {\n          parsedIconClass += iconClass + ' ';\n        });\n        return parsedIconClass.slice(0, -1);\n      }\n      return '';\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptiveModeEnabled() {\n      return this.adaptiveMode === 'auto';\n    }\n    /**\n     * @hidden\n     */\n    get isAdaptive() {\n      return this.isAdaptiveModeEnabled && this.windowSize !== 'large';\n    }\n    /**\n     * @hidden\n     */\n    get actionSheet() {\n      return this.adaptiveRenderer?.actionSheet;\n    }\n    /**\n     * @hidden\n     */\n    get isActionSheetExpanded() {\n      return Boolean(this.actionSheet?.expanded);\n    }\n    /**\n     * @hidden\n     */\n    get iconStyles() {\n      if (this.icon && !this.iconClass) {\n        return `${this.icon}`;\n      }\n      return '';\n    }\n    /**\n     * Provides a reference to a container element inside the component markup.\n     * The container element references the location of the appended popup&mdash;\n     * for example, inside the component markup.\n     */\n\n    constructor(host, popupService, cdr, localizationService, ngZone, renderer, injector, adaptiveService) {\n      _defineProperty(this, \"host\", void 0);\n      _defineProperty(this, \"popupService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"adaptiveService\", void 0);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"role\", 'combobox');\n      _defineProperty(this, \"hasPopup\", 'dialog');\n      _defineProperty(this, \"focusableId\", void 0);\n      /**\n       * Specifies the views that will be rendered in the popup.\n       * By default both the gradient and palette views will be rendered.\n       */\n      _defineProperty(this, \"views\", ['gradient', 'palette']);\n      _defineProperty(this, \"adaptiveMode\", 'none');\n      /**\n       * Sets the initially active view in the popup. The property supports two-way binding.\n       *\n       * The supported values are:\n       * * `gradient`\n       * * `palette`\n       */\n      _defineProperty(this, \"activeView\", void 0);\n      /**\n       * Sets the read-only state of the ColorPicker.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Sets the disabled state of the ColorPicker. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_colorpicker#toc-managing-the-colorpicker-disabled-state-in-reactive-forms).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Specifies the output format of the ColorPicker.\n       *\n       * If the input value is in a different format, it will be parsed into the specified output `format`.\n       *\n       * The supported values are:\n       * * `rgba` (default)\n       * * `hex`\n       */\n      _defineProperty(this, \"format\", 'rgba');\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * A CSS class name which displays an icon in the ColorPicker button.\n       * `iconClass` is compatible with the `ngClass` syntax.\n       *\n       * Takes precedence over `icon` if both are defined.\n       */\n      _defineProperty(this, \"iconClass\", void 0);\n      _defineProperty(this, \"clearButton\", true);\n      _defineProperty(this, \"preview\", false);\n      /**\n       * Configures the layout of the `Apply` and `Cancel` action buttons.\n       *\n       * The possible values are:\n       * * `start`\n       * * `center`\n       * * `end` (default)\n       * * `stretch`\n       */\n      _defineProperty(this, \"actionsLayout\", 'end');\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the Popup (or ActionSheet in adaptive mode) is about to open.\n       * This event is preventable. If you cancel it, the Popup (or the ActionSheet) will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the Popup (or ActionSheet in adaptive mode) is about to close.\n       * This event is preventable. If you cancel it, the Popup (or the ActionSheet) will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires each time ColorPicker is focused.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the ColorPicker is blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires when the user cancels the current color selection.\n       *\n       * Fires on preview pane or 'Cancel' button click.\n       */\n      _defineProperty(this, \"cancel\", new EventEmitter());\n      /**\n       * Fires each time the left side of the ColorPicker wrapper is clicked.\n       * The event is triggered regardless of whether a ColorPicker icon is set or not.\n       *\n       * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.\n       */\n      _defineProperty(this, \"activeColorClick\", new EventEmitter());\n      /**\n       * @hidden\n       * Fires each time the clear button is clicked.\n       */\n      _defineProperty(this, \"clearButtonClick\", new EventEmitter());\n      /**\n       * Fires each time the view is about to change.\n       * Used to provide a two-way binding for the `activeView` property.\n       */\n      _defineProperty(this, \"activeViewChange\", new EventEmitter());\n      /**\n       * Indicates whether the ColorPicker wrapper is focused.\n       */\n      _defineProperty(this, \"isFocused\", false);\n      /**\n      * @hidden\n      */\n      _defineProperty(this, \"windowSize\", 'large');\n      _defineProperty(this, \"container\", void 0);\n      _defineProperty(this, \"activeColor\", void 0);\n      _defineProperty(this, \"popupTemplate\", void 0);\n      _defineProperty(this, \"flatColorPicker\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"adaptiveRenderer\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"arrowDownIcon\", caretAltDownIcon);\n      _defineProperty(this, \"popupRef\", void 0);\n      _defineProperty(this, \"_svgIcon\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"_popupSettings\", {\n        animate: true\n      });\n      _defineProperty(this, \"_paletteSettings\", {});\n      _defineProperty(this, \"_gradientSettings\", {\n        opacity: true,\n        delay: 0\n      });\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"dynamicRTLSubscription\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"popupSubs\", new Subscription());\n      _defineProperty(this, \"colorPickerId\", void 0);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"notifyNgTouched\", () => {});\n      _defineProperty(this, \"notifyNgChanged\", () => {});\n      _defineProperty(this, \"domFocusListener\", event => event.stopImmediatePropagation());\n      this.host = host;\n      this.popupService = popupService;\n      this.cdr = cdr;\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.adaptiveService = adaptiveService;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.colorPickerId = nextColorPickerId++;\n    }\n    ngOnInit() {\n      const defaultPreset = this.format !== 'name' ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n      const settingsPalette = this._paletteSettings.palette;\n      const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : undefined;\n      this._paletteSettings = {\n        palette: settingsPalette || defaultPreset,\n        tileSize: this._paletteSettings.tileSize,\n        columns: this._paletteSettings.columns || presetColumns || 10\n      };\n      this.handleHostId();\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-controls', `k-colorpicker-popup-${this.colorPickerId}`);\n      this.control = this.injector.get(NgControl, null);\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.setHostElementAriaLabel();\n      this.initDomEvents();\n      this.windowSize = this.adaptiveService.size;\n      if (this.actionSheet && isDocumentAvailable()) {\n        // The following syntax is used as it does not violate CSP compliance\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');\n        this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes.format && changes.format.currentValue === 'name') {\n        this.activeView = 'palette';\n      }\n      if (this.activeView === 'gradient' && this.gradientSettings.opacity) {\n        this.format = 'rgba';\n        this.value = parseColor(this.value, this.format, this.gradientSettings.opacity);\n      }\n      if (isChanged('value', changes)) {\n        this.setHostElementAriaLabel();\n      }\n    }\n    ngOnDestroy() {\n      this.closePopup();\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n      this.subscriptions.unsubscribe();\n      this.handleDomEvents('remove', DOM_FOCUS_EVENTS);\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n      const currentWindowSize = this.adaptiveService.size;\n      if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {\n        if (this.isOpen) {\n          this.toggleWithEvents(false);\n        }\n        this.windowSize = currentWindowSize;\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleCancelEvent(ev) {\n      this.cancel.emit(ev);\n    }\n    /**\n     * @hidden\n     */\n    togglePopup() {\n      if (!this.isActionSheetExpanded) {\n        this.focus();\n        this.toggleWithEvents(!this.isOpen);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperClick(event) {\n      if (this.disabled) {\n        return;\n      }\n      this.focus();\n      if (closest$1(event.target, element => element === this.activeColor.nativeElement)) {\n        const event = new ActiveColorClickEvent(this.value);\n        this.activeColorClick.emit(event);\n        if (!event.isOpenPrevented() || this.isOpen) {\n          this.toggleWithEvents(!this.isOpen);\n        }\n        return;\n      }\n      if (!this.isActionSheetExpanded) {\n        this.toggleWithEvents(!this.isOpen);\n      }\n    }\n    /**\n     * Focuses the wrapper of the ColorPicker.\n     */\n    focus() {\n      this.isFocused = true;\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperFocus() {\n      if (this.isFocused) {\n        return;\n      }\n      this.ngZone.run(() => {\n        this.focus();\n        this.onFocus.emit();\n      });\n    }\n    /**\n     * Blurs the ColorPicker.\n     */\n    blur() {\n      this.isFocused = false;\n      this.host.nativeElement.blur();\n      this.notifyNgTouched();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperBlur() {\n      if (!this.isActionSheetExpanded) {\n        if (this.isOpen) {\n          return;\n        }\n        this.ngZone.run(() => {\n          this.onBlur.emit();\n          this.isFocused = false;\n        });\n      }\n    }\n    /**\n     * Clears the value of the ColorPicker.\n     */\n    reset() {\n      if (!isPresent(this.value)) {\n        return;\n      }\n      this._value = undefined;\n      this.setHostElementAriaLabel();\n      this.notifyNgChanged(undefined);\n    }\n    /**\n     * Toggles the Popup (or ActionSheet in adaptive mode) of the ColorPicker.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n    toggle(open) {\n      this.windowSize = this.adaptiveService.size;\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      this.cdr.markForCheck();\n      if (this.isActionSheetExpanded) {\n        this.closeActionSheet();\n      } else {\n        this.closePopup();\n      }\n      open = isPresent(open) ? open : !this.isOpen;\n      if (open) {\n        if (this.isAdaptive && !this.isActionSheetExpanded) {\n          this.openActionSheet();\n        } else {\n          this.openPopup();\n        }\n        this.focusFirstElement();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleValueChange(color) {\n      const parsedColor = parseColor(color, this.format, this.gradientSettings.opacity);\n      const valueChange = parsedColor !== this.value;\n      if (valueChange) {\n        this.value = parsedColor;\n        this.valueChange.emit(parsedColor);\n        this.setHostElementAriaLabel();\n        this.notifyNgChanged(parsedColor);\n      }\n    }\n    /**\n     * @hidden\n     */\n    handlePopupBlur(event) {\n      if (!this.isActionSheetExpanded) {\n        if (this.popupBlurInvalid(event)) {\n          return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n        this.toggleWithEvents(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperKeyDown(event) {\n      if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {\n        event.preventDefault();\n        this.ngZone.run(() => {\n          this.toggleWithEvents(true);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    onApply() {\n      this.handleValueChange(this.flatColorPicker.selection);\n      this.toggleWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n    onCancel(e) {\n      this.flatColorPicker.resetSelection(e);\n      this.toggleWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n    handlePopupKeyDown(event) {\n      if (event.keyCode === Keys.Escape) {\n        this.toggleWithEvents(false);\n        this.host.nativeElement.focus();\n      }\n      if (event.keyCode === Keys.Tab) {\n        const currentElement = event.shiftKey ? this.firstFocusableElement.nativeElement : this.lastFocusableElement.nativeElement;\n        const nextElement = event.shiftKey ? this.lastFocusableElement.nativeElement : this.firstFocusableElement.nativeElement;\n        if (event.target === currentElement) {\n          event.preventDefault();\n          nextElement.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n      return false;\n    }\n    setHostElementAriaLabel() {\n      const ariaLabelValue = `${this.value ? this.value : this.localizationService.get('colorPickerNoColor')}`;\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);\n    }\n    handleClasses(value, input) {\n      const elem = this.host.nativeElement;\n      const classes = getStylingClasses('picker', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    popupBlurInvalid(ev) {\n      const focusInFlatColorPickerElement = this.popupRef?.popupElement?.contains(ev.relatedTarget);\n      const hostClicked = closest$1(ev.relatedTarget, element => element === this.host.nativeElement);\n      return Boolean(hostClicked || focusInFlatColorPickerElement);\n    }\n    toggleWithEvents(open) {\n      const sameState = this.isOpen === open;\n      if (this.disabled || this.readonly || sameState) {\n        return;\n      }\n      let eventArgs;\n      if (open) {\n        eventArgs = new ColorPickerOpenEvent();\n        this.open.emit(eventArgs);\n      } else {\n        eventArgs = new ColorPickerCloseEvent();\n        this.close.emit(eventArgs);\n      }\n      if (!eventArgs.isDefaultPrevented()) {\n        this.toggle(open);\n      }\n      if (open) {\n        this.focusFirstElement();\n      }\n    }\n    focusFirstElement() {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        if (this.flatColorPicker) {\n          const gradientDragHandle = this.flatColorPicker.gradient?.gradientDragHandle;\n          const palette = this.flatColorPicker.palette?.host;\n          const elementToFocus = gradientDragHandle ? gradientDragHandle : palette;\n          elementToFocus.nativeElement.focus();\n        }\n      });\n    }\n    openActionSheet() {\n      this.windowSize = this.adaptiveService.size;\n      this.actionSheet.toggle(true);\n      updateActionSheetAdaptiveAppearance(this.actionSheet, this.windowSize, this.renderer);\n    }\n    closeActionSheet() {\n      this.actionSheet.toggle(false);\n      this.focus();\n    }\n    openPopup() {\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.activeColor,\n        animate: this.popupSettings.animate,\n        appendTo: this.popupSettings.appendTo,\n        popupAlign: popupPosition,\n        anchorAlign: anchorPosition,\n        popupClass: 'k-colorpicker-popup',\n        content: this.popupTemplate,\n        positionMode: 'absolute'\n      });\n      this.renderer.setAttribute(this.popupRef.popupElement.querySelector('.k-colorpicker-popup'), 'id', `k-colorpicker-popup-${this.colorPickerId}`);\n      this.popupSubs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.toggleWithEvents(false);\n        if (!this.isOpen) {\n          this.host.nativeElement.focus({\n            preventScroll: true\n          });\n        }\n      }));\n    }\n    closePopup() {\n      if (!this.isOpen) {\n        return;\n      }\n      this.popupSubs.unsubscribe();\n      this.popupRef.close();\n      this.popupRef = null;\n    }\n    get firstFocusableElement() {\n      if (!this.flatColorPicker.header || this.views.length <= 1 && !this.flatColorPicker.clearButton) {\n        const gradient = this.flatColorPicker.gradient;\n        return gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;\n      }\n      return this.views.length > 1 ? this.flatColorPicker.header.viewButtonsCollection.toArray()[0] : this.flatColorPicker.header.clearButtonElement;\n    }\n    get lastFocusableElement() {\n      if (this.preview) {\n        return this.flatColorPicker.footer?.lastButton || this.adaptiveRenderer.applyButton.nativeElement;\n      }\n      if (this.flatColorPicker.palette) {\n        return this.flatColorPicker.palette.host;\n      }\n      const gradient = this.flatColorPicker.gradient;\n      const inputs = gradient && gradient.inputs;\n      if (gradient && inputs && inputs.formatView === 'hex') {\n        return inputs.hexInput;\n      }\n      return this.gradientSettings.opacity ? inputs.opacityInput.numericInput : inputs.blueInput.numericInput;\n    }\n    handleDomEvents(action, events) {\n      const hostElement = this.host.nativeElement;\n      events.forEach(ev => hostElement[`${action}EventListener`](ev, this.domFocusListener, true));\n    }\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n      const hostElement = this.host.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          this.handleWrapperFocus();\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', event => {\n          const closestPopup = this.popupRef ? closest$1(event.relatedTarget, element => element === this.flatColorPicker.host.nativeElement) : false;\n          const closestWrapper = closest$1(event.relatedTarget, element => element === this.host.nativeElement);\n          const closestActionSheet = this.isActionSheetExpanded ? closest$1(event.relatedTarget, element => element === this.actionSheet.element.nativeElement) : false;\n          if (!closestPopup && !closestWrapper && !closestActionSheet) {\n            this.handleWrapperBlur();\n          }\n        }));\n        this.handleDomEvents('add', DOM_FOCUS_EVENTS);\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', event => {\n          this.handleWrapperKeyDown(event);\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'click', event => {\n          this.ngZone.run(() => {\n            !this.isActionSheetExpanded && this.handleWrapperClick(event);\n          });\n        }));\n      });\n    }\n    handleHostId() {\n      const hostElement = this.host.nativeElement;\n      const existingId = hostElement.getAttribute('id');\n      if (existingId) {\n        this.focusableId = existingId;\n      } else {\n        const id = `k-${guid()}`;\n        hostElement.setAttribute('id', id);\n        this.focusableId = id;\n      }\n    }\n  }\n  _class61 = ColorPickerComponent;\n  _defineProperty(ColorPickerComponent, \"\\u0275fac\", function _class61_Factory(t) {\n    return new (t || _class61)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$2.PopupService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i3.AdaptiveService));\n  });\n  _defineProperty(ColorPickerComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class61,\n    selectors: [[\"kendo-colorpicker\"]],\n    viewQuery: function _class61_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c153, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c154, 7);\n        i0.ɵɵviewQuery(_c155, 7);\n        i0.ɵɵviewQuery(_c156, 5);\n        i0.ɵɵviewQuery(AdaptiveRendererComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.activeColor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.flatColorPicker = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);\n      }\n    },\n    hostVars: 20,\n    hostBindings: function _class61_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"aria-readonly\", ctx.ariaReadonly)(\"aria-expanded\", ctx.ariaExpanded)(\"tabindex\", ctx.hostTabindex)(\"dir\", ctx.direction)(\"role\", ctx.role)(\"aria-haspopup\", ctx.hasPopup)(\"aria-invalid\", ctx.isControlInvalid);\n        i0.ɵɵclassProp(\"k-colorpicker\", ctx.hostClasses)(\"k-icon-picker\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-focus\", ctx.focusedClass)(\"k-disabled\", ctx.disabledClass)(\"k-readonly\", ctx.readonly);\n      }\n    },\n    inputs: {\n      views: \"views\",\n      view: \"view\",\n      adaptiveMode: \"adaptiveMode\",\n      activeView: \"activeView\",\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      format: \"format\",\n      value: \"value\",\n      popupSettings: \"popupSettings\",\n      paletteSettings: \"paletteSettings\",\n      gradientSettings: \"gradientSettings\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      svgIcon: \"svgIcon\",\n      clearButton: \"clearButton\",\n      tabindex: \"tabindex\",\n      preview: \"preview\",\n      actionsLayout: \"actionsLayout\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      open: \"open\",\n      close: \"close\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      cancel: \"cancel\",\n      activeColorClick: \"activeColorClick\",\n      clearButtonClick: \"clearButtonClick\",\n      activeViewChange: \"activeViewChange\"\n    },\n    exportAs: [\"kendoColorPicker\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class61)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class61)\n    }, ColorPickerLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorPickerLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorpicker'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 13,\n    vars: 15,\n    consts: function () {\n      let i18n_157;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPicker component when the value is empty.\n         * @meaning kendo.colorpicker.colorPickerNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_158 = goog.getMsg(\"Colorpicker no color chosen\");\n        i18n_157 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_158;\n      } else {\n        i18n_157 = $localize`:kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty.:Colorpicker no color chosen`;\n      }\n      let i18n_159;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.\n         * @meaning kendo.colorpicker.flatColorPickerNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_160 = goog.getMsg(\"Flatcolorpicker no color chosen\");\n        i18n_159 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_160;\n      } else {\n        i18n_159 = $localize`:kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;\n      }\n      let i18n_161;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.colorpicker.colorGradientNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_162 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_161 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_162;\n      } else {\n        i18n_161 = $localize`:kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n      let i18n_163;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.colorpicker.colorPaletteNoColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_164 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_163 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_164;\n      } else {\n        i18n_163 = $localize`:kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n      let i18n_165;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.colorpicker.colorGradientHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_166 = goog.getMsg(\"Choose color\");\n        i18n_165 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_166;\n      } else {\n        i18n_165 = $localize`:kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n      let i18n_167;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.colorpicker.clearButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_168 = goog.getMsg(\"Clear value\");\n        i18n_167 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_168;\n      } else {\n        i18n_167 = $localize`:kendo.colorpicker.clearButton|The title for the clear button.:Clear value`;\n      }\n      let i18n_169;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.colorpicker.hueSliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_170 = goog.getMsg(\"Set hue\");\n        i18n_169 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_170;\n      } else {\n        i18n_169 = $localize`:kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n      let i18n_171;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.colorpicker.opacitySliderHandle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_172 = goog.getMsg(\"Set opacity\");\n        i18n_171 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_172;\n      } else {\n        i18n_171 = $localize`:kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n      let i18n_173;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.colorpicker.contrastRatio\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_174 = goog.getMsg(\"Contrast ratio\");\n        i18n_173 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_174;\n      } else {\n        i18n_173 = $localize`:kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n      let i18n_175;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the color preview pane.\n         * @meaning kendo.colorpicker.previewColor\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_176 = goog.getMsg(\"Color preview\");\n        i18n_175 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_176;\n      } else {\n        i18n_175 = $localize`:kendo.colorpicker.previewColor|The message for the color preview pane.:Color preview`;\n      }\n      let i18n_177;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the selected color pane.\n         * @meaning kendo.colorpicker.revertSelection\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_178 = goog.getMsg(\"Revert selection\");\n        i18n_177 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_178;\n      } else {\n        i18n_177 = $localize`:kendo.colorpicker.revertSelection|The message for the selected color pane.:Revert selection`;\n      }\n      let i18n_179;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the gradient view button.\n         * @meaning kendo.colorpicker.gradientView\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_180 = goog.getMsg(\"Gradient view\");\n        i18n_179 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_180;\n      } else {\n        i18n_179 = $localize`:kendo.colorpicker.gradientView|The message for the gradient view button.:Gradient view`;\n      }\n      let i18n_181;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the palette view button.\n         * @meaning kendo.colorpicker.paletteView\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_182 = goog.getMsg(\"Palette view\");\n        i18n_181 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_182;\n      } else {\n        i18n_181 = $localize`:kendo.colorpicker.paletteView|The message for the palette view button.:Palette view`;\n      }\n      let i18n_183;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.colorpicker.formatButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_184 = goog.getMsg(\"Change color format\");\n        i18n_183 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_184;\n      } else {\n        i18n_183 = $localize`:kendo.colorpicker.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n      let i18n_185;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Apply action button.\n         * @meaning kendo.colorpicker.applyButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_186 = goog.getMsg(\"Apply\");\n        i18n_185 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_186;\n      } else {\n        i18n_185 = $localize`:kendo.colorpicker.applyButton|The message for the Apply action button.:Apply`;\n      }\n      let i18n_187;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Cancel action button.\n         * @meaning kendo.colorpicker.cancelButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_188 = goog.getMsg(\"Cancel\");\n        i18n_187 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_188;\n      } else {\n        i18n_187 = $localize`:kendo.colorpicker.cancelButton|The message for the Cancel action button.:Cancel`;\n      }\n      let i18n_189;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the Close button.\n         * @meaning kendo.colorpicker.closeButton\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_190 = goog.getMsg(\"Close\");\n        i18n_189 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_190;\n      } else {\n        i18n_189 = $localize`:kendo.colorpicker.closeButton|The title for the Close button.:Close`;\n      }\n      let i18n_191;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the ActionSheet when in adaptive mode.\n         * @meaning kendo.colorpicker.adaptiveTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_192 = goog.getMsg(\"Choose Color\");\n        i18n_191 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_192;\n      } else {\n        i18n_191 = $localize`:kendo.colorpicker.adaptiveTitle|The title for the ActionSheet when in adaptive mode.:Choose Color`;\n      }\n      let i18n_193;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.colorpicker.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_194 = goog.getMsg(\"Red channel\");\n        i18n_193 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_194;\n      } else {\n        i18n_193 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;\n      }\n      let i18n_195;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the green color channel.\n         * @meaning kendo.colorpicker.greenChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_196 = goog.getMsg(\"Green channel\");\n        i18n_195 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_196;\n      } else {\n        i18n_195 = $localize`:kendo.colorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;\n      }\n      let i18n_197;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the blue color channel.\n         * @meaning kendo.colorpicker.blueChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_198 = goog.getMsg(\"Blue channel\");\n        i18n_197 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_198;\n      } else {\n        i18n_197 = $localize`:kendo.colorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;\n      }\n      let i18n_199;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the alpha color channel.\n         * @meaning kendo.colorpicker.alphaChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_200 = goog.getMsg(\"Alpha channel\");\n        i18n_199 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_200;\n      } else {\n        i18n_199 = $localize`:kendo.colorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;\n      }\n      let i18n_201;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the NumericTextBox representing the red color channel.\n         * @meaning kendo.colorpicker.redChannelLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_202 = goog.getMsg(\"R\");\n        i18n_201 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_202;\n      } else {\n        i18n_201 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;\n      }\n      let i18n_203;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the green color input.\n         * @meaning kendo.colorpicker.greenInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_204 = goog.getMsg(\"G\");\n        i18n_203 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_204;\n      } else {\n        i18n_203 = $localize`:kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;\n      }\n      let i18n_205;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the blue color input.\n         * @meaning kendo.colorpicker.blueInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_206 = goog.getMsg(\"B\");\n        i18n_205 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_206;\n      } else {\n        i18n_205 = $localize`:kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;\n      }\n      let i18n_207;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The placeholder for the HEX color input.\n         * @meaning kendo.colorpicker.hexInputPlaceholder\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_208 = goog.getMsg(\"HEX\");\n        i18n_207 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_208;\n      } else {\n        i18n_207 = $localize`:kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;\n      }\n      return [[\"kendoColorPickerLocalizedMessages\", \"\", \"colorPickerNoColor\", i18n_157, \"flatColorPickerNoColor\", i18n_159, \"colorGradientNoColor\", i18n_161, \"colorPaletteNoColor\", i18n_163, \"colorGradientHandle\", i18n_165, \"clearButton\", i18n_167, \"hueSliderHandle\", i18n_169, \"opacitySliderHandle\", i18n_171, \"contrastRatio\", i18n_173, \"previewColor\", i18n_175, \"revertSelection\", i18n_177, \"gradientView\", i18n_179, \"paletteView\", i18n_181, \"formatButton\", i18n_183, \"applyButton\", i18n_185, \"cancelButton\", i18n_187, \"closeButton\", i18n_189, \"adaptiveTitle\", i18n_191, \"redChannelLabel\", i18n_193, \"greenChannelLabel\", i18n_195, \"blueChannelLabel\", i18n_197, \"alphaChannelLabel\", i18n_199, \"redChannelLabel\", i18n_201, \"greenInputPlaceholder\", i18n_203, \"blueInputPlaceholder\", i18n_205, \"hexInputPlaceholder\", i18n_207], [1, \"k-input-inner\"], [\"activeColor\", \"\"], [1, \"k-value-icon\", \"k-color-preview\", 3, \"ngClass\"], [\"innerCssClass\", \"k-color-preview-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\", 4, \"ngIf\"], [1, \"k-color-preview-mask\"], [\"kendoButton\", \"\", \"tabindex\", \"-1\", \"type\", \"button\", \"icon\", \"caret-alt-down\", \"rounded\", \"none\", \"aria-hidden\", \"true\", 1, \"k-input-button\", 3, \"size\", \"svgIcon\", \"fillMode\", \"disabled\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"actionSheetTemplate\", \"isActionSheetExpanded\", \"preview\", \"actionSheetClose\", \"onApply\", \"onCancel\"], [3, \"resize\", 4, \"ngIf\"], [\"innerCssClass\", \"k-color-preview-icon\", 3, \"name\", \"customFontClass\", \"svgIcon\"], [3, \"value\", \"format\", \"size\", \"views\", \"activeView\", \"actionsLayout\", \"adaptiveMode\", \"preview\", \"gradientSettings\", \"paletteSettings\", \"clearButton\", \"cancel\", \"focusout\", \"valueChange\", \"keydown\", \"activeViewChange\", \"clearButtonClick\", \"actionButtonClick\"], [\"flatColorPicker\", \"\"], [3, \"resize\"]];\n    },\n    template: function _class61_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1, 2)(3, \"span\", 3);\n        i0.ɵɵtemplate(4, _class61_kendo_icon_wrapper_4_Template, 1, 3, \"kendo-icon-wrapper\", 4);\n        i0.ɵɵelement(5, \"span\", 5);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(6, \"button\", 6);\n        i0.ɵɵtemplate(7, _class61_ng_template_7_Template, 2, 11, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(9, null, 8);\n        i0.ɵɵelementStart(11, \"kendo-adaptive-renderer\", 9);\n        i0.ɵɵlistener(\"actionSheetClose\", function _class61_Template_kendo_adaptive_renderer_actionSheetClose_11_listener($event) {\n          return ctx.onCancel($event);\n        })(\"onApply\", function _class61_Template_kendo_adaptive_renderer_onApply_11_listener() {\n          return ctx.onApply();\n        })(\"onCancel\", function _class61_Template_kendo_adaptive_renderer_onCancel_11_listener($event) {\n          return ctx.onCancel($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, _class61_kendo_resize_sensor_12_Template, 1, 0, \"kendo-resize-sensor\", 10);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(8);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(12, _c209, ctx.customIconStyles || ctx.iconStyles || ctx.svgIcon, !ctx.value));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass || ctx.icon || ctx.svgIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"background-color\", ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"svgIcon\", ctx.arrowDownIcon)(\"fillMode\", ctx.fillMode)(\"disabled\", ctx.disabled);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"actionSheetTemplate\", _r2)(\"isActionSheetExpanded\", ctx.isActionSheetExpanded)(\"preview\", ctx.preview);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen || ctx.isAdaptiveModeEnabled);\n      }\n    },\n    dependencies: [LocalizedColorPickerMessagesDirective, NgClass, NgIf, IconWrapperComponent, ButtonComponent, FlatColorPickerComponent, ResizeSensorComponent, AdaptiveRendererComponent],\n    encapsulation: 2\n  }));\n  return ColorPickerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet ColorPickerCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class62;\n  class ColorPickerCustomMessagesComponent extends ColorPickerMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class62 = ColorPickerCustomMessagesComponent;\n  _defineProperty(ColorPickerCustomMessagesComponent, \"\\u0275fac\", function _class62_Factory(t) {\n    return new (t || _class62)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(ColorPickerCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class62,\n    selectors: [[\"kendo-colorpicker-messages\"], [\"kendo-flatcolorpicker-messages\"], [\"kendo-colorgradient-messages\"], [\"kendo-colorpalette-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColorPickerMessages,\n      useExisting: forwardRef(() => _class62)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class62_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return ColorPickerCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet serial$1 = 0;\n/**\n * Represents an error message that will be shown underneath\n * a Kendo control or native HTML form-bound component after a validation.\n */\nlet ErrorComponent = /*#__PURE__*/(() => {\n  var _class63;\n  class ErrorComponent {\n    constructor() {\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * Specifies the alignment of the Error message.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n      _defineProperty(this, \"align\", 'start');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"id\", `kendo-error-${serial$1++}`);\n      _defineProperty(this, \"roleAttribute\", 'alert');\n    }\n    get startClass() {\n      return this.align === 'start';\n    }\n    get endClass() {\n      return this.align === 'end';\n    }\n    get idAttribute() {\n      return this.id;\n    }\n  }\n  _class63 = ErrorComponent;\n  _defineProperty(ErrorComponent, \"\\u0275fac\", function _class63_Factory(t) {\n    return new (t || _class63)();\n  });\n  _defineProperty(ErrorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class63,\n    selectors: [[\"kendo-formerror\"]],\n    hostVars: 8,\n    hostBindings: function _class63_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.roleAttribute)(\"id\", ctx.idAttribute);\n        i0.ɵɵclassProp(\"k-form-error\", ctx.hostClass)(\"k-text-start\", ctx.startClass)(\"k-text-end\", ctx.endClass);\n      }\n    },\n    inputs: {\n      align: \"align\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c210,\n    decls: 1,\n    vars: 0,\n    template: function _class63_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return ErrorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet serial = 0;\n/**\n * Represents a hint message that will be shown underneath a form-bound component.\n */\nlet HintComponent = /*#__PURE__*/(() => {\n  var _class64;\n  class HintComponent {\n    constructor() {\n      /**\n       * Specifies the alignment of the Hint message.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n      _defineProperty(this, \"align\", 'start');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"id\", `kendo-hint-${serial++}`);\n      _defineProperty(this, \"hostClass\", true);\n    }\n    get startClass() {\n      return this.align === 'start';\n    }\n    get endClass() {\n      return this.align === 'end';\n    }\n    get idAttribute() {\n      return this.id;\n    }\n  }\n  _class64 = HintComponent;\n  _defineProperty(HintComponent, \"\\u0275fac\", function _class64_Factory(t) {\n    return new (t || _class64)();\n  });\n  _defineProperty(HintComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class64,\n    selectors: [[\"kendo-formhint\"]],\n    hostVars: 7,\n    hostBindings: function _class64_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.idAttribute);\n        i0.ɵɵclassProp(\"k-form-hint\", ctx.hostClass)(\"k-text-start\", ctx.startClass)(\"k-text-end\", ctx.endClass);\n      }\n    },\n    inputs: {\n      align: \"align\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c210,\n    decls: 1,\n    vars: 0,\n    template: function _class64_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return HintComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies a container for form-bound controls (Kendo controls or native HTML controls).\n * Applies styling and behavior rules.\n */\nlet FormFieldComponent = /*#__PURE__*/(() => {\n  var _class65;\n  class FormFieldComponent {\n    get errorClass() {\n      if (!this.control) {\n        return false;\n      }\n      return this.control.invalid && (this.control.touched || this.control.dirty);\n    }\n    get disabledClass() {\n      if (!this.control) {\n        return false;\n      }\n      // radiobutton group\n      if (this.isRadioControl(this.control)) {\n        return false;\n      }\n      return this.disabledControl() || this.disabledElement() || this.disabledKendoInput();\n    }\n    set formControls(formControls) {\n      this.validateFormControl(formControls);\n      this.control = formControls.first;\n    }\n    /**\n     * @hidden\n     */\n    get horizontal() {\n      return this.orientation === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    get hasHints() {\n      return this.showHints === 'always' ? true : this.showHintsInitial();\n    }\n    /**\n     * @hidden\n     */\n    get hasErrors() {\n      return this.showErrors === 'always' ? true : this.showErrorsInitial();\n    }\n    constructor(renderer, localizationService, hostElement) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"controlElementRefs\", void 0);\n      _defineProperty(this, \"kendoInput\", void 0);\n      _defineProperty(this, \"errorChildren\", void 0);\n      _defineProperty(this, \"hintChildren\", void 0);\n      /**\n       *\n       * Specifies when the Hint messages will be shown.\n       *\n       * The possible values are:\n       *\n       * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is\n       * `valid` or `untouched` and `pristine`.\n       * * `always`&mdash;Allows full control over the visibility of the hints.\n       *\n       */\n      _defineProperty(this, \"showHints\", 'initial');\n      /**\n       * Specifies the layout orientation of the form field.\n       *\n       * * The possible values are:\n       *\n       * * (Default) `vertical`\n       * * `horizontal`\n       */\n      _defineProperty(this, \"orientation\", 'vertical');\n      /**\n       * Specifies when the Error messages will be shown.\n       *\n       * The possible values are:\n       *\n       * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is\n       * `invalid` and `touched` or `dirty`.\n       * * `always`&mdash;Allows full control over the visibility of the errors.\n       *\n       */\n      _defineProperty(this, \"showErrors\", 'initial');\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"rtl\", false);\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      }));\n    }\n    ngAfterViewInit() {\n      this.setDescription();\n    }\n    ngAfterViewChecked() {\n      this.updateDescription();\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    disabledKendoInput() {\n      return this.kendoInput && this.kendoInput.disabled;\n    }\n    disabledControl() {\n      return this.control.disabled;\n    }\n    disabledElement() {\n      const elements = this.controlElementRefs.toArray();\n      return elements.every(e => e.nativeElement.hasAttribute('disabled'));\n    }\n    validateFormControl(formControls) {\n      if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {\n        throw new Error('The `kendo-formfield` component should contain ' + 'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' + 'or an ngModel(https://angular.io/api/forms/NgModel) binding.');\n      }\n    }\n    isControlGroup(formControls) {\n      if (!formControls.length) {\n        return false;\n      }\n      const name = formControls.first.name;\n      return formControls.toArray().every(c => c.name === name && this.isRadioControl(c));\n    }\n    isRadioControl(control) {\n      return control.valueAccessor instanceof RadioControlValueAccessor;\n    }\n    updateDescription() {\n      const controls = this.findControlElements().filter(c => !!c);\n      if (!controls) {\n        return;\n      }\n      controls.forEach(control => {\n        if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {\n          const ariaIds = this.generateDescriptionIds(control);\n          if (ariaIds !== '') {\n            this.renderer.setAttribute(control, 'aria-describedby', ariaIds);\n          } else {\n            this.renderer.removeAttribute(control, 'aria-describedby');\n          }\n        }\n      });\n    }\n    findControlElements() {\n      if (!this.controlElementRefs) {\n        return;\n      }\n      // the control is KendoInput and has focusableId - dropdowns, dateinputs, editor\n      if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {\n        // Editor requires special treatment when in iframe mode\n        const isEditor = this.kendoInput.focusableId.startsWith('k-editor');\n        return isEditor ? [this.kendoInput.viewMountElement] : [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];\n      }\n      return this.controlElementRefs.map(el => el.nativeElement);\n    }\n    generateDescriptionIds(control) {\n      const ids = new Set();\n      let errorAttribute = '';\n      if (control.hasAttribute('aria-describedby')) {\n        const attributes = control.getAttribute('aria-describedby').split(' ');\n        errorAttribute = attributes.filter(attr => attr.includes('kendo-error-'))[0];\n        attributes.forEach(attr => {\n          if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {\n            return;\n          }\n          ids.add(attr);\n        });\n      }\n      this.hintChildren.forEach(hint => {\n        ids.add(hint.id);\n      });\n      if (this.hasErrors) {\n        this.errorChildren.forEach(error => {\n          ids.add(error.id);\n        });\n      } else {\n        ids.delete(errorAttribute);\n      }\n      return Array.from(ids).join(' ');\n    }\n    showHintsInitial() {\n      if (!this.control) {\n        return true;\n      }\n      const {\n        valid,\n        untouched,\n        pristine\n      } = this.control;\n      return valid || untouched && pristine;\n    }\n    showErrorsInitial() {\n      if (!this.control) {\n        return false;\n      }\n      const {\n        invalid,\n        dirty,\n        touched\n      } = this.control;\n      return invalid && (dirty || touched);\n    }\n    setDescription() {\n      this.updateDescription();\n      this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));\n      this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));\n    }\n  }\n  _class65 = FormFieldComponent;\n  _defineProperty(FormFieldComponent, \"\\u0275fac\", function _class65_Factory(t) {\n    return new (t || _class65)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(FormFieldComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class65,\n    selectors: [[\"kendo-formfield\"]],\n    contentQueries: function _class65_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KendoInput, 7);\n        i0.ɵɵcontentQuery(dirIndex, NgControl, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgControl, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, ErrorComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, HintComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.formControls = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.controlElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.errorChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hintChildren = _t);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function _class65_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-form-field\", ctx.hostClass)(\"k-form-field-error\", ctx.errorClass)(\"k-form-field-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      showHints: \"showHints\",\n      orientation: \"orientation\",\n      showErrors: \"showErrors\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.formfield'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c212,\n    decls: 5,\n    vars: 2,\n    consts: [[1, \"k-form-field-wrap\"], [4, \"ngIf\"]],\n    template: function _class65_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c211);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"div\", 0);\n        i0.ɵɵprojection(2, 1);\n        i0.ɵɵtemplate(3, _class65_ng_content_3_Template, 1, 0, \"ng-content\", 1);\n        i0.ɵɵtemplate(4, _class65_ng_content_4_Template, 1, 0, \"ng-content\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasHints);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasErrors);\n      }\n    },\n    dependencies: [NgIf],\n    encapsulation: 2\n  }));\n  return FormFieldComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RadioButtonComponent = /*#__PURE__*/(() => {\n  var _class66;\n  class RadioButtonComponent extends RadioCheckBoxBase {\n    get defaultAttributes() {\n      return {\n        type: 'radio',\n        id: this.focusableId,\n        title: this.title,\n        tabindex: this.tabindex,\n        tabIndex: this.tabindex,\n        disabled: this.disabled ? '' : null,\n        value: this.value,\n        checked: this.checked,\n        name: this.name,\n        'aria-invalid': this.isControlInvalid\n      };\n    }\n    constructor(renderer, hostElement, cdr, ngZone, injector, localizationService) {\n      super('radio', hostElement, renderer, cdr, ngZone, injector);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Specifies the checked state of the RadioButton.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"checked\", false);\n      /**\n       * Fires each time the checked state is changed.\n       * When the state of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `checkedStateChange` event is not triggered because it\n       * might cause a mix-up with the built-in mechanisms of the `ngModel` or `formControl` bindings.\n       *\n       * Used to provide a two-way binding for the `checked` property.\n       */\n      _defineProperty(this, \"checkedChange\", new EventEmitter());\n      _defineProperty(this, \"subs\", new Subscription());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleChange\", $event => {\n        this.ngZone.run(() => {\n          this.checked = $event.target.checked;\n          this.checkedChange.emit(this.checked);\n          this.ngChange($event.target.value);\n        });\n      });\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.localizationService = localizationService;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      super.ngOnInit();\n      this.subs.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      }));\n    }\n    ngAfterViewInit() {\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      // Otherwise the view is not updated in Reactive Forms - https://github.com/angular/angular/issues/13792\n      if (this.control) {\n        this.subs.add(this.control.valueChanges.subscribe(e => {\n          this.control.control.setValue(e, {\n            emitEvent: false\n          });\n        }));\n      }\n    }\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.checked = value === this.value;\n    }\n  }\n  _class66 = RadioButtonComponent;\n  _defineProperty(RadioButtonComponent, \"\\u0275fac\", function _class66_Factory(t) {\n    return new (t || _class66)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(RadioButtonComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class66,\n    selectors: [[\"kendo-radiobutton\"]],\n    hostVars: 3,\n    hostBindings: function _class66_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-radio-wrap\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      checked: \"checked\"\n    },\n    outputs: {\n      checkedChange: \"checkedChange\"\n    },\n    exportAs: [\"kendoRadioButton\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.radiobutton'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class66),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class66)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 21,\n    consts: [[\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [\"type\", \"radio\", 1, \"k-radio\", 3, \"id\", \"disabled\", \"value\", \"name\", \"checked\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"]],\n    template: function _class66_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class66_Template_ng_container_isFocusedChange_0_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class66_Template_ng_container_handleBlur_0_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class66_Template_ng_container_onFocus_0_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵelement(1, \"input\", 1, 2);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabled)(\"k-checked\", ctx.checked)(\"k-invalid\", ctx.isControlInvalid);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"disabled\", ctx.disabled)(\"value\", ctx.value)(\"name\", ctx.name)(\"checked\", ctx.checked)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(18, _c37, ctx.handleInputBlur, ctx.handleChange));\n        i0.ɵɵattribute(\"title\", ctx.title)(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null);\n      }\n    },\n    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],\n    encapsulation: 2\n  }));\n  return RadioButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SIZE$3 = 'medium';\n/**\n * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"radio\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"radio\" kendoRadioButton />\n * ```\n */\nlet RadioButtonDirective = /*#__PURE__*/(() => {\n  var _class67;\n  class RadioButtonDirective {\n    /**\n     * The size property specifies the width and height of the RadioButton\n     * ([see example]({% slug appearance_radiobuttondirective %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$3;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    constructor(renderer, hostElement) {\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"kendoClass\", true);\n      _defineProperty(this, \"_size\", 'medium');\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n    }\n    ngAfterViewInit() {\n      // kept in sync with other inputs for easier refactoring\n      // to a common base class\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('radio', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n  }\n  _class67 = RadioButtonDirective;\n  _defineProperty(RadioButtonDirective, \"\\u0275fac\", function _class67_Factory(t) {\n    return new (t || _class67)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(RadioButtonDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class67,\n    selectors: [[\"input\", \"kendoRadioButton\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class67_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-radio\", ctx.kendoClass);\n      }\n    },\n    inputs: {\n      size: \"size\"\n    },\n    standalone: true\n  }));\n  return RadioButtonDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet RangeSliderCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class68;\n  class RangeSliderCustomMessagesComponent extends RangeSliderMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class68 = RangeSliderCustomMessagesComponent;\n  _defineProperty(RangeSliderCustomMessagesComponent, \"\\u0275fac\", function _class68_Factory(t) {\n    return new (t || _class68)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(RangeSliderCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class68,\n    selectors: [[\"kendo-rangeslider-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: RangeSliderMessages,\n      useExisting: forwardRef(() => _class68)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class68_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return RangeSliderCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the hovered rating item content. To define an item template, nest an `<ng-template>` tag\n * with the `kendoRatingHoveredItemTemplate` directive inside the `<kendo-rating>` tag\n * [see example](slug:templates_rating).\n * The index of the currently hovered item is available as an implicit context using the `let-index=\"index\"` syntax.\n */\nlet RatingHoveredItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class69;\n  class RatingHoveredItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class69 = RatingHoveredItemTemplateDirective;\n  _defineProperty(RatingHoveredItemTemplateDirective, \"\\u0275fac\", function _class69_Factory(t) {\n    return new (t || _class69)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(RatingHoveredItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class69,\n    selectors: [[\"\", \"kendoRatingHoveredItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return RatingHoveredItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the rating item content. To define an item template, nest an `<ng-template>` tag\n * with the `kendoRatingItemTemplate` directive inside the `<kendo-rating>` tag\n * [see example](slug:templates_rating).\n * The index of the current item is available as an implicit context using the `let-index=\"index\"` syntax.\n */\nlet RatingItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class70;\n  class RatingItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class70 = RatingItemTemplateDirective;\n  _defineProperty(RatingItemTemplateDirective, \"\\u0275fac\", function _class70_Factory(t) {\n    return new (t || _class70)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(RatingItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class70,\n    selectors: [[\"\", \"kendoRatingItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return RatingItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Renders the selected rating item content. To define an item template, nest an `<ng-template>` tag\n * with the `kendoRatingSelectedItemTemplate` directive inside the `<kendo-rating>` tag\n * [see example](slug:templates_rating).\n * The index of the currently selected item is available as an implicit context using the `let-index=\"index\"` syntax.\n */\nlet RatingSelectedItemTemplateDirective = /*#__PURE__*/(() => {\n  var _class71;\n  class RatingSelectedItemTemplateDirective {\n    constructor(templateRef) {\n      _defineProperty(this, \"templateRef\", void 0);\n      this.templateRef = templateRef;\n    }\n  }\n  _class71 = RatingSelectedItemTemplateDirective;\n  _defineProperty(RatingSelectedItemTemplateDirective, \"\\u0275fac\", function _class71_Factory(t) {\n    return new (t || _class71)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  });\n  _defineProperty(RatingSelectedItemTemplateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class71,\n    selectors: [[\"\", \"kendoRatingSelectedItemTemplate\", \"\"]],\n    standalone: true\n  }));\n  return RatingSelectedItemTemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI Rating component for Angular]({% slug overview_rating %}).\n */\nlet RatingComponent = /*#__PURE__*/(() => {\n  var _class72;\n  class RatingComponent {\n    /**\n     * The initial value of the Rating component.\n     * The component can use either NgModel or the `value` binding but not both of them at the same time.\n     *\n     */\n    set value(value) {\n      this._value = value;\n      this.updateRatingItems();\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the selection mode of the Rating ([see example]({% slug selection_rating %})).\n     *\n     * @default 'continuous'\n     *\n     */\n    set selection(selection) {\n      this._selection = selection;\n      this.updateRatingItems();\n    }\n    get selection() {\n      return this._selection;\n    }\n    /**\n     * Determines the precision of the Rating ([see example]({% slug precision_rating %})).\n     *\n     * @default 'item'\n     *\n     */\n    set precision(precision) {\n      this._precision = precision;\n      this.updateRatingItems();\n    }\n    get precision() {\n      return this._precision;\n    }\n    /**\n     * Sets the Rating label. It is not the native HTML `label` element, it is just a `span` element with the provided text ([see example]({% slug label_rating %})).\n     */\n\n    get isControlInvalid() {\n      return this.control?.invalid?.toString();\n    }\n    get valueMax() {\n      return this.itemsCount;\n    }\n    get valueNow() {\n      return this.value;\n    }\n    constructor(element, renderer, localizationService, cdr, zone) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"itemTemplate\", void 0);\n      _defineProperty(this, \"hoveredItemTemplate\", void 0);\n      _defineProperty(this, \"selectedItemTemplate\", void 0);\n      /**\n       * Determines whether the Rating is disabled ([see example]({% slug disabledstate_rating %})). To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_rating#toc-managing-the-rating-disabled-state-in-reactive-forms).\n       *\n       * @default false\n       *\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Determines whether the Rating is in its read-only state ([see example]({% slug readonly_rating %})).\n       *\n       * @default false\n       *\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Rating.\n       *\n       * @default 0\n       *\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      /**\n       * Sets the number of rating items ([see example]({% slug itemscount_rating %})).\n       *\n       * @default 5\n       *\n       */\n      _defineProperty(this, \"itemsCount\", 5);\n      _defineProperty(this, \"label\", void 0);\n      /**\n       * Sets custom Rating font icon ([see example]({% slug icon_rating %})).\n       */\n      _defineProperty(this, \"icon\", void 0);\n      /**\n       * Sets custom Rating SVG icon. It is the icon that is used for selected/hovered state ([see example]({% slug icon_rating %})).\n       */\n      _defineProperty(this, \"svgIcon\", starIcon);\n      /**\n       * Sets custom Rating SVG icon. It is the icon that is used for not selected/hovered state ([see example]({% slug icon_rating %})).\n       */\n      _defineProperty(this, \"svgIconOutline\", starOutlineIcon);\n      /**\n       * Fires each time the user selects a new value.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"valueMin\", 0);\n      _defineProperty(this, \"ariaRole\", 'slider');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"ratingItems\", []);\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      _defineProperty(this, \"rect\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_selection\", 'continuous');\n      _defineProperty(this, \"_precision\", 'item');\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.element = element;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.cdr = cdr;\n      this.zone = zone;\n      validatePackage(packageMetadata);\n    }\n    ngOnInit() {\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      }));\n      this.subscriptions.add(this.renderer.listen(this.element.nativeElement, 'blur', () => this.ngTouched()));\n      this.subscriptions.add(this.renderer.listen(this.element.nativeElement, 'keydown', event => this.onKeyDown(event)));\n      this.createRatingItems();\n    }\n    ngAfterViewInit() {\n      const items = this.element.nativeElement.querySelectorAll('.k-rating-item');\n      this.zone.runOutsideAngular(() => {\n        items.forEach((item, index) => this.subscriptions.add(this.renderer.listen(item, 'mousemove', event => this.onMouseMove(index, event))));\n      });\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * Focuses the Rating component.\n     */\n    focus() {\n      if (isDocumentAvailable() && !this.disabled) {\n        this.element.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the Rating component.\n     */\n    blur() {\n      if (isDocumentAvailable()) {\n        this.element.nativeElement.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n    createRatingItems() {\n      for (let i = 0; i < this.itemsCount; i++) {\n        const item = {\n          title: this.isHalf(i, this.value) ? String(i + 0.5) : String(i + 1),\n          selected: this.isSelected(i, this.value),\n          selectedIndicator: false,\n          hovered: false,\n          half: this.isHalf(i, this.value)\n        };\n        this.ratingItems.push(item);\n      }\n    }\n    /**\n     * @hidden\n     */\n    onMouseEnter(event) {\n      this.rect = event.target.getBoundingClientRect();\n    }\n    /**\n     * @hidden\n     */\n    onMouseMove(value, event) {\n      const halfPrecision = this.precision === 'half';\n      const isFirstHalf = halfPrecision && this.isFirstHalf(this.rect, event.clientX);\n      this.zone.run(() => this.ratingItems.forEach((item, index) => {\n        item.title = halfPrecision && value === index && isFirstHalf ? String(index + 0.5) : String(index + 1);\n        item.selected = item.hovered = this.isSelected(index, value + 1);\n        item.selectedIndicator = this.isSelected(index, this.value);\n        item.half = halfPrecision && value === index ? isFirstHalf : false;\n      }));\n    }\n    /**\n     * @hidden\n     */\n    onMouseOut() {\n      this.rect = null;\n      this.updateRatingItems();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    changeValue(index, event) {\n      const rect = event.target.getBoundingClientRect();\n      const isFirstHalf = this.isFirstHalf(rect, event.clientX);\n      const value = this.precision === 'half' && isFirstHalf ? index + 0.5 : index + 1;\n      if (!areSame(this.value, value)) {\n        this.value = value;\n        this.ngChange(this.value);\n        this.valueChange.emit(this.value);\n        this.updateRatingItems();\n        this.cdr.markForCheck();\n      }\n    }\n    /**\n     * @hidden\n     */\n    updateRatingItems() {\n      this.ratingItems.forEach((item, index) => {\n        item.title = this.isHalf(index, this.value) ? String(index + 0.5) : String(index + 1);\n        item.selected = this.isSelected(index, this.value);\n        item.selectedIndicator = this.isSelected(index, this.value);\n        item.hovered = false;\n        item.half = this.isHalf(index, this.value);\n      });\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n      this.updateRatingItems();\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    isSelected(index, value) {\n      return this.selection === 'single' ? index === Math.ceil(value - 1) : index <= Math.ceil(value - 1);\n    }\n    isHalf(index, value) {\n      return this.precision === 'half' && value > index && value < index + 1;\n    }\n    isFirstHalf(rect, clientX) {\n      const elementPosition = rect.x + rect.width / 2;\n      return this.direction === 'ltr' ? clientX < elementPosition : clientX > elementPosition;\n    }\n    onKeyDown(event) {\n      const decreaseValue = () => {\n        if (this.value <= 0) {\n          return;\n        }\n        this.value = this.precision === 'half' ? this.value - 0.5 : this.value - 1;\n        this.ngChange(this.value);\n        this.valueChange.emit(this.value);\n        this.updateRatingItems();\n        this.cdr.markForCheck();\n      };\n      const increaseValue = () => {\n        if (this.value >= this.itemsCount) {\n          return;\n        }\n        this.value = this.precision === 'half' ? this.value + 0.5 : this.value + 1;\n        this.ngChange(this.value);\n        this.valueChange.emit(this.value);\n        this.updateRatingItems();\n        this.cdr.markForCheck();\n      };\n      const setMinValue = () => {\n        if (!areSame(this.value, this.valueMin)) {\n          this.value = this.valueMin;\n          this.ngChange(this.value);\n          this.valueChange.emit(this.value);\n          this.updateRatingItems();\n          this.cdr.markForCheck();\n        }\n      };\n      const setMaxValue = () => {\n        if (!areSame(this.value, this.valueMax)) {\n          this.value = this.valueMax;\n          this.ngChange(this.value);\n          this.valueChange.emit(this.value);\n          this.updateRatingItems();\n          this.cdr.markForCheck();\n        }\n      };\n      if (event.keyCode === Keys.ArrowDown) {\n        decreaseValue();\n      }\n      if (event.keyCode === Keys.ArrowLeft) {\n        if (this.direction === 'ltr') {\n          decreaseValue();\n        } else {\n          increaseValue();\n        }\n      }\n      if (event.keyCode === Keys.ArrowUp) {\n        increaseValue();\n      }\n      if (event.keyCode === Keys.ArrowRight) {\n        if (this.direction === 'ltr') {\n          increaseValue();\n        } else {\n          decreaseValue();\n        }\n      }\n      if (event.keyCode === Keys.Home) {\n        setMinValue();\n      }\n      if (event.keyCode === Keys.End) {\n        setMaxValue();\n      }\n    }\n  }\n  _class72 = RatingComponent;\n  _defineProperty(RatingComponent, \"\\u0275fac\", function _class72_Factory(t) {\n    return new (t || _class72)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(RatingComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class72,\n    selectors: [[\"kendo-rating\"]],\n    contentQueries: function _class72_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, RatingItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, RatingHoveredItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, RatingSelectedItemTemplateDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hoveredItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectedItemTemplate = _t.first);\n      }\n    },\n    hostVars: 15,\n    hostBindings: function _class72_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-readonly\", ctx.readonly)(\"tabindex\", ctx.tabindex)(\"dir\", ctx.direction)(\"aria-invalid\", ctx.isControlInvalid)(\"aria-valuemin\", ctx.valueMin)(\"aria-valuemax\", ctx.valueMax)(\"aria-valuenow\", ctx.valueNow)(\"role\", ctx.ariaRole);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabled)(\"k-readonly\", ctx.readonly)(\"k-rating\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      itemsCount: \"itemsCount\",\n      value: \"value\",\n      selection: \"selection\",\n      precision: \"precision\",\n      label: \"label\",\n      icon: \"icon\",\n      svgIcon: \"svgIcon\",\n      svgIconOutline: \"svgIconOutline\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoRating\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.rating'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class72) /* eslint-disable-line*/\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class72)\n    }]), i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"k-rating-container\"], [\"class\", \"k-rating-item\", 3, \"title\", \"ngClass\", \"mouseenter\", \"mouseout\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-rating-label\", 4, \"ngIf\"], [1, \"k-rating-item\", 3, \"title\", \"ngClass\", \"mouseenter\", \"mouseout\", \"click\"], [4, \"ngIf\"], [\"size\", \"xlarge\", 3, \"name\", \"svgIcon\", 4, \"ngIf\"], [\"size\", \"xlarge\", 3, \"name\", 4, \"ngIf\"], [\"size\", \"xlarge\", 3, \"name\", \"svgIcon\"], [\"size\", \"xlarge\", 3, \"name\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-rating-precision-complement\"], [\"class\", \"k-rating-precision-part\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"k-rating-precision-part\", 3, \"ngStyle\"], [1, \"k-rating-label\"]],\n    template: function _class72_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtemplate(1, _class72_span_1_Template, 3, 7, \"span\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, _class72_span_2_Template, 2, 1, \"span\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.ratingItems);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.label);\n      }\n    },\n    dependencies: [NgFor, NgClass, NgIf, IconWrapperComponent, NgTemplateOutlet, NgStyle],\n    encapsulation: 2\n  }));\n  return RatingComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet SignatureMessages = /*#__PURE__*/(() => {\n  var _class73;\n  class SignatureMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the Clear button of the Signature.\n       */\n      _defineProperty(this, \"clear\", void 0);\n      /**\n       * The title of the Minimize button of the Signature.\n       */\n      _defineProperty(this, \"minimize\", void 0);\n      /**\n       * The title of the Maximize button of the Signature.\n       */\n      _defineProperty(this, \"maximize\", void 0);\n      /**\n       * The value of the Signature canvas element aria-label attribute.\n       */\n      _defineProperty(this, \"canvasLabel\", void 0);\n    }\n  }\n  _class73 = SignatureMessages;\n  _defineProperty(SignatureMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class73_BaseFactory;\n    return function _class73_Factory(t) {\n      return (ɵ_class73_BaseFactory || (ɵ_class73_BaseFactory = i0.ɵɵgetInheritedFactory(_class73)))(t || _class73);\n    };\n  }());\n  _defineProperty(SignatureMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class73,\n    selectors: [[\"kendo-signature-messages-base\"]],\n    inputs: {\n      clear: \"clear\",\n      minimize: \"minimize\",\n      maximize: \"maximize\",\n      canvasLabel: \"canvasLabel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return SignatureMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet SignatureCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class74;\n  class SignatureCustomMessagesComponent extends SignatureMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class74 = SignatureCustomMessagesComponent;\n  _defineProperty(SignatureCustomMessagesComponent, \"\\u0275fac\", function _class74_Factory(t) {\n    return new (t || _class74)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(SignatureCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class74,\n    selectors: [[\"kendo-signature-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SignatureMessages,\n      useExisting: forwardRef(() => _class74)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class74_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SignatureCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `close` event of the Signature component.\n */\nclass SignatureCloseEvent extends PreventableEvent {}\n\n/**\n * Arguments for the `open` event of the Signature component.\n */\nclass SignatureOpenEvent extends PreventableEvent {}\n\n/**\n * @hidden\n */\nlet LocalizedSignatureMessagesDirective = /*#__PURE__*/(() => {\n  var _class75;\n  class LocalizedSignatureMessagesDirective extends SignatureMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class75 = LocalizedSignatureMessagesDirective;\n  _defineProperty(LocalizedSignatureMessagesDirective, \"\\u0275fac\", function _class75_Factory(t) {\n    return new (t || _class75)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedSignatureMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class75,\n    selectors: [[\"\", \"kendoSignatureLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SignatureMessages,\n      useExisting: forwardRef(() => _class75)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedSignatureMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst noop = () => {};\nlet _id = 0;\nconst nextId = () => 'k-signature-focusable-' + _id++;\nconst FOCUSED_CLASS = 'k-focus';\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_FILL_MODE$2 = 'solid';\nconst DEFAULT_POPUP_SCALE = 3;\nconst DEFAULT_EXPORT_SCALE = 2;\nconst DEFAULT_COLOR = '#000000';\nconst DEFAULT_BACKGROUND_COLOR = '#ffffff';\nconst iconsMap = {\n  xIcon,\n  hyperlinkOpenIcon\n};\n/**\n * Represents the [Kendo UI Signature component for Angular]({% slug overview_signature %}).\n *\n * The Signature allows users to add a hand-drawn signature to forms.\n */\nlet SignatureComponent = /*#__PURE__*/(() => {\n  var _class76;\n  class SignatureComponent {\n    /**\n     * Gets or sets the value of the signature.\n     *\n     * The value is a Base64-encoded PNG image.\n     */\n    set value(value) {\n      if (value !== this._value) {\n        this._value = value;\n        if (this.instance) {\n          this.instance.loadImage(value);\n        }\n      }\n    }\n    get value() {\n      return this._value;\n    }\n    /**\n     * @hidden\n     */\n    svgIcon(name) {\n      return iconsMap[name];\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * The size property specifies the padding of the Signature internal controls\n     * ([see example]({% slug appearance_signature %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n    /**\n     * @hidden\n     */\n    get isEmpty() {\n      return !this.value;\n    }\n    /**\n     * @hidden\n     */\n    get canvasLabel() {\n      return this.getMessage('canvasLabel');\n    }\n    /**\n     * @hidden\n     */\n    get clearTitle() {\n      return this.getMessage('clear');\n    }\n    /**\n     * @hidden\n     */\n    get minimizeTitle() {\n      return this.getMessage('minimize');\n    }\n    /**\n     * @hidden\n     */\n    get maximizeTitle() {\n      return this.getMessage('maximize');\n    }\n    /**\n     * @hidden\n     */\n    get baseWidth() {\n      return this.width || this.element.nativeElement.offsetWidth;\n    }\n    /**\n     * @hidden\n     */\n    get baseHeight() {\n      return this.height || this.element.nativeElement.offsetHeight;\n    }\n    /**\n     * @hidden\n     */\n    get popupWidth() {\n      return this.baseWidth * this.popupScale;\n    }\n    /**\n     * @hidden\n     */\n    get popupHeight() {\n      return this.baseHeight * this.popupScale;\n    }\n    /**\n     * @hidden\n     */\n\n    /**\n     * @hidden\n     */\n    get showMaximize() {\n      return !(this.maximized || this.isDrawing || !this.maximizable || this.disabled);\n    }\n    /**\n     * @hidden\n     */\n    get showMinimize() {\n      return this.maximized && !this.isDrawing;\n    }\n    /**\n     * @hidden\n     */\n    get showClear() {\n      return !(this.isEmpty || this.isDrawing || this.readonly || this.disabled);\n    }\n    /**\n     * @hidden\n     */\n    get focused() {\n      return this.isFocused;\n    }\n    set focused(value) {\n      if (this.isFocused !== value && this.element) {\n        const wrap = this.element.nativeElement;\n        if (value && !this.maximized) {\n          this.renderer.addClass(wrap, FOCUSED_CLASS);\n        } else {\n          this.renderer.removeClass(wrap, FOCUSED_CLASS);\n        }\n        this.isFocused = value;\n      }\n    }\n    get options() {\n      return {\n        scale: this.maximized ? this.popupScale : 1,\n        color: this.color,\n        backgroundColor: this.backgroundColor,\n        strokeWidth: this.strokeWidth,\n        smooth: this.smooth,\n        readonly: this.readonly\n      };\n    }\n    constructor(element, renderer, ngZone, cd, localization, cdr) {\n      _defineProperty(this, \"element\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"cd\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"staticHostClasses\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", nextId());\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * Sets the read-only state of the Signature.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Sets the disabled state of the Signature. To disable the component in reactive forms, visit the following [article](slug:formssupport_signature#toc-managing-the-signature-disabled-state-in-reactive-forms)\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the width of the signature in pixels.\n       *\n       * The width can also be set using inline styles and CSS.\n       */\n      _defineProperty(this, \"width\", void 0);\n      /**\n       * The height of the signature in pixels.\n       *\n       * The height can also be set using inline styles and CSS.\n       */\n      _defineProperty(this, \"height\", void 0);\n      _defineProperty(this, \"size\", DEFAULT_SIZE$2);\n      /**\n       * The `rounded` property specifies the border radius of the signature\n       * ([see example](slug:appearance_signature#rounded-corners)).\n       *\n       * The possible values are:\n       * * `small`\n       * * `medium` (default)\n       * * `large`\n       * * `full` (not supported by the Signature)\n       * * `none`\n       */\n      _defineProperty(this, \"rounded\", DEFAULT_ROUNDED$2);\n      /**\n       * The `fillMode` property specifies the background and border styles of the signature\n       * ([see example](slug:appearance_signature#toc-fill-mode)).\n       *\n       * The possible values are:\n       * * `flat`\n       * * `solid` (default)\n       * * `outline`\n       * * `none`\n       */\n      _defineProperty(this, \"fillMode\", DEFAULT_FILL_MODE$2);\n      /**\n       * The stroke color of the signature.\n       *\n       * Accepts CSS color names and hex values.\n       *\n       * The default value is determined by the theme `$kendo-input-text` variable.\n       */\n      _defineProperty(this, \"color\", void 0);\n      /**\n       * The background color of the signature.\n       *\n       * Accepts CSS color names and hex values.\n       *\n       * The default value is determined by the theme `$kendo-input-bg` variable.\n       */\n      _defineProperty(this, \"backgroundColor\", void 0);\n      /**\n       * The stroke width of the signature.\n       *\n       * @default 1\n       */\n      _defineProperty(this, \"strokeWidth\", 1);\n      /**\n       * A flag indicating whether to smooth out signature lines.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"smooth\", false);\n      /**\n       * A flag indicating if the signature can be maximized.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"maximizable\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"maximized\", false);\n      /**\n       * The scale factor for the popup.\n       *\n       * The Signature width and height will be multiplied by the scale when showing the popup.\n       *\n       * @default 3\n       */\n      _defineProperty(this, \"popupScale\", DEFAULT_POPUP_SCALE);\n      /**\n       * The scale factor for the exported image.\n       *\n       * The Signature width and height will be multiplied by the scale when converting the signature to an image.\n       *\n       * @default 2\n       */\n      _defineProperty(this, \"exportScale\", DEFAULT_EXPORT_SCALE);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"parentLocalization\", void 0);\n      /**\n       * A flag indicating whether the dotted line should be displayed in the background.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"hideLine\", false);\n      /**\n       * Fires each time the signature value is changed.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n      _defineProperty(this, \"open\", new EventEmitter());\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires each time Signature is focused.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the Signature is blurred.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"minimize\", new EventEmitter());\n      _defineProperty(this, \"canvas\", void 0);\n      _defineProperty(this, \"minimizeButton\", void 0);\n      _defineProperty(this, \"maximizeButton\", void 0);\n      /**\n       * Indicates whether the Signature wrapper is focused.\n       */\n      _defineProperty(this, \"isFocused\", false);\n      /**\n       * Indicates whether the Signature popup is open.\n       */\n      _defineProperty(this, \"isOpen\", void 0);\n      _defineProperty(this, \"isDrawing\", false);\n      _defineProperty(this, \"notifyNgTouched\", noop);\n      _defineProperty(this, \"notifyNgChanged\", noop);\n      _defineProperty(this, \"instance\", void 0);\n      _defineProperty(this, \"_value\", void 0);\n      _defineProperty(this, \"_tabindex\", 0);\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"unsubscribe\", void 0);\n      _defineProperty(this, \"hostClasses\", []);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"popupValue\", void 0);\n      this.element = element;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.cd = cd;\n      this.localization = localization;\n      this.cdr = cdr;\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.subscriptions = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.applyHostClasses();\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this.readThemeColors();\n        this.instance.setOptions(this.options);\n      });\n      this.ngZone.runOutsideAngular(() => {\n        const element = this.canvas.nativeElement;\n        this.instance = new SignaturePad(element, {\n          ...this.options,\n          onChange: () => this.onValueChange(),\n          onDraw: () => this.onDraw(),\n          onDrawEnd: () => this.onDrawEnd()\n        });\n        if (this.value) {\n          this.instance.loadImage(this.value);\n        }\n        if (this.maximized) {\n          this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n            this.minimizeButton?.nativeElement.focus();\n          });\n        }\n        this.addEventListeners();\n      });\n    }\n    ngOnChanges(changes) {\n      if (anyChanged(['readonly', 'color', 'backgroundColor', 'strokeWidth', 'smooth'], changes, true)) {\n        this.instance.setOptions(this.options);\n      }\n      this.applyHostClasses();\n    }\n    ngOnDestroy() {\n      if (this.instance) {\n        this.instance.destroy();\n        this.instance = null;\n      }\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n        this.subscriptions = null;\n      }\n      if (this.unsubscribe) {\n        this.unsubscribe();\n        this.unsubscribe = null;\n      }\n    }\n    /**\n     * @hidden\n     */\n    onClear() {\n      this.reset();\n      this.valueChange.emit(undefined);\n      this.canvas.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    onValueChange() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const value = yield _this.instance.exportImage({\n          width: _this.baseWidth * _this.exportScale,\n          height: _this.baseHeight * _this.exportScale\n        });\n        _this._value = value;\n        _this.cd.markForCheck();\n        _this.ngZone.run(() => {\n          _this.valueChange.emit(value);\n          _this.notifyNgChanged(value);\n        });\n      })();\n    }\n    /**\n     * @hidden\n     */\n    onDialogValueChange(value) {\n      this.value = value;\n      this.valueChange.emit(value);\n      this.notifyNgTouched();\n      this.notifyNgChanged(value);\n    }\n    /**\n     * @hidden\n     */\n    onDialogClick(e) {\n      if (e.target.classList.contains('k-overlay')) {\n        this.isOpen = false;\n        this.maximizeButton?.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onDialogKeydown(e) {\n      if (e.keyCode === Keys.Escape) {\n        this.isOpen = false;\n        this.cd.detectChanges();\n        this.maximizeButton?.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    onDialogClose() {\n      const args = new SignatureCloseEvent();\n      this.close.next(args);\n      if (!args.isDefaultPrevented()) {\n        this.isOpen = false;\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          (this.maximizeButton || this.element)?.nativeElement?.focus();\n        });\n      }\n    }\n    /**\n     * Clears the value of the Signature.\n     */\n    reset() {\n      if (!isPresent(this.value)) {\n        return;\n      }\n      this.instance?.clear();\n      this.value = this._value = undefined;\n      this.notifyNgChanged(undefined);\n    }\n    /**\n     * Toggles the popup of the Signature.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n    toggle(open) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n      open = isPresent(open) ? open : !this.isOpen;\n      this.isOpen = open;\n    }\n    /**\n     * @hidden\n     */\n    onMaximize() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const args = new SignatureOpenEvent();\n        _this2.open.next(args);\n        if (!args.isDefaultPrevented()) {\n          _this2.popupValue = yield _this2.instance.exportImage({\n            width: _this2.popupWidth * _this2.exportScale,\n            height: _this2.popupHeight * _this2.exportScale\n          });\n          _this2.isOpen = true;\n          _this2.cd.detectChanges();\n        }\n      })();\n    }\n    /**\n     * @hidden\n     */\n    onMinimize() {\n      this.minimize.next();\n    }\n    applyHostClasses() {\n      const classList = this.element.nativeElement.classList;\n      this.hostClasses.forEach(([name]) => classList.remove(name));\n      this.hostClasses = [[`k-signature-${SIZE_MAP[this.size || DEFAULT_SIZE$2]}`, !isNone(this.size)], [`k-input-${this.fillMode || DEFAULT_FILL_MODE$2}`, !isNone(this.fillMode)], [`k-rounded-${ROUNDED_MAP[this.rounded || DEFAULT_ROUNDED$2]}`, !isNone(this.rounded)]];\n      this.hostClasses.forEach(([name, enabled]) => classList.toggle(name, enabled));\n    }\n    readThemeColors() {\n      let defaultColor = DEFAULT_COLOR;\n      let defaultBackgroundColor = DEFAULT_BACKGROUND_COLOR;\n      if (isDocumentAvailable()) {\n        const el = this.element.nativeElement;\n        defaultColor = getComputedStyle(el).color;\n        defaultBackgroundColor = getComputedStyle(el).backgroundColor;\n      }\n      this.color = this.color || defaultColor;\n      this.backgroundColor = this.backgroundColor || defaultBackgroundColor;\n    }\n    /**\n     * Focuses the wrapper of the Signature.\n     */\n    focus() {\n      this.focused = true;\n      this.element.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    onWrapperFocus() {\n      if (this.focused) {\n        return;\n      }\n      this.ngZone.run(() => {\n        this.focus();\n        this.onFocus.emit();\n      });\n    }\n    /**\n     * Blurs the Signature.\n     */\n    blur() {\n      this.focused = false;\n      this.element.nativeElement.blur();\n      this.notifyNgTouched();\n    }\n    /**\n     * @hidden\n     */\n    onWrapperBlur() {\n      if (this.isOpen) {\n        return;\n      }\n      this.ngZone.run(() => {\n        this.onBlur.emit();\n        this.focused = false;\n        this.notifyNgTouched();\n      });\n    }\n    /**\n     * @hidden\n     */\n    onWrapperClick(_event) {\n      if (this.disabled) {\n        return;\n      }\n      this.focus();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    onDraw() {\n      this.isDrawing = true;\n      this.cd.markForCheck();\n    }\n    onDrawEnd() {\n      this.isDrawing = false;\n      this.cd.markForCheck();\n    }\n    addEventListeners() {\n      const element = this.element.nativeElement;\n      const focusIn = this.renderer.listen(element, 'focusin', () => this.onWrapperFocus());\n      const focusOut = this.renderer.listen(element, 'focusout', e => {\n        const insideWrapper = closest$1(e.relatedTarget, element => element === this.element.nativeElement);\n        if (!insideWrapper) {\n          this.onWrapperBlur();\n        }\n      });\n      const click = this.renderer.listen(element, 'click', () => {\n        this.ngZone.run(e => {\n          this.onWrapperClick(e);\n        });\n      });\n      this.unsubscribe = () => {\n        focusIn();\n        focusOut();\n        click();\n      };\n    }\n    getMessage(key) {\n      if (this.maximized && this.parentLocalization) {\n        return this.parentLocalization.get(key);\n      }\n      return this.localization.get(key);\n    }\n  }\n  _class76 = SignatureComponent;\n  _defineProperty(SignatureComponent, \"\\u0275fac\", function _class76_Factory(t) {\n    return new (t || _class76)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  });\n  _defineProperty(SignatureComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class76,\n    selectors: [[\"kendo-signature\"]],\n    viewQuery: function _class76_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c216, 5);\n        i0.ɵɵviewQuery(_c217, 5, ElementRef);\n        i0.ɵɵviewQuery(_c218, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.minimizeButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.maximizeButton = _t.first);\n      }\n    },\n    hostVars: 13,\n    hostBindings: function _class76_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\")(\"height\", ctx.height, \"px\");\n        i0.ɵɵclassProp(\"k-signature\", ctx.staticHostClasses)(\"k-input\", ctx.staticHostClasses)(\"k-readonly\", ctx.readonly)(\"k-disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      width: \"width\",\n      height: \"height\",\n      value: \"value\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      color: \"color\",\n      backgroundColor: \"backgroundColor\",\n      strokeWidth: \"strokeWidth\",\n      smooth: \"smooth\",\n      maximizable: \"maximizable\",\n      maximized: \"maximized\",\n      popupScale: \"popupScale\",\n      exportScale: \"exportScale\",\n      parentLocalization: \"parentLocalization\",\n      hideLine: \"hideLine\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      open: \"open\",\n      close: \"close\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      minimize: \"minimize\"\n    },\n    exportAs: [\"kendoSignature\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.signature'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class76)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 10,\n    vars: 8,\n    consts: function () {\n      let i18n_219;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Clear button.\n         * @meaning kendo.signature.clear\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_220 = goog.getMsg(\"Clear\");\n        i18n_219 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_220;\n      } else {\n        i18n_219 = $localize`:kendo.signature.clear|The message for the Clear button.:Clear`;\n      }\n      let i18n_221;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Maximize button.\n         * @meaning kendo.signature.maximize\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_222 = goog.getMsg(\"Maximize\");\n        i18n_221 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_222;\n      } else {\n        i18n_221 = $localize`:kendo.signature.maximize|The message for the Maximize button.:Maximize`;\n      }\n      let i18n_223;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Minimize button.\n         * @meaning kendo.signature.minimize\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_224 = goog.getMsg(\"Minimize\");\n        i18n_223 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_224;\n      } else {\n        i18n_223 = $localize`:kendo.signature.minimize|The message for the Minimize button.:Minimize`;\n      }\n      let i18n_225;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Canvas element aria-label.\n         * @meaning kendo.signature.canvasLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_226 = goog.getMsg(\"Signature canvas\");\n        i18n_225 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_226;\n      } else {\n        i18n_225 = $localize`:kendo.signature.canvasLabel|The message for the Canvas element aria-label.:Signature canvas`;\n      }\n      return [[\"kendoSignatureLocalizedMessages\", \"\", \"clear\", i18n_219, \"maximize\", i18n_221, \"minimize\", i18n_223, \"canvasLabel\", i18n_225], [\"role\", \"img\", 1, \"k-signature-canvas\", 3, \"id\"], [\"canvas\", \"\"], [1, \"k-signature-actions\", \"k-signature-actions-top\"], [\"kendoButton\", \"\", \"type\", \"button\", \"class\", \"k-signature-action k-signature-maximize\", \"icon\", \"hyperlink-open\", \"fillMode\", \"flat\", 3, \"svgIcon\", \"size\", \"title\", \"click\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"type\", \"button\", \"class\", \"k-signature-action k-signature-minimize k-rotate-180\", \"icon\", \"hyperlink-open\", \"fillMode\", \"flat\", 3, \"svgIcon\", \"size\", \"title\", \"click\", 4, \"ngIf\"], [\"class\", \"k-signature-line\", 4, \"ngIf\"], [1, \"k-signature-actions\", \"k-signature-actions-bottom\"], [\"kendoButton\", \"\", \"class\", \"k-signature-action k-signature-clear\", \"icon\", \"close\", \"type\", \"button\", \"fillMode\", \"flat\", 3, \"svgIcon\", \"size\", \"title\", \"click\", 4, \"ngIf\"], [\"autoFocusedElement\", \".k-signature-action.k-signature-minimize\", 3, \"click\", \"keydown\", 4, \"ngIf\"], [\"kendoButton\", \"\", \"type\", \"button\", \"icon\", \"hyperlink-open\", \"fillMode\", \"flat\", 1, \"k-signature-action\", \"k-signature-maximize\", 3, \"svgIcon\", \"size\", \"title\", \"click\"], [\"maximize\", \"\"], [\"kendoButton\", \"\", \"type\", \"button\", \"icon\", \"hyperlink-open\", \"fillMode\", \"flat\", 1, \"k-signature-action\", \"k-signature-minimize\", \"k-rotate-180\", 3, \"svgIcon\", \"size\", \"title\", \"click\"], [\"minimize\", \"\"], [1, \"k-signature-line\"], [\"kendoButton\", \"\", \"icon\", \"close\", \"type\", \"button\", \"fillMode\", \"flat\", 1, \"k-signature-action\", \"k-signature-clear\", 3, \"svgIcon\", \"size\", \"title\", \"click\"], [\"autoFocusedElement\", \".k-signature-action.k-signature-minimize\", 3, \"click\", \"keydown\"], [3, \"readonly\", \"disabled\", \"size\", \"rounded\", \"fillMode\", \"color\", \"backgroundColor\", \"strokeWidth\", \"smooth\", \"value\", \"hideLine\", \"maximized\", \"width\", \"height\", \"popupScale\", \"exportScale\", \"parentLocalization\", \"valueChange\", \"minimize\"]];\n    },\n    template: function _class76_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelement(1, \"div\", 1, 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵtemplate(4, _class76_button_4_Template, 2, 4, \"button\", 4);\n        i0.ɵɵtemplate(5, _class76_button_5_Template, 2, 4, \"button\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, _class76_div_6_Template, 1, 0, \"div\", 6);\n        i0.ɵɵelementStart(7, \"div\", 7);\n        i0.ɵɵtemplate(8, _class76_button_8_Template, 1, 4, \"button\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, _class76_kendo_dialog_9_Template, 2, 19, \"kendo-dialog\", 9);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId);\n        i0.ɵɵattribute(\"tabindex\", ctx.tabindex)(\"aria-label\", ctx.canvasLabel);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMaximize);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMinimize);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.hideLine);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showClear);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    dependencies: [_class76, LocalizedSignatureMessagesDirective, NgIf, ButtonComponent, DialogComponent],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return SignatureComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet SliderCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class77;\n  class SliderCustomMessagesComponent extends SliderMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class77 = SliderCustomMessagesComponent;\n  _defineProperty(SliderCustomMessagesComponent, \"\\u0275fac\", function _class77_Factory(t) {\n    return new (t || _class77)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(SliderCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class77,\n    selectors: [[\"kendo-slider-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SliderMessages,\n      useExisting: forwardRef(() => _class77)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class77_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SliderCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet SwitchCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class78;\n  class SwitchCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class78 = SwitchCustomMessagesComponent;\n  _defineProperty(SwitchCustomMessagesComponent, \"\\u0275fac\", function _class78_Factory(t) {\n    return new (t || _class78)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(SwitchCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class78,\n    selectors: [[\"kendo-switch-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class78)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class78_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return SwitchCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the adornments in the prefix container ([see example]({% slug textarea_adornments %})).\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textarea>\n *    <kendo-textarea-prefix>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </kendo-textarea-prefix>\n *  </kendo-textarea>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextAreaPrefixComponent = /*#__PURE__*/(() => {\n  var _class79;\n  class TextAreaPrefixComponent {\n    constructor() {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"flow\", 'vertical');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"hostClass\", true);\n    }\n    get verticalOrientation() {\n      return this.orientation === 'vertical';\n    }\n    get horizontalOrientation() {\n      return this.orientation === 'horizontal';\n    }\n    get alignItems() {\n      return this.flow === this.orientation;\n    }\n  }\n  _class79 = TextAreaPrefixComponent;\n  _defineProperty(TextAreaPrefixComponent, \"\\u0275fac\", function _class79_Factory(t) {\n    return new (t || _class79)();\n  });\n  _defineProperty(TextAreaPrefixComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class79,\n    selectors: [[\"kendo-textarea-prefix\"]],\n    hostVars: 8,\n    hostBindings: function _class79_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input-prefix\", ctx.hostClass)(\"k-input-prefix-vertical\", ctx.verticalOrientation)(\"k-input-prefix-horizontal\", ctx.horizontalOrientation)(\"!k-align-items-start\", ctx.alignItems);\n      }\n    },\n    inputs: {\n      flow: \"flow\",\n      orientation: \"orientation\"\n    },\n    exportAs: [\"kendoTextAreaPrefix\"],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c210,\n    decls: 1,\n    vars: 0,\n    template: function _class79_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return TextAreaPrefixComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %})).\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textarea>\n *    <kendo-textarea-suffix>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </kendo-textarea-suffix>\n *  </kendo-textarea>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextAreaSuffixComponent = /*#__PURE__*/(() => {\n  var _class80;\n  class TextAreaSuffixComponent {\n    constructor() {\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"flow\", 'vertical');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"orientation\", 'horizontal');\n      _defineProperty(this, \"hostClass\", true);\n    }\n    get verticalOrientation() {\n      return this.orientation === 'vertical';\n    }\n    get horizontalOrientation() {\n      return this.orientation === 'horizontal';\n    }\n    get alignItems() {\n      return this.flow === this.orientation;\n    }\n  }\n  _class80 = TextAreaSuffixComponent;\n  _defineProperty(TextAreaSuffixComponent, \"\\u0275fac\", function _class80_Factory(t) {\n    return new (t || _class80)();\n  });\n  _defineProperty(TextAreaSuffixComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class80,\n    selectors: [[\"kendo-textarea-suffix\"]],\n    hostVars: 8,\n    hostBindings: function _class80_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input-suffix\", ctx.hostClass)(\"k-input-suffix-vertical\", ctx.verticalOrientation)(\"k-input-suffix-horizontal\", ctx.horizontalOrientation)(\"!k-align-items-start\", ctx.alignItems);\n      }\n    },\n    inputs: {\n      flow: \"flow\",\n      orientation: \"orientation\"\n    },\n    exportAs: [\"kendoTextAreaSuffix\"],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c210,\n    decls: 1,\n    vars: 0,\n    template: function _class80_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  }));\n  return TextAreaSuffixComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet TextFieldsBase = /*#__PURE__*/(() => {\n  var _class81;\n  class TextFieldsBase {\n    get disabledClass() {\n      return this.disabled;\n    }\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * Sets the `title` attribute of the internal textarea input element of the component.\n       */\n      _defineProperty(this, \"title\", '');\n      /**\n       * Sets the disabled state of the TextArea component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_textarea#toc-managing-the-textarea-disabled-state-in-reactive-forms).\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Sets the read-only state of the TextArea component.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Provides a value for the TextArea component.\n       */\n      _defineProperty(this, \"value\", null);\n      /**\n       * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"selectOnFocus\", false);\n      /**\n       * The hint, which is displayed when the Textarea is empty.\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      /**\n       * Fires each time the user focuses the internal textarea element of the component.\n       * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.\n       */\n      _defineProperty(this, \"inputFocus\", new EventEmitter());\n      /**\n       * Fires each time the internal textarea element gets blurred.\n       * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.\n       */\n      _defineProperty(this, \"inputBlur\", new EventEmitter());\n      /**\n       * Represents the visible textarea element of the component.\n       */\n      _defineProperty(this, \"input\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"control\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputBlur\", () => {\n        this.changeDetector.markForCheck();\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.inputBlur.emit();\n          });\n        }\n      });\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n  }\n  _class81 = TextFieldsBase;\n  _defineProperty(TextFieldsBase, \"\\u0275fac\", function _class81_Factory(t) {\n    return new (t || _class81)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(TextFieldsBase, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class81,\n    selectors: [[\"kendo-textfield-base\"]],\n    viewQuery: function _class81_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function _class81_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-readonly\", ctx.readonly)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      value: \"value\",\n      selectOnFocus: \"selectOnFocus\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function _class81_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return TextFieldsBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst resizeClasses = {\n  'vertical': 'k-resize-y',\n  'horizontal': 'k-resize-x',\n  'both': 'k-resize',\n  'none': 'k-resize-none',\n  'auto': 'k-resize-none'\n};\nconst FOCUSED = 'k-focus';\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED$1 = 'medium';\nconst DEFAULT_FILL_MODE$1 = 'solid';\n/**\n * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).\n */\nlet TextAreaComponent = /*#__PURE__*/(() => {\n  var _class82;\n  class TextAreaComponent extends TextFieldsBase {\n    get flowCol() {\n      return this.flow === 'vertical';\n    }\n    get flowRow() {\n      return this.flow === 'horizontal';\n    }\n    /**\n     * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify\n     * their position in relation to the textarea element.\n     *\n     * The possible values are:\n     * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.\n     * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.\n     */\n    set flow(flow) {\n      this._flow = flow;\n      if (this.prefix) {\n        this.prefix.flow = flow;\n      }\n      if (this.suffix) {\n        this.suffix.flow = flow;\n      }\n    }\n    get flow() {\n      return this._flow;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      if (isObjectPresent(this.parsedAttributes)) {\n        removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);\n      }\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    /**\n     * Specifies the orientation of the TextArea adornments. This property is used in order to specify\n     * the adornments' position relative to themselves.\n     *\n     * The possible values are:\n     * * `horizontal`(Default) &mdash;TextArea adornments are placed from left to right in `ltr`, and from right to left in `rtl` mode.\n     * * `vertical`&mdash;TextArea adornments are placed from top to bottom.\n     */\n    set adornmentsOrientation(orientation) {\n      this._adornmentsOrientation = orientation;\n      if (this.prefix) {\n        this.prefix.orientation = orientation;\n      }\n      if (this.suffix) {\n        this.suffix.orientation = orientation;\n      }\n    }\n    get adornmentsOrientation() {\n      return this._adornmentsOrientation;\n    }\n    /**\n     *  Specifies the visible height of the textarea element in lines.\n     */\n\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Configures the resize behavior of the TextArea.\n     *\n     * The possible values are:\n     * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.\n     * * `horizontal`&mdash;The TextArea component can be resized only horizontally.\n     * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.\n     * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.\n     * * `none`&mdash;The TextArea cannot be resized.\n     *\n     */\n\n    /**\n     * The size property specifies the padding of the internal textarea element\n     * ([see example]({% slug appearance_textarea %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The `rounded` property specifies the border radius of the TextArea\n     * ([see example](slug:appearance_textarea#toc-roundness)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The `fillMode` property specifies the background and border styles of the TextArea\n     * ([see example](slug:appearance_textarea#toc-fill-mode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Specifies whether the prefix separator of the TextArea is rendered.\n     * If a prefix template is not declared, the separator will not be rendered, regardless of the parameter value.\n     *\n     * @default false\n     */\n\n    get defaultAttributes() {\n      return {\n        id: this.focusableId,\n        disabled: this.disabled ? '' : null,\n        readonly: this.readonly ? '' : null,\n        tabindex: this.disabled ? undefined : this.tabIndex,\n        placeholder: this.placeholder,\n        title: this.title,\n        maxlength: this.maxlength,\n        rows: this.rows,\n        cols: this.cols,\n        'aria-disabled': this.disabled ? true : undefined,\n        'aria-readonly': this.readonly ? true : undefined,\n        'aria-invalid': this.isControlInvalid,\n        required: this.isControlRequired ? '' : null\n      };\n    }\n    get mutableAttributes() {\n      return {\n        'aria-multiline': 'true'\n      };\n    }\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"changeDetector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"focusableId\", `k-${guid()}`);\n      _defineProperty(this, \"hostClasses\", true);\n      _defineProperty(this, \"_flow\", 'vertical');\n      _defineProperty(this, \"rows\", void 0);\n      /**\n       * Specifies the visible width of the textarea element (in average character width).\n       */\n      _defineProperty(this, \"cols\", void 0);\n      /**\n       * Specifies the maximum number of characters that the user can enter in the TextArea component.\n       */\n      _defineProperty(this, \"maxlength\", void 0);\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n      _defineProperty(this, \"tabindex\", 0);\n      _defineProperty(this, \"resizable\", 'vertical');\n      _defineProperty(this, \"showPrefixSeparator\", false);\n      /**\n       * Specifies whether the suffix separator of the TextArea is rendered.\n       * If a suffix template is not declared, the separator will not be rendered, regardless of the parameter value.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"showSuffixSeparator\", false);\n      /**\n       * Fires each time the user focuses the TextArea component.\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textarea (focus)=\"handleFocus()\"></kendo-textarea>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log('Component is focused.');\n       *   }\n       * }\n       * ```\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the TextArea component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textarea (blur)=\"handleBlur()\"></kendo-textarea>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log('Component is blurred');\n       *   }\n       * }\n       * ```\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      /**\n       * Fires each time the value is changed or the component is blurred\n       * ([see example](slug:events_textarea)).\n       * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.\n       */\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      _defineProperty(this, \"initialHeight\", void 0);\n      _defineProperty(this, \"resizeSubscription\", void 0);\n      _defineProperty(this, \"_size\", 'medium');\n      _defineProperty(this, \"_rounded\", 'medium');\n      _defineProperty(this, \"_fillMode\", 'solid');\n      _defineProperty(this, \"_adornmentsOrientation\", 'horizontal');\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"prefix\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"suffix\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInput\", ev => {\n        const incomingValue = ev.target.value;\n        this.updateValue(incomingValue);\n        this.resize();\n      });\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"handleInputFocus\", () => {\n        if (!this.disabled) {\n          if (this.selectOnFocus && this.value) {\n            this.ngZone.run(() => {\n              setTimeout(() => {\n                this.selectAll();\n              });\n            });\n          }\n          if (!this.isFocused) {\n            this.handleFocus();\n          }\n          if (hasObservers(this.inputFocus)) {\n            if (!this.focusChangedProgrammatically) {\n              this.ngZone.run(() => {\n                this.inputFocus.emit();\n              });\n            }\n          }\n        }\n      });\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.handleFlow();\n      });\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n      if (isDocumentAvailable() && this.resizable === 'auto') {\n        this.resizeSubscription = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(() => this.resize());\n      }\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    ngOnChanges(changes) {\n      const hostElement = this.hostElement.nativeElement;\n      const element = this.input.nativeElement;\n      if (changes.flow) {\n        this.handleFlow();\n      }\n      if (changes.resizable) {\n        if (this.resizable === 'auto') {\n          this.renderer.removeClass(element, '\\!k-overflow-y-auto');\n          this.initialHeight = element.offsetHeight;\n        } else if (this.resizable !== 'both') {\n          this.renderer.addClass(element, '\\!k-overflow-y-auto');\n          element.style.height = `${this.initialHeight}px`;\n        }\n      }\n      if (changes.cols) {\n        if (isPresent(changes.cols.currentValue)) {\n          this.renderer.setStyle(hostElement, 'width', 'auto');\n        } else {\n          this.renderer.removeStyle(hostElement, 'width');\n        }\n      }\n      if (changes.value) {\n        this.resize();\n      }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n      this.resize();\n      this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n    get resizableClass() {\n      return resizeClasses[this.resizable];\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.control && this.control.touched && !this.control.valid;\n    }\n    /**\n     * @hidden\n     */\n    get isControlRequired() {\n      return isControlRequired(this.control?.control);\n    }\n    /**\n     * @hidden\n     */\n    get separatorOrientation() {\n      return this.flow === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set isFocused(value) {\n      if (this._isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n        if (value && !this.disabled) {\n          this.renderer.addClass(element, FOCUSED);\n        } else {\n          this.renderer.removeClass(element, FOCUSED);\n        }\n        this._isFocused = value;\n      }\n    }\n    /**\n     * Focuses the TextArea component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"textarea.focus()\">Focus the textarea</button>\n     *  <kendo-textarea #textarea></kendo-textarea>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n      if (!this.input) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.input.nativeElement.focus();\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextArea component.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n    resize() {\n      if (this.resizable !== 'auto') {\n        return;\n      }\n      // The logic of the resize method, does not depend on Angular and thus moving it outisde of it\n      // We need to ensure that the resizing logic runs after the value is updated thus the setTimout\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          const hostElement = this.hostElement.nativeElement;\n          const element = this.input.nativeElement;\n          this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);\n          const scrollHeight = element.scrollHeight;\n          this.renderer.setStyle(hostElement, 'min-height', `${scrollHeight}px`);\n          if (scrollHeight > this.initialHeight) {\n            this.renderer.setStyle(element, 'height', `${scrollHeight}px`);\n          }\n        }, 0);\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      this.changeDetector.markForCheck();\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.onBlur.emit();\n        }\n        this.isFocused = false;\n      });\n    }\n    setSelection(start, end) {\n      if (this.isFocused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n    selectAll() {\n      if (this.value) {\n        this.setSelection(0, this.value.length);\n      }\n    }\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n    handleFlow() {\n      const isVertical = this.flow === 'vertical';\n      const element = this.input.nativeElement;\n      this.renderer[isVertical ? 'addClass' : 'removeClass'](element, '\\!k-flex-none');\n    }\n    setInputAttributes() {\n      const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);\n      setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);\n    }\n  }\n  _class82 = TextAreaComponent;\n  _defineProperty(TextAreaComponent, \"\\u0275fac\", function _class82_Factory(t) {\n    return new (t || _class82)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(TextAreaComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class82,\n    selectors: [[\"kendo-textarea\"]],\n    contentQueries: function _class82_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TextAreaPrefixComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, TextAreaSuffixComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefix = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffix = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function _class82_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-textarea\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"!k-flex-col\", ctx.flowCol)(\"!k-flex-row\", ctx.flowRow);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      flow: \"flow\",\n      inputAttributes: \"inputAttributes\",\n      adornmentsOrientation: \"adornmentsOrientation\",\n      rows: \"rows\",\n      cols: \"cols\",\n      maxlength: \"maxlength\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      resizable: \"resizable\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      showPrefixSeparator: \"showPrefixSeparator\",\n      showSuffixSeparator: \"showSuffixSeparator\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoTextArea\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.textarea'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class82),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class82)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c228,\n    decls: 7,\n    vars: 26,\n    consts: [[\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [3, \"orientation\", 4, \"ngIf\"], [1, \"k-input-inner\", \"!k-overflow-auto\", 3, \"id\", \"ngClass\", \"value\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"], [3, \"orientation\"]],\n    template: function _class82_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c227);\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class82_Template_ng_container_isFocusedChange_0_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class82_Template_ng_container_handleBlur_0_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class82_Template_ng_container_onFocus_0_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵprojection(1);\n        i0.ɵɵtemplate(2, _class82_kendo_input_separator_2_Template, 1, 1, \"kendo-input-separator\", 1);\n        i0.ɵɵelement(3, \"textarea\", 2, 3);\n        i0.ɵɵtemplate(5, _class82_kendo_input_separator_5_Template, 1, 1, \"kendo-input-separator\", 1);\n        i0.ɵɵprojection(6, 1);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefix && ctx.showPrefixSeparator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"ngClass\", ctx.resizableClass)(\"value\", ctx.value)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(22, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));\n        i0.ɵɵattribute(\"aria-multiline\", true)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-invalid\", ctx.isControlInvalid)(\"required\", ctx.isControlRequired ? \"\" : null)(\"placeholder\", ctx.placeholder)(\"rows\", ctx.rows)(\"cols\", ctx.cols)(\"tabindex\", ctx.tabIndex)(\"title\", ctx.title)(\"maxlength\", ctx.maxlength)(\"aria-invalid\", ctx.isControlInvalid);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffix && ctx.showSuffixSeparator);\n      }\n    },\n    dependencies: [SharedInputEventsDirective, NgIf, InputSeparatorComponent, NgClass, EventsOutsideAngularDirective],\n    encapsulation: 2\n  }));\n  return TextAreaComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet TextBoxCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class83;\n  class TextBoxCustomMessagesComponent extends TextBoxMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class83 = TextBoxCustomMessagesComponent;\n  _defineProperty(TextBoxCustomMessagesComponent, \"\\u0275fac\", function _class83_Factory(t) {\n    return new (t || _class83)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(TextBoxCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class83,\n    selectors: [[\"kendo-textbox-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TextBoxMessages,\n      useExisting: forwardRef(() => _class83)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class83_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return TextBoxCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet OTPInputSeparatorComponent = /*#__PURE__*/(() => {\n  var _class84;\n  class OTPInputSeparatorComponent {\n    constructor() {\n      _defineProperty(this, \"wrapperClass\", true);\n      _defineProperty(this, \"hasText\", void 0);\n      _defineProperty(this, \"hasIconClass\", void 0);\n      _defineProperty(this, \"hasSVGIcon\", void 0);\n      _defineProperty(this, \"hasFontIcon\", void 0);\n      _defineProperty(this, \"separatorIconString\", void 0);\n      _defineProperty(this, \"separatorSVGIcon\", void 0);\n      _defineProperty(this, \"_separator\", void 0);\n    }\n    set separator(otpSeparator) {\n      this._separator = otpSeparator;\n      this.clearSeparator();\n      if (!isPresent$1(otpSeparator)) {\n        return;\n      }\n      if (typeof otpSeparator === 'string') {\n        this.hasText = true;\n        return;\n      }\n      if (typeof otpSeparator.value !== 'string') {\n        this.hasSVGIcon = otpSeparator?.type === 'svgIcon';\n        this.separatorSVGIcon = otpSeparator.value;\n        return;\n      }\n      this.hasIconClass = otpSeparator?.type === 'iconClass';\n      this.hasFontIcon = otpSeparator?.type === 'fontIcon';\n      this.separatorIconString = otpSeparator.value;\n    }\n    get separator() {\n      return this._separator;\n    }\n    clearSeparator() {\n      this.hasText = false;\n      this.hasFontIcon = false;\n      this.hasIconClass = false;\n      this.hasSVGIcon = false;\n    }\n  }\n  _class84 = OTPInputSeparatorComponent;\n  _defineProperty(OTPInputSeparatorComponent, \"\\u0275fac\", function _class84_Factory(t) {\n    return new (t || _class84)();\n  });\n  _defineProperty(OTPInputSeparatorComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class84,\n    selectors: [[\"kendo-otpinput-separator\"]],\n    hostVars: 2,\n    hostBindings: function _class84_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-otp-separator\", ctx.wrapperClass);\n      }\n    },\n    inputs: {\n      separator: \"separator\"\n    },\n    exportAs: [\"kendoOTPInputSeparator\"],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [3, \"name\", \"svgIcon\", 4, \"ngIf\"], [3, \"ngClass\"], [3, \"name\", \"svgIcon\"]],\n    template: function _class84_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class84_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, _class84_span_1_Template, 1, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class84_kendo_icon_wrapper_2_Template, 1, 2, \"kendo-icon-wrapper\", 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.hasText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasIconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasFontIcon || ctx.hasSVGIcon);\n      }\n    },\n    dependencies: [NgIf, NgClass, IconWrapperComponent],\n    encapsulation: 2\n  }));\n  return OTPInputSeparatorComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet OTPInputMessages = /*#__PURE__*/(() => {\n  var _class85;\n  class OTPInputMessages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The aria-label of the OTP Input. Follows the pattern **Input {currentInput} of {totalInputs}, current value {value}** by default.\n       * Тhe default label text when the current input is 1, and the total number of inputs is 4 will be\n       * **Input 1 of 4, current value null**.\n       *\n       * The message consists of several parts - the current input number, the total number of inputs, the current value and a localizable string.\n       * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current input,\n       * total number of inputs and current value. The `{currentInput}`, `{totalInputs}` and `{currentValue}` placeholders will be\n       * replaced internally with the respective actual values.\n       */\n      _defineProperty(this, \"ariaLabel\", void 0);\n    }\n  }\n  _class85 = OTPInputMessages;\n  _defineProperty(OTPInputMessages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class85_BaseFactory;\n    return function _class85_Factory(t) {\n      return (ɵ_class85_BaseFactory || (ɵ_class85_BaseFactory = i0.ɵɵgetInheritedFactory(_class85)))(t || _class85);\n    };\n  }());\n  _defineProperty(OTPInputMessages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class85,\n    selectors: [[\"kendo-otpinput-messages-base\"]],\n    inputs: {\n      ariaLabel: \"ariaLabel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return OTPInputMessages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedOTPInputMessagesDirective = /*#__PURE__*/(() => {\n  var _class86;\n  class LocalizedOTPInputMessagesDirective extends OTPInputMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class86 = LocalizedOTPInputMessagesDirective;\n  _defineProperty(LocalizedOTPInputMessagesDirective, \"\\u0275fac\", function _class86_Factory(t) {\n    return new (t || _class86)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedOTPInputMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class86,\n    selectors: [[\"\", \"kendoOTPInputLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: OTPInputMessages,\n      useExisting: forwardRef(() => _class86)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedOTPInputMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_ROUNDED = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\nconst DEFAULT_OTPINPUT_LENGTH = 4;\nlet OTPInputComponent = /*#__PURE__*/(() => {\n  var _class87;\n  class OTPInputComponent {\n    /**\n     * Configures the total number of input fields.\n     *\n     * @default 4\n     */\n    set length(value) {\n      if (value < 1 || this._length === value) {\n        return;\n      }\n      this._length = value;\n      this.inputsArray = new Array(this._length);\n    }\n    get length() {\n      return this._length;\n    }\n    /**\n     * Configures the input type.\n     *\n     * * The possible values are:\n     * * `text` (default)\n     * * `number`\n     * * `password`\n     *\n     * @default 'text'\n     */\n\n    /**\n     * Configures the length of the groups. If `groupLength` is a number, all groups will have the same length. If it's an array, each group can have a different length.\n     */\n    get groupLength() {\n      return this._groupLength;\n    }\n    set groupLength(length) {\n      const isNumber = typeof length === 'number';\n      if (this._groupLength === length || isPresent$1(length) && (isNumber && (length < 1 || length > this.length) || !isNumber && !this.isValidGroupArray(length))) {\n        return;\n      }\n      if (!isPresent$1(length)) {\n        this.clearGroups();\n      } else if (isNumber) {\n        this.populateGroupArray(length);\n      } else {\n        this.groupLengthArray = length;\n        if (!this.spacing) {\n          this.adjacentGroups = this.groupLengthArray;\n        }\n      }\n      this._groupLength = length;\n      this.populateSeparatorPositions();\n    }\n    /**\n     * Configures the value of the component. Unfilled input fields are represented with space.\n     */\n    get value() {\n      return this._value;\n    }\n    set value(input) {\n      const isInvalidInput = this.type === 'number' && isPresent$1(input) && !this.containsDigitsOrSpaces(input);\n      if (this._value === input || isInvalidInput) {\n        return;\n      }\n      if (!isPresent$1(input)) {\n        this.clearInputValues();\n        this._value = null;\n      } else {\n        this._value = input.slice(0, this.length);\n        if (!this.inputFieldValueChanged) {\n          this.fillInputs(input, 0, true);\n        }\n      }\n      if (this.inputAttributes) {\n        this.setInputAttributes();\n      } else {\n        this.setDefaultAttributes();\n      }\n    }\n    /**\n     * The `size` property specifies the padding of the input fields.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n    set size(size) {\n      const newSize = size || DEFAULT_SIZE;\n      const elem = this.hostElement.nativeElement;\n      this.renderer.removeClass(elem, `k-otp-${SIZE_MAP[this._size]}`);\n      this.renderer.addClass(elem, `k-otp-${SIZE_MAP[newSize]}`);\n      this._size = newSize;\n    }\n    get size() {\n      return this._size;\n    }\n    /**\n     * The `rounded` property specifies the border radius of the OTP Input.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n    set rounded(rounded) {\n      this._rounded = rounded || DEFAULT_ROUNDED;\n    }\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The `fillMode` property specifies the background and border styles of the OTP Input.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n    set fillMode(fillMode) {\n      const newFillMode = fillMode || DEFAULT_FILL_MODE;\n      this.setGroupFillMode(newFillMode, this._fillMode);\n      this._fillMode = newFillMode;\n    }\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.\n     */\n    set inputAttributes(attributes) {\n      this._inputAttributes = attributes;\n      this.parsedAttributes = this.inputAttributes ? {\n        ...this.defaultAttributes,\n        ...this.inputAttributes\n      } : this.inputAttributes;\n      this.setInputAttributes();\n    }\n    get inputAttributes() {\n      return this._inputAttributes;\n    }\n    /**\n     * Fires each time the value is changed by the user&mdash;\n     * When the value of the component is programmatically changed to `ngModel` or `formControl`\n     * through its API or form binding, the `valueChange` event is not triggered because it\n     * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n     */\n\n    get invalidClass() {\n      return this.isControlInvalid;\n    }\n    /**\n     * @hidden\n     */\n    set inputGroups(elements) {\n      this._inputGroups = elements;\n      this.setGroupFillMode(this.fillMode);\n    }\n    get inputGroups() {\n      return this._inputGroups;\n    }\n    /**\n     * @hidden\n     */\n\n    get defaultAttributes() {\n      return {\n        autocomplete: 'off'\n      };\n    }\n    constructor(hostElement, cdr, injector, renderer, localizationService, zone) {\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"type\", 'text');\n      /**\n       * Configures whether the input fields are separate or adjacent to each other.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"spacing\", true);\n      /**\n       * Specifies the separator between groups of input fields.\n       *\n       * > The configuration can only be applied when `groupLength` is set.\n       */\n      _defineProperty(this, \"separator\", void 0);\n      /**\n       * Configures whether the component is enabled or disabled.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"disabled\", false);\n      /**\n       * Configures whether the component is readonly.\n       *\n       * @default false\n       */\n      _defineProperty(this, \"readonly\", false);\n      /**\n       * Configures the placeholder of the input fields.\n       */\n      _defineProperty(this, \"placeholder\", void 0);\n      _defineProperty(this, \"valueChange\", new EventEmitter());\n      /**\n       * Fires each time the user focuses the OTP Input.\n       */\n      _defineProperty(this, \"onFocus\", new EventEmitter());\n      /**\n       * Fires each time the user blurs the OTP Input.\n       */\n      _defineProperty(this, \"onBlur\", new EventEmitter());\n      _defineProperty(this, \"wrapperClass\", true);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"role\", 'group');\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"inputFields\", void 0);\n      _defineProperty(this, \"groupLengthArray\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"inputsArray\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"inputsValues\", [].constructor(DEFAULT_OTPINPUT_LENGTH));\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"adjacentGroups\", void 0);\n      _defineProperty(this, \"_length\", DEFAULT_OTPINPUT_LENGTH);\n      _defineProperty(this, \"_groupLength\", void 0);\n      _defineProperty(this, \"_inputGroups\", void 0);\n      _defineProperty(this, \"separatorPositions\", new Set());\n      _defineProperty(this, \"_value\", null);\n      _defineProperty(this, \"_size\", DEFAULT_SIZE);\n      _defineProperty(this, \"_rounded\", DEFAULT_ROUNDED);\n      _defineProperty(this, \"_fillMode\", DEFAULT_FILL_MODE);\n      _defineProperty(this, \"_isFocused\", false);\n      _defineProperty(this, \"focusChangedProgrammatically\", false);\n      _defineProperty(this, \"inputFieldValueChanged\", false);\n      _defineProperty(this, \"focusedInput\", void 0);\n      _defineProperty(this, \"_inputAttributes\", void 0);\n      _defineProperty(this, \"parsedAttributes\", {});\n      _defineProperty(this, \"subscriptions\", void 0);\n      _defineProperty(this, \"ngChange\", _ => {});\n      _defineProperty(this, \"ngTouched\", () => {});\n      this.hostElement = hostElement;\n      this.cdr = cdr;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.zone = zone;\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    ngOnInit() {\n      this.inputsArray = Array.from({\n        length: this._length\n      });\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.zone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, 'paste', this.handlePaste.bind(this)));\n        this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n      });\n    }\n    ngAfterViewInit() {\n      this.subscriptions.add(this.inputFields.changes.subscribe(this.handleInputChanges.bind(this)));\n      this.handleInputChanges();\n      this.renderer.addClass(this.hostElement.nativeElement, `k-otp-${SIZE_MAP[this._size]}`);\n      this.setGroupFillMode(this.fillMode);\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        this.fillInputs(this.value);\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes.length) {\n        if (typeof this.groupLength === 'number') {\n          this.populateGroupArray(this.groupLength);\n        }\n        this.populateSeparatorPositions();\n      }\n      if (changes.spacing) {\n        if (this.spacing === true) {\n          this.adjacentGroups = null;\n        } else {\n          this.adjacentGroups = this.groupLengthArray ?? [this.length];\n        }\n      }\n      if (changes.type && this.type === 'number') {\n        if (isPresent$1(this.value) && !this.containsDigitsOrSpaces(this.value)) {\n          this.value = null;\n          this.zone.runOutsideAngular(() => setTimeout(() => this.zone.run(() => {\n            this.ngChange(null);\n            this.cdr.markForCheck();\n          })));\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    get formControl() {\n      const ngControl = this.injector.get(NgControl, null);\n      return ngControl?.control || null;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get isControlInvalid() {\n      return this.formControl?.touched && this.formControl.invalid;\n    }\n    /**\n     * @hidden\n     */\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * @hidden\n     */\n    set isFocused(value) {\n      if (this._isFocused !== value && this.hostElement) {\n        this._isFocused = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n    get hasGroups() {\n      if (!this.spacing && isPresent$1(this.groupLength)) {\n        return true;\n      }\n    }\n    /**\n     * @hidden\n     */\n    showGroupSeparator(index) {\n      return this.groupLengthArray && index < this.groupLengthArray.length - 1;\n    }\n    /**\n     * @hidden\n     */\n    showSeparator(index) {\n      return this.groupLength ? this.separatorPositions.has(index) : false;\n    }\n    /**\n     * @hidden\n     */\n    handleValueChange(index, groupIndex) {\n      this.inputFieldValueChanged = true;\n      if (groupIndex) {\n        index = this.getIndexByGroup(groupIndex, index);\n      }\n      let newValue = '';\n      this.inputFields.forEach(input => newValue = newValue.concat(input.value?.toString() || ' '));\n      if (!areSame(this.value, newValue)) {\n        this.zone.run(() => {\n          this.value = newValue;\n          this.ngChange(newValue);\n          this.valueChange.emit(newValue);\n          this.cdr.markForCheck();\n        });\n      }\n      this.inputFieldValueChanged = false;\n      if (isPresent$1(index) && isPresent$1(this.inputFields?.get(index).value)) {\n        this.focusNext();\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInputFocus(index, groupIndex) {\n      if (this.focusChangedProgrammatically) {\n        return;\n      }\n      if (groupIndex) {\n        index = this.getIndexByGroup(groupIndex, index);\n      }\n      this.focusedInput = index;\n    }\n    /**\n     * @hidden\n     */\n    handleInput(event, index, groupIndex) {\n      if (this.type === 'number' && !this.isValidNumber(event?.data)) {\n        const inputIndex = groupIndex ? this.getIndexByGroup(groupIndex, index) : index;\n        const textbox = this.inputFields.get(inputIndex);\n        if (this.value && this.isValidNumber(this.value[inputIndex])) {\n          textbox.value = this.value[inputIndex];\n        } else {\n          textbox.value = null;\n        }\n        this.showInvalidInput(inputIndex);\n        return;\n      }\n      this.handleValueChange(index, groupIndex);\n    }\n    /**\n     * @hidden\n     */\n    fillInputs(text, start = 0, replaceLast = false) {\n      if (!isPresent$1(text)) {\n        return;\n      }\n      let charCounter = 0;\n      this.inputFields?.forEach((otpInput, i) => {\n        if (i < start) {\n          return;\n        }\n        if (charCounter < text.length) {\n          if (text[charCounter] === ' ') {\n            otpInput.value = null;\n          } else {\n            otpInput.value = text[charCounter];\n          }\n          charCounter++;\n        } else if (replaceLast) {\n          otpInput.value = null;\n        }\n      });\n    }\n    /**\n     * Focuses the OTP Input.\n     */\n    focus(index) {\n      if (!this.inputFields || index < 0 || index >= this.length) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.inputFields.get(index || 0).focus();\n      this.focusedInput = index || 0;\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the OTP Input.\n     */\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n      this.zone.run(() => {\n        if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {\n          this.onFocus.emit();\n        }\n        this.isFocused = true;\n      });\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n      this.zone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.ngTouched();\n          this.onBlur.emit();\n        }\n        this.isFocused = false;\n      });\n    }\n    getIndexByGroup(groupIndex, itemIndex) {\n      return this.groupLengthArray.slice(0, groupIndex).reduce((sum, current) => sum + current, 0) + itemIndex;\n    }\n    focusNext() {\n      if (!this.inputFields || this.focusedInput === this.length - 1) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.inputFields.get(this.focusedInput).blur();\n      this.inputFields.get(this.focusedInput + 1).focus();\n      this.focusedInput++;\n      this.focusChangedProgrammatically = false;\n    }\n    focusPrevious() {\n      if (!this.inputFields || this.focusedInput === 0) {\n        return;\n      }\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.inputFields.get(this.focusedInput).blur();\n      this.inputFields.get(this.focusedInput - 1).focus();\n      this.focusedInput--;\n      this.focusChangedProgrammatically = false;\n    }\n    handlePaste(event) {\n      event.preventDefault();\n      const text = event.clipboardData.getData('text').trim();\n      if (text === '') {\n        return;\n      }\n      if (this.type === 'number' && !this.isValidNumber(text)) {\n        this.showInvalidInput(this.focusedInput);\n        return;\n      }\n      this.inputFieldValueChanged = true;\n      this.fillInputs(text, this.focusedInput);\n      this.handleValueChange();\n      this.inputFieldValueChanged = false;\n      const focusedInput = this.focusedInput + text.length < this.inputFields?.length ? this.focusedInput + text.length : this.inputFields.length - 1;\n      this.inputFields.get(this.focusedInput).blur();\n      this.focusedInput = focusedInput;\n      this.inputFields.get(this.focusedInput).focus();\n    }\n    handleKeydown(event) {\n      if (this.readonly) {\n        const isCopyCommand = (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyC;\n        if (!(event.keyCode === Keys.Tab || isCopyCommand)) {\n          event.preventDefault();\n          return;\n        }\n      }\n      switch (event.keyCode) {\n        case Keys.ArrowRight:\n          event.preventDefault();\n          this.direction === 'ltr' ? this.focusNext() : this.focusPrevious();\n          break;\n        case Keys.ArrowLeft:\n          event.preventDefault();\n          this.direction === 'ltr' ? this.focusPrevious() : this.focusNext();\n          break;\n        case Keys.Backspace:\n          event.preventDefault();\n          this.inputFields.get(this.focusedInput).value = null;\n          this.handleValueChange();\n          this.focusPrevious();\n          break;\n        case Keys.Delete:\n          event.preventDefault();\n          this.inputFields.get(this.focusedInput).value = null;\n          this.handleValueChange();\n          break;\n        default:\n          break;\n      }\n    }\n    isValidGroupArray(groups) {\n      if (!isPresent$1(groups)) {\n        return;\n      }\n      const sum = groups.reduce((sum, current) => sum + current, 0);\n      return sum === this.length;\n    }\n    populateGroupArray(length) {\n      const groupsCount = Math.floor(this.length / length);\n      const remainder = this.length % length;\n      const result = Array(groupsCount).fill(length);\n      if (remainder > 0) {\n        result.push(remainder);\n      }\n      this.groupLengthArray = [...result];\n      // groups with spacing shouldn't be wrapped in `k-input-group`\n      if (!this.spacing) {\n        this.adjacentGroups = [...this.groupLengthArray];\n      }\n    }\n    populateSeparatorPositions() {\n      let itemIndex = 0;\n      this.separatorPositions.clear();\n      if (!isPresent$1(this.groupLengthArray)) {\n        return;\n      }\n      for (let i = 0; i < this.groupLengthArray.length - 1; i++) {\n        itemIndex += this.groupLengthArray[i];\n        this.separatorPositions.add(itemIndex - 1);\n      }\n    }\n    clearGroups() {\n      this.groupLengthArray = null;\n      if (!this.spacing) {\n        this.adjacentGroups = [this.length];\n      } else {\n        this.adjacentGroups = null;\n      }\n      this.separatorPositions.clear();\n    }\n    clearInputValues() {\n      this.inputFields?.forEach(input => input.value = null);\n    }\n    handleInputChanges() {\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        this.fillInputs(this.value?.trim());\n        if (this.inputAttributes) {\n          this.setInputAttributes();\n        } else {\n          this.setDefaultAttributes();\n        }\n        this.cdr.detectChanges();\n      });\n    }\n    setGroupFillMode(fillMode, previousFillMode) {\n      this.inputGroups?.forEach(element => {\n        if (previousFillMode !== 'none') {\n          this.renderer.removeClass(element.nativeElement, `k-input-group-${previousFillMode}`);\n        }\n        if (fillMode !== 'none') {\n          this.renderer.addClass(element.nativeElement, `k-input-group-${fillMode}`);\n        }\n      });\n    }\n    setInputAttributes() {\n      this.inputFields?.forEach((input, index) => {\n        if (!this.parsedAttributes || !this.parsedAttributes?.['aria-label']) {\n          input.inputAttributes = {\n            ...this.parsedAttributes,\n            'aria-label': this.ariaLabel(index)\n          };\n        } else {\n          input.inputAttributes = this.parsedAttributes;\n        }\n      });\n    }\n    setDefaultAttributes() {\n      this.inputFields?.forEach((input, index) => {\n        input.inputAttributes = {\n          autocomplete: 'off',\n          'aria-label': this.ariaLabel(index)\n        };\n      });\n    }\n    ariaLabel(index) {\n      const localizationMsg = this.localizationService.get('ariaLabel') || '';\n      return replaceMessagePlaceholder(replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, 'currentInput', (index + 1).toString()), 'totalInputs', this.length.toString()), 'value', this.value);\n    }\n    isValidNumber(value) {\n      if (!isPresent$1(value)) {\n        return;\n      }\n      const trimmedValue = value.trim();\n      return trimmedValue !== '' && trimmedValue !== 'Infinity' && trimmedValue !== '-Infinity' && !isNaN(Number(trimmedValue));\n    }\n    showInvalidInput(index) {\n      const textbox = this.inputFields.get(index);\n      const textboxElement = this.inputFields.get(index).hostElement.nativeElement;\n      const inputElement = textbox.input.nativeElement;\n      this.renderer.addClass(textboxElement, 'k-invalid');\n      if (textbox.value && this.isValidNumber(textbox.value)) {\n        this.zone.onStable.pipe(take(1)).subscribe(() => inputElement.select());\n      }\n      this.zone.runOutsideAngular(() => {\n        setTimeout(() => {\n          if (!this.isControlInvalid && textboxElement) {\n            this.renderer.removeClass(textboxElement, 'k-invalid');\n          }\n        }, 300);\n      });\n    }\n    containsDigitsOrSpaces(value) {\n      // @ts-expect-error TS does not allow comparing string with number\n      const isDigitOrSpace = char => char == +char || char === ' ';\n      for (let i = 0; i < value.length; i++) {\n        if (!isDigitOrSpace(value[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  _class87 = OTPInputComponent;\n  _defineProperty(OTPInputComponent, \"\\u0275fac\", function _class87_Factory(t) {\n    return new (t || _class87)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(OTPInputComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class87,\n    selectors: [[\"kendo-otpinput\"]],\n    viewQuery: function _class87_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TextBoxComponent, 5);\n        i0.ɵɵviewQuery(_c229, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputFields = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroups = _t);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function _class87_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-otp\", ctx.wrapperClass)(\"k-invalid\", ctx.invalidClass);\n      }\n    },\n    inputs: {\n      length: \"length\",\n      type: \"type\",\n      spacing: \"spacing\",\n      separator: \"separator\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      placeholder: \"placeholder\",\n      groupLength: \"groupLength\",\n      value: \"value\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      inputAttributes: \"inputAttributes\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoOTPInput\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.otpinput'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => _class87),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => _class87)\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 7,\n    vars: 5,\n    consts: function () {\n      let i18n_230;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The value of the aria-label attribute of the input fields.\n         * @meaning kendo.otpinput.ariaLabel\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_231 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        }, {\n          original_code: {\n            \"interpolation\": \"{{ 'Input {currentInput} of {totalInputs}, current value {value}' }}\"\n          }\n        });\n        i18n_230 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_231;\n      } else {\n        i18n_230 = $localize`:kendo.otpinput.ariaLabel|The value of the aria-label attribute of the input fields.:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n      return [[\"kendoOTPInputLocalizedMessages\", \"\", 6, \"ariaLabel\"], [\"ariaLabel\", i18n_230], [\"kendoInputSharedEvents\", \"\", 3, \"hostElement\", \"isFocused\", \"isFocusedChange\", \"handleBlur\", \"onFocus\"], [4, \"ngIf\", \"ngIfElse\"], [\"groups\", \"\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-otp-input\", 3, \"selectOnFocus\", \"maxlength\", \"type\", \"placeholder\", \"size\", \"rounded\", \"fillMode\", \"disabled\", \"readonly\", \"focus\", \"input\"], [3, \"separator\", 4, \"ngIf\"], [3, \"separator\"], [1, \"k-input-group\"], [\"inputGroup\", \"\"], [\"class\", \"k-otp-input\", 3, \"k-invalid\", \"selectOnFocus\", \"maxlength\", \"type\", \"placeholder\", \"size\", \"rounded\", \"fillMode\", \"disabled\", \"readonly\", \"focus\", \"input\", 4, \"ngFor\", \"ngForOf\"]];\n    },\n    template: function _class87_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵi18nAttributes(1, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵlistener(\"isFocusedChange\", function _class87_Template_ng_container_isFocusedChange_2_listener($event) {\n          return ctx.isFocused = $event;\n        })(\"handleBlur\", function _class87_Template_ng_container_handleBlur_2_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function _class87_Template_ng_container_onFocus_2_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵtemplate(3, _class87_ng_container_3_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵtemplate(4, _class87_ng_template_4_Template, 1, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(6);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(5);\n        i0.ɵɵi18nExp(\"Input {currentInput} of {totalInputs}, current value {value}\");\n        i0.ɵɵi18nApply(1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"hostElement\", ctx.hostElement)(\"isFocused\", ctx.isFocused);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.spacing)(\"ngIfElse\", _r1);\n      }\n    },\n    dependencies: [SharedInputEventsDirective, TextBoxComponent, OTPInputSeparatorComponent, NgFor, NgIf, LocalizedOTPInputMessagesDirective],\n    encapsulation: 2\n  }));\n  return OTPInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages.\n */\nlet OTPInputCustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class88;\n  class OTPInputCustomMessagesComponent extends OTPInputMessages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class88 = OTPInputCustomMessagesComponent;\n  _defineProperty(OTPInputCustomMessagesComponent, \"\\u0275fac\", function _class88_Factory(t) {\n    return new (t || _class88)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(OTPInputCustomMessagesComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class88,\n    selectors: [[\"kendo-otpinput-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: OTPInputMessages,\n      useExisting: forwardRef(() => _class88)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class88_Template(rf, ctx) {},\n    encapsulation: 2\n  }));\n  return OTPInputCustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility array that contains all `TextBox` related components and directives\n */\nconst KENDO_TEXTBOX = [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];\n/**\n * Utility array that contains all `NumericTextBox` related components and directives\n */\nconst KENDO_NUMERICTEXTBOX = [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];\n/**\n * Utility array that contains all `MaskedTextBox` related components and directives\n */\nconst KENDO_MASKEDTEXTBOX = [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];\n/**\n * Utility array that contains all `OTP` related components and directives\n */\nconst KENDO_OTPINPUT = [OTPInputComponent, OTPInputCustomMessagesComponent];\n/**\n * Utility array that contains all `TextArea` related components and directives\n */\nconst KENDO_TEXTAREA = [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent];\n/**\n * Utility array that contains all `CheckBox` related components and directives\n */\nconst KENDO_CHECKBOX = [CheckBoxComponent, CheckBoxDirective];\n/**\n * Utility array that contains all `RadioButton` related components and directives\n */\nconst KENDO_RADIOBUTTON = [RadioButtonComponent, RadioButtonDirective];\n/**\n * Utility array that contains all `Switch` related components and directives\n */\nconst KENDO_SWITCH = [SwitchComponent, SwitchCustomMessagesComponent];\n/**\n * Utility array that contains all `FormField` related components and directives\n */\nconst KENDO_FORMFIELD = [FormFieldComponent, HintComponent, ErrorComponent];\n/**\n * Utility array that contains all `Slider` related components and directives\n */\nconst KENDO_SLIDER = [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective];\n/**\n * Utility array that contains all `RangeSlider` related components and directives\n */\nconst KENDO_RANGESLIDER = [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective];\n/**\n * Utility array that contains all `Rating` related components and directives\n */\nconst KENDO_RATING = [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective];\n/**\n * Utility array that contains all `Signature` related components and directives\n */\nconst KENDO_SIGNATURE = [SignatureComponent, SignatureCustomMessagesComponent];\n/**\n * Utility array that contains all `ColorPicker` related components and directives\n */\nconst KENDO_COLORPICKER = [ColorPickerComponent, ColorPickerCustomMessagesComponent];\n/**\n * Utility array that contains all `FlatColorPicker` related components and directives\n */\nconst KENDO_FLATCOLORPICKER = [FlatColorPickerComponent, ColorPickerCustomMessagesComponent];\n/**\n * Utility array that contains all `ColorPallete` related components and directives\n */\nconst KENDO_COLORPALETTE = [ColorPaletteComponent, ColorPickerCustomMessagesComponent];\n/**\n * Utility array that contains all `ColorGradient` related components and directives\n */\nconst KENDO_COLORGRADIENT = [ColorGradientComponent, ColorPickerCustomMessagesComponent];\n/**\n * Utility array that contains all `@progress/kendo-angular-inputs` related components and directives\n */\nconst KENDO_INPUTS = [...KENDO_TEXTBOX, ...KENDO_NUMERICTEXTBOX, ...KENDO_MASKEDTEXTBOX, ...KENDO_TEXTAREA, ...KENDO_CHECKBOX, ...KENDO_RADIOBUTTON, ...KENDO_SWITCH, ...KENDO_FORMFIELD, ...KENDO_SLIDER, ...KENDO_RANGESLIDER, ...KENDO_RATING, ...KENDO_SIGNATURE, ...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE, ...KENDO_OTPINPUT];\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { InputsModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet InputsModule = /*#__PURE__*/(() => {\n  var _class89;\n  class InputsModule {}\n  _class89 = InputsModule;\n  _defineProperty(InputsModule, \"\\u0275fac\", function _class89_Factory(t) {\n    return new (t || _class89)();\n  });\n  _defineProperty(InputsModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class89\n  }));\n  _defineProperty(InputsModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],\n    imports: [TextBoxComponent, i7.SeparatorComponent, NumericTextBoxComponent, i7.SeparatorComponent, i7.SeparatorComponent, i7.SeparatorComponent, SliderComponent, RangeSliderComponent, RatingComponent, SignatureComponent, ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent, OTPInputComponent, i7.SeparatorComponent]\n  }));\n  return InputsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Slider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { SliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet SliderModule = /*#__PURE__*/(() => {\n  var _class90;\n  class SliderModule {}\n  _class90 = SliderModule;\n  _defineProperty(SliderModule, \"\\u0275fac\", function _class90_Factory(t) {\n    return new (t || _class90)();\n  });\n  _defineProperty(SliderModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class90\n  }));\n  _defineProperty(SliderModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService],\n    imports: [SliderComponent]\n  }));\n  return SliderModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the RangeSlider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { RangeSliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet RangeSliderModule = /*#__PURE__*/(() => {\n  var _class91;\n  class RangeSliderModule {}\n  _class91 = RangeSliderModule;\n  _defineProperty(RangeSliderModule, \"\\u0275fac\", function _class91_Factory(t) {\n    return new (t || _class91)();\n  });\n  _defineProperty(RangeSliderModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class91\n  }));\n  _defineProperty(RangeSliderModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ResizeBatchService],\n    imports: [RangeSliderComponent]\n  }));\n  return RangeSliderModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Switch component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Switch module\n * import { SwitchModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SwitchModule], // import Switch module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet SwitchModule = /*#__PURE__*/(() => {\n  var _class92;\n  class SwitchModule {}\n  _class92 = SwitchModule;\n  _defineProperty(SwitchModule, \"\\u0275fac\", function _class92_Factory(t) {\n    return new (t || _class92)();\n  });\n  _defineProperty(SwitchModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class92\n  }));\n  _defineProperty(SwitchModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ResizeBatchService]\n  }));\n  return SwitchModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the NumericTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the NumericTextBox module\n * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet NumericTextBoxModule = /*#__PURE__*/(() => {\n  var _class93;\n  class NumericTextBoxModule {}\n  _class93 = NumericTextBoxModule;\n  _defineProperty(NumericTextBoxModule, \"\\u0275fac\", function _class93_Factory(t) {\n    return new (t || _class93)();\n  });\n  _defineProperty(NumericTextBoxModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class93\n  }));\n  _defineProperty(NumericTextBoxModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [NumericTextBoxComponent, i7.SeparatorComponent, i7.SeparatorComponent]\n  }));\n  return NumericTextBoxModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the MaskedTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MaskedTextBox module\n * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet MaskedTextBoxModule = /*#__PURE__*/(() => {\n  var _class94;\n  class MaskedTextBoxModule {}\n  _class94 = MaskedTextBoxModule;\n  _defineProperty(MaskedTextBoxModule, \"\\u0275fac\", function _class94_Factory(t) {\n    return new (t || _class94)();\n  });\n  _defineProperty(MaskedTextBoxModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class94\n  }));\n  _defineProperty(MaskedTextBoxModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [i7.SeparatorComponent, i7.SeparatorComponent]\n  }));\n  return MaskedTextBoxModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the TextBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextBox module\n * import { TextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextBoxModule], // import TextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet TextBoxModule = /*#__PURE__*/(() => {\n  var _class95;\n  class TextBoxModule {}\n  _class95 = TextBoxModule;\n  _defineProperty(TextBoxModule, \"\\u0275fac\", function _class95_Factory(t) {\n    return new (t || _class95)();\n  });\n  _defineProperty(TextBoxModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class95\n  }));\n  _defineProperty(TextBoxModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [TextBoxComponent, i7.SeparatorComponent, i7.SeparatorComponent]\n  }));\n  return TextBoxModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the TextArea component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextArea module\n * import { TextAreaModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextAreaModule], // import TextArea module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet TextAreaModule = /*#__PURE__*/(() => {\n  var _class96;\n  class TextAreaModule {}\n  _class96 = TextAreaModule;\n  _defineProperty(TextAreaModule, \"\\u0275fac\", function _class96_Factory(t) {\n    return new (t || _class96)();\n  });\n  _defineProperty(TextAreaModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class96\n  }));\n  _defineProperty(TextAreaModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [i7.SeparatorComponent, i7.SeparatorComponent]\n  }));\n  return TextAreaModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the CheckBox directive and CheckBoxComponent.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the CheckBox module\n * import { CheckBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet CheckBoxModule = /*#__PURE__*/(() => {\n  var _class97;\n  class CheckBoxModule {}\n  _class97 = CheckBoxModule;\n  _defineProperty(CheckBoxModule, \"\\u0275fac\", function _class97_Factory(t) {\n    return new (t || _class97)();\n  });\n  _defineProperty(CheckBoxModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class97\n  }));\n  _defineProperty(CheckBoxModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return CheckBoxModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the RadioButton directive and RadioButtonComponent.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the RadioButton module\n * import { RadioButtonModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet RadioButtonModule = /*#__PURE__*/(() => {\n  var _class98;\n  class RadioButtonModule {}\n  _class98 = RadioButtonModule;\n  _defineProperty(RadioButtonModule, \"\\u0275fac\", function _class98_Factory(t) {\n    return new (t || _class98)();\n  });\n  _defineProperty(RadioButtonModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class98\n  }));\n  _defineProperty(RadioButtonModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return RadioButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Arguments for the `blur` event of the Switch component.\n */\nclass SwitchBlurEvent {\n  constructor() {\n    /**\n     * The original DOM [`blur`](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) event.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n  }\n}\n\n/**\n * Arguments for the `focus` event of the Switch component.\n */\nclass SwitchFocusEvent {\n  constructor() {\n    /**\n     * The original DOM [`focus`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event) event.\n     */\n    _defineProperty(this, \"originalEvent\", void 0);\n  }\n}\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the ColorPicker.\n */\nlet ColorPickerModule = /*#__PURE__*/(() => {\n  var _class101;\n  class ColorPickerModule {}\n  _class101 = ColorPickerModule;\n  _defineProperty(ColorPickerModule, \"\\u0275fac\", function _class101_Factory(t) {\n    return new (t || _class101)();\n  });\n  _defineProperty(ColorPickerModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class101\n  }));\n  _defineProperty(ColorPickerModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [PopupService, IconsService, ResizeBatchService, AdaptiveService],\n    imports: [ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent]\n  }));\n  return ColorPickerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the FormField, Error and Hint components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the FormField module\n * import { FormFieldModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, FormFieldModule], // import FormField module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet FormFieldModule = /*#__PURE__*/(() => {\n  var _class102;\n  class FormFieldModule {}\n  _class102 = FormFieldModule;\n  _defineProperty(FormFieldModule, \"\\u0275fac\", function _class102_Factory(t) {\n    return new (t || _class102)();\n  });\n  _defineProperty(FormFieldModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class102\n  }));\n  _defineProperty(FormFieldModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return FormFieldModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Signature component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Signature module\n * import { SignatureModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SignatureModule], // import Signature module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet SignatureModule = /*#__PURE__*/(() => {\n  var _class103;\n  class SignatureModule {}\n  _class103 = SignatureModule;\n  _defineProperty(SignatureModule, \"\\u0275fac\", function _class103_Factory(t) {\n    return new (t || _class103)();\n  });\n  _defineProperty(SignatureModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class103\n  }));\n  _defineProperty(SignatureModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],\n    imports: [SignatureComponent]\n  }));\n  return SignatureModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Rating component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Rating module\n * import { RatingModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RatingModule], // import Rating module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet RatingModule = /*#__PURE__*/(() => {\n  var _class104;\n  class RatingModule {}\n  _class104 = RatingModule;\n  _defineProperty(RatingModule, \"\\u0275fac\", function _class104_Factory(t) {\n    return new (t || _class104)();\n  });\n  _defineProperty(RatingModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class104\n  }));\n  _defineProperty(RatingModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService],\n    imports: [RatingComponent]\n  }));\n  return RatingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActiveColorClickEvent, CheckBoxComponent, CheckBoxDirective, CheckBoxModule, ColorGradientComponent, ColorPaletteComponent, ColorPickerCancelEvent, ColorPickerCloseEvent, ColorPickerComponent, ColorPickerCustomMessagesComponent, ColorPickerModule, ColorPickerOpenEvent, ErrorComponent, FlatColorPickerComponent, FormFieldComponent, FormFieldModule, HintComponent, InputSeparatorComponent, InputsModule, KENDO_CHECKBOX, KENDO_COLORGRADIENT, KENDO_COLORPALETTE, KENDO_COLORPICKER, KENDO_FLATCOLORPICKER, KENDO_FORMFIELD, KENDO_INPUTS, KENDO_MASKEDTEXTBOX, KENDO_NUMERICTEXTBOX, KENDO_OTPINPUT, KENDO_RADIOBUTTON, KENDO_RANGESLIDER, KENDO_RATING, KENDO_SIGNATURE, KENDO_SLIDER, KENDO_SWITCH, KENDO_TEXTAREA, KENDO_TEXTBOX, LabelTemplateDirective, LocalizedColorPickerMessagesDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSignatureMessagesDirective, LocalizedSliderMessagesDirective, LocalizedSwitchMessagesDirective, LocalizedTextBoxMessagesDirective, MaskedTextBoxComponent, MaskedTextBoxModule, MaskingService, NumericLabelDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, NumericTextBoxModule, OTPInputComponent, OTPInputCustomMessagesComponent, RadioButtonComponent, RadioButtonDirective, RadioButtonModule, RangeSliderComponent, RangeSliderCustomMessagesComponent, RangeSliderModule, RatingComponent, RatingHoveredItemTemplateDirective, RatingItemTemplateDirective, RatingModule, RatingSelectedItemTemplateDirective, SignatureCloseEvent, SignatureComponent, SignatureCustomMessagesComponent, SignatureMessages, SignatureModule, SignatureOpenEvent, SliderComponent, SliderCustomMessagesComponent, SliderModule, SliderTicksComponent, SwitchBlurEvent, SwitchComponent, SwitchCustomMessagesComponent, SwitchFocusEvent, SwitchModule, TextAreaComponent, TextAreaDirective, TextAreaModule, TextAreaPrefixComponent, TextAreaSuffixComponent, TextBoxComponent, TextBoxCustomMessagesComponent, TextBoxDirective, TextBoxModule, TextBoxPrefixTemplateDirective, TextBoxSuffixTemplateDirective };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}