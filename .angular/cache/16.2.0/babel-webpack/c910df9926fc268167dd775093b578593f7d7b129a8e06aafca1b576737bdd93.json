{"ast":null,"code":"import _defineProperty from \"C:/Users/Mobile programming/Documents/angular-pwa-boilerplate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2025 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { TemplateRef, EventEmitter, Component, Input, Output, HostBinding, InjectionToken, Injectable, Inject, Optional, Directive, forwardRef, ContentChildren, ViewChildren, ViewChild, isDevMode, Renderer2, Host, HostListener, ContentChild, NgModule } from '@angular/core';\nimport { NgIf, NgFor, NgClass, NgTemplateOutlet, NgStyle } from '@angular/common';\nimport * as i2 from '@angular/animations';\nimport { style, animate, keyframes, trigger, state, transition } from '@angular/animations';\nimport { of, Subscription, Subject, merge } from 'rxjs';\nimport { delay, takeUntil, take, filter, map, share, tap, switchMap } from 'rxjs/operators';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { xIcon, windowRestoreIcon, windowIcon, windowMinimizeIcon } from '@progress/kendo-svg-icons';\nimport { ButtonComponent, Button } from '@progress/kendo-angular-buttons';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { setHTMLAttributes, shouldShowValidationUI, isDocumentAvailable, focusableSelector, WatermarkOverlayComponent, DraggableDirective, isChanged } from '@progress/kendo-angular-common';\nimport { offset, scrollPosition, positionWithScroll, getDocumentElement, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';\n\n/**\n * @hidden\n */\nfunction _class_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!actions\"]);\n  }\n}\nfunction _class_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n}\nfunction _class_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function _class_ng_container_1_ng_container_1_ng_template_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const action_r5 = i0.ɵɵnextContext().$implicit;\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r9.onButtonClick(action_r5, $event));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const action_r5 = i0.ɵɵnextContext().$implicit;\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r8.buttonClass(action_r5));\n    i0.ɵɵattribute(\"aria-label\", action_r5.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", action_r5.text, \" \");\n  }\n}\nfunction _class_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class_ng_container_1_ng_container_1_ng_container_1_Template, 2, 0, \"ng-container\", 1);\n    i0.ɵɵtemplate(2, _class_ng_container_1_ng_container_1_ng_template_2_Template, 2, 3, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const action_r5 = ctx.$implicit;\n    const _r7 = i0.ɵɵreference(3);\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.isDivider(action_r5))(\"ngIfElse\", _r7);\n  }\n}\nfunction _class_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, _class_ng_container_1_ng_container_1_Template, 4, 2, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.actionsArray);\n  }\n}\nfunction _class_ng_template_2_Template(rf, ctx) {}\nconst _c0 = [\"*\"];\nconst _c3 = [\"dialog\"];\nfunction _class7_kendo_dialog_titlebar_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-dialog-titlebar\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"closeTitle\", ctx_r1.closeTitle)(\"id\", ctx_r1.titleId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.title);\n  }\n}\nfunction _class7_ng_content_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!title\"]);\n  }\n}\nfunction _class7_ng_content_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!contentTemplate\"]);\n  }\n}\nfunction _class7_8_ng_template_0_Template(rf, ctx) {}\nfunction _class7_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class7_8_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.contentTemplate);\n  }\n}\nfunction _class7_ng_content_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"!actions\"]);\n  }\n}\nfunction _class7_kendo_dialog_actions_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-dialog-actions\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"actions\", ctx_r6.actions)(\"layout\", ctx_r6.actionsLayout);\n  }\n}\nfunction _class7_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 12);\n  }\n}\nconst _c6 = [[[\"kendo-dialog-titlebar\"]], \"*\", [[\"kendo-dialog-actions\"]]];\nconst _c7 = [\"kendo-dialog-titlebar\", \"*\", \"kendo-dialog-actions\"];\nfunction _class17_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!template\"]);\n  }\n}\nfunction _class17_1_ng_template_0_Template(rf, ctx) {}\nconst _c8 = function (a0) {\n  return {\n    \"$implicit\": a0\n  };\n};\nfunction _class17_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class17_1_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c8, ctx_r1.service));\n  }\n}\nconst _c9 = [\"kendoWindowCloseAction\", \"\"];\nfunction _class19_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r0.xIcon);\n  }\n}\nfunction _class19_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class19_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c10 = [\"kendoWindowRestoreAction\", \"\"];\nfunction _class20_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r0.windowRestoreIcon);\n  }\n}\nfunction _class20_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class20_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c11 = [\"kendoWindowMaximizeAction\", \"\"];\nfunction _class21_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r0.windowIcon);\n  }\n}\nfunction _class21_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class21_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nconst _c12 = [\"kendoWindowMinimizeAction\", \"\"];\nfunction _class22_kendo_icon_wrapper_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-icon-wrapper\", 4);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"svgIcon\", ctx_r0.windowMinimizeIcon);\n  }\n}\nfunction _class22_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵelement(1, \"img\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"src\", ctx_r1.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\nfunction _class22_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.iconClass);\n  }\n}\nfunction _class23_kendo_window_titlebar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-window-titlebar\", 6)(1, \"span\", 7);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 8);\n    i0.ɵɵelement(4, \"button\", 9)(5, \"button\", 10)(6, \"button\", 11)(7, \"button\", 12);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"template\", ctx_r0.titleBarTemplate)(\"id\", ctx_r0.titleId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"title\", ctx_r0.minimizeButtonTitle)(\"aria-label\", ctx_r0.minimizeButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.maximizeButtonTitle)(\"aria-label\", ctx_r0.maximizeButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.restoreButtonTitle)(\"aria-label\", ctx_r0.restoreButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.closeButtonTitle)(\"aria-label\", ctx_r0.closeButtonTitle);\n  }\n}\nfunction _class23_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!showDefaultTitleBar\"]);\n  }\n}\nfunction _class23_div_4_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!contentTemplate\"]);\n  }\n}\nfunction _class23_div_4_2_ng_template_0_Template(rf, ctx) {}\nfunction _class23_div_4_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class23_div_4_2_ng_template_0_Template, 0, 0, \"ng-template\", 14);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.contentTemplate);\n  }\n}\nfunction _class23_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵtemplate(1, _class23_div_4_ng_content_1_Template, 1, 0, \"ng-content\", 2);\n    i0.ɵɵtemplate(2, _class23_div_4_2_Template, 1, 1, null, 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"hidden\", ctx_r2.state === \"minimized\" && ctx_r2.keepContent);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.contentTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.contentTemplate);\n  }\n}\nfunction _class23_ng_template_5_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 16);\n  }\n  if (rf & 2) {\n    const dir_r9 = ctx.$implicit;\n    i0.ɵɵproperty(\"direction\", dir_r9);\n  }\n}\nfunction _class23_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class23_ng_template_5_div_0_Template, 1, 1, \"div\", 15);\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.resizeDirections);\n  }\n}\nfunction _class23_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 17);\n  }\n}\nconst _c21 = [[[\"kendo-window-titlebar\"]], \"*\"];\nconst _c22 = [\"kendo-window-titlebar\", \"*\"];\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isTruthy = value => !!value;\nconst toClassList = classNames => String(classNames).trim().split(' ');\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\nvar Keys = /*#__PURE__*/function (Keys) {\n  Keys[Keys[\"esc\"] = 27] = \"esc\";\n  Keys[Keys[\"tab\"] = 9] = \"tab\";\n  Keys[Keys[\"enter\"] = 13] = \"enter\";\n  Keys[Keys[\"space\"] = 32] = \"space\";\n  Keys[Keys[\"ctrl\"] = 17] = \"ctrl\";\n  Keys[Keys[\"shift\"] = 16] = \"shift\";\n  Keys[Keys[\"left\"] = 37] = \"left\";\n  Keys[Keys[\"up\"] = 38] = \"up\";\n  Keys[Keys[\"right\"] = 39] = \"right\";\n  Keys[Keys[\"down\"] = 40] = \"down\";\n  return Keys;\n}(Keys || {});\n/**\n * @hidden\n */\nconst DIALOG_ELEMENTS_HANDLING_ESC_KEY = 'k-dialog-wrapper k-actions k-dialog-titlebar-action';\n/**\n * @hidden\n */\nconst DIALOG_ELEMENTS_HANDLING_ARROWS = 'k-actions';\n/**\n * @hidden\n */\nconst WINDOW_CLASSES = 'k-window';\n/**\n * @hidden\n */\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\nconst isFocusable = (element, checkVisibility = true) => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;\n    let focusable = false;\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled;\n    } else {\n      focusable = validTabIndex;\n    }\n    return focusable && (!checkVisibility || isVisible(element));\n  }\n  return false;\n};\n/**\n * Receives CSS class declarations either as an object, string or array and returns an array of the class names.\n *\n * @hidden\n */\nconst parseCSSClassNames = value => {\n  if (isObject(value)) {\n    return parseObjectClassNames(value);\n  }\n  if (isString(value)) {\n    return parseStringClassNames(value);\n  }\n  if (Array.isArray(value)) {\n    return parseArrayClassNames(value);\n  }\n};\nconst parseObjectClassNames = value => {\n  const classes = [];\n  Object.keys(value).forEach(className => {\n    const currentClassName = splitStringToArray(className);\n    if (value[className] && currentClassName[0]) {\n      classes.push(...currentClassName);\n    }\n  });\n  return classes;\n};\nconst parseStringClassNames = value => {\n  const classes = [];\n  const classesArray = splitStringToArray(value);\n  classesArray.forEach(className => {\n    classes.push(className);\n  });\n  return classes;\n};\nconst parseArrayClassNames = value => {\n  const classes = [];\n  value.forEach(className => {\n    const current = splitStringToArray(className);\n    if (current[0]) {\n      classes.push(...current);\n    }\n  });\n  return classes;\n};\n/**\n * @hidden\n */\nconst preventDefault = ({\n  originalEvent: event\n}) => {\n  event.stopPropagation();\n  event.preventDefault();\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n/**\n * @hidden\n */\nconst RESIZE_DIRECTIONS = ['n', 'e', 's', 'w', 'se', 'sw', 'ne', 'nw'];\n/**\n * @hidden\n */\nconst OFFSET_STYLES = ['top', 'left', 'width', 'height'];\n/**\n * @hidden\n */\nconst isString = value => value instanceof String || typeof value === 'string';\n/**\n * @hidden\n */\nconst isObject = value => isPresent(value) && !Array.isArray(value) && typeof value === 'object';\n/**\n * @hidden\n */\nconst isNumber = value => typeof value === 'number' && isFinite(value);\n/**\n * @hidden\n */\nconst createValueWithUnit = value => value + (isNumber(value) ? 'px' : '');\n/**\n * @hidden\n */\nconst splitStringToArray = value => value.trim().replace(/\\s+/g, \" \").split(' ');\n/**\n * @hidden\n */\nconst findPrimaryButton = buttons => {\n  for (let i = buttons.length - 1; i >= 0; i--) {\n    const classList = buttons[i].classList;\n    for (let j = 0; j < classList.length; j++) {\n      if (classList[j].endsWith('-primary')) {\n        return buttons[i];\n      }\n    }\n  }\n};\n\n/**\n * Specifies the action buttons of the Dialog\n * ([see example]({% slug actionbuttons_dialog %})).\n */\nlet DialogActionsComponent = /*#__PURE__*/(() => {\n  var _class;\n  class DialogActionsComponent {\n    /**\n     * Allows the declarative specification of the actions.\n     */\n    set actions(value) {\n      if (value instanceof TemplateRef) {\n        this.actionsTemplate = value;\n      } else if (Array.isArray(value)) {\n        this.actionsArray = value;\n      } else {\n        throw new Error('\"actions\" must be either TemplateRef or DialogAction[] instance.');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n    get startClassName() {\n      return this.layout === 'start';\n    }\n    get centerClassName() {\n      return this.layout === 'center';\n    }\n    get endClassName() {\n      return this.layout === 'end';\n    }\n    get stretchedClassName() {\n      return this.layout === 'stretched';\n    }\n    constructor(el) {\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"actionsArray\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"actionsTemplate\", void 0);\n      /**\n       * Specifies the possible layout of the action buttons.\n       * @default 'stretched'\n       */\n      _defineProperty(this, \"layout\", 'stretched');\n      /**\n       * Fires when the user clicks an action button.\n       */\n      _defineProperty(this, \"action\", new EventEmitter());\n      _defineProperty(this, \"hostClasses\", true);\n      this.el = el;\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick(action, _e) {\n      this.action.emit(action);\n    }\n    /**\n     * @hidden\n     */\n    buttonClass(action) {\n      let classes = ['k-button k-button-md k-rounded-md'];\n      const fillMode = action.fillMode ? action.fillMode : 'solid';\n      const themeColor = action.themeColor ? action.themeColor : 'base';\n      const cssClasses = action.cssClass ? parseCSSClassNames(action.cssClass) : [];\n      classes.push(`k-button-${fillMode} k-button-${fillMode}-${themeColor}`);\n      if (cssClasses.length > 0) {\n        classes = classes.concat(cssClasses);\n      }\n      return classes.join(' ');\n    }\n    /**\n     * @hidden\n     */\n    isDivider(action) {\n      return action === 'spacer';\n    }\n  }\n  _class = DialogActionsComponent;\n  _defineProperty(DialogActionsComponent, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  _defineProperty(DialogActionsComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"kendo-dialog-actions\"]],\n    hostVars: 16,\n    hostBindings: function _class_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-actions\", ctx.hostClasses)(\"k-actions-horizontal\", ctx.hostClasses)(\"k-window-actions\", ctx.hostClasses)(\"k-dialog-actions\", ctx.hostClasses)(\"k-actions-start\", ctx.startClassName)(\"k-actions-center\", ctx.centerClassName)(\"k-actions-end\", ctx.endClassName)(\"k-actions-stretched\", ctx.stretchedClassName);\n      }\n    },\n    inputs: {\n      actions: \"actions\",\n      layout: \"layout\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 4,\n    consts: [[4, \"ngIf\"], [4, \"ngIf\", \"ngIfElse\"], [3, \"ngTemplateOutlet\"], [\"actionTemplate\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"defaultAction\", \"\"], [1, \"k-spacer\"], [\"type\", \"button\", 3, \"ngClass\", \"click\"]],\n    template: function _class_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, _class_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, _class_ng_template_2_Template, 0, 0, \"ng-template\", 2, 3, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(3);\n        i0.ɵɵproperty(\"ngIf\", !ctx.actions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsArray)(\"ngIfElse\", _r2);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.actionsTemplate);\n      }\n    },\n    dependencies: [NgIf, NgFor, NgClass, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return DialogActionsComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor() {\n    _defineProperty(this, \"prevented\", false);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n}\n\n/**\n * @hidden\n */\nconst DIALOG_LOCALIZATION_SERVICE = new InjectionToken('Dialog LocalizationService');\n\n/**\n * @hidden\n */\nlet TitleBarLocalizationService = /*#__PURE__*/(() => {\n  var _class3;\n  class TitleBarLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, rtl, dialogLocalization) {\n      super(prefix, messageService, rtl);\n      _defineProperty(this, \"dialogLocalization\", void 0);\n      this.dialogLocalization = dialogLocalization;\n    }\n    get(shortKey) {\n      if (this.dialogLocalization) {\n        return this.dialogLocalization.get(shortKey);\n      }\n      return super.get(shortKey);\n    }\n  }\n  _class3 = TitleBarLocalizationService;\n  _defineProperty(TitleBarLocalizationService, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(DIALOG_LOCALIZATION_SERVICE, 8));\n  });\n  _defineProperty(TitleBarLocalizationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  }));\n  return TitleBarLocalizationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet Messages = /*#__PURE__*/(() => {\n  var _class4;\n  class Messages extends ComponentMessages {\n    constructor(...args) {\n      super(...args);\n      /**\n       * The title of the close button.\n       */\n      _defineProperty(this, \"closeTitle\", void 0);\n      /**\n       * The title of the restore button.\n       */\n      _defineProperty(this, \"restoreTitle\", void 0);\n      /**\n       * The title of the maximize button.\n       */\n      _defineProperty(this, \"maximizeTitle\", void 0);\n      /**\n       * The title of the minimize button.\n       */\n      _defineProperty(this, \"minimizeTitle\", void 0);\n    }\n  }\n  _class4 = Messages;\n  _defineProperty(Messages, \"\\u0275fac\", /* @__PURE__ */function () {\n    let ɵ_class4_BaseFactory;\n    return function _class4_Factory(t) {\n      return (ɵ_class4_BaseFactory || (ɵ_class4_BaseFactory = i0.ɵɵgetInheritedFactory(_class4)))(t || _class4);\n    };\n  }());\n  _defineProperty(Messages, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class4,\n    selectors: [[\"kendo-dialog-messages-base\"]],\n    inputs: {\n      closeTitle: \"closeTitle\",\n      restoreTitle: \"restoreTitle\",\n      maximizeTitle: \"maximizeTitle\",\n      minimizeTitle: \"minimizeTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return Messages;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  var _class5;\n  class LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n  }\n  _class5 = LocalizedMessagesDirective;\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(LocalizedMessagesDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class5,\n    selectors: [[\"\", \"kendoDialogLocalizedMessages\", \"\"], [\"\", \"kendoWindowLocalizedMessages\", \"\"], [\"\", \"kendoDialogTitleBarLocalizedMessages\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class5)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return LocalizedMessagesDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI DialogTitleBar component for Angular]({% slug api_dialog_dialogtitlebarcomponent %}).\n *\n * It is used as part of the Dialog content when the component is created dynamically by using an [Angular service]({% slug service_dialog %}).\n */\nlet DialogTitleBarComponent = /*#__PURE__*/(() => {\n  var _class6;\n  class DialogTitleBarComponent {\n    get className() {\n      return true;\n    }\n    /**\n     * @hidden\n     */\n\n    constructor(zone, hostElement, localizationService) {\n      _defineProperty(this, \"zone\", void 0);\n      _defineProperty(this, \"hostElement\", void 0);\n      _defineProperty(this, \"localizationService\", void 0);\n      /**\n       * Fires when the close button of the title-bar is clicked.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"id\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"closeTitle\", void 0);\n      _defineProperty(this, \"xIcon\", xIcon);\n      this.zone = zone;\n      this.hostElement = hostElement;\n      this.localizationService = localizationService;\n    }\n    get closeButtonTitle() {\n      return this.closeTitle || this.localizationService.get('closeTitle');\n    }\n    ngAfterViewInit() {\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        const element = this.hostElement.nativeElement.querySelector('.k-dialog-title');\n        element.setAttribute('id', this.id);\n      });\n    }\n    /**\n     * @hidden\n     */\n    onCloseClick(e) {\n      e.preventDefault();\n      const eventArgs = new PreventableEvent();\n      this.close.emit(eventArgs);\n    }\n  }\n  _class6 = DialogTitleBarComponent;\n  _defineProperty(DialogTitleBarComponent, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService, 8));\n  });\n  _defineProperty(DialogTitleBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class6,\n    selectors: [[\"kendo-dialog-titlebar\"]],\n    hostVars: 4,\n    hostBindings: function _class6_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-window-titlebar\", ctx.className)(\"k-dialog-titlebar\", ctx.className);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      closeTitle: \"closeTitle\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([TitleBarLocalizationService, {\n      provide: LocalizationService,\n      useExisting: TitleBarLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dialog'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: function () {\n      let i18n_1;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.dialog.closeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_2 = goog.getMsg(\"Close\");\n        i18n_1 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_2;\n      } else {\n        i18n_1 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;\n      }\n      return [[\"kendoDialogTitleBarLocalizedMessages\", \"\", \"closeTitle\", i18n_1], [1, \"k-window-title\", \"k-dialog-title\"], [1, \"k-window-titlebar-actions\", \"k-dialog-titlebar-actions\"], [\"kendoButton\", \"\", \"fillMode\", \"flat\", \"type\", \"button\", \"icon\", \"close\", 1, \"k-window-titlebar-action\", \"k-dialog-titlebar-action\", 3, \"svgIcon\", \"click\"]];\n    },\n    template: function _class6_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"button\", 3);\n        i0.ɵɵlistener(\"click\", function _class6_Template_button_click_4_listener($event) {\n          return ctx.onCloseClick($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"svgIcon\", ctx.xIcon);\n        i0.ɵɵattribute(\"title\", ctx.closeButtonTitle)(\"aria-label\", ctx.closeButtonTitle);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, ButtonComponent],\n    encapsulation: 2\n  }));\n  return DialogTitleBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dialog',\n  productName: 'Kendo UI for Angular',\n  productCode: 'KENDOUIANGULAR',\n  productCodes: ['KENDOUIANGULAR'],\n  publishDate: 1741163583,\n  version: '18.1.1',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'\n};\n\n/**\n * Indicates that the **Close** button is clicked. Used when the results from\n * the Dialogs that are opened through `DialogService` are filtered\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogCloseResult {}\n\n/**\n * @hidden\n */\nfunction animations(duration, direction, animationType) {\n  switch (animationType) {\n    case 'slide':\n      {\n        const translate = direction === 'left' || direction === 'right' ? 'translateX' : 'translateY';\n        const start = direction === 'right' || direction === 'down' ? -100 : 100;\n        const end = 0;\n        return [style({\n          transform: `${translate}(${start}%)`\n        }), animate(`${duration}ms ease-in`, style({\n          transform: `${translate}(${end}%)`\n        }))];\n      }\n    case 'expand':\n      {\n        const scale = direction === 'up' || direction === 'down' ? 'scaleY' : 'scaleX';\n        const startScale = 0;\n        const endScale = 1;\n        let origin;\n        if (direction === 'down') {\n          origin = 'top';\n        } else if (direction === 'left') {\n          origin = 'right';\n        } else if (direction === 'right') {\n          origin = 'left';\n        } else {\n          origin = 'bottom';\n        }\n        return [style({\n          transform: `${scale}(${startScale})`,\n          transformOrigin: origin\n        }), animate(`${duration}ms ease-in`, style({\n          transform: `${scale}(${endScale})`\n        }))];\n      }\n    case 'zoom':\n      {\n        const startZoom = 0;\n        const endZoom = 1;\n        return [animate(duration, keyframes([style({\n          transform: `scale(${startZoom})`\n        }), style({\n          transform: `scale(${endZoom})`\n        })]))];\n      }\n    case 'fade':\n      {\n        const startFade = 0;\n        const endFade = 1;\n        return [animate(duration, keyframes([style({\n          opacity: `${startFade}`\n        }), style({\n          opacity: `${endFade}`\n        })]))];\n      }\n    case 'translate':\n      return [style({\n        transform: 'translate(0, -10%)'\n      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];\n    default:\n      return [style({\n        transform: 'translate(0, -10%)'\n      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];\n  }\n}\n\n/**\n * @hidden\n */\nconst createPlayer = (builder, animation, animatedElement) => {\n  const factory = builder.build(animation);\n  let player = factory.create(animatedElement);\n  player.onDone(() => {\n    if (player) {\n      player.destroy();\n      player = null;\n    }\n  });\n  return player;\n};\n\n/**\n * @hidden\n */\nconst animateContent = (animation, defAnimationConfig, animatedElement, builder) => {\n  let animationConfig = defAnimationConfig;\n  if (typeof animation !== 'boolean') {\n    animationConfig = animation;\n    animationConfig.duration = animationConfig.duration ? animationConfig.duration : defAnimationConfig.duration;\n  }\n  const animationSpecs = animations(animationConfig.duration, animationConfig.direction, animationConfig.type);\n  const player = createPlayer(builder, animationSpecs, animatedElement);\n  player.play();\n};\nconst DEFAULT_ANIMATION_CONFIG = {\n  duration: 300,\n  type: 'translate'\n};\n/**\n * Represents the [Kendo UI Dialog component for Angular]({% slug overview_dialog_dialogs %}).\n */\nlet DialogComponent = /*#__PURE__*/(() => {\n  var _class7;\n  class DialogComponent {\n    /**\n     * The Dialog allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color to the titlebar while also amending the text color accordingly.\n     *\n     * The possible values are:\n     * * `primary`\n     * * `dark`\n     * * `light`\n     */\n    set themeColor(themeColor) {\n      this.handleThemeColorClass(this.themeColor, themeColor);\n      this._themeColor = themeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * @hidden\n     */\n    set htmlAttributes(attributes) {\n      setHTMLAttributes(attributes, this.renderer, this.wrapper.nativeElement);\n      const el = this.wrapper.nativeElement;\n      const dir = el.getAttribute('dir');\n      const tIndex = el.getAttribute('tabindex');\n      if (this.direction !== dir && dir) {\n        this.direction = dir;\n      }\n      if (this.tabIndex !== tIndex && tIndex) {\n        this.tabIndex = tIndex;\n      }\n      this._htmlAttributes = attributes;\n    }\n    get htmlAttributes() {\n      return this._htmlAttributes;\n    }\n    /**\n     * @hidden\n     */\n    set cssClass(classes) {\n      this.setServiceClasses(this._cssClass, classes);\n      this._cssClass = classes;\n    }\n    get cssClass() {\n      return this._cssClass;\n    }\n    /**\n     * @hidden\n     */\n\n    get dir() {\n      return this.direction;\n    }\n    constructor(wrapper, renderer, localization, cdr, ngZone, builder) {\n      _defineProperty(this, \"wrapper\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"builder\", void 0);\n      /**\n       * Specifies the action buttons that will be rendered.\n       */\n      _defineProperty(this, \"actions\", void 0);\n      /**\n       * Specifies the layout of the action buttons in the Dialog.\n       * This option is only applicable if the action buttons are specified through the `actions` options.\n       *\n       * @default 'stretched'\n       */\n      _defineProperty(this, \"actionsLayout\", 'stretched');\n      /**\n       * Specifies the query selector used to set the initial focus ([see examples]({% slug initial_focus_dialog %})).\n       */\n      _defineProperty(this, \"autoFocusedElement\", void 0);\n      /**\n       * Specifies the text that is rendered in the title bar.\n       */\n      _defineProperty(this, \"title\", void 0);\n      /**\n       * Specifies the width of the Dialog.\n       * A numeric value sets the width in pixels.\n       * A string value sets the width in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"width\", void 0);\n      /**\n       * Specifies the minimum width of the Dialog.\n       * A numeric value sets the minimum width in pixels.\n       * A string value sets the minimum width in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"minWidth\", void 0);\n      /**\n       * Specifies the maximum width of the Dialog.\n       * A numeric value sets the maximum width in pixels.\n       * A string value sets the maximum width in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"maxWidth\", void 0);\n      /**\n       * Specifies the height of the Dialog.\n       * A numeric value sets the height in pixels.\n       * A string value sets the height in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"height\", void 0);\n      /**\n       * Specifies the minimum height of the Dialog.\n       * A numeric value sets the minimum height in pixels.\n       * A string value sets the minimum height in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"minHeight\", void 0);\n      /**\n       * Specifies the maximum height of the Dialog.\n       * A numeric value sets the maximum height in pixels.\n       * A string value sets the maximum height in arbitrary units&mdash;for example, `50%`.\n       */\n      _defineProperty(this, \"maxHeight\", void 0);\n      /**\n       * Configures the Dialog opening animation ([see example]({% slug animations_dialog %})).\n       * By default the animation type is set to `translate` and its duration is `300ms`.\n       *\n       * @default true\n       */\n      _defineProperty(this, \"animation\", true);\n      _defineProperty(this, \"contentTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"titleId\", null);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"contentId\", null);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"closeTitle\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      /**\n       * Fires when the user clicks an action button of the Dialog.\n       * The event is fired only when the action buttons are specified through the `actions` options.\n       */\n      _defineProperty(this, \"action\", new EventEmitter());\n      /**\n       * Fires when the user clicks the **Close** button of the Dialog or the **ESC** key.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"tabIndex\", 0);\n      _defineProperty(this, \"titlebarContent\", void 0);\n      _defineProperty(this, \"titlebarView\", void 0);\n      _defineProperty(this, \"actionsView\", void 0);\n      _defineProperty(this, \"dialog\", void 0);\n      _defineProperty(this, \"_htmlAttributes\", void 0);\n      _defineProperty(this, \"_cssClass\", void 0);\n      _defineProperty(this, \"_themeColor\", null);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"subscriptions\", []);\n      _defineProperty(this, \"domSubs\", new Subscription());\n      this.wrapper = wrapper;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.builder = builder;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscriptions.push(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.titleId = this.generateTitleId();\n      this.contentId = this.generateContentId();\n    }\n    ngAfterContentInit() {\n      this.bubble('close', this.titlebarContent.first);\n      this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-describedby', this.contentId);\n      if (this.titlebarContent.first) {\n        this.titlebarContent.first.id = this.titleId;\n      } else {\n        this.subscriptions.push(this.titlebarContent.changes.subscribe(() => {\n          if (isPresent(this.titlebarContent.first)) {\n            this.titlebarContent.first.id = this.titleId;\n            this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n              this.bubble('close', this.titlebarContent.first);\n              this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n            });\n          }\n        }));\n      }\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this.handleInitialFocus();\n      });\n      this.bubble('close', this.titlebarView.first);\n      this.bubble('action', this.actionsView);\n      if (this.titlebarView.first || this.titlebarContent.first) {\n        //Needed for Dialogs created via service\n        this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n      } else {\n        this.subscriptions.push(this.titlebarView.changes.subscribe(() => {\n          if (isPresent(this.titlebarView.first)) {\n            this.titlebarView.first.id = this.titleId;\n            this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n              this.bubble('close', this.titlebarView.first);\n              this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n            });\n          }\n        }));\n      }\n      this.initDomEvents();\n      this.handleThemeColorClass(null, this.themeColor);\n    }\n    ngOnInit() {\n      if (this.animation) {\n        animateContent(this.animation, DEFAULT_ANIMATION_CONFIG, this.dialog.nativeElement, this.builder);\n      }\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'title');\n      this.cdr.detectChanges();\n    }\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n      this.subscriptions = [];\n      if (this.domSubs) {\n        this.domSubs.unsubscribe();\n      }\n    }\n    /**\n     * Focuses the wrapper of the Dialog component.\n     */\n    focus() {\n      const wrapper = this.wrapper.nativeElement;\n      if (isPresent(wrapper)) {\n        wrapper.focus();\n      }\n    }\n    initDomEvents() {\n      if (!this.wrapper) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubs.add(this.renderer.listen(this.wrapper.nativeElement, 'keydown', ev => {\n          this.onKeyDown(ev);\n        }));\n      });\n    }\n    onKeyDown(event) {\n      const target = event.target;\n      const parent = target.parentElement;\n      if (hasClasses(target, DIALOG_ELEMENTS_HANDLING_ESC_KEY) || hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ESC_KEY)) {\n        if (event.keyCode === Keys.esc) {\n          this.ngZone.run(() => {\n            this.close.emit(new DialogCloseResult());\n          });\n        }\n      }\n      if (hasClasses(target, 'k-button') && hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ARROWS) && (event.keyCode === Keys.left || event.keyCode === Keys.right)) {\n        this.ngZone.run(() => {\n          this.handleActionButtonFocus(parent, event.keyCode);\n        });\n      }\n      if (event.keyCode === Keys.tab) {\n        this.ngZone.run(() => {\n          this.keepFocusWithinComponent(target, event);\n        });\n      }\n    }\n    setServiceClasses(prevValue, value) {\n      const el = this.wrapper.nativeElement;\n      if (prevValue) {\n        parseCSSClassNames(prevValue).forEach(className => {\n          this.renderer.removeClass(el, className);\n        });\n      }\n      if (value) {\n        parseCSSClassNames(value).forEach(className => {\n          this.renderer.addClass(el, className);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n    handleInitialFocus() {\n      const wrapper = this.wrapper.nativeElement;\n      const primaryButton = this.findPrimary(wrapper);\n      if (this.autoFocusedElement) {\n        const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n        if (initiallyFocusedElement) {\n          initiallyFocusedElement.focus();\n        }\n      } else if (this.shouldFocusPrimary(primaryButton)) {\n        primaryButton.focus();\n      } else {\n        wrapper.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    findPrimary(wrapper) {\n      const actionBtns = wrapper.querySelectorAll('.k-actions .k-button');\n      return findPrimaryButton(actionBtns);\n    }\n    /**\n     * @hidden\n     */\n    handleActionButtonFocus(parent, key) {\n      const focusableActionButtons = this.getAllFocusableChildren(parent);\n      for (let i = 0; i < focusableActionButtons.length; i++) {\n        const current = focusableActionButtons[i];\n        if (current === document.activeElement) {\n          if (key === Keys.left && i > 0) {\n            focusableActionButtons[i - 1].focus();\n            break;\n          }\n          if (key === Keys.right && i < focusableActionButtons.length - 1) {\n            focusableActionButtons[i + 1].focus();\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n    keepFocusWithinComponent(target, event) {\n      const wrapper = this.wrapper.nativeElement;\n      const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);\n      const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;\n      const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;\n      if (tabAfterLastFocusable) {\n        event.preventDefault();\n        firstFocusable.focus();\n      }\n      if (shiftTabAfterFirstFocusable) {\n        event.preventDefault();\n        lastFocusable.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    shouldFocusPrimary(el) {\n      return isPresent(el) && isFocusable(el);\n    }\n    /**\n     * @hidden\n     */\n    getAllFocusableChildren(parent) {\n      return parent.querySelectorAll(focusableSelector);\n    }\n    /**\n     * @hidden\n     */\n    getFirstAndLastFocusable(parent) {\n      const all = this.getAllFocusableChildren(parent);\n      const firstFocusable = all.length > 0 ? all[0] : parent;\n      const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;\n      return [firstFocusable, lastFocusable];\n    }\n    /**\n     * @hidden\n     */\n    generateTitleId() {\n      return 'kendo-dialog-title-' + Math.ceil(Math.random() * 1000000).toString();\n    }\n    /**\n     * @hidden\n     */\n    generateContentId() {\n      return 'kendo-dialog-content-' + Math.ceil(Math.random() * 1000000).toString();\n    }\n    get wrapperClass() {\n      return true;\n    }\n    get styles() {\n      const styles = {};\n      if (this.width) {\n        styles.width = createValueWithUnit(this.width);\n      }\n      if (this.height) {\n        styles.height = createValueWithUnit(this.height);\n      }\n      if (this.minWidth) {\n        styles.minWidth = createValueWithUnit(this.minWidth);\n      }\n      if (this.maxWidth) {\n        styles.maxWidth = createValueWithUnit(this.maxWidth);\n      }\n      if (this.minHeight) {\n        styles.minHeight = createValueWithUnit(this.minHeight);\n      }\n      if (this.maxHeight) {\n        styles.maxHeight = createValueWithUnit(this.maxHeight);\n      }\n      return styles;\n    }\n    bubble(eventName, component) {\n      if (component) {\n        const emit = e => this[eventName].emit(e);\n        const s = component[eventName].subscribe(emit);\n        this.subscriptions.push(s);\n      }\n    }\n    handleThemeColorClass(previousValue, currentValue) {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        const dialog = this.dialog.nativeElement;\n        if (previousValue) {\n          const classToRemove = `k-dialog-${previousValue}`;\n          this.renderer.removeClass(dialog, classToRemove);\n        }\n        if (currentValue) {\n          const classToAdd = `k-dialog-${currentValue}`;\n          this.renderer.addClass(dialog, classToAdd);\n        }\n      });\n    }\n  }\n  _class7 = DialogComponent;\n  _defineProperty(DialogComponent, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AnimationBuilder));\n  });\n  _defineProperty(DialogComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class7,\n    selectors: [[\"kendo-dialog\"]],\n    contentQueries: function _class7_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DialogTitleBarComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titlebarContent = _t);\n      }\n    },\n    viewQuery: function _class7_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DialogActionsComponent, 5);\n        i0.ɵɵviewQuery(_c3, 7);\n        i0.ɵɵviewQuery(DialogTitleBarComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionsView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialog = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titlebarView = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function _class7_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir)(\"tabIndex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"k-dialog-wrapper\", ctx.wrapperClass);\n      }\n    },\n    inputs: {\n      actions: \"actions\",\n      actionsLayout: \"actionsLayout\",\n      autoFocusedElement: \"autoFocusedElement\",\n      title: \"title\",\n      width: \"width\",\n      minWidth: \"minWidth\",\n      maxWidth: \"maxWidth\",\n      height: \"height\",\n      minHeight: \"minHeight\",\n      maxHeight: \"maxHeight\",\n      animation: \"animation\",\n      themeColor: \"themeColor\"\n    },\n    outputs: {\n      action: \"action\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoDialog\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: DIALOG_LOCALIZATION_SERVICE,\n      useExisting: LocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dialog'\n    }]), i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c7,\n    decls: 12,\n    vars: 10,\n    consts: function () {\n      let i18n_4;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.dialog.closeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_5 = goog.getMsg(\"Close\");\n        i18n_4 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_5;\n      } else {\n        i18n_4 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;\n      }\n      return [[\"kendoDialogLocalizedMessages\", \"\", \"closeTitle\", i18n_4], [1, \"k-overlay\"], [\"role\", \"dialog\", \"aria-modal\", \"true\", 1, \"k-window\", \"k-dialog\", 3, \"ngStyle\"], [\"dialog\", \"\"], [3, \"closeTitle\", \"id\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-window-content\", \"k-dialog-content\", 3, \"id\"], [3, \"actions\", \"layout\", 4, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [3, \"closeTitle\", \"id\"], [3, \"ngTemplateOutlet\"], [3, \"actions\", \"layout\"], [\"kendoWatermarkOverlay\", \"\"]];\n    },\n    template: function _class7_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c6);\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2, 3);\n        i0.ɵɵtemplate(4, _class7_kendo_dialog_titlebar_4_Template, 2, 3, \"kendo-dialog-titlebar\", 4);\n        i0.ɵɵtemplate(5, _class7_ng_content_5_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementStart(6, \"div\", 6);\n        i0.ɵɵtemplate(7, _class7_ng_content_7_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵtemplate(8, _class7_8_Template, 1, 1, null, 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, _class7_ng_content_9_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵtemplate(10, _class7_kendo_dialog_actions_10_Template, 1, 2, \"kendo-dialog-actions\", 7);\n        i0.ɵɵtemplate(11, _class7_div_11_Template, 1, 0, \"div\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"@overlayAppear\", undefined);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngStyle\", ctx.styles);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.contentId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.contentTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.contentTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.actions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgStyle, NgIf, DialogTitleBarComponent, NgTemplateOutlet, DialogActionsComponent, WatermarkOverlayComponent],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('overlayAppear', [state('in', style({\n        opacity: 1\n      })), transition('void => *', [style({\n        opacity: 0.1\n      }), animate('.3s cubic-bezier(.2, .6, .4, 1)')])])]\n    }\n  }));\n  return DialogComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Holds references to the object instance and published events of the Dialog.\n * Controls the Dialogs that were opened through the `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogRef {\n  constructor() {\n    /**\n     * Emits events when the Dialog is closed either through the **Close** button of the title bar or through the action buttons.\n     * If the **Close** button of the title bar is clicked, `DialogResult` is a `DialogCloseResult` instance.\n     * If the Dialog is closed through the action buttons, `DialogResult` contains the object that was passed when the Dialog was opened.\n     * When `close` is called with an argument, the result is the passed argument.\n     */\n    _defineProperty(this, \"result\", void 0);\n    /**\n     * A reference to the Dialog instance.\n     */\n    _defineProperty(this, \"dialog\", void 0);\n    /**\n     * A reference to the child component of the Dialog.\n     * Available when the Dialog is opened with [component content](slug:service_dialog#toc-rendering-the-content-area).\n     */\n    _defineProperty(this, \"content\", void 0);\n    /**\n     * Allows you to close the Dialog through code.\n     * When called with no arguments,\n     * the `result` Observable will be of type DialogCloseResult.\n     * When called with an argument, the `result` Observable will hold the provided value.\n     */\n    _defineProperty(this, \"close\", void 0);\n  }\n}\n\n/**\n * The base class  which will be extended by a component that is provided as content through `content`\n * ([see example](slug:service_dialog#toc-single-component-rendering)).\n */\nlet DialogContentBase = /*#__PURE__*/(() => {\n  var _class9;\n  class DialogContentBase {\n    constructor(dialog) {\n      _defineProperty(this, \"dialog\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dialogTitleBar\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"dialogActions\", void 0);\n      this.dialog = dialog;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n      if (this.dialogTitleBar) {\n        // when opening component inside dialog with service AND the component has defined its own titlebar\n        this.dialogTitleBar.close.pipe(filter(e => !e.isDefaultPrevented())).subscribe(() => {\n          this.dialog.close();\n        });\n      }\n      if (this.dialogActions) {\n        if (this.dialogActions.actions) {\n          this.dialogActions.action.subscribe(action => this.dialog.dialog.instance.action.emit(action));\n        }\n      }\n    }\n  }\n  _class9 = DialogContentBase;\n  _defineProperty(DialogContentBase, \"\\u0275fac\", function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵdirectiveInject(DialogRef));\n  });\n  _defineProperty(DialogContentBase, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class9,\n    viewQuery: function _class9_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DialogTitleBarComponent, 5);\n        i0.ɵɵviewQuery(DialogActionsComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialogTitleBar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialogActions = _t.first);\n      }\n    }\n  }));\n  return DialogContentBase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet DialogContainerService = /*#__PURE__*/(() => {\n  var _class10;\n  class DialogContainerService {\n    set container(container) {\n      DialogContainerService.container = container;\n    }\n    get container() {\n      return DialogContainerService.container;\n    }\n  }\n  _class10 = DialogContainerService;\n  _defineProperty(DialogContainerService, \"container\", null);\n  _defineProperty(DialogContainerService, \"\\u0275fac\", function _class10_Factory(t) {\n    return new (t || _class10)();\n  });\n  _defineProperty(DialogContainerService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class10,\n    factory: _class10.ɵfac,\n    providedIn: 'root'\n  }));\n  return DialogContainerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The settings for the Dialog actions when the Dialog is opened through `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogAction {\n  constructor() {\n    /**\n     * The text of the action button.\n     */\n    _defineProperty(this, \"text\", void 0);\n    /**\n     * Determines the theme color of the action button. The theme color will be applied as a background and border color while also amending the text color accordingly.\n     */\n    _defineProperty(this, \"themeColor\", void 0);\n    /**\n     * Specifies the background and border styles of the action button.\n     */\n    _defineProperty(this, \"fillMode\", void 0);\n    /**\n     * Sets the CSS classes that will be rendered on the action button.\n     * Supports the union type of values that NgClass accepts [ngClass](link:site.data.urls.angular['ngclassapi']).\n     */\n    _defineProperty(this, \"cssClass\", void 0);\n  }\n}\n\n/**\n * The settings that can be used when the Dialog is opened through `DialogService`.\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogSettings {\n  constructor() {\n    /**\n     * Defines a predicate that verifies if the pressed dialog action should be prevented. Returning true from the predicate prevents the dialog from closing.\n     * If the **Close** button of the title bar is clicked, `DialogResult` is a `DialogCloseResult` instance.\n     * If the Dialog is closed through the action buttons, `DialogResult` contains the object that was passed when the Dialog was opened. ([see example](slug:service_dialog#toc-dialog-close-prevention))\n     * @param {DialogResult} ev\n     * @param {DialogRef} [dialogRef] - provided only when the dialog is created using a component.\n     * @returns\n     */\n    _defineProperty(this, \"preventAction\", void 0);\n    /**\n     * Sets the title of the Dialog. If `title` is omitted,\n     * the Dialog will not render a **Close** button.\n     */\n    _defineProperty(this, \"title\", void 0);\n    /**\n     * Sets the CSS classes that will be rendered on the Dialog wrapper element.\n     * Supports the union type of values that NgClass accepts [ngClass](link:site.data.urls.angular['ngclassapi']).\n     */\n    _defineProperty(this, \"cssClass\", void 0);\n    /**\n     * Configures the Dialog opening animation ([see example]({% slug animations_dialog %})).\n     * By default the animation type is set to `translate` and its duration is `300ms`.\n     */\n    _defineProperty(this, \"animation\", void 0);\n    /**\n     * Sets the HTML attributes of the Dialog wrapper element.\n     * The property accepts string key-value based pairs.\n     */\n    _defineProperty(this, \"htmlAttributes\", void 0);\n    /**\n     * Defines the content of the Dialog.\n     * ([see example](slug:service_dialog#toc-rendering-the-content-area)).\n     */\n    _defineProperty(this, \"content\", void 0);\n    /**\n     * Specifies the width of the Dialog.\n     * A numeric value sets the width in pixels.\n     * A string value sets the width in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"width\", void 0);\n    /**\n     * Specifies the minimum width of the Dialog.\n     * A numeric value sets the minimum width in pixels.\n     * A string value sets the minimum width in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"minWidth\", void 0);\n    /**\n     * Specifies the maximum width of the Dialog.\n     * A numeric value sets the maximum width in pixels.\n     * A string value sets the maximum width in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"maxWidth\", void 0);\n    /**\n     * Specifies the height of the Dialog.\n     * A numeric value sets the height in pixels.\n     * A string value sets the height in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"height\", void 0);\n    /**\n     * Specifies the minimum height of the Dialog.\n     * A numeric value sets the minimum height in pixels.\n     * A string value sets the minimum height in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"minHeight\", void 0);\n    /**\n     * Specifies the maximum height of the Dialog.\n     * A numeric value sets the maximum height in pixels.\n     * A string value sets the maximum height in arbitrary units&mdash;for example, `50%`.\n     */\n    _defineProperty(this, \"maxHeight\", void 0);\n    /**\n     * Defines the container in which the Dialog will be inserted.\n     * Specifying this option changes the place in the page hierarchy where the Dialog will be inserted.\n     * The styling of the component will remain the same.\n     */\n    _defineProperty(this, \"appendTo\", void 0);\n    /**\n     * Specifies the title of the close button.\n     */\n    _defineProperty(this, \"closeTitle\", void 0);\n    /**\n     * Sets the action buttons of the Dialog.\n     */\n    _defineProperty(this, \"actions\", void 0);\n    /**\n     * Specifies the layout of the action buttons in the Dialog.\n     */\n    _defineProperty(this, \"actionsLayout\", void 0);\n    /**\n     * Sets the focused element query selector.\n     */\n    _defineProperty(this, \"autoFocusedElement\", void 0);\n    /**\n     * Specifies the theme color of the Dialog.\n     */\n    _defineProperty(this, \"themeColor\", void 0);\n  }\n}\n\n// eslint-disable max-line-length\nconst isNotComponent$1 = component => isString(component) || component instanceof TemplateRef;\nclass DialogInjector {\n  constructor(getDialogRef, parentInjector) {\n    _defineProperty(this, \"getDialogRef\", void 0);\n    _defineProperty(this, \"parentInjector\", void 0);\n    this.getDialogRef = getDialogRef;\n    this.parentInjector = parentInjector;\n  }\n  get(token, notFoundValue) {\n    if (token === DialogRef) {\n      return this.getDialogRef();\n    }\n    return this.parentInjector.get(token, notFoundValue);\n  }\n}\n/**\n * A service for opening Dialog windows dynamically\n * ([see example]({% slug service_dialog %})).\n */\nlet DialogService = /*#__PURE__*/(() => {\n  var _class14;\n  class DialogService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n      _defineProperty(this, \"resolver\", void 0);\n      _defineProperty(this, \"containerService\", void 0);\n      this.resolver = resolver;\n      this.containerService = containerService;\n    }\n    /**\n     * Opens a Dialog window. Requires an element in the application that uses the\n     * [`kendoDialogContainer`]({% slug api_dialog_dialogcontainerdirective %}) directive.\n     * Created Dialogs will be mounted in the DOM directly after that element.\n     *\n     * @param {DialogAction} options - The options that define the Dialog.\n     * @returns {DialogRef} - A reference to the Dialog object and the convenience properties.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Harmless button</button>\n     *     <div kendoDialogContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private dialogService: DialogService ) {}\n     *\n     *     public open() {\n     *         var dialog = this.dialogService.open({\n     *           title: \"Please confirm\",\n     *           content: \"Are you sure?\",\n     *           actions: [\n     *             { text: \"No\" },\n     *             { text: \"Yes\", themeColor: 'primary' }\n     *           ]\n     *         });\n     *\n     *         dialog.result.subscribe((result) => {\n     *           if (result instanceof DialogCloseResult) {\n     *             console.log(\"close\");\n     *           } else {\n     *             console.log(\"action\", result);\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n    open(options) {\n      const factory = this.resolver.resolveComponentFactory(DialogComponent);\n      const container = options.appendTo || this.containerService.container;\n      if (!container) {\n        throw new Error(`\nCannot attach dialog to the page.\nAdd an element that uses the kendoDialogContainer directive, or set the 'appendTo' property.\nSee https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/.\n          `);\n      }\n      // create DialogRef to (1) pass as result, (2) provide through injector\n      const dialogRef = {\n        close: () => {\n          /* noop */\n        },\n        content: null,\n        dialog: null,\n        result: null\n      };\n      return this.initializeDialog(options.content, factory, container, dialogRef, options);\n    }\n    initializeDialog(component, factory, container, dialogRef, options) {\n      const content = this.contentFrom(component, container, dialogRef);\n      const dialog = container.createComponent(factory, undefined, undefined, content.nodes);\n      dialogRef.dialog = dialog;\n      dialog.changeDetectorRef.markForCheck();\n      // copy @Input options to dialog instance\n      this.applyOptions(dialog.instance, options);\n      // create close handler and result stream\n      const apiClose = new Subject();\n      const close = e => {\n        if (e instanceof PreventableEvent) {\n          e = new DialogCloseResult();\n        }\n        apiClose.next(e || new DialogCloseResult());\n        if (content.componentRef) {\n          content.componentRef.destroy();\n        }\n        dialog.destroy();\n      };\n      const result = merge(apiClose,\n      // triggered when the titlebar or actions are defined in DialogSettings\n      merge(dialog.instance.close, dialog.instance.action).pipe(map(e => e instanceof PreventableEvent ? new DialogCloseResult() : e), filter(e => {\n        if (options.preventAction) {\n          // add dialogRef only when using component\n          const dialogRefParameter = isNotComponent$1(component) ? undefined : dialogRef;\n          return !options.preventAction(e, dialogRefParameter);\n        }\n        return true;\n      }))).pipe(take(1),\n      // Takes care for multiple subscriptions:\n      // We subscribe internaly and the user may subscribe to get a close result - dialog.result.subscribe().\n      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.\n      share());\n      result.subscribe(close);\n      dialogRef.close = close;\n      dialogRef.result = result;\n      if (component && isDevMode()) {\n        const hasContentTitle = content.nodes[0] && content.nodes[0].length > 0;\n        const hasContentActions = content.nodes[2] && content.nodes[2].length > 0;\n        const multipleTitles = options.title && hasContentTitle;\n        const multipleActions = options.actions && hasContentActions;\n        if (component.prototype instanceof DialogContentBase) {\n          // content component extends DialogContentBase\n          if (multipleTitles || multipleActions) {\n            console.warn(`\n                    Multiple Title and/or Actions configurations detected.\n                    When using a component as content, provide the title and actions either in the component's markup\n                    or via the title and actions properties of the DialogSettings object, but not both.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);\n          }\n        } else {\n          if (hasContentTitle || hasContentActions) {\n            console.warn(`\n                    When Title and/or Actions markup is provided in content component's template,\n                    the component needs to inherit the DialogContentBase class to ensure that close and result events are properly hooked.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);\n          }\n        }\n      }\n      return dialogRef;\n    }\n    applyOptions(instance, options) {\n      instance.title = options.title;\n      instance.actions = options.actions;\n      instance.actionsLayout = options.actionsLayout || 'stretched';\n      instance.width = options.width;\n      instance.minWidth = options.minWidth;\n      instance.maxWidth = options.maxWidth;\n      instance.height = options.height;\n      instance.minHeight = options.minHeight;\n      instance.maxHeight = options.maxHeight;\n      instance.autoFocusedElement = options.autoFocusedElement;\n      instance.themeColor = options.themeColor != undefined ? options.themeColor : null;\n      instance.closeTitle = options.closeTitle;\n      instance.cssClass = options.cssClass;\n      instance.htmlAttributes = options.htmlAttributes;\n      instance.animation = options.animation !== undefined ? options.animation : true;\n      if (options.content instanceof TemplateRef) {\n        instance.contentTemplate = options.content;\n      }\n    }\n    contentFrom(content, container, dialogRef) {\n      const renderer = container.injector.get(Renderer2);\n      let nodes = [];\n      let titleNodes = [];\n      let actionNodes = [];\n      let componentRef = null;\n      if (typeof content === 'string') {\n        nodes = [renderer.createText(content)];\n      } else if (content && !(content instanceof TemplateRef)) {\n        // Component\n        const injector = new DialogInjector(() => dialogRef, container.injector);\n        const factory = this.resolver.resolveComponentFactory(content);\n        componentRef = container.createComponent(factory, undefined, injector);\n        titleNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-titlebar'));\n        nodes = [componentRef.location.nativeElement];\n        actionNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-actions'));\n        dialogRef.content = componentRef;\n      }\n      return {\n        componentRef,\n        nodes: [titleNodes, nodes, actionNodes // <ng-content select=\"kendo-dialog-actions\">\n        ]\n      };\n    }\n  }\n  _class14 = DialogService;\n  _defineProperty(DialogService, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(DialogContainerService));\n  });\n  _defineProperty(DialogService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class14,\n    factory: _class14.ɵfac,\n    providedIn: 'root'\n  }));\n  return DialogService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet newZIndex = 10002;\n/**\n * @hidden\n */\nconst DEFAULT_OPTIONS = {\n  draggable: true,\n  height: null,\n  left: null,\n  minHeight: 100,\n  minWidth: 120,\n  position: 'absolute',\n  resizable: true,\n  state: 'default',\n  top: null,\n  width: null\n};\n/**\n * @hidden\n */\nconst createMoveStream = (el, ev) => mouseDown => {\n  return el.kendoDrag.pipe(takeUntil(el.kendoRelease.pipe(tap(() => {\n    ev.emit();\n  }))), map(({\n    pageX,\n    pageY\n  }) => ({\n    originalX: mouseDown.pageX,\n    originalY: mouseDown.pageY,\n    pageX,\n    pageY\n  })));\n};\n/**\n * @hidden\n */\nlet DragResizeService = /*#__PURE__*/(() => {\n  var _class15;\n  class DragResizeService {\n    constructor(ngZone) {\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"close\", new EventEmitter());\n      _defineProperty(this, \"focus\", new EventEmitter());\n      _defineProperty(this, \"change\", new EventEmitter());\n      _defineProperty(this, \"stateChange\", new EventEmitter());\n      _defineProperty(this, \"dragStart\", new EventEmitter());\n      _defineProperty(this, \"dragEnd\", new EventEmitter());\n      _defineProperty(this, \"resizeStart\", new EventEmitter());\n      _defineProperty(this, \"resizeEnd\", new EventEmitter());\n      _defineProperty(this, \"options\", Object.assign({}, DEFAULT_OPTIONS));\n      _defineProperty(this, \"restoreOptions\", void 0);\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"lastAction\", null);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      _defineProperty(this, \"dragSubscription\", new Subscription());\n      this.ngZone = ngZone;\n    }\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n      if (this.dragSubscription) {\n        this.dragSubscription.unsubscribe();\n      }\n    }\n    init(el) {\n      const state = this.options.state;\n      const options = this.options;\n      this.window = el;\n      if (state !== 'default') {\n        this.restoreOptions = Object.assign({}, options);\n      }\n      if (state === 'minimized') {\n        options.height = 0;\n        options.minHeight = 0;\n      }\n      if (state === 'maximized') {\n        options.position = 'fixed';\n      }\n    }\n    onDrag(el) {\n      this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n        let startPosition;\n        let dragStarted;\n        this.dragSubscription = el.kendoPress.pipe(tap(ev => {\n          if (!ev.isTouch) {\n            preventDefault(ev);\n          }\n          this.focus.emit();\n          startPosition = this.currentPosition();\n          dragStarted = false;\n        }), switchMap(createMoveStream(el, this.dragEnd))).subscribe(({\n          pageX,\n          pageY,\n          originalX,\n          originalY\n        }) => {\n          if (!dragStarted) {\n            this.ensureWidth();\n            this.dragStart.emit();\n            dragStarted = true;\n          }\n          this.handleDrag({\n            originalX,\n            originalY,\n            pageX,\n            pageY,\n            startPosition\n          });\n        });\n      }));\n    }\n    handleDrag({\n      originalX,\n      originalY,\n      pageX,\n      pageY,\n      startPosition\n    }) {\n      this.options.left = startPosition.x + pageX - originalX;\n      this.options.top = startPosition.y + pageY - originalY;\n      if (this.options.state === 'minimized' && isPresent(this.restoreOptions)) {\n        this.restoreOptions.left = this.options.left;\n        this.restoreOptions.top = this.options.top;\n      }\n      this.change.emit({\n        left: startPosition.x + pageX - originalX,\n        top: startPosition.y + pageY - originalY\n      });\n    }\n    onResize(handle, direction) {\n      this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n        let startOffsetAndPosition;\n        let resizeStarted = false;\n        handle.kendoPress.pipe(tap(ev => {\n          preventDefault(ev);\n          this.focus.emit();\n          startOffsetAndPosition = this.currentOffsetAndPosition();\n          resizeStarted = false;\n        }), switchMap(createMoveStream(handle, this.resizeEnd))).subscribe(({\n          pageX,\n          pageY,\n          originalX,\n          originalY\n        }) => {\n          if (!resizeStarted) {\n            this.resizeStart.emit(direction);\n            resizeStarted = true;\n          }\n          const deltaX = pageX - originalX;\n          const deltaY = pageY - originalY;\n          this.handleResize(startOffsetAndPosition, direction, deltaX, deltaY);\n        });\n      }));\n    }\n    handleResize(initial, dir, deltaX, deltaY) {\n      const old = this.options;\n      const ev = {};\n      if (dir.indexOf('e') >= 0) {\n        const newWidth = initial.width + deltaX;\n        if (newWidth !== old.width && newWidth >= old.minWidth) {\n          ev.width = newWidth;\n        }\n      }\n      if (dir.indexOf('n') >= 0) {\n        const newHeight = initial.height - deltaY;\n        const newTop = initial.y + deltaY;\n        if (newHeight !== old.height && newHeight >= old.minHeight && newTop !== old.top) {\n          ev.height = newHeight;\n          ev.top = newTop;\n        }\n      }\n      if (dir.indexOf('s') >= 0) {\n        const newHeight = initial.height + deltaY;\n        if (newHeight !== old.height && newHeight >= old.minHeight) {\n          ev.height = newHeight;\n        }\n      }\n      if (dir.indexOf('w') >= 0) {\n        const newLeft = initial.x + deltaX;\n        const newWidth = initial.width - deltaX;\n        if (newWidth !== old.width && newWidth >= old.minWidth && newLeft !== old.left) {\n          ev.width = newWidth;\n          ev.left = newLeft;\n        }\n      }\n      if (isPresent(ev.width) || isPresent(ev.height)) {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.options[style] = ev[style];\n          }\n        });\n        this.change.emit(ev);\n      }\n    }\n    restoreAction() {\n      this.lastAction = 'restore';\n      this.defaultState();\n    }\n    defaultState() {\n      if (isPresent(this.restoreOptions)) {\n        this.options = Object.assign({}, this.restoreOptions);\n      }\n      this.options.state = 'default';\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        if (!isPresent(this.options.left) || !isPresent(this.options.top)) {\n          this.center();\n        }\n      });\n      this.stateChange.emit('default');\n    }\n    storeOptions() {\n      this.restoreOptions = Object.assign({}, this.options);\n    }\n    maximizeAction() {\n      this.lastAction = 'maximize';\n      this.maximizeState();\n    }\n    maximizeState() {\n      this.storeOptions();\n      const wnd = this.windowViewPort;\n      this.options = Object.assign({}, this.options, {\n        height: wnd.height,\n        left: 0,\n        position: 'fixed',\n        state: 'maximized',\n        top: 0,\n        width: wnd.width\n      });\n      this.stateChange.emit('maximized');\n    }\n    minimizeAction() {\n      this.lastAction = 'minimize';\n      this.minimizeState();\n    }\n    minimizeState() {\n      this.storeOptions();\n      this.options = Object.assign({}, this.options, {\n        height: null,\n        minHeight: 0,\n        state: 'minimized'\n      });\n      this.stateChange.emit('minimized');\n    }\n    /**\n     * Handles manual changes of the 'state' property.\n     * Required to distinguish them from action clicks.\n     */\n    applyManualState() {\n      const state = this.options.state;\n      switch (state) {\n        case 'default':\n          this.clearHeight();\n          this.defaultState();\n          break;\n        case 'maximized':\n          this.clearHeight();\n          this.maximizeState();\n          break;\n        case 'minimized':\n          this.minimizeState();\n          break;\n        default:\n          break;\n      }\n    }\n    closeAction() {\n      this.close.emit();\n    }\n    ensureWidth() {\n      const windowOffset = offset(this.window.nativeElement);\n      if (!isPresent(this.options.width)) {\n        this.options.width = windowOffset.width;\n        this.change.emit({\n          width: windowOffset.width\n        });\n      }\n    }\n    clearHeight() {\n      if (this.options.height === 0) {\n        delete this.options.height;\n      }\n      if (this.options.minHeight === 0) {\n        delete this.options.minHeight;\n      }\n    }\n    center() {\n      if (this.options.state === 'maximized') {\n        return;\n      }\n      const scroll = scrollPosition(this.window.nativeElement);\n      const wnd = this.windowViewPort;\n      const wrapper = offset(this.window.nativeElement);\n      const ev = {};\n      if (!isPresent(this.options.left)) {\n        this.options.left = scroll.x + Math.max(0, (wnd.width - wrapper.width) / 2);\n        ev.left = this.options.left;\n      }\n      if (!isPresent(this.options.top)) {\n        this.options.top = scroll.y + Math.max(0, (wnd.height - wrapper.height) / 2);\n        ev.top = this.options.top;\n      }\n      this.change.emit(ev);\n    }\n    currentOffsetAndPosition() {\n      const o = this.options;\n      const off = offset(this.window.nativeElement);\n      return Object.assign({}, this.currentPosition(), {\n        height: o.height ? o.height : off.height,\n        width: o.width ? o.width : off.width\n      });\n    }\n    currentPosition() {\n      const o = this.options;\n      if (!o.top || !o.left) {\n        this.setPosition();\n      }\n      return {\n        x: this.options.left,\n        y: this.options.top\n      };\n    }\n    setPosition() {\n      const wrapper = positionWithScroll(this.window.nativeElement, getDocumentElement(this.window.nativeElement));\n      this.options.left = wrapper.left;\n      this.options.top = wrapper.top;\n    }\n    setRestoreOption(style, value) {\n      if (isPresent(this.restoreOptions)) {\n        this.restoreOptions[style] = value;\n      }\n    }\n    get nextPossibleZIndex() {\n      return newZIndex;\n    }\n    get nextZIndex() {\n      return newZIndex++;\n    }\n    get windowViewPort() {\n      return getWindowViewPort(this.window.nativeElement);\n    }\n  }\n  _class15 = DragResizeService;\n  _defineProperty(DragResizeService, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(DragResizeService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class15,\n    factory: _class15.ɵfac\n  }));\n  return DragResizeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet ResizeHandleDirective = /*#__PURE__*/(() => {\n  var _class16;\n  class ResizeHandleDirective {\n    get hostClass() {\n      return true;\n    }\n    constructor(draggable, el, renderer, service) {\n      _defineProperty(this, \"draggable\", void 0);\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"subscriptions\", new Subscription());\n      this.draggable = draggable;\n      this.el = el;\n      this.renderer = renderer;\n      this.service = service;\n    }\n    ngOnInit() {\n      this.setDisplay();\n      this.renderer.addClass(this.el.nativeElement, 'k-resize-' + this.direction);\n      this.subscriptions.add(of(this.draggable).subscribe(handle => {\n        this.service.onResize(handle, this.direction);\n      }));\n      this.subscriptions.add(this.service.resizeStart.subscribe(dir => {\n        if (dir !== this.direction) {\n          this.setDisplay('none');\n        }\n      }));\n      this.subscriptions.add(this.service.dragStart.subscribe(() => {\n        this.setDisplay('none');\n      }));\n      this.subscriptions.add(merge(this.service.resizeEnd, this.service.dragEnd).subscribe(() => {\n        this.setDisplay('block');\n      }));\n      this.subscriptions.add(this.service.stateChange.subscribe(state => {\n        this.setDisplay(state === 'default' ? 'block' : 'none');\n      }));\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    setDisplay(value = 'block') {\n      this.renderer.setStyle(this.el.nativeElement, 'display', this.service.options.state === 'default' ? value : 'none');\n    }\n  }\n  _class16 = ResizeHandleDirective;\n  _defineProperty(ResizeHandleDirective, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService));\n  });\n  _defineProperty(ResizeHandleDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class16,\n    selectors: [[\"\", \"kendoWindowResizeHandle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function _class16_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-resize-handle\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      direction: \"direction\"\n    },\n    standalone: true\n  }));\n  return ResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WindowTitleBarComponent = /*#__PURE__*/(() => {\n  var _class17;\n  class WindowTitleBarComponent {\n    constructor(el, service, ngZone) {\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"template\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"id\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"dragDirective\", void 0);\n      _defineProperty(this, \"dragSubscription\", void 0);\n      _defineProperty(this, \"stateSubscription\", void 0);\n      this.el = el;\n      this.ngZone = ngZone;\n      this.service = service;\n    }\n    ngOnInit() {\n      this.dragDirective = new DraggableDirective(this.el, this.ngZone);\n      this.dragDirective.ngOnInit();\n      if (this.isDraggable) {\n        this.subscribeDrag();\n      }\n      this.subscribeStateChange();\n    }\n    ngAfterViewInit() {\n      const element = this.el.nativeElement.querySelector('.k-window-title');\n      if (isPresent(element)) {\n        element.setAttribute('id', this.id);\n      }\n    }\n    ngOnDestroy() {\n      this.dragDirective.ngOnDestroy();\n      this.unsubscribeDrag();\n      this.unsubscribeState();\n    }\n    /**\n     * @hidden\n     */\n    subscribeDrag() {\n      this.unsubscribeDrag();\n      this.dragSubscription = of(this.dragDirective).subscribe(titleBar => {\n        this.service.onDrag(titleBar);\n      });\n    }\n    /**\n     * @hidden\n     */\n    subscribeStateChange() {\n      this.stateSubscription = this.service.stateChange.subscribe(state => {\n        if (this.service.options.draggable) {\n          if (state === 'maximized') {\n            this.unsubscribeDrag();\n          } else {\n            this.subscribeDrag();\n          }\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n    unsubscribeDrag() {\n      if (this.dragSubscription) {\n        this.service.dragSubscription.unsubscribe();\n        this.dragSubscription.unsubscribe();\n        this.dragSubscription = null;\n      }\n    }\n    /**\n     * @hidden\n     */\n    unsubscribeState() {\n      if (this.stateSubscription) {\n        this.stateSubscription.unsubscribe();\n        this.stateSubscription = null;\n      }\n    }\n    get className() {\n      return true;\n    }\n    get touchAction() {\n      if (this.isDraggable) {\n        return 'none';\n      }\n    }\n    /**\n     * @hidden\n     */\n    handle(ev) {\n      const target = ev.target;\n      const state = this.service.options.state;\n      if (!hasClasses(target, 'k-icon') && !isFocusable(target, false) && this.service.options.resizable) {\n        if (state === 'default') {\n          this.service.maximizeAction();\n        } else if (state === 'maximized') {\n          this.service.restoreAction();\n        }\n      }\n    }\n    get isDraggable() {\n      const options = this.service.options;\n      return options.draggable && options.state !== 'maximized';\n    }\n  }\n  _class17 = WindowTitleBarComponent;\n  _defineProperty(WindowTitleBarComponent, \"\\u0275fac\", function _class17_Factory(t) {\n    return new (t || _class17)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DragResizeService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(WindowTitleBarComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class17,\n    selectors: [[\"kendo-window-titlebar\"]],\n    hostVars: 4,\n    hostBindings: function _class17_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function _class17_dblclick_HostBindingHandler($event) {\n          return ctx.handle($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchAction);\n        i0.ɵɵclassProp(\"k-window-titlebar\", ctx.className);\n      }\n    },\n    inputs: {\n      template: \"template\",\n      id: \"id\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function _class17_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class17_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, _class17_1_Template, 1, 4, null, 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    dependencies: [NgIf, NgTemplateOutlet],\n    encapsulation: 2\n  }));\n  return WindowTitleBarComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @hidden\n */\nlet NavigationService = /*#__PURE__*/(() => {\n  var _class18;\n  class NavigationService {\n    constructor(window, ngZone) {\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      this.window = window;\n      this.ngZone = ngZone;\n    }\n    process(ev) {\n      const key = ev.keyCode;\n      switch (key) {\n        case Keys.up:\n        case Keys.down:\n        case Keys.left:\n        case Keys.right:\n          {\n            ev.preventDefault();\n            this.ngZone.run(() => {\n              this.handleArrow(key, ev);\n            });\n            break;\n          }\n        case Keys.esc:\n          this.ngZone.run(() => {\n            this.handleEscape();\n          });\n          break;\n        default:\n          break;\n      }\n    }\n    handleArrow(key, ev) {\n      const options = this.window.options;\n      if (ev.altKey) {\n        this.handleStateChange(key, options.state);\n        return;\n      }\n      if ((ev.ctrlKey || ev.metaKey) && options.state === 'default') {\n        this.handleResize(key);\n      } else {\n        this.handleDrag(key);\n      }\n    }\n    handleEscape() {\n      this.window.closeAction();\n    }\n    handleDrag(key) {\n      const options = this.window.options;\n      if (!options.draggable) {\n        return;\n      }\n      const offset = this.window.currentOffsetAndPosition();\n      const restoreOptions = this.window.restoreOptions;\n      const ev = {};\n      let delta = 10;\n      if (key === Keys.left || key === Keys.up) {\n        delta *= -1;\n      }\n      switch (key) {\n        case Keys.left:\n        case Keys.right:\n          {\n            ev.left = offset.x + delta;\n            options.left = ev.left;\n            break;\n          }\n        case Keys.up:\n        case Keys.down:\n          {\n            ev.top = offset.y + delta;\n            options.top = ev.top;\n            break;\n          }\n        default:\n          break;\n      }\n      if (options.state === 'minimized' && isPresent(restoreOptions)) {\n        restoreOptions.left = options.left;\n        restoreOptions.top = options.top;\n      }\n      this.window.change.emit(ev);\n    }\n    handleResize(key) {\n      const options = this.window.options;\n      if (!options.resizable) {\n        return;\n      }\n      const offset = this.window.currentOffsetAndPosition();\n      let newWidth;\n      let newHeight;\n      const ev = {};\n      let delta = 10;\n      if (key === Keys.left || key === Keys.up) {\n        delta *= -1;\n      }\n      switch (key) {\n        case Keys.left:\n        case Keys.right:\n          {\n            newWidth = offset.width + delta;\n            if (newWidth !== options.width && newWidth >= options.minWidth) {\n              ev.width = newWidth;\n            }\n            break;\n          }\n        case Keys.up:\n        case Keys.down:\n          {\n            newHeight = offset.height + delta;\n            if (newHeight !== options.height && newHeight >= options.minHeight) {\n              ev.height = newHeight;\n            }\n            break;\n          }\n        default:\n          break;\n      }\n      if (isPresent(ev.width) || isPresent(ev.height)) {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.window.options[style] = ev[style];\n          }\n        });\n        this.window.change.emit(ev);\n      }\n    }\n    handleStateChange(key, state) {\n      if (state === 'minimized' && key === Keys.up || state === 'maximized' && key === Keys.down) {\n        this.window.restoreAction();\n        return;\n      }\n      if (state === 'default') {\n        if (key === Keys.up) {\n          this.window.maximizeAction();\n        } else if (key === Keys.down) {\n          this.window.minimizeAction();\n        }\n      }\n    }\n  }\n  _class18 = NavigationService;\n  _defineProperty(NavigationService, \"\\u0275fac\", function _class18_Factory(t) {\n    return new (t || _class18)(i0.ɵɵinject(DragResizeService), i0.ɵɵinject(i0.NgZone));\n  });\n  _defineProperty(NavigationService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class18,\n    factory: _class18.ɵfac\n  }));\n  return NavigationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WindowCloseActionDirective = /*#__PURE__*/(() => {\n  var _class19;\n  class WindowCloseActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"window\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"xIcon\", xIcon);\n      _defineProperty(this, \"buttonType\", 'button');\n      _defineProperty(this, \"buttonClass\", true);\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'x';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.closeAction();\n      }\n    }\n  }\n  _class19 = WindowCloseActionDirective;\n  _defineProperty(WindowCloseActionDirective, \"\\u0275fac\", function _class19_Factory(t) {\n    return new (t || _class19)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(WindowCloseActionDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class19,\n    selectors: [[\"button\", \"kendoWindowCloseAction\", \"\"]],\n    hostVars: 3,\n    hostBindings: function _class19_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class19_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵclassProp(\"k-window-titlebar-action\", ctx.buttonClass);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowCloseAction\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c9,\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", \"name\", \"close\", 3, \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", \"name\", \"close\", 3, \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class19_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class19_kendo_icon_wrapper_0_Template, 1, 1, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class19_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class19_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.imageUrl && !ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return WindowCloseActionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WindowRestoreActionDirective = /*#__PURE__*/(() => {\n  var _class20;\n  class WindowRestoreActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"window\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"windowRestoreIcon\", windowRestoreIcon);\n      _defineProperty(this, \"buttonType\", 'button');\n      _defineProperty(this, \"buttonClass\", true);\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window-restore';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.restoreAction();\n      }\n    }\n    get visible() {\n      return this.window.options.state === 'default' ? 'none' : 'inline-flex';\n    }\n  }\n  _class20 = WindowRestoreActionDirective;\n  _defineProperty(WindowRestoreActionDirective, \"\\u0275fac\", function _class20_Factory(t) {\n    return new (t || _class20)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(WindowRestoreActionDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class20,\n    selectors: [[\"button\", \"kendoWindowRestoreAction\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class20_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class20_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-window-titlebar-action\", ctx.buttonClass);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowRestoreAction\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c10,\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", \"name\", \"window-restore\", 3, \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", \"name\", \"window-restore\", 3, \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class20_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class20_kendo_icon_wrapper_0_Template, 1, 1, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class20_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class20_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.imageUrl && !ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return WindowRestoreActionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WindowMaximizeActionDirective = /*#__PURE__*/(() => {\n  var _class21;\n  class WindowMaximizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"buttonType\", 'button');\n      _defineProperty(this, \"buttonClass\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"windowIcon\", windowIcon);\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.maximizeAction();\n      }\n    }\n    get visible() {\n      return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n  }\n  _class21 = WindowMaximizeActionDirective;\n  _defineProperty(WindowMaximizeActionDirective, \"\\u0275fac\", function _class21_Factory(t) {\n    return new (t || _class21)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(WindowMaximizeActionDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class21,\n    selectors: [[\"button\", \"kendoWindowMaximizeAction\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class21_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class21_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-window-titlebar-action\", ctx.buttonClass);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowMaximizeAction\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c11,\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", \"name\", \"window\", 3, \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", \"name\", \"window\", 3, \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class21_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class21_kendo_icon_wrapper_0_Template, 1, 1, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class21_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class21_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.imageUrl && !ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return WindowMaximizeActionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WindowMinimizeActionDirective = /*#__PURE__*/(() => {\n  var _class22;\n  class WindowMinimizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"buttonType\", 'button');\n      _defineProperty(this, \"buttonClass\", true);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"windowMinimizeIcon\", windowMinimizeIcon);\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window-minimize';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.minimizeAction();\n      }\n    }\n    get visible() {\n      return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n  }\n  _class22 = WindowMinimizeActionDirective;\n  _defineProperty(WindowMinimizeActionDirective, \"\\u0275fac\", function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  });\n  _defineProperty(WindowMinimizeActionDirective, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class22,\n    selectors: [[\"button\", \"kendoWindowMinimizeAction\", \"\"]],\n    hostVars: 5,\n    hostBindings: function _class22_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class22_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-window-titlebar-action\", ctx.buttonClass);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowMinimizeAction\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n    attrs: _c12,\n    ngContentSelectors: _c0,\n    decls: 5,\n    vars: 3,\n    consts: [[\"innerCssClass\", \"k-button-icon\", \"name\", \"window-minimize\", 3, \"svgIcon\", 4, \"ngIf\"], [\"class\", \"k-button-icon k-icon\", 4, \"ngIf\"], [\"class\", \"k-button-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-button-text\"], [\"innerCssClass\", \"k-button-icon\", \"name\", \"window-minimize\", 3, \"svgIcon\"], [1, \"k-button-icon\", \"k-icon\"], [\"role\", \"presentation\", 1, \"k-image\", 3, \"src\"], [1, \"k-button-icon\", 3, \"ngClass\"]],\n    template: function _class22_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, _class22_kendo_icon_wrapper_0_Template, 1, 1, \"kendo-icon-wrapper\", 0);\n        i0.ɵɵtemplate(1, _class22_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵtemplate(2, _class22_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.imageUrl && !ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass);\n      }\n    },\n    dependencies: [NgIf, IconWrapperComponent, NgClass],\n    encapsulation: 2\n  }));\n  return WindowMinimizeActionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents the [Kendo UI Window component for Angular]({% slug overview_window_dialogs %}).\n */\nlet WindowComponent = /*#__PURE__*/(() => {\n  var _class23;\n  class WindowComponent {\n    /**\n     * Specifies whether the user will be able to drag the component.\n     * @default true\n     */\n    set draggable(value) {\n      this.options.draggable = value;\n    }\n    get draggable() {\n      return this.options.draggable;\n    }\n    /**\n     * Specifies whether the user will be able to resize the component.\n     * @default true\n     */\n    set resizable(value) {\n      this.options.resizable = value;\n    }\n    get resizable() {\n      return this.options.resizable;\n    }\n    /**\n     * The Window allows you to specify predefined theme colors.\n     * The theme color will be applied as a background and border color to the titlebar while also amending the text color accordingly.\n     *\n     * The possible values are:\n     * * `primary`\n     * * `dark`\n     * * `light`\n     */\n    set themeColor(themeColor) {\n      this.handleThemeColorClass(this.themeColor, themeColor);\n      this._themeColor = themeColor;\n    }\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * @hidden\n     */\n    set cssClass(classes) {\n      this.setServiceClasses(this._cssClass, classes);\n      this._cssClass = classes;\n    }\n    get cssClass() {\n      return this._cssClass;\n    }\n    /**\n     * @hidden\n     */\n    set htmlAttributes(attributes) {\n      setHTMLAttributes(attributes, this.renderer, this.el.nativeElement);\n      const el = this.el.nativeElement;\n      const dir = el.getAttribute('dir');\n      const tIndex = el.getAttribute('tabindex');\n      if (this.direction !== dir) {\n        this.direction = dir;\n      }\n      if (this.tabIndex !== tIndex) {\n        this.tabIndex = tIndex;\n      }\n      this._htmlAttributes = attributes;\n    }\n    get htmlAttributes() {\n      return this._htmlAttributes;\n    }\n    /**\n     * Specifies if the content of the component is persisted in the DOM when minimized.\n     * @default false\n     */\n\n    /**\n     * Specifies the initial state of the component.\n     * If not specified, the value is set to `default`.\n     *\n     * The possible values are:\n     * * `minimized`\n     * * `maximized`\n     * * `default`\n     */\n    set state(value) {\n      this.options.state = value;\n    }\n    get state() {\n      return this.options.state;\n    }\n    /**\n     * Specifies the minimum width of the component.\n     * The `minWidth` property has to be set in pixels.\n     * @default 120\n     */\n    set minWidth(value) {\n      this.setOption('minWidth', value);\n    }\n    get minWidth() {\n      return this.options.minWidth;\n    }\n    /**\n     * Specifies the minimum height of the Window.\n     * The `minHeight` property has to be set in pixels.\n     * @default 100\n     */\n    set minHeight(value) {\n      this.setOption('minHeight', value);\n    }\n    get minHeight() {\n      return this.options.minHeight;\n    }\n    /**\n     * Specifies the width of the Window.\n     * The `width` property has to be set in pixels.\n     */\n    set width(value) {\n      this.setOption('width', value);\n    }\n    get width() {\n      return this.options.width;\n    }\n    /**\n     * Specifies the height of the Window.\n     * The `height` property has to be set in pixels.\n     */\n    set height(value) {\n      this.setOption('height', value);\n    }\n    get height() {\n      return this.options.height;\n    }\n    /**\n     * Specifies the initial top offset of the Window.\n     * The `top` property has to be set in pixels.\n     */\n    set top(value) {\n      this.setOption('top', value);\n    }\n    get top() {\n      return this.options.top;\n    }\n    /**\n     * Specifies the initial left offset of the Window.\n     * Numeric values are treated as pixels.\n     */\n    set left(value) {\n      this.setOption('left', value);\n    }\n    get left() {\n      return this.options.left;\n    }\n    get closeButtonTitle() {\n      if (this.messages && this.messages.closeTitle) {\n        return this.messages.closeTitle;\n      }\n      return this.localization.get('closeTitle');\n    }\n    get restoreButtonTitle() {\n      if (this.messages && this.messages.restoreTitle) {\n        return this.messages.restoreTitle;\n      }\n      return this.localization.get('restoreTitle');\n    }\n    get maximizeButtonTitle() {\n      if (this.messages && this.messages.maximizeTitle) {\n        return this.messages.maximizeTitle;\n      }\n      return this.localization.get('maximizeTitle');\n    }\n    get minimizeButtonTitle() {\n      if (this.messages && this.messages.minimizeTitle) {\n        return this.messages.minimizeTitle;\n      }\n      return this.localization.get('minimizeTitle');\n    }\n    /**\n     * Fires when the user starts to move the Window.\n     */\n\n    get dir() {\n      return this.direction;\n    }\n    constructor(el, renderer, service, navigation, ngZone, localization) {\n      _defineProperty(this, \"el\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"navigation\", void 0);\n      _defineProperty(this, \"ngZone\", void 0);\n      _defineProperty(this, \"localization\", void 0);\n      /**\n       * Specifies the query selector used to set the initial focus ([see examples]({% slug initial_focus_window %})).\n       */\n      _defineProperty(this, \"autoFocusedElement\", void 0);\n      /**\n       * Specifies the text that is rendered in the title bar.\n       */\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"keepContent\", false);\n      _defineProperty(this, \"dragStart\", new EventEmitter());\n      /**\n       * Fires when the Window was moved by the user.\n       */\n      _defineProperty(this, \"dragEnd\", new EventEmitter());\n      /**\n       * Fires when the user starts to resize the Window.\n       */\n      _defineProperty(this, \"resizeStart\", new EventEmitter());\n      /**\n       * Fires when the Window was resized by the user.\n       */\n      _defineProperty(this, \"resizeEnd\", new EventEmitter());\n      /**\n       * Fires when the user closes the Window.\n       */\n      _defineProperty(this, \"close\", new EventEmitter());\n      /**\n       * Fires when the `width` property of the component was updated. The event is triggered only after the resizing\n       * has ended. The event data contains the new width. Allows a two-way binding of the `width` property.\n       */\n      _defineProperty(this, \"widthChange\", new EventEmitter());\n      /**\n       * Fires when the `height` property of the component was updated. The event is triggered only after the resizing\n       * has ended. The event data contains the new height. Allows a two-way binding of the `height` property.\n       */\n      _defineProperty(this, \"heightChange\", new EventEmitter());\n      /**\n       * Fires when the `top` property of the component was updated. The event is triggered only after the dragging\n       * and resizing have ended. The event data contains the new top offset. Allows a two-way binding of the `top` property.\n       */\n      _defineProperty(this, \"topChange\", new EventEmitter());\n      /**\n       * Fires when the `left` property of the component was updated. The event is triggered only after the dragging\n       * and resizing have ended. The event data contains the new left offset. Allows a two-way binding of the `left` property.\n       */\n      _defineProperty(this, \"leftChange\", new EventEmitter());\n      /**\n       * Fires when the `state` property of the component was updated. The event data contains the new state. Allows a\n       * two-way binding of the `state` property.\n       */\n      _defineProperty(this, \"stateChange\", new EventEmitter());\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"contentTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"titleBarTemplate\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"messages\", {});\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"showLicenseWatermark\", false);\n      _defineProperty(this, \"tabIndex\", 0);\n      _defineProperty(this, \"role\", 'dialog');\n      _defineProperty(this, \"hostClass\", true);\n      _defineProperty(this, \"titleBarView\", void 0);\n      _defineProperty(this, \"titleBarContent\", void 0);\n      _defineProperty(this, \"resizeHandles\", void 0);\n      _defineProperty(this, \"resizeDirections\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"titleId\", null);\n      _defineProperty(this, \"_htmlAttributes\", void 0);\n      _defineProperty(this, \"_cssClass\", void 0);\n      _defineProperty(this, \"_themeColor\", null);\n      _defineProperty(this, \"direction\", void 0);\n      _defineProperty(this, \"draged\", false);\n      _defineProperty(this, \"resized\", false);\n      _defineProperty(this, \"windowSubscription\", new Subscription());\n      _defineProperty(this, \"domSubs\", new Subscription());\n      _defineProperty(this, \"localizationChangeSubscription\", void 0);\n      this.el = el;\n      this.renderer = renderer;\n      this.service = service;\n      this.navigation = navigation;\n      this.ngZone = ngZone;\n      this.localization = localization;\n      const isValid = validatePackage(packageMetadata);\n      this.showLicenseWatermark = shouldShowValidationUI(isValid);\n      this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n      this.localizationChangeSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n      this.resizeDirections = RESIZE_DIRECTIONS;\n      this.subscribeEvents();\n      this.titleId = this.generateTitleId();\n    }\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.setNextZIndex();\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this.handleInitialFocus();\n      });\n      this.ngZone.runOutsideAngular(() => Promise.resolve(null).then(() => this.setInitialOffset()));\n      this.initDomEvents();\n      if (this.titleBarView || this.titleBarContent) {\n        this.renderer.setAttribute(this.el.nativeElement, 'aria-labelledby', this.titleId);\n      }\n      this.handleThemeColorClass(null, this.themeColor);\n    }\n    ngOnInit() {\n      this.renderer.removeAttribute(this.el.nativeElement, 'title');\n      this.service.init(this.el);\n    }\n    ngOnChanges(changes) {\n      OFFSET_STYLES.forEach(style => {\n        if (isChanged(style, changes)) {\n          this.setStyle(style, this.options[style]);\n        }\n      });\n      if (isChanged('draggable', changes)) {\n        const titleBar = isPresent(this.titleBarContent) ? this.titleBarContent : this.titleBarView;\n        if (isTruthy(changes['draggable'].currentValue)) {\n          titleBar.subscribeDrag();\n        } else {\n          titleBar.unsubscribeDrag();\n        }\n      }\n      if (isChanged('state', changes)) {\n        if (isPresent(this.service.lastAction)) {\n          this.service.lastAction = null;\n        } else {\n          this.service.applyManualState();\n          this.updateAllOffset();\n        }\n      }\n    }\n    ngOnDestroy() {\n      if (this.windowSubscription) {\n        this.windowSubscription.unsubscribe();\n      }\n      if (this.domSubs) {\n        this.domSubs.unsubscribe();\n      }\n      this.localizationChangeSubscription.unsubscribe();\n    }\n    /**\n     * Focuses the wrapper of the Window component.\n     */\n    focus() {\n      const wrapper = this.el.nativeElement;\n      if (isPresent(wrapper)) {\n        wrapper.focus();\n      }\n    }\n    /**\n     * Brings the current Window component on top of other Window components on the page.\n     */\n    bringToFront() {\n      this.setNextZIndex();\n    }\n    /**\n     * Manually updates the `width` or `height` option of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for sizing dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowDimensionSetting} dimension - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n    setDimension(dimension, value) {\n      this.setOption(dimension, value);\n      this.setStyle(dimension, value);\n    }\n    /**\n     * Manually updates the `top` or `left` offset of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for positioning dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowOffsetSetting} offset - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n    setOffset(offset, value) {\n      this.setOption(offset, value);\n      this.setStyle(offset, value);\n    }\n    get showDefaultTitleBar() {\n      return !isPresent(this.titleBarContent);\n    }\n    get styleMinWidth() {\n      return this.minWidth + 'px';\n    }\n    get styleMinHeight() {\n      return this.minHeight + 'px';\n    }\n    get stylePosition() {\n      return this.options.position;\n    }\n    get wrapperMaximizedClass() {\n      return this.state === 'maximized';\n    }\n    get wrapperMinimizedClass() {\n      return this.state === 'minimized';\n    }\n    /**\n     * @hidden\n     */\n    onComponentFocus() {\n      this.renderer.addClass(this.el.nativeElement, 'k-focus');\n      this.setNextZIndex();\n    }\n    /**\n     * @hidden\n     */\n    onComponentBlur() {\n      this.renderer.removeClass(this.el.nativeElement, 'k-focus');\n    }\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n      this.windowSubscription.add(this.service.focus.subscribe(() => {\n        this.el.nativeElement.focus();\n      }));\n      this.windowSubscription.add(this.service.dragStart.subscribe(() => {\n        this.draged = true;\n        this.ngZone.run(() => {\n          this.dragStart.emit();\n        });\n      }));\n      this.windowSubscription.add(this.service.dragEnd.subscribe(() => {\n        if (this.draged) {\n          this.draged = false;\n          this.ngZone.run(() => {\n            this.dragEnd.emit();\n          });\n        }\n      }));\n      this.windowSubscription.add(this.service.close.subscribe(() => {\n        this.close.emit();\n      }));\n      this.windowSubscription.add(this.service.resizeStart.subscribe(() => {\n        this.resized = true;\n        this.ngZone.run(() => {\n          this.resizeStart.emit();\n        });\n      }));\n      this.windowSubscription.add(this.service.resizeEnd.subscribe(() => {\n        if (this.resized) {\n          this.resized = false;\n          this.ngZone.run(() => {\n            this.resizeEnd.emit();\n          });\n        }\n      }));\n      this.windowSubscription.add(this.service.change.subscribe(ev => {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.setStyle(style, ev[style]);\n            if (this.state !== 'maximized') {\n              const emitter = this[style + 'Change'];\n              if (emitter.observers.length) {\n                this.ngZone.run(() => {\n                  emitter.emit(ev[style]);\n                });\n              }\n            }\n          }\n        });\n      }));\n      this.windowSubscription.add(this.service.stateChange.subscribe(state => {\n        if (isPresent(this.service.lastAction)) {\n          this.updateAllOffset();\n          this.stateChange.emit(state);\n        }\n      }));\n    }\n    initDomEvents() {\n      if (!this.el) {\n        return;\n      }\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubs.add(this.renderer.listen(this.el.nativeElement, 'keydown', ev => {\n          this.onKeyDown(ev);\n        }));\n      });\n    }\n    onKeyDown(event) {\n      if (hasClasses(event.target, WINDOW_CLASSES)) {\n        this.navigation.process(event);\n      }\n    }\n    setServiceClasses(prevValue, value) {\n      const el = this.el.nativeElement;\n      if (prevValue) {\n        parseCSSClassNames(prevValue).forEach(className => {\n          this.renderer.removeClass(el, className);\n        });\n      }\n      if (value) {\n        parseCSSClassNames(value).forEach(className => {\n          this.renderer.addClass(el, className);\n        });\n      }\n    }\n    setNextZIndex() {\n      const currentZIndex = this.el.nativeElement.style['z-index'];\n      const nextPossibleZIndex = this.service.nextPossibleZIndex;\n      if (!currentZIndex || nextPossibleZIndex - currentZIndex > 1) {\n        this.renderer.setStyle(this.el.nativeElement, \"z-index\", this.service.nextZIndex);\n      }\n    }\n    setInitialOffset() {\n      if (this.state !== 'maximized') {\n        this.updateAllOffset();\n        if (!isPresent(this.left) || !isPresent(this.top)) {\n          this.service.center();\n        }\n      } else {\n        const viewPort = this.service.windowViewPort;\n        this.setStyle('width', viewPort.width);\n        this.setStyle('height', viewPort.height);\n        this.setStyle('top', 0);\n        this.setStyle('left', 0);\n      }\n    }\n    updateAllOffset() {\n      OFFSET_STYLES.forEach(style => {\n        if (isPresent(this[style])) {\n          this.setStyle(style, this[style]);\n        } else {\n          this.removeStyle(style);\n        }\n      });\n    }\n    setStyle(style, value) {\n      this.renderer.setStyle(this.el.nativeElement, style, value + 'px');\n    }\n    removeStyle(style) {\n      this.renderer.removeStyle(this.el.nativeElement, style);\n    }\n    get options() {\n      return this.service.options;\n    }\n    setOption(style, value) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        return;\n      }\n      const parsedValue = typeof value === 'number' ? value : parseInt(value, 10);\n      this.options[style] = parsedValue;\n      this.service.setRestoreOption(style, parsedValue);\n    }\n    handleInitialFocus() {\n      const wrapper = this.el.nativeElement;\n      if (this.autoFocusedElement) {\n        const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n        if (initiallyFocusedElement) {\n          initiallyFocusedElement.focus();\n        }\n      } else {\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n    generateTitleId() {\n      return 'kendo-window-title-' + Math.ceil(Math.random() * 1000000).toString();\n    }\n    handleThemeColorClass(previousValue, currentValue) {\n      const wrapper = this.el.nativeElement;\n      if (previousValue) {\n        const classToRemove = `k-window-${previousValue}`;\n        this.renderer.removeClass(wrapper, classToRemove);\n      }\n      if (currentValue) {\n        const classToAdd = `k-window-${currentValue}`;\n        this.renderer.addClass(wrapper, classToAdd);\n      }\n    }\n  }\n  _class23 = WindowComponent;\n  _defineProperty(WindowComponent, \"\\u0275fac\", function _class23_Factory(t) {\n    return new (t || _class23)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(WindowComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class23,\n    selectors: [[\"kendo-window\"]],\n    contentQueries: function _class23_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, WindowTitleBarComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleBarContent = _t.first);\n      }\n    },\n    viewQuery: function _class23_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(WindowTitleBarComponent, 5);\n        i0.ɵɵviewQuery(ResizeHandleDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleBarView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeHandles = _t);\n      }\n    },\n    hostVars: 15,\n    hostBindings: function _class23_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function _class23_focus_HostBindingHandler() {\n          return ctx.onComponentFocus();\n        })(\"blur\", function _class23_blur_HostBindingHandler() {\n          return ctx.onComponentBlur();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabIndex\", ctx.tabIndex)(\"role\", ctx.role)(\"dir\", ctx.dir);\n        i0.ɵɵstyleProp(\"min-width\", ctx.styleMinWidth)(\"min-height\", ctx.styleMinHeight)(\"position\", ctx.stylePosition);\n        i0.ɵɵclassProp(\"k-window\", ctx.hostClass)(\"k-window-maximized\", ctx.wrapperMaximizedClass)(\"k-window-minimized\", ctx.wrapperMinimizedClass);\n      }\n    },\n    inputs: {\n      autoFocusedElement: \"autoFocusedElement\",\n      title: \"title\",\n      draggable: \"draggable\",\n      resizable: \"resizable\",\n      themeColor: \"themeColor\",\n      keepContent: \"keepContent\",\n      state: \"state\",\n      minWidth: \"minWidth\",\n      minHeight: \"minHeight\",\n      width: \"width\",\n      height: \"height\",\n      top: \"top\",\n      left: \"left\"\n    },\n    outputs: {\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\",\n      resizeStart: \"resizeStart\",\n      resizeEnd: \"resizeEnd\",\n      close: \"close\",\n      widthChange: \"widthChange\",\n      heightChange: \"heightChange\",\n      topChange: \"topChange\",\n      leftChange: \"leftChange\",\n      stateChange: \"stateChange\"\n    },\n    exportAs: [\"kendoWindow\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DragResizeService, NavigationService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.window'\n    }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c22,\n    decls: 7,\n    vars: 5,\n    consts: function () {\n      let i18n_13;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.window.closeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_14 = goog.getMsg(\"Close\");\n        i18n_13 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_14;\n      } else {\n        i18n_13 = $localize`:kendo.window.closeTitle|The title of the close button:Close`;\n      }\n      let i18n_15;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the restore button\n         * @meaning kendo.window.restoreTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_16 = goog.getMsg(\"Restore\");\n        i18n_15 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_16;\n      } else {\n        i18n_15 = $localize`:kendo.window.restoreTitle|The title of the restore button:Restore`;\n      }\n      let i18n_17;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the maximize button\n         * @meaning kendo.window.maximizeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_18 = goog.getMsg(\"Maximize\");\n        i18n_17 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_18;\n      } else {\n        i18n_17 = $localize`:kendo.window.maximizeTitle|The title of the maximize button:Maximize`;\n      }\n      let i18n_19;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the minimize button\n         * @meaning kendo.window.minimizeTitle\n         */\n        const MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_20 = goog.getMsg(\"Minimize\");\n        i18n_19 = MSG_C__USERS_MOBILE_PROGRAMMING_DOCUMENTS_ANGULAR_PWA_BOILERPLATE_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2022_PROGRESS_KENDO_ANGULAR_DIALOG_MJS_20;\n      } else {\n        i18n_19 = $localize`:kendo.window.minimizeTitle|The title of the minimize button:Minimize`;\n      }\n      return [[\"kendoWindowLocalizedMessages\", \"\", \"closeTitle\", i18n_13, \"restoreTitle\", i18n_15, \"maximizeTitle\", i18n_17, \"minimizeTitle\", i18n_19], [3, \"template\", \"id\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-window-content\", 3, \"hidden\", 4, \"ngIf\"], [3, \"ngIf\"], [\"kendoWatermarkOverlay\", \"\", 4, \"ngIf\"], [3, \"template\", \"id\"], [1, \"k-window-title\"], [1, \"k-window-titlebar-actions\"], [\"kendoWindowMinimizeAction\", \"\"], [\"kendoWindowMaximizeAction\", \"\"], [\"kendoWindowRestoreAction\", \"\"], [\"kendoWindowCloseAction\", \"\"], [1, \"k-window-content\", 3, \"hidden\"], [3, \"ngTemplateOutlet\"], [\"kendoWindowResizeHandle\", \"\", \"kendoDraggable\", \"\", 3, \"direction\", 4, \"ngFor\", \"ngForOf\"], [\"kendoWindowResizeHandle\", \"\", \"kendoDraggable\", \"\", 3, \"direction\"], [\"kendoWatermarkOverlay\", \"\"]];\n    },\n    template: function _class23_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c21);\n        i0.ɵɵelementContainerStart(0, 0)(1);\n        i0.ɵɵtemplate(2, _class23_kendo_window_titlebar_2_Template, 8, 11, \"kendo-window-titlebar\", 1);\n        i0.ɵɵtemplate(3, _class23_ng_content_3_Template, 1, 0, \"ng-content\", 2);\n        i0.ɵɵtemplate(4, _class23_div_4_Template, 3, 3, \"div\", 3);\n        i0.ɵɵtemplate(5, _class23_ng_template_5_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵtemplate(6, _class23_div_6_Template, 1, 0, \"div\", 5);\n        i0.ɵɵelementContainerEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showDefaultTitleBar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.showDefaultTitleBar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.state !== \"minimized\" || ctx.keepContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.resizable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLicenseWatermark);\n      }\n    },\n    dependencies: [LocalizedMessagesDirective, NgIf, WindowTitleBarComponent, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowCloseActionDirective, NgTemplateOutlet, NgFor, ResizeHandleDirective, DraggableDirective, WatermarkOverlayComponent],\n    encapsulation: 2\n  }));\n  return WindowComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Indicates that the **Close** button of a Window that is opened through `WindowService` is clicked.\n */\nclass WindowCloseResult {}\n\n/**\n * Holds references to the object instance of the Window.\n * Controls the Windows that were opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\nclass WindowRef {\n  constructor() {\n    /**\n     * A reference to the Window instance.\n     */\n    _defineProperty(this, \"window\", void 0);\n    /**\n     * A reference to the child component of the Window.\n     * Available when the Window is opened with\n     * [component content](slug:service_window#toc-rendering-the-content-area).\n     */\n    _defineProperty(this, \"content\", void 0);\n    /**\n     * Allows you to close the Window by using code.\n     * When called with no arguments,\n     * the `result` Observable will be of type WindowCloseResult.\n     * When called with an argument, the `result` Observable will hold the provided value.\n     */\n    _defineProperty(this, \"close\", void 0);\n    /**\n     * Emits events when the Window is closed through the **Esc** key, the **Close** button of the title bar or\n     * by calling the `close` method.\n     * When the Window is closed with the title bar button, **Esc** or by calling `close` with no arguments,\n     * the result is of type [WindowCloseResult]({% slug api_dialog_windowcloseresult %}).\n     * When `close` is called with an argument, the result is the passed argument.\n     */\n    _defineProperty(this, \"result\", void 0);\n  }\n}\n\n/**\n * The settings for the Window actions when the Window is opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\nclass WindowSettings {\n  constructor() {\n    /**\n     * Defines a predicate that verifies if the closing of the Window should be prevented.\n     * It applies to clicking the **Close** button of the title bar, pressing the **Esc** key or calling the `close` method.\n     * Returning true from the predicate prevents the Window from closing.\n     * If the **Close** button of the title bar is clicked or **Esc** is pressed, a [WindowCloseResult]({% slug api_dialog_windowcloseresult %}) instance is passed.\n     * @param {any} ev\n     * @param {WindowRef} [windowRef] - provided only when the window is created using a component.\n     * @returns\n     */\n    _defineProperty(this, \"preventClose\", void 0);\n    /**\n     * Sets the title of the Window.\n     */\n    _defineProperty(this, \"title\", void 0);\n    /**\n     * Defines the content of the Window.\n     */\n    _defineProperty(this, \"content\", void 0);\n    /**\n     * Defines the content of the title bar.\n     */\n    _defineProperty(this, \"titleBarContent\", void 0);\n    /**\n     * Defines the text of the labels that are shown within the Window.\n     * Used primarily for localization.\n     */\n    _defineProperty(this, \"messages\", void 0);\n    /**\n     * Specifies if the content of the Window is persisted in the DOM\n     * when the Window is minimized.\n     */\n    _defineProperty(this, \"keepContent\", void 0);\n    /**\n     * Specifies the width of the Window.\n     */\n    _defineProperty(this, \"width\", void 0);\n    /**\n     * Specifies the minimum width of the Window.\n     */\n    _defineProperty(this, \"minWidth\", void 0);\n    /**\n     * Specifies the height of the Window.\n     */\n    _defineProperty(this, \"height\", void 0);\n    /**\n     * Specifies the minimum height of the Window.\n     */\n    _defineProperty(this, \"minHeight\", void 0);\n    /**\n     * Specifies the left offset of the Window.\n     */\n    _defineProperty(this, \"left\", void 0);\n    /**\n     * Specifies the top offset of the Window.\n     */\n    _defineProperty(this, \"top\", void 0);\n    /**\n     * Specifies is the Window is draggable.\n     */\n    _defineProperty(this, \"draggable\", void 0);\n    /**\n     * Sets the custom CSS classes that will be rendered on the Window wrapper element.\n     * Supports the union type of values that NgClass accepts [ngClass](link:site.data.urls.angular['ngclassapi']).\n     */\n    _defineProperty(this, \"cssClass\", void 0);\n    /**\n     * Sets the HTML attributes of the Window wrapper element.\n     * The property accepts string key-value based pairs.\n     */\n    _defineProperty(this, \"htmlAttributes\", void 0);\n    /**\n     * Specifies if the Window is resizable.\n     */\n    _defineProperty(this, \"resizable\", void 0);\n    /**\n     * Specifies the initial state of the Window.\n     */\n    _defineProperty(this, \"state\", void 0);\n    /**\n     * Defines the container in which the Window will be inserted.\n     * Specifying this option changes the place in the page hierarchy where the Window will be inserted.\n     */\n    _defineProperty(this, \"appendTo\", void 0);\n    /**\n     * Sets the focused element query selector.\n     */\n    _defineProperty(this, \"autoFocusedElement\", void 0);\n    /**\n     * Sets the theme color of the Window.\n     */\n    _defineProperty(this, \"themeColor\", void 0);\n  }\n}\n\n/**\n * @hidden\n */\nlet WindowContainerService = /*#__PURE__*/(() => {\n  var _class26;\n  class WindowContainerService {\n    set container(container) {\n      WindowContainerService.container = container;\n    }\n    get container() {\n      return WindowContainerService.container;\n    }\n  }\n  _class26 = WindowContainerService;\n  _defineProperty(WindowContainerService, \"container\", null);\n  _defineProperty(WindowContainerService, \"\\u0275fac\", function _class26_Factory(t) {\n    return new (t || _class26)();\n  });\n  _defineProperty(WindowContainerService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class26,\n    factory: _class26.ɵfac,\n    providedIn: 'root'\n  }));\n  return WindowContainerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isNotComponent = component => isString(component) || component instanceof TemplateRef;\nclass WindowInjector {\n  constructor(getWindowRef, parentInjector) {\n    _defineProperty(this, \"getWindowRef\", void 0);\n    _defineProperty(this, \"parentInjector\", void 0);\n    this.getWindowRef = getWindowRef;\n    this.parentInjector = parentInjector;\n  }\n  get(token, notFoundValue) {\n    if (token === WindowRef) {\n      return this.getWindowRef();\n    }\n    return this.parentInjector.get(token, notFoundValue);\n  }\n}\n/**\n * A service for opening Windows dynamically\n * ([see example]({% slug service_window %})).\n */\nlet WindowService = /*#__PURE__*/(() => {\n  var _class28;\n  class WindowService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n      _defineProperty(this, \"resolver\", void 0);\n      _defineProperty(this, \"containerService\", void 0);\n      this.resolver = resolver;\n      this.containerService = containerService;\n    }\n    /**\n     * Opens a Window component.\n     *\n     * @param {WindowSettings} settings - The settings that define the Window.\n     * @returns {WindowRef} - A reference to the Window object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Open window</button>\n     *     <div kendoWindowContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private windowService: WindowService ) {}\n     *\n     *     public open() {\n     *         var window = this.windowService.open({\n     *           title: \"My window\",\n     *           content: \"My content!\"\n     *         });\n     *\n     *         window.result.subscribe((result) => {\n     *           if (result instanceof WindowCloseResult) {\n     *             console.log(\"Window was closed\");\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n    open(settings) {\n      const factory = this.resolver.resolveComponentFactory(WindowComponent);\n      const container = settings.appendTo || this.containerService.container;\n      if (!container) {\n        throw new Error(`Cannot attach window to the page.\n                Add an element that uses the kendoWindowContainer directive, or set the 'appendTo' property.\n                See https://www.telerik.com/kendo-angular-ui/components/dialogs/window/service/\n            `);\n      }\n      const windowRef = {\n        close: () => {},\n        content: null,\n        result: null,\n        window: null\n      };\n      const content = this.contentFrom(settings.content, container, windowRef);\n      const window = container.createComponent(factory, undefined, undefined, content.nodes);\n      windowRef.window = window;\n      this.applyOptions(window.instance, settings);\n      const apiClose = new Subject();\n      const close = e => {\n        apiClose.next(e || new WindowCloseResult());\n        if (content.componentRef) {\n          content.componentRef.destroy();\n        }\n        window.destroy();\n      };\n      const result = merge(apiClose, window.instance.close.pipe(map(e => e ? e : new WindowCloseResult()), filter(e => {\n        if (settings.preventClose) {\n          // add windowRef only when using component\n          const windowRefParameter = isNotComponent(settings.content) ? undefined : windowRef;\n          return !settings.preventClose(e, windowRefParameter);\n        }\n        return true;\n      }))).pipe(take(1),\n      // Takes care for multiple subscriptions:\n      // We subscribe internally and the user may subscribe to get a close result - window.result.subscribe().\n      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.\n      share());\n      result.subscribe(close);\n      windowRef.close = close;\n      windowRef.result = result;\n      window.changeDetectorRef.markForCheck();\n      return windowRef;\n    }\n    applyOptions(instance, options) {\n      if (isPresent(options.htmlAttributes)) {\n        instance.htmlAttributes = options.htmlAttributes;\n      }\n      if (isPresent(options.cssClass)) {\n        instance.cssClass = options.cssClass;\n      }\n      if (isPresent(options.title)) {\n        instance.title = options.title;\n      }\n      if (isPresent(options.keepContent)) {\n        instance.keepContent = options.keepContent;\n      }\n      if (isPresent(options.width)) {\n        instance.width = options.width;\n      }\n      if (isPresent(options.minWidth)) {\n        instance.minWidth = options.minWidth;\n      }\n      if (isPresent(options.height)) {\n        instance.height = options.height;\n      }\n      if (isPresent(options.minHeight)) {\n        instance.minHeight = options.minHeight;\n      }\n      if (isPresent(options.left)) {\n        instance.left = options.left;\n      }\n      if (isPresent(options.top)) {\n        instance.top = options.top;\n      }\n      if (isPresent(options.draggable)) {\n        instance.draggable = options.draggable;\n      }\n      if (isPresent(options.resizable)) {\n        instance.resizable = options.resizable;\n      }\n      if (isPresent(options.messages && options.messages.closeTitle)) {\n        instance.messages.closeTitle = options.messages.closeTitle;\n      }\n      if (isPresent(options.messages && options.messages.restoreTitle)) {\n        instance.messages.restoreTitle = options.messages.restoreTitle;\n      }\n      if (isPresent(options.messages && options.messages.maximizeTitle)) {\n        instance.messages.maximizeTitle = options.messages.maximizeTitle;\n      }\n      if (isPresent(options.messages && options.messages.minimizeTitle)) {\n        instance.messages.minimizeTitle = options.messages.minimizeTitle;\n      }\n      if (isPresent(options.autoFocusedElement)) {\n        instance.autoFocusedElement = options.autoFocusedElement;\n      }\n      if (isPresent(options.state)) {\n        instance.state = options.state;\n        if (options.state === 'minimized') {\n          instance.keepContent = true;\n        }\n      }\n      if (isPresent(options.themeColor)) {\n        instance.themeColor = options.themeColor;\n      }\n      if (options.content instanceof TemplateRef) {\n        instance.contentTemplate = options.content;\n      }\n      if (options.titleBarContent instanceof TemplateRef) {\n        instance.titleBarTemplate = options.titleBarContent;\n      }\n    }\n    contentFrom(content, container, windowRef) {\n      const renderer = container.injector.get(Renderer2);\n      let nodes = [];\n      let componentRef = null;\n      if (typeof content === 'string') {\n        nodes = [renderer.createText(content)];\n      } else if (content && !(content instanceof TemplateRef)) {\n        const injector = new WindowInjector(() => windowRef, container.injector);\n        const factory = this.resolver.resolveComponentFactory(content);\n        componentRef = container.createComponent(factory, undefined, injector);\n        nodes = [componentRef.location.nativeElement];\n        windowRef.content = componentRef;\n      }\n      return {\n        componentRef,\n        nodes: [[], nodes // Content\n        ]\n      };\n    }\n  }\n  _class28 = WindowService;\n  _defineProperty(WindowService, \"\\u0275fac\", function _class28_Factory(t) {\n    return new (t || _class28)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(WindowContainerService));\n  });\n  _defineProperty(WindowService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class28,\n    factory: _class28.ɵfac,\n    providedIn: 'root'\n  }));\n  return WindowService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Provides an insertion point for the Dialogs which are created through the\n * Dialog service ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n * Created Dialogs will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoDialogContainer></div>\n * ```\n */\nlet DialogContainerDirective = /*#__PURE__*/(() => {\n  var _class29;\n  class DialogContainerDirective {\n    constructor(container, service) {\n      service.container = container;\n    }\n  }\n  _class29 = DialogContainerDirective;\n  _defineProperty(DialogContainerDirective, \"\\u0275fac\", function _class29_Factory(t) {\n    return new (t || _class29)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DialogContainerService));\n  });\n  _defineProperty(DialogContainerDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class29,\n    selectors: [[\"\", \"kendoDialogContainer\", \"\"]],\n    standalone: true\n  }));\n  return DialogContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom component messages override default component messages\n * ([see example](slug:globalization_dialogs#toc-internationalization)).\n */\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  var _class30;\n  class CustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      _defineProperty(this, \"service\", void 0);\n      this.service = service;\n    }\n    get override() {\n      return true;\n    }\n  }\n  _class30 = CustomMessagesComponent;\n  _defineProperty(CustomMessagesComponent, \"\\u0275fac\", function _class30_Factory(t) {\n    return new (t || _class30)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  });\n  _defineProperty(CustomMessagesComponent, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class30,\n    selectors: [[\"kendo-dialog-messages\"], [\"kendo-window-messages\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => _class30)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  }));\n  return CustomMessagesComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Provides an insertion point for the Windows which are created through the\n * Window service ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n * Created Windows will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoWindowContainer></div>\n * ```\n */\nlet WindowContainerDirective = /*#__PURE__*/(() => {\n  var _class31;\n  class WindowContainerDirective {\n    constructor(container, service) {\n      service.container = container;\n    }\n  }\n  _class31 = WindowContainerDirective;\n  _defineProperty(WindowContainerDirective, \"\\u0275fac\", function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(WindowContainerService));\n  });\n  _defineProperty(WindowContainerDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class31,\n    selectors: [[\"\", \"kendoWindowContainer\", \"\"]],\n    standalone: true\n  }));\n  return WindowContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n* Utility array that contains all `Dialog` related components and directives.\n*/\nconst KENDO_DIALOG = [DialogComponent, DialogTitleBarComponent, DialogContainerDirective, DialogActionsComponent, CustomMessagesComponent];\n/**\n* Utility array that contains all `Window` related components and directives.\n*/\nconst KENDO_WINDOW = [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent, WindowContainerDirective, DialogActionsComponent, CustomMessagesComponent];\n/**\n* Utility array that contains all `@progress/kendo-angular-dialog` related components and directives.\n*/\nconst KENDO_DIALOGS = [...KENDO_DIALOG, ...KENDO_WINDOW];\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Dialog component that includes all Dialog components and directives.\n * Imports `DialogModule` into the [root module](link:site.data.urls.angular['ngmodules']#angular-modularity)\n * of your application or into any other sub-module that will use the Dialog component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { DialogModule } from '@progress/kendo-angular-dialog';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\nlet DialogModule = /*#__PURE__*/(() => {\n  var _class32;\n  class DialogModule {}\n  _class32 = DialogModule;\n  _defineProperty(DialogModule, \"\\u0275fac\", function _class32_Factory(t) {\n    return new (t || _class32)();\n  });\n  _defineProperty(DialogModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class32\n  }));\n  _defineProperty(DialogModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DialogContainerService, DialogService, IconsService],\n    imports: [DialogComponent, DialogTitleBarComponent]\n  }));\n  return DialogModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Window component. Imports `WindowModule` into the\n * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity)\n * of your application or into any other sub-module that will use the Window component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { WindowModule } from '@progress/kendo-angular-window';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, WindowModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\nlet WindowModule = /*#__PURE__*/(() => {\n  var _class33;\n  class WindowModule {}\n  _class33 = WindowModule;\n  _defineProperty(WindowModule, \"\\u0275fac\", function _class33_Factory(t) {\n    return new (t || _class33)();\n  });\n  _defineProperty(WindowModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class33\n  }));\n  _defineProperty(WindowModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [WindowContainerService, WindowService, IconsService],\n    imports: [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective]\n  }));\n  return WindowModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n//IMPORTANT: NgModule export kept for backwards compatibility\n/**\n * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])\n * definition for the Dialogs components.\n *\n * @example\n *\n * ```ts\n * import { DialogsModule } from '@progress/kendo-angular-dialog';\n *\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { NgModule } from '@angular/core';\n *\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogsModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet DialogsModule = /*#__PURE__*/(() => {\n  var _class34;\n  class DialogsModule {}\n  _class34 = DialogsModule;\n  _defineProperty(DialogsModule, \"\\u0275fac\", function _class34_Factory(t) {\n    return new (t || _class34)();\n  });\n  _defineProperty(DialogsModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class34\n  }));\n  _defineProperty(DialogsModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IconsService, DialogService, DialogContainerService, WindowService, WindowContainerService],\n    imports: [DialogComponent, DialogTitleBarComponent, WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective]\n  }));\n  return DialogsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CustomMessagesComponent, DialogAction, DialogActionsComponent, DialogCloseResult, DialogComponent, DialogContainerDirective, DialogContainerService, DialogContentBase, DialogModule, DialogRef, DialogService, DialogSettings, DialogTitleBarComponent, DialogsModule, DragResizeService, KENDO_DIALOG, KENDO_DIALOGS, KENDO_WINDOW, LocalizedMessagesDirective, Messages, NavigationService, PreventableEvent, WindowCloseActionDirective, WindowCloseResult, WindowComponent, WindowContainerDirective, WindowContainerService, WindowMaximizeActionDirective, WindowMinimizeActionDirective, WindowModule, WindowRef, WindowRestoreActionDirective, WindowService, WindowSettings, WindowTitleBarComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}